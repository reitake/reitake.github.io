<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algorithm 笔记</title>
    <url>/2019/03/14/Alg-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>算法学习笔记</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">题目</a>:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：[<span class="number">-4</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">100</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入：[<span class="number">-7</span>,<span class="number">-3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">11</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">49</span>,<span class="number">121</span>]</span><br></pre></td></tr></table></figure>

<p>思路：双指针。从前、后开始算平方，比大小。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSquares</span><span class="params">(A []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">        result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(A))</span><br><span class="line">    top := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(A) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        topVal := A[top] * A[top]</span><br><span class="line">        endVal := A[end] * A[end]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> topVal &gt; endVal &#123;</span><br><span class="line">            result[i] = topVal</span><br><span class="line">            top++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i] = endVal</span><br><span class="line">            end--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="按奇、偶顺序排序数组"><a href="#按奇、偶顺序排序数组" class="headerlink" title="按奇、偶顺序排序数组"></a>按奇、偶顺序排序数组</h2><p><a href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" rel="noopener">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个非负整数数组 A，返回一个由 A 的所有偶数元素组成的数组，后面跟 A 的所有奇数元素。</span><br><span class="line"></span><br><span class="line">你可以返回满足此条件的任何数组作为答案。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 也会被接受。</span><br></pre></td></tr></table></figure>
<p>思路：构建两个slice，分别append奇数和偶数，然后把两个slice拼起来。</p>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">题目</a>:  </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 <span class="number">0</span> 和 <span class="number">1</span> 开始，后面的每一项数字都是前面两项数字的和。也就是：</span><br><span class="line"></span><br><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1.</span></span><br><span class="line">给定 N，计算 F(N)。</span><br></pre></td></tr></table></figure>
<p>思路：因为提前给了N，所以可以直接构建长度为N的slice来计算数列，而不是无脑append，花时间。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">S := <span class="built_in">make</span>([]<span class="keyword">int</span>, N)</span><br></pre></td></tr></table></figure>
<h2 id="数组拆分：求min-ai-bi-和的最大值"><a href="#数组拆分：求min-ai-bi-和的最大值" class="headerlink" title="数组拆分：求min(ai, bi)和的最大值"></a>数组拆分：求min(ai, bi)和的最大值</h2><p><a href="">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定长度为 <span class="number">2</span>n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从<span class="number">1</span> 到 n 的 min(ai, bi) 总和最大。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: n 等于 <span class="number">2</span>, 最大总和为 <span class="number">4</span> = min(<span class="number">1</span>, <span class="number">2</span>) + min(<span class="number">3</span>, <span class="number">4</span>).</span><br><span class="line">提示:</span><br><span class="line"></span><br><span class="line">n 是正整数,范围在 [<span class="number">1</span>, <span class="number">10000</span>].</span><br><span class="line">数组中的元素范围在 [<span class="number">-10000</span>, <span class="number">10000</span>].</span><br></pre></td></tr></table></figure>
<p>思路：先排序，再求min的和。因为给了n的个数范围，所以可以构建2n+1容量的slice来桶排序：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayPairSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr [<span class="number">20001</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        arr[v+<span class="number">10000</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    sum, flag := <span class="number">0</span>, <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">for</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> flag &#123;</span><br><span class="line">                sum += i - <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">            v--</span><br><span class="line">            flag = !flag</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="杨辉三角形1：返回前N行"><a href="#杨辉三角形1：返回前N行" class="headerlink" title="杨辉三角形1：返回前N行"></a>杨辉三角形1：返回前N行</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle" target="_blank" rel="noopener">题目</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(numRows <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    A := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numRows)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> A &#123;</span><br><span class="line">        A[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j, _ := <span class="keyword">range</span> A[i] &#123;</span><br><span class="line">            <span class="keyword">switch</span> j &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                A[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">case</span> i:</span><br><span class="line">                A[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                A[i][j] = A[i<span class="number">-1</span>][j<span class="number">-1</span>] + A[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="杨辉三角形2：-返回第N行"><a href="#杨辉三角形2：-返回第N行" class="headerlink" title="杨辉三角形2： 返回第N行"></a>杨辉三角形2： 返回第N行</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">题目</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRow</span><span class="params">(rowIndex <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="keyword">int</span>,rowIndex+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i &lt;= rowIndex &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            ret[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            ret[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> index,v := <span class="keyword">range</span> ret &#123;</span><br><span class="line">                <span class="keyword">if</span> index &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    tmp,ret[index] = ret[index],ret[index] + tmp</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp = v</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求众数：出现次数大于n-2的元素"><a href="#求众数：出现次数大于n-2的元素" class="headerlink" title="求众数：出现次数大于n/2的元素"></a>求众数：出现次数大于n/2的元素</h2><p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/<span class="number">2</span> ⌋ 的元素。</span><br><span class="line"></span><br><span class="line">你可以假设数组是非空的，并且给定的数组总是存在众数。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>思路：从第一个数开始count=1，遇到相同的就+1，不同的就-1，减到0时候就重新换个数开始计数：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    count := <span class="number">1</span></span><br><span class="line">    res := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == res &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">                res = nums[i]</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重塑矩阵"><a href="#重塑矩阵" class="headerlink" title="重塑矩阵"></a>重塑矩阵</h2><p><a href="https://leetcode-cn.com/problems/reshape-the-matrix/" target="_blank" rel="noopener">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</span><br><span class="line"></span><br><span class="line">给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</span><br><span class="line"></span><br><span class="line">重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</span><br><span class="line"></span><br><span class="line">如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">1</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。新的矩阵是 <span class="number">1</span> * <span class="number">4</span> 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">2</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 <span class="number">2</span> * <span class="number">2</span> 矩阵转化为 <span class="number">2</span> * <span class="number">4</span> 矩阵。 所以输出原矩阵。</span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">给定矩阵的宽和高范围在 [<span class="number">1</span>, <span class="number">100</span>]。</span><br><span class="line">给定的 r 和 c 都是正数。</span><br></pre></td></tr></table></figure>
<p>思路：用<code>A[n/c][n%c]</code>来构建矩阵：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixReshape</span><span class="params">(nums [][]<span class="keyword">int</span>, r <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)*<span class="built_in">len</span>(nums[<span class="number">0</span>]) != r * c&#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    A := <span class="built_in">make</span>([][]<span class="keyword">int</span>,r)</span><br><span class="line">    <span class="keyword">for</span> rownum:= <span class="keyword">range</span> A&#123;</span><br><span class="line">        A[rownum]=<span class="built_in">make</span>([]<span class="keyword">int</span>,c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> rowNum := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">for</span> i,_ := <span class="keyword">range</span> nums[rowNum]&#123;</span><br><span class="line">            n= rowNum*<span class="built_in">len</span>(nums[<span class="number">0</span>])+i</span><br><span class="line">            A[n/c][n%c]=nums[rowNum][i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</span><br><span class="line"></span><br><span class="line">不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(<span class="number">1</span>) 额外空间的条件下完成。</span><br><span class="line"></span><br><span class="line">元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</span><br><span class="line"></span><br><span class="line">示例见上方超链接</span><br></pre></td></tr></table></figure>
<p>思路：双指针。发现val时，交换跟末尾的数的值。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> n= <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i&lt;n&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i]==val&#123;</span><br><span class="line">            nums[i]=nums[n<span class="number">-1</span>]</span><br><span class="line">            n--</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++</span><br><span class="line">             &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移动零到数组末尾"><a href="#移动零到数组末尾" class="headerlink" title="移动零到数组末尾"></a>移动零到数组末尾</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums，编写一个函数将所有 <span class="number">0</span> 移动到数组的末尾，同时保持非零元素的相对顺序。</span><br><span class="line">示例:</span><br><span class="line">输入: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">必须在原数组上操作，不能拷贝额外的数组。</span><br><span class="line">尽量减少操作次数。</span><br></pre></td></tr></table></figure>
<p>思路：双指针。1个指针用来遍历，1个指针用来填非零值，然后把剩下的值改0。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    dist := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num != <span class="number">0</span> &#123;</span><br><span class="line">            nums[dist] = num</span><br><span class="line">            dist++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := dist; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line"></span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span><span class="number">-3</span> = <span class="number">3</span> 。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span><span class="number">-1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<p>思路：最简单粗暴的方法是遍历，后一位的值大于前一位的值时候，利润就加差值累计。<br>还可以寻找峰、谷，然后求峰谷的差的和：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices)==<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    max, min, res, i := prices[<span class="number">0</span>], prices[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span> &amp;&amp; prices[i] &gt;= prices[i+<span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        min = prices[i]</span><br><span class="line">        <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span> &amp;&amp; prices[i] &lt;= prices[i+<span class="number">1</span>] &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        max = prices[i]</span><br><span class="line">        res += max - min</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="找数组中消失的数字"><a href="#找数组中消失的数字" class="headerlink" title="找数组中消失的数字"></a>找数组中消失的数字</h2><p><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">题目</a>:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个范围在  <span class="number">1</span> ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</span><br><span class="line"></span><br><span class="line">找到所有在 [<span class="number">1</span>, n] 范围之间没有出现在数组中的数字。</span><br><span class="line"></span><br><span class="line">您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入:</span><br><span class="line">[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出:</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>思路：将所有正数为置为相反数。那么，出现正数的位置即为消失的数字。比如，[4,3,2,7,8,2,3,1]  </p>
<p>重置后将为[-4,-3,-2,-7,8,2,-3,-1]  </p>
<p>[8,2] 分别对应的index为[5,6]。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDisappearedNumbers</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        nums[Abs(nums[i])<span class="number">-1</span>] = -Abs(nums[Abs(nums[i])<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    res :=[]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>&#123;</span><br><span class="line">            res=<span class="built_in">append</span>(res,i+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大自序和"><a href="#最大自序和" class="headerlink" title="最大自序和"></a>最大自序和</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>],</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure>
<p>思路：单指针遍历求和，如果当前的和小于等于0，就直接从下一个数开始重新求和。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxSubSum, sum := nums[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; <span class="number">0</span> &#123;</span><br><span class="line">            sum += nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> sum &gt; maxSubSum &#123;</span><br><span class="line">            maxSubSum = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxSubSum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">题目</a>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br><span class="line">示例:</span><br><span class="line">输入:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>思路：短数组往大数组里填，从大数组屁股开始填，谁大先填谁。<br>如果先把nums1填完了，num2还剩一些没填完，要把这部分剩下的转移到nums1中：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[m<span class="number">-1</span>] &gt; nums2[n<span class="number">-1</span>] &#123;</span><br><span class="line">            nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">            m--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n-- &#123;</span><br><span class="line">            nums1[n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">题目</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>思路：异或，且0与任何数异或等于任何数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        res ^= v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">题目</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</span><br><span class="line"></span><br><span class="line">现有一个链表 -- head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>]，它可以表示为:</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">1</span> -&gt; <span class="number">9.</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">1</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 <span class="number">1</span> 的第三个节点，那么在调用了你的函数之后，该链表应变为 <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9.</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">链表至少包含两个节点。</span><br><span class="line">链表中所有节点的值都是唯一的。</span><br><span class="line">给定的节点为非末尾节点并且一定是链表中的一个有效节点。</span><br><span class="line">不要从你的函数中返回任何结果。</span><br></pre></td></tr></table></figure>

<p>思路：最简单的方法是把上衣节点的next指向下一节点，来跳过要删除的节点。  </p>
<p>但是节点结构体中不包含上一节点的地址，所以只能把下一节点在val和next的拷贝到要删除的节点中：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(node *ListNode)</span></span> &#123;</span><br><span class="line">    node.Val = node.Next.Val</span><br><span class="line">    node.Next = node.Next.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">题目</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，找出其最大深度。</span><br><span class="line"></span><br><span class="line">二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<p>思路：递归求解。或用栈迭代（？？？）  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left := maxDepth(root.Left)</span><br><span class="line">        right := maxDepth(root.Right)</span><br><span class="line">        <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            <span class="keyword">return</span> left + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">题目</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">反转一个单链表。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br><span class="line">进阶:</span><br><span class="line">你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><br></pre></td></tr></table></figure>

<p>思路：迭代，在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    curr := head</span><br><span class="line">    <span class="keyword">var</span> prev *ListNode = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> curr != <span class="literal">nil</span> &#123;</span><br><span class="line">        nextTemp := curr.Next</span><br><span class="line">        curr.Next = prev</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = nextTemp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><p><a href="">题目</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</span><br><span class="line"></span><br><span class="line">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span><br><span class="line"></span><br><span class="line">例如，给定如下二叉搜索树:  root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,null,null,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">4</span> 的最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">所有节点的值都是唯一的。</span><br><span class="line">p、q 为不同节点且均存在于给定的二叉搜索树中。</span><br></pre></td></tr></table></figure>

<p>思路：利用二叉搜索树的特性。一共就3种情况：</p>
<p>要么2个值都比根节点小，那都在root的左侧；要么2个值都比跟节点大，那都在root的右侧；或者在两侧，那最近祖先就是root。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for TreeNode.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *ListNode</span></span><br><span class="line"><span class="comment"> *     Right *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p.Val &lt; root.Val &amp;&amp; q.Val &lt; root.Val &#123;</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> p.Val &gt; root.Val &amp;&amp; q.Val &gt; root.Val &#123;</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p><em><code>to be continued...</code></em></p>
]]></content>
      <categories>
        <category>「算法」</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Go</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>Axure Learn</title>
    <url>/2019/11/25/Axure-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>重要的是用工具的人，也就是工具人</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="元件（组件）"><a href="#元件（组件）" class="headerlink" title="元件（组件）"></a>元件（组件）</h2><h3 id="基本元件"><a href="#基本元件" class="headerlink" title="基本元件"></a>基本元件</h3><ul>
<li><code>矩形框</code>、<code>圆形</code>：图形，可写字</li>
<li><code>图片</code>、<code>占位符</code>：双击图片组件来添加图片</li>
<li><code>按钮</code>、<code>主要按钮</code>、<code>链接按钮</code></li>
<li><code>标题</code>、<code>标签</code>、<code>段落</code>：写字，仅样式不同</li>
<li><code>水平线</code>、<code>垂直线</code>：线段，固定宽度1</li>
<li><code>热区</code>：制作不可见但想要交互的区域</li>
<li><code>动态面板</code>：强大，常用来制作轮播图等</li>
<li><code>内联框架</code>：在页面内嵌套其他页面或者URL的内容</li>
<li><code>重复器</code>（“中继器”翻译不太行）：制作重复内容，功能强大，常用来构建列表属性的元素</li>
</ul>
<h3 id="表单元件"><a href="#表单元件" class="headerlink" title="表单元件"></a>表单元件</h3><ul>
<li>文本框、文本域、下拉列表、列表框、复选框、单选按钮</li>
</ul>
<h3 id="菜单-表格"><a href="#菜单-表格" class="headerlink" title="菜单|表格"></a>菜单|表格</h3><ul>
<li>树状菜单（可折叠）、表格、水平菜单、垂直菜单</li>
</ul>
<h3 id="标记元件"><a href="#标记元件" class="headerlink" title="标记元件"></a>标记元件</h3><ul>
<li>快照</li>
<li>水平箭头、垂直箭头</li>
<li>便签</li>
<li>圆形标记、水滴标记</li>
</ul>
<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul>
<li><code>事件（Event）</code>：部件状态有变化，如文本框内文字变化、按钮点击<ul>
<li>时间起名习俗：on+对象名+时间，如onHideBotmClick</li>
</ul>
</li>
<li><code>动作（Action）</code>：对事件的响应，如跳转页面、显示弹出层<ul>
<li>多个动作按次序执行，除了动画</li>
</ul>
</li>
<li><code>情况（Case）</code>：根据不同条件作出不同响应</li>
</ul>
<h3 id="母版"><a href="#母版" class="headerlink" title="母版"></a>母版</h3><ul>
<li>动作只能操作当前容器内的元件。</li>
<li>可以给母版内动作跑出事件，在具体页面中根据时间来执行动作。</li>
</ul>
<h3 id="动态面板"><a href="#动态面板" class="headerlink" title="动态面板"></a>动态面板</h3><ul>
<li>页面内部分页面变换，通常用动态面板实现，例如用户名登录/手机号登录</li>
<li>切换按钮的动作：set panel state</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><code>方向键</code>单个像素调整，再按住<code>Shift</code>键，10个像素调整。</li>
<li>按住<code>Shift</code>等比例调整大小。</li>
<li>双击：<ul>
<li>普通组件：添加文字</li>
<li>类型组件：编辑</li>
</ul>
</li>
<li>对齐到网络</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>预览：<code>F5</code></li>
</ul>
<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><h2 id="Raise-Event（引发事件）"><a href="#Raise-Event（引发事件）" class="headerlink" title="Raise Event（引发事件）"></a>Raise Event（引发事件）</h2><ul>
<li>抛出一个事件，交给上一级来处理<ul>
<li>事件起名：on+对象名+事件<ul>
<li>如：onHideBodyClick</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><p>如果case条件中不加，那就是其他情况</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://www.chanpinban.com/downloads/" target="_blank" rel="noopener">汉化资源</a></p>
]]></content>
      <categories>
        <category>「笔记」- 软件</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Axure</tag>
      </tags>
  </entry>
  <entry>
    <title>《能源互联网》笔记</title>
    <url>/2020/06/26/Energy-Internet-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Energy Internet</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<ul>
<li>作者：孙宏斌  </li>
<li>出版社：科学出版社 </li>
</ul>
<hr>
<h1 id="第四部分-价值层-第3章-虚拟电厂"><a href="#第四部分-价值层-第3章-虚拟电厂" class="headerlink" title="第四部分 价值层  第3章 虚拟电厂"></a>第四部分 价值层  第3章 虚拟电厂</h1><p>分布式能源（DER）单独运行时，电源容量较小，且具有较大的随机性、波动性、间歇性，并网后难以对其进行调度。为解决单独的分布式能源介入电网造成的不利影响，学者提出了虚拟电厂（VPP）。  </p>
<h2 id="虚拟电厂概述"><a href="#虚拟电厂概述" class="headerlink" title="虚拟电厂概述"></a>虚拟电厂概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>没有统一定义。  </p>
<ul>
<li>①是一系列分布式能源的集合，以传统发电厂的角色参与电力系统的运行。</li>
<li>②是对电网中各种能源进行综合管理的软件系统。</li>
<li>③VPP也包括效能电厂，通过减少终端用电设备和装置的用电需求的方式来产生“富余“的电能，即通过需求方提高效能，达到建实际电厂的效果。</li>
<li>③在能源互联网建设提出之后，虚拟电厂可以看成可以广域、动态聚合多种能源的能源互联网。</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据功能，分为商业型虚拟电厂（commercial VPP，CVPP）、技术型虚拟电厂（technical VPP，TVPP）。  </p>
<ul>
<li>CVPP<ul>
<li>从商业收益的角度出发，对用户需求和发电潜力进行预测，将虚拟电场中的分布式能源接入电力市场，以优化和调度用电量，是分布式能源投资组合的一中灵活表述。</li>
<li>要实现：<ul>
<li>①根据从市场获得的信息订立合同，并提交信息至系统运营商。</li>
<li>②便是交易计划，确定市场价格，实现实时市场交易。</li>
<li>③实现啊投资组合交易与服务，提供两者的平衡。</li>
</ul>
</li>
</ul>
</li>
<li>TVPP<ul>
<li>从系统管理的角度出发，有分布式能源和可控负荷共同组成，考虑分布式能源聚合对本地网络的实时邮箱，可以看成一个带有传输系统的发电厂，具有与其他和电网项链的电厂相同的表征参数。</li>
<li>主要为管理者和提供可视化的信息，优化分布式能源的运行，并根据当地电网的运行约束提供配套服务。</li>
<li>要实现的功能：<ul>
<li>①整合所有分布式能源和负荷的输入，为配电管理员（DSO）提供系统管理服务。</li>
<li>②为输电管理员（TSO）提供系统平衡和配套服务。</li>
<li>③提供可视化操作界面，并允许控制系统内的分布式能源，增强分布式能源的可控性，提供系统最低成本的运营方式。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><p>根据信息流传输控制结构的不同，分为集中控制方式虚拟电厂（centralized controlled VPP，CCVPP）、分散控制方式虚拟电厂（distributed controlled VPP, DCVPP）、完全分散控制方式虚拟电厂（fully DCVPP，FDCVPP）。  </p>
<ul>
<li>集中控制方式<ul>
<li>通过控制些调整下（CCC）完全掌握涉及分布式运行的所有单位的信息，并可以对所有发电或用电单元进行控制。</li>
<li>具有优先的可拓展性和兼容性</li>
</ul>
</li>
<li>分散控制方式<ul>
<li>VPP分为多个层次</li>
<li>使VPP模块化，可改善集中控制方式下的通信阻塞和兼容性差的问题</li>
</ul>
</li>
<li>完全分散控制方式<ul>
<li>控制协调中心由数据交换与处理中心代替，交换与处理中心只提供市场价格、天气预报等信息。</li>
<li>VPP被划分为相互独立自治的只能子单元，不受数据交换与处理中心控制，只接受来自数据交换与处理中心的信息，根据信息对资深的运行状态进行优化。</li>
<li>具有好的可拓展性和开放性，也更适合参与电力市场</li>
</ul>
</li>
</ul>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>目标是将分布式能源优化组合成有机整体，提供店里辅助服务，通过协调控制使VPP运行在最优运行点，实现整体利益的最大化。  </p>
<ul>
<li>发电商预测，提交各自的第二日发电计划</li>
<li>VPP需协调个发电商电价</li>
<li>VPP根据发电商电价、输出功率、电能质量和电力储备等特性，指定第二天的发电计划</li>
<li>VPP根据发电计划和发电商所报电价及电量，指定虚拟电厂电价，并确定电网接入点和注入功率</li>
<li>VPP与市场运营商签订发电协议（电量、电价），校验协议是否符合潮流、阻塞等系统网络条件</li>
<li>系统通知虚拟电厂订立发电合同，VPP与发电商协调制定第二天的发电计划</li>
<li>VPP根据发电计划控制个发电商的输出功率，对实际网络情况进行优化调整，并将发电结果录入数据库，为之后提供数据和依据</li>
</ul>
<h3 id="虚拟电厂与微电网的区别"><a href="#虚拟电厂与微电网的区别" class="headerlink" title="虚拟电厂与微电网的区别"></a>虚拟电厂与微电网的区别</h3><ul>
<li>对分布式能源聚合的有效区域不同<ul>
<li>微网对地理位置要求高，一般处于同一区域内</li>
<li>虚拟电厂可跨区聚合</li>
</ul>
</li>
<li>与配电网的连接点不同<ul>
<li>VPP可能有多个公共连接点</li>
<li>微网一般只有一个</li>
</ul>
</li>
<li>与电网的连接方式不同<ul>
<li>VPP不改变聚合的风不是能源的并网形式没更侧重于通过联测、通信技术聚合</li>
<li>微网需要对电网进行物理拓展</li>
</ul>
</li>
<li>运行方式不同<ul>
<li>微网可孤岛运行，可并网运行</li>
<li>VPP只能并网</li>
</ul>
</li>
<li>侧重功能不同<ul>
<li>微网侧重就地平衡负荷</li>
<li>VPP侧重实现供应主体利益最大化，具有电力市场经营能力</li>
</ul>
</li>
</ul>
<h3 id="示范项目"><a href="#示范项目" class="headerlink" title="示范项目"></a>示范项目</h3><ul>
<li>2001<del>2005年，欧盟第5框架计划下试试的VFCPP（virtual fuel cell power plant）项目、2005</del>2009年欧盟第6框架下FENIX（flexible electricity network to integrate the expected energy solution）项目、2012<del>2015年，欧盟第7框架TWENTIES研究项目和WEB2ENERGY项目、2008</del>2013年德国E-E能源计划</li>
<li>2016年日本关西电力、富士电机、三社电机、杰士汤浅、住友电工、优利系统等合作推出了一个虚拟电厂试验项目</li>
<li>2016年8月澳大利亚公共事业AGL公司宣布将要大枣世界上最大的虚拟电厂，美国储能开放商Sunverge</li>
<li>2016年8月美国Nest Labs与南加州爱迪生电力公司签订虚拟电厂资源</li>
<li>2016年纽约公共事业公司Con Edison公示和美国储能开发商Sunverge投资1500万美元虚拟电厂试点项目</li>
<li>国内示范工程偏向于实现能效电厂的功能。<ul>
<li>江苏昆山</li>
<li>上海</li>
</ul>
</li>
</ul>
<h2 id="能源互联网下虚拟电厂的模型框架"><a href="#能源互联网下虚拟电厂的模型框架" class="headerlink" title="能源互联网下虚拟电厂的模型框架"></a>能源互联网下虚拟电厂的模型框架</h2><h3 id="VPP组成结构"><a href="#VPP组成结构" class="headerlink" title="VPP组成结构"></a>VPP组成结构</h3><p>3部分，由发电系统、能量存储系统、通信系统组成。   </p>
<ul>
<li>发电系统主要包括家庭型分布式电源（DDG）和公用型分布式能源（PDG）</li>
<li>能量存储系统补偿波动性和不可控性</li>
<li>通信系统进行能量管理、数据采集与监控每一集与电力系统调度中心通信</li>
<li>未来发展：用户侧管理，需求响应<ul>
<li>需求响应：电力用户对市场价格信号或激励机制做出响应，主动改变自身原有电力消费模式的行为</li>
<li>分为基于价格的需求响应（PBDR）、基于激励的需求响应（IBDR）</li>
</ul>
</li>
</ul>
<h3 id="VPP组成框架"><a href="#VPP组成框架" class="headerlink" title="VPP组成框架"></a>VPP组成框架</h3><p>一系列分布式电源的聚合：可控机组、不可控机组、储能设备、可控负荷、电动汽车、通信设备等。  </p>
<h3 id="VPP容量配置"><a href="#VPP容量配置" class="headerlink" title="VPP容量配置"></a>VPP容量配置</h3><p>集中于局部优化和就地平衡。常用方法有多目标优化方法、博弈论方法、投资组合理论等。  </p>
<h3 id="VPP的组合选择与利益分配"><a href="#VPP的组合选择与利益分配" class="headerlink" title="VPP的组合选择与利益分配"></a>VPP的组合选择与利益分配</h3><p>通过多种组合结构下的优先级排序，从而自适应地组合成一个虚拟电厂最佳组合结构。  </p>
<p>考虑到虚拟电厂内部成员的多样性和多产权型，需要对其组合内部的收益分配机制进行研究。同时需要指定其与大电网以及电力交易中心之间的合作机制，以保证所有参与者的合理收益、积极性、稳定性、满意度。  </p>
<h2 id="能源互联网下虚拟电厂的运行与控制"><a href="#能源互联网下虚拟电厂的运行与控制" class="headerlink" title="能源互联网下虚拟电厂的运行与控制"></a>能源互联网下虚拟电厂的运行与控制</h2><h3 id="VPP的内部优化调度"><a href="#VPP的内部优化调度" class="headerlink" title="VPP的内部优化调度"></a>VPP的内部优化调度</h3><p>指由虚拟电厂对自身内部的分布式能源进行出力的优化，从而定制内部分布式能源的出力计划。  </p>
<p>常用的目标函数：  </p>
<ul>
<li>经济效益最大</li>
<li>运行成本最小</li>
<li>弃电弃负荷的惩罚成本最小</li>
<li>环境成本最小</li>
</ul>
<p>常用的约束条件：  </p>
<ul>
<li>功率平衡约束</li>
<li>机组出力约束</li>
<li>机组爬坡率约束</li>
<li>储能设备充放电约束</li>
<li>传输功率约束</li>
</ul>
<h3 id="含VPP的电网优化调度"><a href="#含VPP的电网优化调度" class="headerlink" title="含VPP的电网优化调度"></a>含VPP的电网优化调度</h3><p>从电网的角度出发，将虚拟电厂看成一个传统电厂，根据电网的实际运行环境进行优化，确定虚拟电厂的处理。  </p>
<p>常用的目标函数：  </p>
<ul>
<li>系统效益最大</li>
<li>系统成本最小</li>
<li>网络损耗最小</li>
</ul>
<p>常用的约束条件：  </p>
<ul>
<li>系统潮流约束</li>
<li>系统电压约束</li>
<li>虚拟电厂处理约束</li>
<li>传输功率约束</li>
</ul>
<h3 id="不确定性处理"><a href="#不确定性处理" class="headerlink" title="不确定性处理"></a>不确定性处理</h3><p>存在不确定因素：风、光等不可控电源处理的不确定性、负荷的不确定性、机组随机故障、电价不确定性等。  </p>
<p>处理方法：模糊规划、随机规划、鲁棒优化等  </p>
<h3 id="能源互联网下虚拟电厂的多层优化调度"><a href="#能源互联网下虚拟电厂的多层优化调度" class="headerlink" title="能源互联网下虚拟电厂的多层优化调度"></a>能源互联网下虚拟电厂的多层优化调度</h3><ul>
<li>虚拟电厂的多时间尺度优化调度，电力市场分日间市场、日内市场、实时市场。</li>
<li>虚拟电厂的多层级优化调度</li>
</ul>
<h3 id="基于多代理系统的虚拟电厂运行与控制"><a href="#基于多代理系统的虚拟电厂运行与控制" class="headerlink" title="基于多代理系统的虚拟电厂运行与控制"></a>基于多代理系统的虚拟电厂运行与控制</h3><ul>
<li>多代理系统是由多个相互独立、可以双向互通通信的智能代理组合形成的，这些代理在逻辑与物理上是分离的。各个代理具有自主性和独立性</li>
<li>基于多代理系统的模拟电厂控制框架</li>
</ul>
<h2 id="能源互联网下虚拟电厂的市场竞价"><a href="#能源互联网下虚拟电厂的市场竞价" class="headerlink" title="能源互联网下虚拟电厂的市场竞价"></a>能源互联网下虚拟电厂的市场竞价</h2><h3 id="虚拟电厂市场竞价问题"><a href="#虚拟电厂市场竞价问题" class="headerlink" title="虚拟电厂市场竞价问题"></a>虚拟电厂市场竞价问题</h3><ul>
<li>按功能，可参与的市场模式：能量市场、辅助服务市场等<ul>
<li>能量市场：考虑电网安全约束，目标为经济效益最优</li>
<li>辅助服务市场：考虑备用容量约束、调峰容量约束等，目标为社会支付服务成本最小</li>
</ul>
</li>
<li>按时间尺度：中长期合约市场、日前市场、日内市场和实时市场<ul>
<li>日前市场<ul>
<li>目标函数：运行成本最小或经济效益最大</li>
<li>约束条件：系统功率平衡约束；机组出力约束；机组爬坡约束；系统旋转备用约束；弃风量、弃光亮约束；网络潮流约束；网络节点电压约束；传统机组启停时间约束</li>
</ul>
</li>
<li>日内市场<ul>
<li>目标函数：运行成本最小或经济效益最大</li>
<li>约束条件：系统功率平衡约束；机组出力约束；机组爬坡约束；系统旋转备用约束；弃风量、弃光亮约束；网络潮流约束；网络节点电压约束</li>
</ul>
</li>
<li>实时市场<ul>
<li>目标函数：最小调整成本</li>
<li>约束条件：系统功率平衡约束；出力调整量约束；系统旋转备用约束；弃风量、弃光亮约束；网络潮流约束；网络节点电压约束</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于多代理系统的虚拟电厂市场竞价问题"><a href="#基于多代理系统的虚拟电厂市场竞价问题" class="headerlink" title="基于多代理系统的虚拟电厂市场竞价问题"></a>基于多代理系统的虚拟电厂市场竞价问题</h3><ul>
<li>电力市场代理</li>
<li>传统电厂代理及虚拟电厂代理</li>
<li>分布式能源代理</li>
</ul>
<h3 id="多市场模式下虚拟电厂市场竞价问题"><a href="#多市场模式下虚拟电厂市场竞价问题" class="headerlink" title="多市场模式下虚拟电厂市场竞价问题"></a>多市场模式下虚拟电厂市场竞价问题</h3><p>关键在于如何制定多市场模式下的参与规则、如何确定多市场之间的耦合关系，以及如何解决多市场模式下的多目标优化问题，是的虚拟电厂具有更好的适应性。  </p>
<h2 id="能源互联网下虚拟电厂的发展与展望"><a href="#能源互联网下虚拟电厂的发展与展望" class="headerlink" title="能源互联网下虚拟电厂的发展与展望"></a>能源互联网下虚拟电厂的发展与展望</h2><h3 id="虚拟电厂在能源互联网中的作用与地位"><a href="#虚拟电厂在能源互联网中的作用与地位" class="headerlink" title="虚拟电厂在能源互联网中的作用与地位"></a>虚拟电厂在能源互联网中的作用与地位</h3><p>构建能源互联网的重点在于智能发电、智能配电、智能用电和用户侧服务。  </p>
<p>在能源互联网中，虚拟电厂可以利用能源互联网的先进技术实现对资深的运行优化与能量管理。  </p>
<p>虚拟电厂在能源互联网中的作用：  </p>
<ul>
<li>虚拟电厂是高效利用新能源发电的有效形式</li>
<li>是推动能源互联网建设的重要环节</li>
<li>对于完善中国电力市场体制具有重要的促进作用和指导意义</li>
</ul>
<h3 id="能源互联网下虚拟电厂的前进展望"><a href="#能源互联网下虚拟电厂的前进展望" class="headerlink" title="能源互联网下虚拟电厂的前进展望"></a>能源互联网下虚拟电厂的前进展望</h3><ul>
<li>广域合作</li>
<li>广域消纳</li>
<li>广域优化</li>
<li>广域通信</li>
</ul>
]]></content>
      <categories>
        <category>「笔记」- 读书</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>能源</tag>
        <tag>VPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel VBA Notes</title>
    <url>/2020/12/15/Excel-VBA/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>提高工作效率吧打工人</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="入门方法"><a href="#入门方法" class="headerlink" title="入门方法"></a>入门方法</h2><h3 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h3><p><code>视图</code>→<code>宏</code>→<code>录制宏</code>  / <code>开发工具</code>  </p>
<p><code>Alt+F11</code>查看录制内容  </p>
<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><p><a href="https://www.lanrenexcel.com/excel-vba-tutorial/" target="_blank" rel="noopener">懒人Excel - VBA教程</a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="VBE编辑器-Visual-Basic-Editor"><a href="#VBE编辑器-Visual-Basic-Editor" class="headerlink" title="VBE编辑器 Visual Basic Editor"></a>VBE编辑器 Visual Basic Editor</h3><p><code>Alt+F11</code>进入编辑器</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以英文单引号<code>‘</code>开头 。  </p>
<p>用途：  </p>
<ul>
<li>提供过程或函数的基本信息、用途</li>
<li>说明变量的用途</li>
<li>解释为什么使用当前的方法</li>
<li>区分开不同代码块</li>
<li>在开发调试过程中，临时注释一段代码，使其不被执行，检查代码其余部分是否有错误</li>
</ul>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>可运行的VBA代码块。  </p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是一个物，它可以是一个事、一个物体、一个概念、一个名词。对象包含描述静态信息的<strong>属性</strong>和对对象可以操作的<strong>方法</strong>。  </p>
<p>以生活中的对象为例子，汽车是一个对象。汽车的车牌号、油量、里程等是汽车的属性；开车、加油、换车牌等是汽车的方法。  </p>
<p><strong>常用Excel对象</strong>  </p>
<ul>
<li><code>Application 对象</code>，表示 Excel 应用程序。</li>
<li><code>Workbook 对象</code>，表示工作簿对象。</li>
<li><code>Worksheet 对象</code>，表示工作表对象</li>
<li><code>Range 对象</code>，表示单元格区域对象。</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块是包含一个或多个过程或函数的内部组件。一个工作簿内包含的模块数量没有限制，一个模块内包含的过程或函数数量也没有限制。<u>模块用来作为保存过程或函数的容器</u>，这些过程和函数通常应用于整个工作簿。  </p>
<p>通过把多个过程和函数，合理的放置在不同的模块，可以使整个 VBA 代码逻辑更清晰、更易于阅读和理解。  </p>
<h3 id="用户窗体"><a href="#用户窗体" class="headerlink" title="用户窗体"></a>用户窗体</h3><p>VBA和用户交互的界面，最基本的窗体控件包括：  </p>
<ul>
<li>文本控件</li>
<li>按钮控件</li>
<li>列表控件</li>
<li>输入控件</li>
</ul>
<h3 id="「开发工具」选项卡"><a href="#「开发工具」选项卡" class="headerlink" title="「开发工具」选项卡"></a>「开发工具」选项卡</h3><p>功能区中右键→「自定义功能区」→√「开发工具」  </p>
<h2 id="Excel-VBA设置宏安全性"><a href="#Excel-VBA设置宏安全性" class="headerlink" title="Excel VBA设置宏安全性"></a>Excel VBA设置宏安全性</h2><p>默认情况下，为防止来源不明的工作簿自带宏自动运行，Excel 会禁用宏的运行。  </p>
<h3 id="宏安全性"><a href="#宏安全性" class="headerlink" title="宏安全性"></a>宏安全性</h3><p>「开发工具」选项卡→「宏安全性」→打开信任中心：  </p>
<ul>
<li><strong>禁用所有宏，并且不通知</strong>：无法运行打开的工作簿内的 VBA 代码，Excel 也不会提示工作簿包含代码。</li>
<li><strong>禁用所有宏，并发出通知</strong>：默认状态下，无法运行 VBA 代码。但是 Excel 在打开包含 VBA 代码的工作簿时，在编辑栏上方，显示安全警告，并且可以选择启用代码运行或不启用。如果选择启用，下次打开相同的工作簿，不会出现警告。</li>
<li><strong>禁用无数字签署的所有宏</strong>：宏将被禁用，但如果存在宏，则会显示安全警告。但是，如果受信任发布者对宏进行了数字签名，并且您已经信任该发布者，则可运行该宏。如果您尚未信任该发布者，则会通知您启用签署的宏并信任该发布者。</li>
<li><strong>启用所有宏(不推荐；可能会运行有潜在危险的代码)</strong>：可以运行所有宏。一般不推荐选择此选项。</li>
</ul>
<p>安全起见，可以采取：</p>
<ul>
<li>禁用所有宏，并发出通知。</li>
<li>在电脑上创建一个用于存放信任的包含代码的工作簿的文件夹，将此工作簿添加到受信任为位置。<ul>
<li>把一个文件夹添加到 Excel 受信任的位置后，该文件夹下的包含 VBA 代码的工作簿打开时，不会提示安全警告，也无需每次手动开启代码。</li>
<li>在开发工具选项卡，点击「宏安全性」按钮，弹出信任中心窗口，在左侧列表中，选择「受信任位置」。点击下方的「添加新位置」按钮，添加自己信任的一个文件夹。</li>
</ul>
</li>
</ul>
<h2 id="Excel-保存包含-VBA-代码的工作簿"><a href="#Excel-保存包含-VBA-代码的工作簿" class="headerlink" title="Excel 保存包含 VBA 代码的工作簿"></a>Excel 保存包含 VBA 代码的工作簿</h2><p>2003 及之前的版本中，在 <code>xls</code>类型工作簿可以任意编写并保存 VBA 代码。  </p>
<p>2007 版本开始，第一次保存包含 VBA 代码的工作簿时，Excel 会提示“无法保存工作簿”。  </p>
<p>含 VBA 代码的工作簿，必须保存成启用宏的工作簿类型。Excel 为此提供了<code>xlsm</code>类型的工作簿，称之为「<strong>启用宏的工作簿</strong>」。</p>
<h2 id="使用VBA-编辑器进行-Excel-VBA-开发"><a href="#使用VBA-编辑器进行-Excel-VBA-开发" class="headerlink" title="使用VBA 编辑器进行 Excel VBA 开发"></a>使用VBA 编辑器进行 Excel VBA 开发</h2><h3 id="打开方法"><a href="#打开方法" class="headerlink" title="打开方法"></a>打开方法</h3><ul>
<li>方法一：「开发工具」选项卡→<code>Visual Basic</code></li>
<li>方法二：工作表右键菜单→<code>查看代码(V)</code></li>
<li>方法三：快捷键<code>Alt + F11</code></li>
</ul>
<h3 id="编辑器模块"><a href="#编辑器模块" class="headerlink" title="编辑器模块"></a>编辑器模块</h3><ul>
<li><strong>工具栏</strong>：编辑器命令栏，与 Excel 功能区域类似，包含 Excel VBA 开发相关的命令。</li>
<li><strong>VBA 工程</strong>：显示当前 VBA 工程包含的所有对象。通常，一个工作簿就是一个 VBA 工程，其中包括 Excel 对象、工作表对象、模块等。</li>
<li><strong>属性窗口</strong>：查看和设置选中对象的属性的窗口。</li>
<li><strong>代码编辑窗口</strong>：实际编写代码的位置。编写、修改、保存代码，都在这里进行。</li>
<li><strong>立即窗口</strong>：代码运行过程中，打印出的内容，在立即窗口中显示。一般用于调试代码</li>
</ul>
<h3 id="运行VBA代码"><a href="#运行VBA代码" class="headerlink" title="运行VBA代码"></a>运行VBA代码</h3><ul>
<li>方法一：VBA编辑器工具栏「运行」→「运行子过程」</li>
<li>方法二：VBA编辑器快捷工具栏的播放图标</li>
<li>方法三：快捷键<code>F5</code></li>
<li>方法四：给<code>图形</code>或者<code>按钮</code>指定宏，点击运行</li>
</ul>
<hr>
<h1 id="VBA-变量、类型、运算符"><a href="#VBA-变量、类型、运算符" class="headerlink" title="VBA 变量、类型、运算符"></a>VBA 变量、类型、运算符</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>VBA变量时一个存储数据的VBA代码接口，可存储、改变、参与计算  </p>
<ul>
<li><strong>变量名</strong>：代表变量的名称</li>
<li><strong>变量类型</strong>：变量存储的数据的类型，例如数字、文本、逻辑值等</li>
</ul>
<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> [变量名] <span class="keyword">As</span> [数据类型]</span><br></pre></td></tr></table></figure>

<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><ul>
<li>首字母必须以字母开头。</li>
<li>不能包含空格、.(英文句号)、!(感叹号)、@、&amp;、$、# 等字符。</li>
<li>长度不能超过 255 个字符。</li>
<li>不能使用 VBA 中保存的关键词作为变量名。</li>
</ul>
<blockquote>
<p>驼峰命名法：当变量名或函数名是由一个或多个单词连结在一起，而构成的唯一识别字时<strong>，第一个单词以小写字母开始；从第二个单词开始以后的每个单词的首字母都采用大写字母。</strong></p>
<p>例如：myFirstName、myLastName，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。</p>
</blockquote>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>三大类数据类型：数字类型、非数字类型、通用类型。  </p>
<p><strong>数字类型</strong>： </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>字节</td>
<td>0 至 255</td>
</tr>
<tr>
<td>Integer</td>
<td>整数</td>
<td>-32,768 至 32,767</td>
</tr>
<tr>
<td>Long</td>
<td>长整数</td>
<td>-2,147,483,648 至 2,147,483,648</td>
</tr>
<tr>
<td>Single</td>
<td>单精度浮点数</td>
<td>在表示负数时： -3.402823E38 ~ -1.401298E-45 在表示正数时： 1.401298E-45 ~ 3.402823E38</td>
</tr>
<tr>
<td>Double</td>
<td>双精度浮点数</td>
<td>在表示负数时： -1.79769313486231E308 ~ -4.94065645841247E-324 在表示正数时： 4.94065645841247E-324 ~ 1.79769313486231E308</td>
</tr>
<tr>
<td>Currency</td>
<td>货币</td>
<td>-922,337,203,685,477.5808 至 922,337,203,685,477.5807</td>
</tr>
<tr>
<td>Decimal</td>
<td>定点数</td>
<td>未放置定点数： +/- 79,228,162,514,264,337,593,543,950,335 放置定点数： +/- 7.9228162514264337593543950335</td>
</tr>
</tbody></table>
<p><strong>非数字类型</strong>：  </p>
<p>非数字变量通常不能直接参与算术运算。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>文本类型</td>
<td>0 至 20亿字符</td>
</tr>
<tr>
<td>Boolean</td>
<td>逻辑值</td>
<td>True 或 False</td>
</tr>
<tr>
<td>Date</td>
<td>日期和时间</td>
<td>时间：00:00:00 至 23:59:59 日期： 100-1-1 至 9999-12-31</td>
</tr>
<tr>
<td>Object</td>
<td>对象</td>
<td>VBA 和 Excel 对象</td>
</tr>
</tbody></table>
<p><strong>通用类型</strong>：  </p>
<p>可存储任何类型的数据。在程序运行过程，VBA 可以自动识别数据类型，参与计算。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>Variant</td>
<td>任意类型</td>
<td>不限</td>
</tr>
</tbody></table>
<p>Variant 类型虽然灵活，但是它会占用更多内存空间，执行效率也会受影响。因此建议，在明确知道数据是何种类型时，指定数据类型；如果数据类型是可变的或不明确，使用 Variant 类型。</p>
<h3 id="给变量赋值"><a href="#给变量赋值" class="headerlink" title="给变量赋值"></a>给变量赋值</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">[变量名] = [数据]</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在声明时就要指定值。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Const</span> [常量名] <span class="keyword">As</span> [数据类型] = [值]</span><br></pre></td></tr></table></figure>

<h3 id="常量类型"><a href="#常量类型" class="headerlink" title="常量类型"></a>常量类型</h3><p>与变量相同。  </p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>给变量赋值</td>
<td>name = “Zhang San”</td>
</tr>
</tbody></table>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>假设 <code>a = 10</code>，<code>b = 3</code>，<code>-&gt;</code> 表示结果。  </p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>两数相加</td>
<td>a + b -&gt; 13</td>
</tr>
<tr>
<td>–</td>
<td>两数相减</td>
<td>a – b -&gt; 7</td>
</tr>
<tr>
<td>*</td>
<td>两数相乘</td>
<td>a * b -&gt; 30</td>
</tr>
<tr>
<td>/</td>
<td>两数相除</td>
<td>a / b -&gt; 2.5</td>
</tr>
<tr>
<td>\</td>
<td>两数相除，取整数部分</td>
<td>a \ b -&gt; 3</td>
</tr>
<tr>
<td>Mod</td>
<td>两数相除，取余数</td>
<td>a Mod b -&gt; 1</td>
</tr>
<tr>
<td>^</td>
<td>幂运算</td>
<td>a ^ b -&gt; 1000</td>
</tr>
<tr>
<td>-（取负）</td>
<td>对数字取负</td>
<td>-a -&gt; -10</td>
</tr>
</tbody></table>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>假设 <code>a = 10</code>，<code>b = 3</code>，<code>-&gt;</code> 表示结果。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>比较两个值是否相等</td>
<td>a = b -&gt; False</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>a &gt; b -&gt; True</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>a &gt;= b =&gt; False</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>a &lt; b -&gt; False</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>a &lt;= b -&gt; False</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于</td>
<td>a &lt;&gt; b -&gt; True</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符对逻辑值，即 True 和 False，进行逻辑运算，返回运算结果，运算结果也是逻辑值。</p>
<p>假设 <code>a = True</code>，<code>b = False</code>，<code>-&gt;</code> 表示结果。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>And</td>
<td>逻辑与，两个表达式都是真，返回 True。</td>
<td>a And b -&gt; False</td>
</tr>
<tr>
<td>Or</td>
<td>逻辑或，两个表达式至少有一个为真，返回 True。</td>
<td>a Or b -&gt; True</td>
</tr>
<tr>
<td>Not</td>
<td>逻辑否，对逻辑表达式取否</td>
<td>Not a -&gt; False</td>
</tr>
<tr>
<td>Xor</td>
<td>逻辑异或，如果两个表达式不相同，返回 True</td>
<td>a Xor b -&gt; True</td>
</tr>
</tbody></table>
<h3 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h3><p>VBA 中的连接运算符用于连接 2 个或多个文本。其用法与 Excel 公式中的 &amp; 符号相同。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>连接两个文本</td>
<td>“Zhang” &amp; ” ” &amp; “San” -&gt; “Zhang San”</td>
</tr>
</tbody></table>
<h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><h2 id="其他操作符-1"><a href="#其他操作符-1" class="headerlink" title="其他操作符"></a>其他操作符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>_ (下划线)</td>
<td>将一行代码分解成两行</td>
</tr>
<tr>
<td>: ( 英文冒号)</td>
<td>将两行代码放置在一行</td>
</tr>
</tbody></table>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="文本类型"><a href="#文本类型" class="headerlink" title="文本类型"></a>文本类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>文本类型</td>
<td>0 至 20亿字符</td>
</tr>
</tbody></table>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> name <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">name = <span class="string">"Zhang San"</span></span><br><span class="line">name = <span class="string">"101"</span></span><br><span class="line">name = Range(<span class="string">"A1"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>选择合适的数字类型：如果小数字使用大范围数字类型存储，会浪费计算机内存；如果大数字使用小范围的数字类型存储，VBA 会自动转换成对应小范围数字，导致数字丢失精度。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>比特</td>
<td>0 至 255</td>
</tr>
<tr>
<td>Integer</td>
<td>整数</td>
<td>-32,768 至 32,767</td>
</tr>
<tr>
<td>Long</td>
<td>长整数</td>
<td>-2,147,483,648 至 2,147,483,648</td>
</tr>
<tr>
<td>Single</td>
<td>单精度浮点数</td>
<td>在表示负数时： -3.402823E38 ~ -1.401298E-45 在表示正数时： 1.401298E-45 ~ 3.402823E38</td>
</tr>
<tr>
<td>Double</td>
<td>双精度浮点数</td>
<td>在表示负数时： -1.79769313486231E308 ~ -4.94065645841247E-324 在表示正数时： 4.94065645841247E-324 ~ 1.79769313486231E308</td>
</tr>
<tr>
<td>Currency</td>
<td>货币</td>
<td>-922,337,203,685,477.5808 至 922,337,203,685,477.5807</td>
</tr>
<tr>
<td>Decimal</td>
<td>定点数</td>
<td>未放置定点数： +/- 79,228,162,514,264,337,593,543,950,335 放置定点数： +/- 7.9228162514264337593543950335</td>
</tr>
</tbody></table>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> age <span class="keyword">as</span> <span class="built_in">Integer</span></span><br></pre></td></tr></table></figure>

<h3 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>逻辑值</td>
<td>True 或 False</td>
</tr>
</tbody></table>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> isPass <span class="keyword">As</span> <span class="built_in">Boolean</span></span><br><span class="line">isPass = <span class="literal">False</span></span><br><span class="line">isPass = <span class="number">70</span> &gt;= <span class="number">60</span></span><br></pre></td></tr></table></figure>

<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>VBA 中的日期和时间使用数字表示，整数部分代表日期，小数部分代表时间。  </p>
<ul>
<li>日期从 100-1-1 开始到 9999-12-31。</li>
<li>时间从 00:00:00 到 23:59:59。</li>
</ul>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> birthday <span class="keyword">As</span> <span class="built_in">Date</span></span><br><span class="line"><span class="keyword">Dim</span> time <span class="keyword">As</span> <span class="built_in">Date</span></span><br></pre></td></tr></table></figure>

<p>给日期变量赋值时，可以直接把日期放置在两个 # 之间赋值，也可以使用数字，还可以把日期作为文本赋值：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">birthday = <span class="meta">#2018-1-1#</span></span><br><span class="line">birthday = <span class="number">43101</span></span><br><span class="line">birthday = <span class="string">"2018-1-1"</span></span><br><span class="line"></span><br><span class="line">time = <span class="meta">#12:00:00#</span></span><br><span class="line">time = <span class="number">0.5</span></span><br><span class="line">time = <span class="string">"12:00:00"</span></span><br></pre></td></tr></table></figure>

<h3 id="Variant-类型"><a href="#Variant-类型" class="headerlink" title="Variant 类型"></a>Variant 类型</h3><p>Variant 类型是一种通用类型，可以表示任何一种类型的数据。它也是声明变量未指定数据类型时的默认类型。  </p>
<p>虽然 Variant 类型方便，但是相应的，占用更大的内存空间，也会影响程序运行效率。因此建议，在明确知道数据时何种类型时，指定数据类型；如果数据类型是可变的或不明确，使用 Variant 类型。  </p>
<hr>
<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过程是 VBA 中，程序实际运行的最小结构。单独的一行或多行代码无法运行，必须把它们放置在一个过程里，才能运行。  </p>
<p>在示例中，<code>Sub 过程名()</code> 开头，<code>End Sub</code> 为结尾部分是一个过程的主题，其余代码需要放置在两者之间。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> 过程名()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<h3 id="程序语句"><a href="#程序语句" class="headerlink" title="程序语句"></a>程序语句</h3><p>语句，是表示一个完整意思的一行代码。  </p>
<ul>
<li><strong>声明式语句</strong>，也就是声明变量、常量、过程或者函数。</li>
<li><strong>执行式语句</strong>，执行指定动作。动作可以包括执行一个过程、开始一个循环、判断表达式等。</li>
<li><strong>赋值语句</strong>，给变量赋值，是执行式语句的特殊形式。</li>
</ul>
<h3 id="VBA对象"><a href="#VBA对象" class="headerlink" title="VBA对象"></a>VBA对象</h3><h3 id="程序运行结构"><a href="#程序运行结构" class="headerlink" title="程序运行结构"></a>程序运行结构</h3><ul>
<li>顺序结构</li>
<li>循环结构</li>
<li>判断结构</li>
</ul>
<h2 id="声明和赋值"><a href="#声明和赋值" class="headerlink" title="声明和赋值"></a>声明和赋值</h2><p>声明变量，就是告诉 VBA，变量的名字和它所存储的值的数据类型。  </p>
<p>有4种变量：  </p>
<ul>
<li><p><strong>基本类型变量</strong>。基本类型变量是那些存储单个数据的变量，例如数字、文本、日期等。</p>
<ul>
<li><pre><code class="vb"><span class="comment">'语法</span>
<span class="keyword">Dim</span> [变量名] <span class="keyword">As</span> [数据类型]

<span class="comment">'实例</span>
<span class="keyword">Dim</span> name <span class="keyword">As</span> <span class="built_in">String</span>
<span class="keyword">Dim</span> age <span class="keyword">As</span> <span class="built_in">Integer</span>
<span class="keyword">Dim</span> height <span class="keyword">As</span> <span class="built_in">Double</span>
<span class="keyword">Dim</span> birthday <span class="keyword">As</span> <span class="built_in">Date</span>
&lt;!--￼<span class="number">9</span>--&gt;</code></pre>
</li>
</ul>
</li>
<li><p><strong>数组</strong>。数组包含多个变量的集合。</p>
<ul>
<li><pre><code class="vb"><span class="comment">'语法</span>
<span class="comment">'固定长度数组声明</span>
<span class="keyword">Dim</span> [变量名](开始序号 <span class="keyword">to</span> 结束序号) <span class="keyword">As</span> [数据类型]
<span class="comment">'动态数组声明</span>
<span class="keyword">Dim</span> [变量名]() <span class="keyword">As</span> [数据类型]

<span class="comment">'实例</span>
<span class="comment">'声明包含10个文本类型元素的数组</span>
<span class="keyword">Dim</span> names(<span class="number">1</span> <span class="keyword">to</span> <span class="number">10</span>) <span class="keyword">As</span> <span class="built_in">String</span>
<span class="comment">'声明长度未知的文本类型数组</span>
<span class="keyword">Dim</span> names() <span class="keyword">As</span> <span class="built_in">String</span>
&lt;!--￼<span class="number">10</span>--&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>声明变量的语句，必须写在使用它的语句前。  </p>
<h3 id="声明多个同类型变量"><a href="#声明多个同类型变量" class="headerlink" title="声明多个同类型变量"></a>声明多个同类型变量</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'第一种，按两行写</span></span><br><span class="line"><span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line"><span class="keyword">Dim</span> j <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'第二种，使用 : 符号，在一行写</span></span><br><span class="line"><span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="built_in">Integer</span> : <span class="keyword">Dim</span> j <span class="keyword">As</span> <span class="built_in">Integer</span></span><br></pre></td></tr></table></figure>

<h3 id="不声明变量就使用"><a href="#不声明变量就使用" class="headerlink" title="不声明变量就使用"></a>不声明变量就使用</h3><p>也可以，但非常不推荐，弊端：  </p>
<ul>
<li>数据类型自动设置为 Variant 类型，效率低。</li>
<li>变量名写错，不会提示错误。</li>
<li>无法使用 VBA 代码自动补全。</li>
<li>数据类型不匹配时，不会提示错误。</li>
</ul>
<p><strong>强制声明变量</strong>：在模块头部写上：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Option</span> <span class="keyword">Explicit</span></span><br></pre></td></tr></table></figure>

<h3 id="基本类型变量的赋值"><a href="#基本类型变量的赋值" class="headerlink" title="基本类型变量的赋值"></a>基本类型变量的赋值</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'语法，两种写法相同</span></span><br><span class="line"><span class="keyword">Let</span> [变量名] = [数据]</span><br><span class="line">[变量名] = [数据]</span><br><span class="line"></span><br><span class="line"><span class="comment">'实例</span></span><br><span class="line"><span class="keyword">Dim</span> name <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line"><span class="keyword">Let</span> name = <span class="string">"Zhang San"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> age <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line"><span class="keyword">Let</span> age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> birthday <span class="keyword">As</span> <span class="built_in">Date</span></span><br><span class="line"><span class="keyword">Let</span> birthday = <span class="meta">#2000-1-1#</span></span><br></pre></td></tr></table></figure>

<p>在实际开发中，给基本类型变量赋值时，<code>Let</code>关键词可以忽略不写，直接以变量开头写赋值语句。  </p>
<h3 id="数组类型变量赋值"><a href="#数组类型变量赋值" class="headerlink" title="数组类型变量赋值"></a>数组类型变量赋值</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'语法</span></span><br><span class="line">[数组名](元素序号) = [数据]</span><br><span class="line"></span><br><span class="line"><span class="comment">'声明数组</span></span><br><span class="line"><span class="keyword">Dim</span> arr(<span class="number">1</span> <span class="keyword">to</span> <span class="number">5</span>) <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line"><span class="comment">'数组赋值</span></span><br><span class="line">arr(<span class="number">1</span>) = <span class="string">"Zhang San"</span></span><br><span class="line">arr(<span class="number">2</span>) = <span class="string">"Li Si"</span></span><br><span class="line">arr(<span class="number">3</span>) = <span class="string">"Wang Wu"</span></span><br></pre></td></tr></table></figure>

<h3 id="对象类型变量的赋值"><a href="#对象类型变量的赋值" class="headerlink" title="对象类型变量的赋值"></a>对象类型变量的赋值</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'语法</span></span><br><span class="line"><span class="keyword">Set</span> [变量名] = [对象类型数据]</span><br><span class="line">    </span><br><span class="line"><span class="comment">'声明工作表类型的对象</span></span><br><span class="line"><span class="keyword">Dim</span> sheet <span class="keyword">As</span> Worksheet</span><br><span class="line"><span class="comment">'将名称为“绩效表”的工作表，赋到 sheet 变量</span></span><br><span class="line"><span class="keyword">Set</span> sheet = Worksheets(<span class="string">"绩效表"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>对象使用 <code>Set</code> 关键词，并且<code>Set</code>关键词不能省略。</strong>  </p>
<p>由于对象可以包含多个属性，因此 VBA 提供一种同时给多个属性赋值的简单方法。具体方法是对象多个属性赋值语句，放置在 <code>With</code>+<code>对象</code>和<code>End With</code>关键词中间。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> sheet <span class="keyword">As</span> Worksheet</span><br><span class="line"><span class="keyword">Set</span> sheet = Worksheets(<span class="string">"绩效表"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">With</span> sheet</span><br><span class="line">    .Name = <span class="string">"旧绩效"</span></span><br><span class="line">    .Visible = <span class="literal">False</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">With</span></span><br></pre></td></tr></table></figure>

<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="If-Then-结构"><a href="#If-Then-结构" class="headerlink" title="If Then 结构"></a>If Then 结构</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> 条件表达式 <span class="keyword">Then</span></span><br><span class="line">    <span class="comment">'表达式为真时，执行的代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>

<h3 id="If-Else-结构"><a href="#If-Else-结构" class="headerlink" title="If Else 结构"></a>If Else 结构</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> 条件表达式 <span class="keyword">Then</span></span><br><span class="line">    <span class="comment">'真时执行的代码</span></span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    <span class="comment">'假时执行的代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>

<h3 id="If-ElseIf-Else-结构"><a href="#If-ElseIf-Else-结构" class="headerlink" title="If ElseIf Else 结构"></a>If ElseIf Else 结构</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> 条件表达式<span class="number">1</span> <span class="keyword">Then</span></span><br><span class="line">    <span class="comment">'表达式1真时，执行的代码</span></span><br><span class="line"><span class="keyword">ElseIf</span> 条件表达式<span class="number">2</span> <span class="keyword">Then</span></span><br><span class="line">    <span class="comment">'表达式2真时，执行的代码</span></span><br><span class="line"><span class="keyword">ElseIf</span> 条件表达式<span class="number">3</span> <span class="keyword">Then</span></span><br><span class="line">    <span class="comment">'表达式3真时，执行的代码</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ElseIf</span> 条件表达式n <span class="keyword">Then</span></span><br><span class="line">    <span class="comment">'表达式n真时，执行的代码</span></span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">    <span class="comment">'以上表达式都不为真时，执行的代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">If</span></span><br></pre></td></tr></table></figure>

<p>注意：  </p>
<ul>
<li>条件表达式是从第一个开始判断。</li>
<li>判断过程中，只要有一个表达式结果为真，那么执行对应的代码块，然后退出选择结构，不再继续判断剩下的表达式。</li>
<li>当所有的表达式都不为真时，执行 <code>Else</code>后的代码块。</li>
</ul>
<h3 id="Select-Case-结构"><a href="#Select-Case-结构" class="headerlink" title="Select Case 结构"></a>Select Case 结构</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Case</span> 变量</span><br><span class="line">	<span class="keyword">Case</span> 判断条件 <span class="number">1</span></span><br><span class="line">    	<span class="comment">'条件 1 真时，执行的代码</span></span><br><span class="line">	<span class="keyword">Case</span> 判断条件 <span class="number">2</span></span><br><span class="line">    	<span class="comment">'条件 2 真时，执行的代码</span></span><br><span class="line">	<span class="keyword">Case</span> 判断条件 <span class="number">3</span></span><br><span class="line">    	<span class="comment">'条件 3 真时，执行的代码</span></span><br><span class="line">    <span class="keyword">Case</span> <span class="keyword">Else</span></span><br><span class="line">    	<span class="comment">'之前的所有条件都不为真时，执行的代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Select</span></span><br></pre></td></tr></table></figure>

<p>举例：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> MyCode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> i <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">For</span> i = <span class="number">2</span> <span class="keyword">To</span> <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">Select</span> <span class="keyword">Case</span> Cells(i, <span class="string">"B"</span>).Value</span><br><span class="line">            <span class="keyword">Case</span> <span class="keyword">Is</span> &gt;= <span class="number">85</span></span><br><span class="line">                Cells(i, <span class="string">"D"</span>) = <span class="string">"优"</span></span><br><span class="line">            <span class="keyword">Case</span> <span class="keyword">Is</span> &gt;= <span class="number">75</span></span><br><span class="line">                Cells(i, <span class="string">"D"</span>) = <span class="string">"良"</span></span><br><span class="line">            <span class="keyword">Case</span> <span class="keyword">Is</span> &gt;= <span class="number">60</span></span><br><span class="line">                Cells(i, <span class="string">"D"</span>) = <span class="string">"及格"</span></span><br><span class="line">            <span class="keyword">Case</span> <span class="keyword">Else</span></span><br><span class="line">                Cells(i, <span class="string">"D"</span>) = <span class="string">"不及格"</span></span><br><span class="line">        <span class="keyword">End</span> <span class="keyword">Select</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">Next</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h3><ul>
<li><p><strong>For … Next 循环</strong></p>
<ul>
<li><pre><code class="vb"><span class="keyword">For</span> [变量] = [初始值] <span class="keyword">To</span> [结束值] <span class="keyword">Step</span> [步长]
    <span class="comment">'这里是循环执行的语句</span>
<span class="keyword">Next</span>
&lt;!--￼<span class="number">22</span>--&gt;</code></pre>
</li>
<li><p><code>[元素]</code> 是与集合中的元素相同类型的变量，该变量可在循环代码中使用。</p>
</li>
<li><p><code>[元素集合]</code>是包括多个元素的集合。</p>
</li>
<li><p>不需要数字变量</p>
</li>
<li><p>用于遍历</p>
</li>
</ul>
</li>
<li><p><strong>Exit For 语句</strong></p>
<ul>
<li>用于跳出循环</li>
</ul>
</li>
</ul>
<h3 id="Do-While-循环"><a href="#Do-While-循环" class="headerlink" title="Do While 循环"></a>Do While 循环</h3><ul>
<li><p><strong>Do While … Loop 循环</strong></p>
<ul>
<li><pre><code class="vb"><span class="keyword">Do</span> <span class="keyword">While</span> [条件表达式]
    <span class="comment">'循环执行的代码</span>
<span class="keyword">Loop</span>
&lt;!--￼<span class="number">23</span>--&gt;</code></pre>
</li>
<li><p><code>Do ... Loop While</code>循环至少循环执行代码一次后，再判断条件表达式的值</p>
</li>
<li><p>While 和条件表达式写在 Loop 关键词后</p>
</li>
</ul>
</li>
<li><p><strong>Exit Do 语句</strong></p>
<ul>
<li>用于跳出 <code>Do While</code> 循环</li>
</ul>
</li>
</ul>
<h3 id="Do-Until-循环"><a href="#Do-Until-循环" class="headerlink" title="Do Until 循环"></a>Do Until 循环</h3><ul>
<li><p><code>Do Until</code> 在条件表达式为真时，停止执行循环</p>
</li>
<li><p>Do Until … Loop 循环</p>
<ul>
<li><pre><code class="vb"><span class="keyword">Do</span> <span class="keyword">Until</span> [条件表达式]
    <span class="comment">'循环执行的代码</span>
<span class="keyword">Loop</span>
&lt;!--￼<span class="number">24</span>--&gt;</code></pre>
</li>
<li><p>先运行一次，再判断 <code>Until</code> 后条件表达式的值，如果是真，停止循环；如果是假，继续执行循环</p>
</li>
</ul>
</li>
</ul>
<h3 id="循环小结"><a href="#循环小结" class="headerlink" title="循环小结"></a>循环小结</h3><table>
<thead>
<tr>
<th>循环结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>For … Next 循环</td>
<td>按指定次数循环执行</td>
</tr>
<tr>
<td>For Each 循环</td>
<td>逐一遍历数据集合中的每一个元素</td>
</tr>
<tr>
<td>Do While … Loop 循环</td>
<td>当条件为真时，循环执行</td>
</tr>
<tr>
<td>Do … Loop While 循环</td>
<td>当条件为真时，循环执行。无论条件真假，至少运行一次</td>
</tr>
<tr>
<td>Do Until … Loop 循环</td>
<td>直到条件为真时，停止执行</td>
</tr>
<tr>
<td>Do … Loop Until 循环</td>
<td>直到条件为真时，停止执行。无论条件真假，至少运行一次</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>跳出语句</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Exit For</td>
<td>跳出 For 循环</td>
</tr>
<tr>
<td>Exit Do</td>
<td>跳出 Do While/Until 循环</td>
</tr>
</tbody></table>
<h2 id="With-结构"><a href="#With-结构" class="headerlink" title="With 结构"></a>With 结构</h2><p>With 结构可以将同一个对象的多个属性和方法组合起来，避免重复写对象名。此外，With 结构还能嵌套使用，进一步提高编程效率和程序运行效率。  </p>
<p><code>With</code> 结构由 <code>With</code> 和 <code>End With</code> 两个语句构成，对象的属性和方法都写在两者之间。基本语法如下：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">With</span> [对象]</span><br><span class="line">    .[属性] = [数据]</span><br><span class="line">    .[方法]</span><br><span class="line">    <span class="comment">'其他属性和方法</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">With</span></span><br></pre></td></tr></table></figure>

<p><code>With</code> 结构里，对象的属性和方法均有<code>点 (.)</code>符号开始，后接对象的属性名和方法名。  </p>
<p>举例：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> MyCode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">With</span> Worksheets(<span class="string">"Sheet1"</span>)</span><br><span class="line">        .Name = <span class="string">"新名称"</span></span><br><span class="line">        .Tab.ThemeColor = xlThemeColorLight1</span><br><span class="line">        .Visible = xlSheetHidden</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套-with-结构"><a href="#嵌套-with-结构" class="headerlink" title="嵌套 with 结构"></a>嵌套 with 结构</h3><p>如果父对象的属性是另一个对象，则针对这个子对象，继续使用 With 结构。  </p>
<p>举例：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> MyCode()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">With</span> Worksheets(<span class="string">"Sheet1"</span>)</span><br><span class="line">        .Name = <span class="string">"新名称"</span></span><br><span class="line">        .Tab.ThemeColor = xlThemeColorLight1</span><br><span class="line">        .Visible = xlSheetHidden</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">With</span> .Range(<span class="string">"A1:A10"</span>)</span><br><span class="line">            .Interior.ThemeColor = xlThemeColorAccent1</span><br><span class="line">            .Font.Size = <span class="number">12</span></span><br><span class="line">            .Font.Name = <span class="string">"等线"</span></span><br><span class="line">        <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">With</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<h2 id="GoTo-结构"><a href="#GoTo-结构" class="headerlink" title="GoTo 结构"></a>GoTo 结构</h2><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GoTo</span> [标签]</span><br><span class="line"><span class="comment">'被跳过的代码</span></span><br><span class="line">...</span><br><span class="line">[标签]:</span><br><span class="line"><span class="comment">'被执行的代码</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，跳转处的标签，后接冒号 ( : ) 。  </p>
<hr>
<h1 id="过程和函数（Sub-Function）"><a href="#过程和函数（Sub-Function）" class="headerlink" title="过程和函数（Sub | Function）"></a>过程和函数（Sub | Function）</h1><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p>通常一个过程，建议只完成一个特定的小目标。因此，我们的程序往往会包含多个过程。这就是 VBA 中过程概念存在的一个原因。  </p>
<h3 id="过程基本语法"><a href="#过程基本语法" class="headerlink" title="过程基本语法"></a>过程基本语法</h3><p>VBA 过程以 <code>Sub</code> 语句开始，以 <code>End Sub</code> 语句结束，包含一个或多个语句，完成一个特定的目标。  </p>
<p><strong>无参数过程</strong>：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> [过程名]()</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    语句n</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p><strong>有参数过程</strong>：  </p>
<p>过程还可以接受一个或多个参数，参数可以是常量、变量、表达式，并且每个参数指定其名称。在过程的语句中，接受的参数，以名称指定方式被使用。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> [过程名]([变量名<span class="number">1</span>] <span class="keyword">As</span> [数据类型<span class="number">1</span>],...[变量名n] <span class="keyword">As</span> [数据类型n])</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>举例：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'声明一个过程</span></span><br><span class="line"><span class="keyword">Sub</span> SayHello(name <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    Msgbox <span class="string">"Hello"</span> &amp; name</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'在另一个过程，调用上述过程，调用时，提供一个实际的 name 参数</span></span><br><span class="line"><span class="keyword">Sub</span> MyCode()</span><br><span class="line">    SayHello <span class="string">"World 2"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<h3 id="调用子过程（Sub）"><a href="#调用子过程（Sub）" class="headerlink" title="调用子过程（Sub）"></a>调用子过程（Sub）</h3><p>在程序开发中，把代码拆分成多个子过程和函数，可以使项目更容易管理、测试和运行，VBA 中也不例外。  </p>
<p>实际开发中，项目通常具备一个主入口过程，或称为父过程。父过程通过调用多个子过程和函数，完成一系列复杂的操作。其中子过程和函数一般只负责一个操作或动作。  </p>
<p><strong>直接调用</strong>：  </p>
<p>直接写过程名，即可调用过程。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    MySub</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> MySub()</span><br><span class="line">    <span class="comment">'代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    MySub <span class="number">2019</span>,<span class="string">"年"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> MySub(val1 <span class="keyword">As</span> <span class="built_in">Integer</span>, val2 <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    <span class="comment">'代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p><strong>使用关键词Call调用</strong>：  </p>
<p>Call 后接过程名。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    <span class="keyword">Call</span> MySub</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> MySub()</span><br><span class="line">    <span class="comment">'代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>如果子过程需要输入参数，则<strong>需要将参数放在括号内</strong>。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    <span class="keyword">Call</span> MySub(<span class="number">2019</span>,<span class="string">"年"</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> MySub(val1 <span class="keyword">As</span> <span class="built_in">Integer</span>, val2 <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    <span class="comment">'代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<h3 id="提前退出过程"><a href="#提前退出过程" class="headerlink" title="提前退出过程"></a>提前退出过程</h3><p><strong>Exit Sub 语句</strong>：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    <span class="keyword">Call</span> MySub</span><br><span class="line">    Msgbox <span class="string">"父过程"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> MySub()</span><br><span class="line">    <span class="keyword">Exit</span> <span class="keyword">Sub</span></span><br><span class="line">    Msgbox <span class="string">"子过程"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'运行 Main 过程，返回结果：</span></span><br><span class="line">=&gt; <span class="string">"父过程"</span></span><br></pre></td></tr></table></figure>

<p><strong>这里需要注意的是，<code>Exit Sub</code> 语句只作用于当前过程，不影响调用它的父过程。</strong>  </p>
<p><strong>End 语句</strong>：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    <span class="keyword">Call</span> MySub</span><br><span class="line">    Msgbox <span class="string">"父过程"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> MySub()</span><br><span class="line">	<span class="keyword">End</span></span><br><span class="line">    Msgbox <span class="string">"子过程"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'运行 Main 过程，返回结果：</span></span><br><span class="line">=&gt; 无返回结果</span><br></pre></td></tr></table></figure>

<p>在实际开发中，应谨慎使用 <code>End</code> 结束语句。<code>End</code> 语句的效果类似于电脑的强制关机命令，立即结束所有程序，不会保存任何值，于 VBA 有以下效果：  </p>
<ul>
<li>程序中对象的各类事件不会被触发；</li>
<li>任何在运行的 VBA 程序都会停止；</li>
<li>对象引用都会失效；</li>
<li>任何打开的窗体都被关闭。</li>
</ul>
<h2 id="函数（Function）"><a href="#函数（Function）" class="headerlink" title="函数（Function）"></a>函数（Function）</h2><p>函数与过程很相似，除了使用的关键词外，主要区别是，<strong>函数可以返回值</strong>。  </p>
<h3 id="函数基础语法"><a href="#函数基础语法" class="headerlink" title="函数基础语法"></a>函数基础语法</h3><p><strong>无参数函数</strong>：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Function</span> [函数名]() <span class="keyword">As</span> [返回值类型]</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    语句n</span><br><span class="line">    [函数名] = [返回值]</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>

<p>相比过程，可以看到多一个 <code>[函数名] = [返回值]</code> 语句，这是函数的返回值语句。函数名后制定该函数返回值的类型，语法与声明变量类似。  </p>
<p>举例：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'声明函数，该函数随机返回 true 或 false。函数需指定返回值类型。</span></span><br><span class="line"><span class="keyword">Function</span> RandomLogic() <span class="keyword">As</span> <span class="built_in">Boolean</span></span><br><span class="line">    RandomLogic = Rnd() &gt; <span class="number">0.5</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>

<p><strong>有参数函数</strong>：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Function</span> [函数名]([变量名<span class="number">1</span>] <span class="keyword">As</span> [数据类型<span class="number">1</span>],...[变量名n] <span class="keyword">As</span> [数据类型n]) <span class="keyword">As</span> [返回值类型]</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line">    [函数名] = [返回值]</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>

<p>举例：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Function</span> Add2Number(num1 <span class="keyword">As</span> <span class="built_in">Double</span>, num2 <span class="keyword">As</span> <span class="built_in">Double</span>) <span class="keyword">As</span> <span class="built_in">Double</span></span><br><span class="line">    Add2Number = num1 + num2</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>

<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>如果一个函数不返回值，它与子过程并无区别，其中调用方式与子过程相同。  </p>
<p>调用有返回值的函数时，一般有两种情形：  </p>
<ul>
<li>一是，使用一个变量存储函数返回的值</li>
<li>二是，函数返回的值参与其他计算</li>
</ul>
<p>举例：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    <span class="comment">'使用变量存储函数返回的值</span></span><br><span class="line">    <span class="keyword">Dim</span> result <span class="keyword">As</span> <span class="built_in">Double</span></span><br><span class="line">    result = Add(<span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">'函数返回值继续参与计算</span></span><br><span class="line">    <span class="keyword">Dim</span> result <span class="keyword">As</span> <span class="built_in">Double</span></span><br><span class="line">    result = RandNum + Add(<span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'函数：返回一个随机值</span></span><br><span class="line"><span class="keyword">Function</span> RandNum()</span><br><span class="line">    RandNum = Rnd * <span class="number">100</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br><span class="line"><span class="comment">'函数：返回两数的和</span></span><br><span class="line"><span class="keyword">Function</span> Add(num1 <span class="keyword">As</span> <span class="built_in">Double</span>, num2 <span class="keyword">As</span> <span class="built_in">Double</span>) <span class="keyword">As</span> <span class="built_in">Double</span></span><br><span class="line">    Add = num1 + num2</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Function</span></span><br></pre></td></tr></table></figure>

<h3 id="提前退出函数"><a href="#提前退出函数" class="headerlink" title="提前退出函数"></a>提前退出函数</h3><p><strong>Exit Function 语句</strong>：  </p>
<p>在一个函数中，当程序运行到 <code>Exit Function</code> 语句时，立即结束<strong>当前函数</strong>，提前退出。  </p>
<p><strong>这里需要注意的是，<code>Exit Function</code> 语句只作用于当前过程，不影响调用它的父过程或函数。</strong>  </p>
<p><strong>End 语句</strong>：  </p>
<p>在一个函数，当程序运行到 <code>End</code> 语句时，立即<strong>结束当前运行的所有 VBA 过程和函数</strong>。  </p>
<p>在实际开发中，应谨慎使用 <code>End</code> 结束语句。<code>End</code> 语句的效果类似于电脑的强制关机命令，立即结束所有程序，不会保存任何值，于 VBA 有以下效果：  </p>
<ul>
<li>程序中对象的各类事件不会被触发；</li>
<li>任何在运行的 VBA 程序都会停止；</li>
<li>对象引用都会失效；</li>
<li>任何打开的窗体都被关闭。</li>
</ul>
<h2 id="函数与过程的6个不同点"><a href="#函数与过程的6个不同点" class="headerlink" title="函数与过程的6个不同点"></a>函数与过程的6个不同点</h2><h3 id="声明语句不同"><a href="#声明语句不同" class="headerlink" title="声明语句不同"></a>声明语句不同</h3><p>函数的声明语句是 <code>Function</code> 和 <code>End Function</code>，而过程的声明语句是 <code>Sub</code> 和 <code>End Sub</code>。  </p>
<h3 id="函数可以返回值"><a href="#函数可以返回值" class="headerlink" title="函数可以返回值"></a>函数可以返回值</h3><p>函数相对子过程最大的不同点是，函数可以返回指定的值。调用函数时，使用一个变量存储函数返回的值，可以在后续的代码中使用。  </p>
<p>这里需要指出的是，函数可以不返回值，这种情况其作用与子过程相同。因此建议，不需要返回值时，直接使用子过程代替函数。  </p>
<h3 id="函数需指定返回值类型"><a href="#函数需指定返回值类型" class="headerlink" title="函数需指定返回值类型"></a>函数需指定返回值类型</h3><p>VBA 中数据有多种类型，准确使用数据类型可以是程序效率更高。  </p>
<p>同样，函数声明时也需要指定其返回值的类型。其语法与变量声明类似，在函数名后指定数据类型。  </p>
<h3 id="函数主体代码中，返回值赋值到函数自己"><a href="#函数主体代码中，返回值赋值到函数自己" class="headerlink" title="函数主体代码中，返回值赋值到函数自己"></a>函数主体代码中，返回值赋值到函数自己</h3><p>函数返回一个值，是通过在函数主体代码中，将返回的值赋值到函数自己的方法来实现。  </p>
<h3 id="调用函数时，使用类型与函数返回值类型相同的变量获得返回值"><a href="#调用函数时，使用类型与函数返回值类型相同的变量获得返回值" class="headerlink" title="调用函数时，使用类型与函数返回值类型相同的变量获得返回值"></a>调用函数时，使用类型与函数返回值类型相同的变量获得返回值</h3><p>当主程序中调用函数获取其值时，需要使用类型与函数返回值类型相同的变量，否则程序会出错。  </p>
<h3 id="函数可在单元格内公式中使用"><a href="#函数可在单元格内公式中使用" class="headerlink" title="函数可在单元格内公式中使用"></a>函数可在单元格内公式中使用</h3><p>与 Excel 内置的函数一样，用户自定义编写的函数可在公式中直接使用，其用法与内置函数一样。  </p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><h3 id="带参数的子过程定义方法"><a href="#带参数的子过程定义方法" class="headerlink" title="带参数的子过程定义方法"></a>带参数的子过程定义方法</h3><p>子过程可以接受一个或多个参数，参数可以是常量、变量、表达式，并且每个参数指定其名称和数据类型。  </p>
<p>看实际的例子，以下代码定义了带两个参数的一个过程，过程名是 <code>CustomLog</code> ，参数分别是 <code>num</code> 和 <code>base</code>。此过程的用途是计算任意底数的对数，<code>num</code> 是计算对数的值，<code>base</code> 是底数。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'声明一个带参数的子过程</span></span><br><span class="line"><span class="keyword">Sub</span> CustomLog(num <span class="keyword">As</span> <span class="built_in">Double</span>, base <span class="keyword">As</span> <span class="built_in">Integer</span>)</span><br><span class="line">    Debug.Print Log(num) / Log(base)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>子过程按照这种方法定义后，调用时，VBA 会提示需要提供什么参数以及参数类型。  </p>
<h3 id="调用带参数的子过程"><a href="#调用带参数的子过程" class="headerlink" title="调用带参数的子过程"></a>调用带参数的子过程</h3><p>调用带参数的过程，只需将参数<strong>按定义顺序</strong>书写即可，多个参数使用逗号分开。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'主入口</span></span><br><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    CustomLog <span class="number">100</span>, <span class="number">10</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>除了按顺序书写参数外，也可以按任意顺序书写参数，但是这时需要<strong>给出参数名</strong>。带参数名的传递参数语法如下：  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">[参数名]:=[实际参数值]</span><br></pre></td></tr></table></figure>

<p>参数名后写冒号等号(:=)，再写需传递的参数值。看实际的例子，以下三种方式是等效的。</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'主入口</span></span><br><span class="line"><span class="keyword">Sub</span> Main()</span><br><span class="line">    CustomLog <span class="number">100</span>, <span class="number">10</span> <span class="comment">'方式一</span></span><br><span class="line">    CustomLog num:=<span class="number">100</span>, base:=<span class="number">10</span> <span class="comment">'方式二</span></span><br><span class="line">    CustomLog base:=<span class="number">10</span>, num:=<span class="number">100</span> <span class="comment">'方式三</span></span><br><span class="line"><span class="keyword">End</span> Subxxxxxxxxxx <span class="comment">'主入口'主入口Sub Main()    CustomLog 100, 10 '方式一    CustomLog num:=100, base:=10 '方式二    CustomLog base:=10, num:=100 '方式三End Sub</span></span><br></pre></td></tr></table></figure>

<h3 id="可选参数的用法"><a href="#可选参数的用法" class="headerlink" title="可选参数的用法"></a>可选参数的用法</h3><p>实际开发中，有时子过程的参数可能不是必须的，我们希望根据参数有无情况，执行不同的操作。针对这种情况，VBA 提供了可选参数机制。  </p>
<p><strong>可选参数语法</strong>：  </p>
<p>可选参数在定义子过程时需要指定，方法是在参数名前添加 <code>Optional</code> 关键词。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Optional</span> [参数名] <span class="keyword">As</span> [数据类型]</span><br></pre></td></tr></table></figure>

<p>还是以 <code>CustomLog</code> 子过程为例，我们把底数 <code>base</code> 设为可选参数。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'声明一个带可选参数的子过程</span></span><br><span class="line"><span class="keyword">Sub</span> CustomLog(num <span class="keyword">As</span> <span class="built_in">Double</span>, <span class="keyword">Optional</span> base <span class="keyword">As</span> <span class="built_in">Integer</span>)</span><br><span class="line">    <span class="comment">'子过程代码</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>调用时，VBA 会提示可选参数，参数放置在中括号中。  </p>
<p><strong>设置可选参数的默认值</strong>：  </p>
<p>可选参数定以后，如果在子过程中使用，需要判断参数有无提供。否则未提供而直接使用时，程序会出错。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Optional</span> [参数名] <span class="keyword">As</span> [数据类型] = [默认值]</span><br></pre></td></tr></table></figure>

<p>还是以 <code>CustomLog</code> 子过程为例，我们把底数 <code>base</code> 设为可选参数，并且默认值设为 10。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'声明一个带可选参数的子过程</span></span><br><span class="line"><span class="keyword">Sub</span> CustomLog(num <span class="keyword">As</span> <span class="built_in">Double</span>, <span class="keyword">Optional</span> base <span class="keyword">As</span> <span class="built_in">Integer</span> = <span class="number">10</span>)</span><br><span class="line">    Debug.Print Log(num) / Log(base)</span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p><strong>可选参数的位置</strong>：  </p>
<p>当子过程有多个参数时，其中的<strong>可选参数需写在参数列表的末尾</strong>，否则 VBA 提示错误。  </p>
<h2 id="传参类型：ByVal-和-ByRef-的基础用法和区别"><a href="#传参类型：ByVal-和-ByRef-的基础用法和区别" class="headerlink" title="传参类型：ByVal 和 ByRef 的基础用法和区别"></a>传参类型：ByVal 和 ByRef 的基础用法和区别</h2><p>VBA 中定义过程或函数时，如果需要传递变量，需指定参数的传递类型，包括以下 2 类：  </p>
<ul>
<li><strong>ByVal</strong>：传递参数的值</li>
<li><strong>ByRef</strong>：传递参数的引用</li>
</ul>
<h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'ByVal 传递类型</span></span><br><span class="line"><span class="keyword">Sub</span> TestSub1(<span class="keyword">ByVal</span> msg <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'ByRef 传递类型</span></span><br><span class="line"><span class="keyword">Sub</span> TestSub2(<span class="keyword">ByRef</span> msg <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>针对基础数据类型，例如数字、文本等，两种传递类型的说明和区别如下：  </p>
<ul>
<li><strong>ByVal</strong>：传递变量时，复制一份该变量，传入过程或函数。在过程和函数内部对该变量进行修改，只对该副本有效，对上一级过程（父过程）的变量没有影响。</li>
<li><strong>ByRef</strong>：传递变量时，将该变量的引用地址传入过程或函数。传入引用地址意味着，在过程或函数内部对其修改时，也会影响上一级过程（父过程）中的变量的值。</li>
</ul>
<h3 id="ByVal实例"><a href="#ByVal实例" class="headerlink" title="ByVal实例"></a>ByVal实例</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Test()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> msg <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    msg = <span class="string">"main"</span></span><br><span class="line">    </span><br><span class="line">    TestSub1 msg</span><br><span class="line">    </span><br><span class="line">    Msgbox msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'ByVal 传递类型</span></span><br><span class="line"><span class="keyword">Sub</span> TestSub1(<span class="keyword">ByVal</span> msg <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    msg = <span class="string">"val"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>首先定义一个 <code>msg</code> 变量，赋值 <code>main</code>，然后调用 <code>TestSub1</code> 过程，传入 <code>msg</code> 变量，在过程内部对 <code>msg</code> 重新赋值 <code>val</code>。最后返回上一个过程，显示 <code>msg</code> 变量。结果如下，<code>msg</code> 变量的值没有改变。  </p>
<h3 id="ByRef实例"><a href="#ByRef实例" class="headerlink" title="ByRef实例"></a>ByRef实例</h3><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Test()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> msg <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    msg = <span class="string">"main"</span></span><br><span class="line">    </span><br><span class="line">    TestSub2 msg</span><br><span class="line">    </span><br><span class="line">    MsgBox msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'ByRef 传递类型</span></span><br><span class="line"><span class="keyword">Sub</span> TestSub2(<span class="keyword">ByRef</span> msg <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line">    msg = <span class="string">"ref"</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>首先定义一个 <code>msg</code> 变量，赋值 <code>main</code>，然后调用 <code>TestSub2</code> 过程，传入 <code>msg</code> 变量，在过程内部对 <code>msg</code> 重新赋值 <code>ref</code>。最后返回上一个过程，显示 <code>msg</code> 变量。结果如下，<code>msg</code> 变量的值已改变。  </p>
<h3 id="省略传递类型：默认ByVal"><a href="#省略传递类型：默认ByVal" class="headerlink" title="省略传递类型：默认ByVal"></a>省略传递类型：默认ByVal</h3><p>默认情况下，当省略传递类型时，默认值是 <code>ByVal</code>，因此以下两种写法是等效的。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">'指定 ByVal 传递类型</span></span><br><span class="line"><span class="keyword">Sub</span> TestSub1(<span class="keyword">ByVal</span> msg <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">'省略传递类型</span></span><br><span class="line"><span class="keyword">Sub</span> TestSub1(msg <span class="keyword">As</span> <span class="built_in">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-ByVal-和-ByRef-传递对象"><a href="#使用-ByVal-和-ByRef-传递对象" class="headerlink" title="使用 ByVal 和 ByRef 传递对象"></a>使用 ByVal 和 ByRef 传递对象</h3><p>以上机制适用于传递基础类型变量，例如数字、文本、逻辑值等。  </p>
<p>使用 ByVal 和 ByRef 传递对象时，情况有些不同。  </p>
<h3 id="使用-ByVal-和-ByRef-传递数组"><a href="#使用-ByVal-和-ByRef-传递数组" class="headerlink" title="使用 ByVal 和 ByRef 传递数组"></a>使用 ByVal 和 ByRef 传递数组</h3><p>过程或函数传递数组时，<strong>只能以引用形式传递</strong>，即以 <code>ByRef</code> 形式。如果尝试用 ByVal 传递数组，VBA 会提示错误。  </p>
<hr>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="过程作用域"><a href="#过程作用域" class="headerlink" title="过程作用域"></a>过程作用域</h3><p>在过程或函数内部声明的变量，只有在当前过程或函数内被使用。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Test()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> name <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    <span class="keyword">Dim</span> age <span class="keyword">As</span> <span class="built_in">Integer</span></span><br><span class="line">    </span><br><span class="line">    name = <span class="string">"张三"</span></span><br><span class="line">    age = <span class="number">35</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，变量 <code>name</code> 和 <code>age</code> 在 <code>Test</code> 过程声明，因此它们只能在该过程中内使用，包括赋值和读取。如果尝试在外部和其他过程中直接使用它们，VBA 会提示<strong>变量未定义错误</strong>。  </p>
<h3 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h3><p>一个模块中，在任何一个过程和函数外面，使用关键词 <code>Private</code> 或 <code>Dim</code> 声明的变量，称之为<strong>模块变量</strong>，其作用域是当前模块。例如，  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> guest <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> Test()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> message <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    </span><br><span class="line">    guest = <span class="string">"张三"</span></span><br><span class="line">    message = <span class="string">"你好"</span></span><br><span class="line">    </span><br><span class="line">    MsgBox message &amp; <span class="string">"！ "</span> &amp; guest</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，变量 <code>guest</code> 是在过程 <code>Test</code> 外面，使用 <code>Dim</code> 关键词声明的，称之为模块变量。模块变量的作用域是当前模块，<strong>在模块里面任何过程和函数内均可以使用</strong>。  </p>
<p>如前文所述，使用关键词 <code>Private</code> 或 <code>Dim</code> 声明的变量，都是模块变量，因此以下两种声明方式是等效的。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> guest <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line"><span class="keyword">Private</span> guest <span class="keyword">As</span> <span class="built_in">String</span></span><br></pre></td></tr></table></figure>

<h3 id="工程作用域"><a href="#工程作用域" class="headerlink" title="工程作用域"></a>工程作用域</h3><p>一个 Excel 工作簿是一个 VBA 工程。与之对应，工程作用域表示变量在当前工程中的模块、Excel 对象、用户窗体、类模块中均可以被使用。  </p>
<p>工程级别变量，在所在模块顶部声明 <code>Option Private Module</code> 修饰语句前提下，在过程或函数外面，使用关键词 <code>Public</code> 声明的变量，其作用域是当前工程。例如，  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Option</span> <span class="keyword">Private</span> <span class="keyword">Module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Public</span> guest <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> Test()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Dim</span> message <span class="keyword">As</span> <span class="built_in">String</span></span><br><span class="line">    </span><br><span class="line">    guest = <span class="string">"张三"</span></span><br><span class="line">    message = <span class="string">"你好"</span></span><br><span class="line">    </span><br><span class="line">    MsgBox message &amp; <span class="string">"！ "</span> &amp; guest</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，变量 <code>guest</code> 是使用 <code>Public</code> 关键词声明，是工程级别变量。它在当前工程中其他的模块中也能被使用。  </p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>全局作用域表示，全局变量在打开的任何一个工作簿都可以被使用。全局变量的声明方式与工程变量相似，不同点是<strong>不使用模块顶部的 <code>Option Private Module</code> 修饰语句</strong>。  </p>
<h3 id="作用域冲突"><a href="#作用域冲突" class="headerlink" title="作用域冲突"></a>作用域冲突</h3><p>当相同名称的变量，多次以不同的作用域声明时，出现作用域冲突。这种情况，VBA 会自动以<strong>就近原则</strong>使用变量，即优先使用最近定义的变量。例如，  </p>
<h2 id="过程或函数作用域"><a href="#过程或函数作用域" class="headerlink" title="过程或函数作用域"></a>过程或函数作用域</h2><h3 id="模块作用域-1"><a href="#模块作用域-1" class="headerlink" title="模块作用域"></a>模块作用域</h3><p>在模块中，使用 <strong>Private</strong> 关键词声明的过程或函数，具备模块作用域，只能在当前模块中使用。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Private</span> <span class="keyword">Sub</span> Test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<h3 id="工程作用域-1"><a href="#工程作用域-1" class="headerlink" title="工程作用域"></a>工程作用域</h3><p>在模块中，顶部声明 <code>Option Private Module</code> 修饰语句，并且直接声明或使用 Public 关键词声明的过程或函数，具备工程作用域，在当前工程的所有模块中使用。  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Option</span> <span class="keyword">Private</span> <span class="keyword">Module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Sub</span> Test1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Sub</span> Test2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，Test1 过程和 Test2 过程均具备工程作用域。由于直接声明和使用关键词 <code>Public</code> 是等效的，因此可以省略 <code>Public</code> 关键词。  </p>
<h3 id="全局作用域-1"><a href="#全局作用域-1" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在模块中，直接声明或使用 Public 关键词声明的过程或函数，具备全局作用域。例如，  </p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Sub</span> Test1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Public</span> <span class="keyword">Sub</span> Test2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure>

<p>以上例子中，Test1 过程和 Test2 过程均具备全局作用域，可以在打开的任何一个工作簿中使用。  </p>
<p>此外，它们还能直接在工作簿宏列表中执行。  </p>
]]></content>
      <categories>
        <category>「语言」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Excel</tag>
        <tag>VBA</tag>
      </tags>
  </entry>
  <entry>
    <title>吃肉使人快乐</title>
    <url>/2020/12/22/Food/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>为什么好吃的都是热量高的</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="聚餐"><a href="#聚餐" class="headerlink" title="聚餐"></a>聚餐</h1><h2 id="肉"><a href="#肉" class="headerlink" title="肉"></a>肉</h2><h3 id="谢大牛馆"><a href="#谢大牛馆" class="headerlink" title="谢大牛馆"></a>谢大牛馆</h3><ul>
<li>位置：华星路</li>
<li>时间：2020年冬、2021年春</li>
<li>同伴：项目组</li>
<li>评价：吃牛肉很合适，大块的肉，饱腹感强，不夹杂其他味道</li>
</ul>
<h2 id="烤肉"><a href="#烤肉" class="headerlink" title="烤肉"></a>烤肉</h2><h3 id="鞑子烤羊腿"><a href="#鞑子烤羊腿" class="headerlink" title="鞑子烤羊腿"></a>鞑子烤羊腿</h3><ul>
<li>位置：华星路</li>
<li>时间：2020年夏、秋</li>
<li>同伴：一次超j，一次zcm、lqm、zsx</li>
<li>评价：可以满足大口吃羊肉的欲望，整块的羊排/羊腿，烤的滋油；其他烧烤小食没怎么吃</li>
<li>人均：100</li>
</ul>
<h3 id="牛牛兄弟碳烤鲜牛肉"><a href="#牛牛兄弟碳烤鲜牛肉" class="headerlink" title="牛牛兄弟碳烤鲜牛肉"></a>牛牛兄弟碳烤鲜牛肉</h3><ul>
<li>位置：文二路华星发展大厦</li>
<li>时间：2021年2月</li>
<li>同伴：万塘路300号时代 猴子 超j</li>
<li>评价：还行，算是实惠；秋刀鱼感觉不够新鲜</li>
<li>人均：70（78折）</li>
</ul>
<h2 id="日料"><a href="#日料" class="headerlink" title="日料"></a>日料</h2><h3 id="米浅"><a href="#米浅" class="headerlink" title="米浅"></a>米浅</h3><ul>
<li>位置：华星路</li>
<li>时间：2020年10月</li>
<li>同伴：xsx徐工</li>
<li>评价：<ul>
<li>必点玉子烧</li>
<li>徐工推荐的鹅肝手握很阔以</li>
<li>炒饭没上次去的好吃</li>
<li>菜单跟浅草屋一模一样</li>
</ul>
</li>
<li>人均：100</li>
</ul>
<h2 id="火锅"><a href="#火锅" class="headerlink" title="火锅"></a>火锅</h2><h3 id="海底捞"><a href="#海底捞" class="headerlink" title="海底捞"></a>海底捞</h3><ul>
<li>位置：铂澜·大象城</li>
<li>时间：2020年12月</li>
<li>同伴：信爷</li>
<li>评价：还行，没有那么让人尴尬的热情；菜品没多少感触，感觉火锅都差不多</li>
<li>人均：220</li>
</ul>
<h3 id="捞王"><a href="#捞王" class="headerlink" title="捞王"></a>捞王</h3><ul>
<li>位置：铂澜·大象城</li>
<li>时间：2020年12月</li>
<li>同伴：信爷</li>
<li>评价：信爷喜欢捞王的汤底，比较奶的感觉</li>
<li>人均：150+</li>
</ul>
<h3 id="御荣府"><a href="#御荣府" class="headerlink" title="御荣府"></a>御荣府</h3><ul>
<li>位置：华星路</li>
<li>时间：2021年2月</li>
<li>同伴：周工、黄工</li>
<li>评价：中规中矩，没感觉到印象深刻的点</li>
</ul>
<h2 id="烤鱼"><a href="#烤鱼" class="headerlink" title="烤鱼"></a>烤鱼</h2><h3 id="葫炉鱼"><a href="#葫炉鱼" class="headerlink" title="葫炉鱼"></a>葫炉鱼</h3><ul>
<li>位置：文二路万塘路口，大华国际对面</li>
<li>时间：2020年12月</li>
<li>同伴：超j，猴子</li>
<li>评价：新店活动鱼3.8折，烤鱼没自带小料有点套路，各种烤鱼区分特色不能，其实3个人光光三条鱼的话，性价比非常高</li>
<li>人均：50-（活动价）</li>
</ul>
<hr>
<h1 id="个人餐"><a href="#个人餐" class="headerlink" title="个人餐"></a>个人餐</h1><h2 id="饭"><a href="#饭" class="headerlink" title="饭"></a>饭</h2><h3 id="食其家-すき家"><a href="#食其家-すき家" class="headerlink" title="食其家 すき家"></a>食其家 すき家</h3><ul>
<li>位置：文三路华星科技大厦、星光城</li>
<li>评价：<ul>
<li>招牌牛丼可以，现在的饭量中碗感觉都有点多</li>
<li>大阪烧牛丼味道甚佳，小贵</li>
<li>番茄牛丼太甜，总体味道没有惊喜，感觉有点对不起价格</li>
<li>拉面的辅材感觉偏少</li>
<li>关东煮性价比不如便利店</li>
</ul>
</li>
<li>人均：20-40</li>
</ul>
]]></content>
      <categories>
        <category>「备忘」</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Design Notes</title>
    <url>/2019/03/19/Game-Design-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>游戏设计相关笔记</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="箴言（雾"><a href="#箴言（雾" class="headerlink" title="箴言（雾"></a>箴言（雾</h1><blockquote>
<p>策划是一个游戏的灵魂，抄来的灵魂至少靠谱，原创的灵魂可能短命。<br><em>——黄J  2019.3.19</em>  </p>
</blockquote>
<hr>
<h1 id="按游戏类型分类"><a href="#按游戏类型分类" class="headerlink" title="按游戏类型分类"></a>按游戏类型分类</h1><h2 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h2><h3 id="3种FPS地图布局流程技巧"><a href="#3种FPS地图布局流程技巧" class="headerlink" title="3种FPS地图布局流程技巧"></a>3种FPS地图布局流程技巧</h3><p>以 <code>CS:GO</code> 为例  </p>
<blockquote>
<p>前置教程参考：<br>CS:GO 6 Principles of Choke Point Level Design<br>CS:GO How to Design Gameplay Map Layouts (Complete In-Depth Guide)</p>
</blockquote>
<p><strong>做地图的通常步骤：</strong></p>
<ul>
<li>第一步：Layout布局阶段<br>把地图的玩法可视化，规划好地图中可行走的路线、备选路线、连接通路、阻塞点、目标、障碍物、地图边界。  </li>
<li>再进BSP填充地图，迭代更新。  <ul>
<li>（注：BSP其实是使用二叉空间分割方法Binary space partitioning生成的多边形，简单来说就是各种多边形体。Source引擎、Unreal4都提供了这种方法来快速创建关卡原型，优点是调整多边形非常方便，直接在场景内就可见，而且面数奇低）  </li>
</ul>
</li>
</ul>
<p><strong>地图布局方法：</strong><br>路线图就是从整个布局图中提取的精华，这样你就对双方如何处理地图目标有了清晰的概念。  </p>
<ul>
<li><strong>方法一：先画路径（通路），再画场景布局的边缘</strong><ul>
<li>适用情况：当你对你地图玩起来是啥样子有了概念，并且你已经考虑过布局情况，但是对细节不是很清楚的时候。  </li>
<li>开始先画简单的线条来定义地图的路径  </li>
<li>绝对的精简，别设计任何边界，只专注考虑两队玩家的通路</li>
<li>标记：CT、T出生点；包点、人质点；阻塞点（关键）</li>
<li>再画地图布局，一直画到你能确定剩下的所有结构：地图的边界，视野，双方复生点，包点和人质点，阻塞点，连接通路，还有其他通路。</li>
</ul>
</li>
<li><strong>方法二：一次只关注一个区域，然后组合起来</strong>  <ul>
<li>适用情况：当你不知道你的地图布局最终是什么样子，你举步维艰无法弄清楚每个区域怎么去做的时候</li>
<li>先挑一个区域开始：A点、B点、CT或T出生点、中路、任一阻塞点</li>
<li>选一个区域设计，再画出区域的布局，专注该区域</li>
<li>选其他区域，再来一遍</li>
<li>整合到一个布局图里</li>
<li>从布局简化出路径图</li>
</ul>
</li>
<li><strong>方法三：直接完成全部布局，再简化通路</strong><ul>
<li>适用情况：当你已经对整体布局有过深思熟虑并且确切的知道最终的样子。或许你已经画过这个布局许多次了，并且你打算重新设计它。</li>
<li>从一个具体的区域开始然后逐渐展开直到整体布局画完。如果你在某个区域没有进展了，那就再接着画别的区域。记住一次画完。</li>
<li>然后另画出地图简化通路</li>
<li>新手慎用</li>
</ul>
</li>
</ul>
<p><em><a href="https://mp.weixin.qq.com/s/6euKxO_D4IzwPPgCD8GSww" target="_blank" rel="noopener">原文:3种设计FPS游戏地图布局的流程技巧</a></em>  </p>
<h3 id="FPS地图阻塞点设计6原则"><a href="#FPS地图阻塞点设计6原则" class="headerlink" title="FPS地图阻塞点设计6原则"></a>FPS地图阻塞点设计6原则</h3><blockquote>
<p>控制了阻塞点，就控制了整张地图。  </p>
</blockquote>
<p>阻塞点是地图上进攻方到达目标之前，遭遇防守方抵抗的区域。阻塞点也叫做控制点（Control Point）或者堵塞区（Bottleneck）。<br>进攻方（爆破模式中的匪徒或营救模式中的警察）必须从阻塞点干过去，才能到达目标区域。否则就必须撤退或者更换策略换条路线进攻。  </p>
<p>阻塞点的设计目的：<strong>增强游戏性</strong>，利用阻塞点可以控制地图内的玩家流向，节奏，和平衡。</p>
<ul>
<li><strong>原则1：增强和促进游戏性（Gameplay）</strong>  <ul>
<li>通过整体结构的设计将可见的入口降低到1-2个，来缩紧玩家的流向</li>
<li>常见结构如：走廊，门口，隧道或是巷道登，是双方相遇、激战的阻塞点 </li>
</ul>
</li>
<li><strong>原则2：阻塞点放置</strong><ul>
<li>一定要部署在攻击方到达地图目标点之前</li>
</ul>
</li>
<li><strong>原则3：时机</strong><ul>
<li>需要让双方几乎在相同的时间到达阻塞点。防守方可以稍微早几秒到达站好位置。但最重要的是攻击方永远都不能在防守方刚刚到达的时候就已经冲过阻塞点。</li>
<li>到达阻塞点的时间在地图的BSP搭建阶段就应该确定：直接方法-计时器、亲自跑</li>
<li>时机也可能取决于地图，如dust2地图中防守方ct到A平台非常近</li>
</ul>
</li>
<li><strong>原则4：入口、出口数量</strong><ul>
<li>限制出入口的选择，将阻塞点通路数量<strong>控制在1到2个</strong>。这样攻击方不会太轻易地占领目标。许多CS地图的阻塞点都只有一个通路（通向目标点）</li>
<li>两条通路入口的阻塞点给进攻方提供了选择和策略，<strong>增加策略性</strong>，但也可能把阻塞点搞无聊</li>
<li>增加同一个阻塞点的通路数量，破快了局部的战斗节奏，<strong>可能让阻塞点变得无法控制</strong>，需要慎重把握</li>
<li>如果要为阻塞点增加2条通路入口，应确保防守方在同一个视角可以清晰看到两个入口</li>
</ul>
</li>
<li><strong>原则5：战斗方式</strong><ul>
<li>阻塞点都应该支持多种战斗方式：狙击战、近距离的卡点战斗、暗中推进（猥琐推进）。</li>
<li>支持的方式越多，越能迎合多类型玩家喜好。需要为策略性和玩家技巧来进行设计。</li>
<li>使用<strong>距离</strong>和<strong>掩体</strong>作为布局元素<ul>
<li>距离维度：长、短、宽、窄、高度</li>
</ul>
</li>
</ul>
</li>
<li><strong>原则6：动态阻塞点</strong><ul>
<li>营救人质地图中的阻塞点都是动态的。在设计人质地图的阻塞点时，你需要考虑防守方（T）是如何进行的。</li>
<li>最主要的是需要把到达营救位置的通路数量控制在2到3条。</li>
</ul>
</li>
</ul>
<p>关于<strong>区域阻塞点</strong>：  </p>
<ul>
<li>它们是在特定区域，带有多种选择和掩体的开放式阻塞点</li>
<li>一个地图1个足以，复杂的掩体和多样的选择都大大增加了设计的难度，要有取舍。</li>
</ul>
<p><em><a href="https://www.gameres.com/789358.html" target="_blank" rel="noopener">原文：FPS地图阻塞点的六种设计原则</a></em>  </p>
<h3 id="FPS地图设计心得tips"><a href="#FPS地图设计心得tips" class="headerlink" title="FPS地图设计心得tips"></a>FPS地图设计心得tips</h3><ul>
<li><strong>第一步：区域划分和规划</strong>：地图的尺寸、交战距离（和玩家的移动属性）；敌我双方/多方的出生点，冲突点都会在这个阶段设计完成，可以说是完成整个图的大结构设定——根据玩法设计目标和游戏定位来确认。</li>
<li><strong>第二步：动线规划</strong>：动线就是“运动轨迹”：即设计连接区域的路径、区域内的运动路线、主路与支路、汇合点与展开点。并不是有路的地方就有动线，动线是代表关卡中最高效的战术运动轨迹。</li>
<li><strong>第三步：关键点设计</strong>：关键点就是我们常说的兵家必争之地，比如集中的通路，近道，视野宽阔的优势阵地等。往往也是双方动线天然的汇合点，必经之路，或是可以扼守目标点的阵地。</li>
<li><strong>局部战术</strong>：确定不同区域的优势和风险，引导玩家在不同阵地选择不同的武器和战术，或选择与队友配合（狙击、投掷、冲锋、埋伏、绕后等），进行一定程度的策略对抗。</li>
<li><strong>第五步：指引性设计</strong>：为了防止玩家在地图中迷路，需要加入明显的地标指示物，帮助玩家明确判断自己的位置。</li>
<li><strong>第六步：平衡</strong>：在结构和美术设计上，通常会从结构对称（镜像平衡）、优势对等（各有优势区域，相对对等）的方向考虑，以在地图中维持双方的竞技公平。</li>
</ul>
<p><em><a href="https://www.taptap.com/topic/4512299" target="_blank" rel="noopener">原文:一些FPS游戏地图设计心得</a></em> </p>
<h3 id="FPS类大型超多人战场地图设计的8个tips"><a href="#FPS类大型超多人战场地图设计的8个tips" class="headerlink" title="FPS类大型超多人战场地图设计的8个tips"></a>FPS类大型超多人战场地图设计的8个tips</h3><p>PUBG相对于OW、CSGO的成功说明超大地图、超多人PVP的魅力。  </p>
<ul>
<li><strong>1.谨慎设定场景尺寸</strong><ul>
<li>因素：核心玩法（GamePlay Mode）；参与人数；移动数值与移动方式；预期交战密度；次级关卡的规模与数量；游戏单局时长；项目的技术瓶颈；研发工作量限制等等</li>
</ul>
</li>
<li><strong>2.明确游戏的核心体验方向</strong><ul>
<li>如<strong>PUBG</strong>的精准倍镜和武器弹道，把远距离战斗作为重要的游戏体验，所以的建筑、掩体、草木的分布都服从于此；<strong>堡垒之夜</strong>建造自由度是游戏的中药体验，所以关卡设计上留了很多空闲的区域，给玩家脑洞；<strong>Apex英雄</strong>偏向中近程作战，战斗节奏中角色快速立体移动，故提供了更狭窄受控的对战空间，大部分掩体可自由登顶。</li>
<li>因素：交战距离、交战频率、战斗风格、游戏目标、预期移动节奏、玩家行动方式、角色特性、武器技能道具、资源分布情况。</li>
</ul>
</li>
<li><strong>3.设立严格的标准，用规则创造世界</strong><ul>
<li>场景建筑、物件的标准：<ul>
<li>建筑的核心参数：墙体厚度、门高宽、窗高宽、层高、窗户距地高度、门窗分类情况、房间最小尺寸、楼梯宽度角度长度、建筑内结构约束、室内物件约束等等</li>
<li>建筑的外围参数：房屋与房屋间距、城镇街道与房屋间距、房屋与围栏间距、房屋高度范围、房屋可攀爬约束等等</li>
<li>物件的参数：物件种类尺寸、物件距离房屋安全距离、是否作为掩体、碰撞规范约束、贴图新旧程度等等</li>
</ul>
</li>
<li>PGC生成内容的标准：<ul>
<li>地形：最大高度、海平面高度、平原山体河流峡谷森林所有区域的确切分布、区域地表贴图设定、最大行走角度等</li>
<li>植被系统：地表植物的高度、遮蔽情况，树木生成的总量、密度、间隔、直径、树冠特征，草和树木与地表自然贴图的限定关系、植被的生成规则等</li>
<li>其他系统：路网分布、道路的类型与宽度、石头总量与密度、水体的特性：深度、可否游泳、水中能否使用载具、能否与火焰交互等等</li>
</ul>
</li>
<li>角色相关的标准；整体地图的分布标准<ul>
<li>角色Pawn的各项属性：体型Hitbox、移动速度（行走、持枪、奔跑、蹲伏等）、跳跃高度、距离、掉落伤害、攀爬高度距离、可行走角度、特殊移动方式（如滑索、载具）等等，都会影响具体场景的制作</li>
<li>子场景的分布标准：规定了子场景的分级（重要程度，例如PUBG中机场就是一个分级为重要的子场景）、每类子场景的建筑数量与规模、不同子场景之间的间距（如两个核心资源点的最小距离）、局内资源的分布情况、资源的总量与密度等</li>
</ul>
</li>
</ul>
</li>
<li><strong>4.用局部设计为关卡注入灵魂</strong><ul>
<li>为区域添加LandMark</li>
<li>局部场景植被的变化</li>
<li>利用好地形，进行二次创造</li>
<li>布局Layout的艺术</li>
<li>设定特殊主题</li>
</ul>
</li>
<li><strong>5.在设计上留白</strong></li>
<li><strong>6.建立完善的工具与制作流程</strong><ul>
<li>PGC内容的编辑工具（引擎内）：树木地表道路篱笆等</li>
<li>关卡管理工具：关卡拆分与多人协同编辑支持</li>
<li>关卡预览工具：大世界的实时调整与预览工具</li>
<li>大世界的批量测试工具：异常碰撞检测、地表贴合检测等</li>
<li>美术资源的工具：批量处理资源、自动烘焙流程等</li>
<li>其他一切提升LD/LA战斗力的引擎工具：比如扩展Unity糟糕的关卡编辑器</li>
</ul>
</li>
<li><strong>7.用数据监测Review关卡的设计</strong><ul>
<li>通用规则：死亡分布、各阶段时长、胜率等</li>
<li>资源投放情况：物资产出、分布、物资获取评估等</li>
<li>武器数据：KD、TTK、ADR（AVERAGE DAMAGE per ROUND）、配件出场率等</li>
<li>道具/技能数据：道具消耗量、存量、使用率、有效率等</li>
<li>载具使用情况：生成、获取评估、使用率、移动情况、损坏率、载具ADR等</li>
<li>热力图数据：选点情况、出生跳伞、击杀死亡、区域活跃时间、决赛位置等</li>
</ul>
</li>
<li><strong>8.让技术主导玩法，打破规则</strong><ul>
<li>曾经我们认为关卡必须是<strong>CS</strong>一样的固态结构，<strong>Rainbow Six</strong>通过破碎系统的突破性尝试让我们看到了墙体破坏的战斗魅力；曾经我们以为手机上只能做2<em>2的小场景马赛克吃鸡，*</em>PUBG Mobile<strong>做到了64平方千米准端游画质并且不卡的世界！曾经我们以为大逃杀BR就是一条命苟到底飙车跑毒圈的ChickenDinner，但是</strong>APEX**用滑铲复活飞檐走壁华丽地技能钢枪告诉我们它也是一个Legend</li>
</ul>
</li>
</ul>
<p><em><a href="https://mp.weixin.qq.com/s/2j0U6BWyi9MLVOXBM0GWsg" target="_blank" rel="noopener">原文:FPS大世界关卡设计的8个锦囊</a></em>  </p>
<h2 id="经营策略类"><a href="#经营策略类" class="headerlink" title="经营策略类"></a>经营策略类</h2><h3 id="3个玩法要素与3个乐趣的来源"><a href="#3个玩法要素与3个乐趣的来源" class="headerlink" title="3个玩法要素与3个乐趣的来源"></a>3个玩法要素与3个乐趣的来源</h3><ul>
<li>要素：可选择的橙装路径、资源、胜利条件</li>
<li><strong>思考和推理的乐趣</strong>：给玩家以不同选择的取舍；使用随机性、外部条件来应对玩家的攻略</li>
<li><strong>博弈的乐趣</strong>：多个参与者时发生争夺、博弈</li>
<li><strong>意想的乐趣</strong>：把游戏中的内容具象化，结合生活概念，有助于玩家理解</li>
<li>总结：策略经营类的本质是逐步展开选择路径，玩家根据现有的消息，猜测将来可能出现的情况，来选择在一条最优路径获得“数值成果”。经历若干个阶段后，来结算成功。  </li>
</ul>
<p><em><a href="https://www.gameres.com/840787.html" target="_blank" rel="noopener">参考：经营策略游戏设计要点：3个玩法要素与3个乐趣的来源</a></em>  </p>
<hr>
<h1 id="关卡类"><a href="#关卡类" class="headerlink" title="关卡类"></a>关卡类</h1><h2 id="设计可重复挑战关卡？"><a href="#设计可重复挑战关卡？" class="headerlink" title="设计可重复挑战关卡？"></a>设计可重复挑战关卡？</h2><ul>
<li><strong>目标结论</strong>：<ul>
<li>随机性</li>
<li>可操作性</li>
</ul>
</li>
<li><strong>关卡规则构建</strong>：主要从目的和手段两个角度入手，用同样的资源去打造不同的关卡</li>
<li><strong>关卡元素</strong>：如何站在基本型和关卡元素组合的思路去制作关卡元素，让它们有足够的差异性和复用价值</li>
<li>语境重构，利用语境重构来复用关卡元素，并增加其代入感。其实每一个关卡元素都是一个很值得塑造的元素，每一个角色在进行复用的时候，都可以看作是他一次重新上场的机会，并推翻之前观众对他的印象</li>
</ul>
<p><em><a href="https://mp.weixin.qq.com/s/U_GsdgAwVrfEUoa6dodYYQ" target="_blank" rel="noopener">原文:在资源有限时，如何设计出可重复挑战的游戏关卡？</a></em>  </p>
<h2 id="打破PVP玩法最优解"><a href="#打破PVP玩法最优解" class="headerlink" title="打破PVP玩法最优解"></a>打破PVP玩法最优解</h2><ul>
<li><strong>非单一相克</strong>：石头剪刀布</li>
<li><strong>可控约束性</strong>：玩家可以利用游戏规则，和自己的技巧来约束对方，从而使一些不透明的信息变得透明</li>
<li><strong>“使绊子”</strong>：致使玩家并不那么容易达到最优解的一些方式，主要包括“操作难度”和“不可控因素”两点</li>
</ul>
<p><em><a href="https://mp.weixin.qq.com/s/uPGrfLwlzHhmIfOkMq8-Yg" target="_blank" rel="noopener">原文：打破PvP玩法的“最优解”</a></em></p>
<hr>
<h1 id="游戏架构类"><a href="#游戏架构类" class="headerlink" title="游戏架构类"></a>游戏架构类</h1><h2 id="开放世界不让玩家路痴"><a href="#开放世界不让玩家路痴" class="headerlink" title="开放世界不让玩家路痴"></a>开放世界不让玩家路痴</h2><p>游戏内的自动导航是与“对于现实世界的拟真”所相违背。<br>提升玩家寻路体验tips：  </p>
<ul>
<li><strong>缩小世界规模</strong>：简单粗暴，但如果引入了快速交通工具，玩家的体验会大打折扣。</li>
<li><strong>炮制宏达景观</strong>：多设立大型地标，形成记忆锚点，但美术资源可能有限</li>
<li><strong>为世界命名</strong>：对游戏中的区块和道路进行命名</li>
<li><strong>减少素材重复利用</strong>：不要大粒度的方式重复利用</li>
<li><strong>主线路径的重复利用</strong>：主线任务尽可能让玩家多重复在同一条路径上，加深记忆</li>
</ul>
<p><em><a href="https://www.gameres.com/840600.html" target="_blank" rel="noopener">原文：什么样的开放世界游戏才会让玩家不路痴？</a></em>  </p>
<h2 id="潜行游戏的AI设计"><a href="#潜行游戏的AI设计" class="headerlink" title="潜行游戏的AI设计"></a>潜行游戏的AI设计</h2><p>潜行游戏的核心——暗杀  </p>
<p>潜行AI需要增加视觉、听觉模拟器，以视觉为例：  </p>
<p>AI的视觉模拟器：  </p>
<ul>
<li>AI看到什么会引起警觉<ul>
<li>敌人</li>
<li>同伴尸体</li>
<li>同伴小时</li>
<li>物品状态改变（如关着的门开了）</li>
</ul>
</li>
<li>引起警觉之后，如何行动<ul>
<li>查看异常（一般是单人行动）</li>
<li>搜索敌人（一般是和周围同伴一起群体行动）</li>
<li>触发警报（整个区域开始寻找敌人）</li>
<li>呼叫增援（在增加区域内敌人数量）</li>
</ul>
</li>
<li>行动后的变化<ul>
<li>回归初始状态</li>
<li>继续保持警戒状态</li>
<li>保持搜索敌人状态</li>
<li>保持战斗状态</li>
</ul>
</li>
</ul>
<p>潜行游戏的其他要素：变装、引诱、、隐蔽点、阴影、陷阱、移动尸体、藏匿尸体、离间、审问、墙体透视……</p>
<hr>
<h1 id="交互类"><a href="#交互类" class="headerlink" title="交互类"></a>交互类</h1><h2 id="交互设计入门原则和规范"><a href="#交互设计入门原则和规范" class="headerlink" title="交互设计入门原则和规范"></a>交互设计入门原则和规范</h2><ul>
<li><strong>一致性原则</strong>：界面的视觉风格、布局、功能、用语、操作应在所有页面中保持一致。</li>
<li><strong>有效性原则</strong>：难以点击的问题一定要彻底解决</li>
<li><strong>易读性原则</strong>：尽管某些游戏的字号你拿着细看也是完全可以看清楚的，甚至还觉得挺精致。但基于手机的实际应用情景（拥挤的地铁、公交、步行时），字号还是建议略为调大一点，使用户即便在户外依然能够轻松地读取到画面中的文字信息。<ul>
<li>提高文字与底图之间的对比度。</li>
<li>承载文字的底图尽可能不设置透明度或较低透明度。</li>
<li>多运用界面留白，包括设置较大的文字的行距，都能有助提升易读性。</li>
</ul>
</li>
<li><strong>3次点击原则</strong>：用户经常会关心到的内容，务必在3次点击之内让他们找到。</li>
<li><strong>防错原则</strong>：通过对信息的强调，或者二次确认，或增加上锁\解锁功能，或确认按钮位置的改变来防止用户在操作过程中发生失误。</li>
<li><strong>字体规范</strong>：强化字阶差异，减少字号种类；统一“韵律”，简化字阶递增规律；以灰度、固定色彩体系强化文字性质；</li>
<li><strong>控件规范</strong>：复用性要高，尽量控制相同样式不同尺寸的控件数量；确保视觉输出的控件，设备上看，边缘是锐利清晰的； 确保视觉输出的控件，配色方案不会对用户构成交互体验上的干扰；</li>
</ul>
<p><em><a href="https://mp.weixin.qq.com/s/euhqs07p1-AefQrCHqzA5A" target="_blank" rel="noopener">原文：交互设计入门引导：5点原则两条规范</a></em>  </p>
<h2 id="游戏交互设计5要素"><a href="#游戏交互设计5要素" class="headerlink" title="游戏交互设计5要素"></a>游戏交互设计5要素</h2><ul>
<li>感受用户体验要素<ul>
<li>表现层：呈献给用户的第一印象内容，看个大概基调</li>
<li>框架层：整个系统的框架，图标等</li>
<li>结构层：规划整个界面，较抽象</li>
<li>范围层：可以看到这个页面提供什么、不提供什么</li>
<li>战略层：这个界面的目的</li>
<li>用户感受是从上到下，产品设计是从下到上</li>
<li>框架层和结构层是交互设计师的主要负责区</li>
</ul>
</li>
<li>用户体验要素与游戏交互设计<ul>
<li>产品目标和用户目标-战略层：<ul>
<li>研究用户是谁：定性研究（玩家对Demo试玩的意见）、定量研究（问卷调查），来了解用户特征，尝试对用户细分</li>
<li>用户画像：基本信息（年龄、性别、单生？等）、何时游戏？游戏经验？技术水平？等</li>
<li>二次元游戏用户画像4种：IP教徒典型画像、游戏宅典型画像、游戏向二次元人典型画像、跟风宅典型画像</li>
</ul>
</li>
<li>功能规格和内容需求-范围层：<ul>
<li>梳理系统蓝图：核心系统内容、系统常规玩法等……</li>
<li>时间规划：每个版本节点中游戏的完成度、复杂度，来确定哪些交互规则必须优先搭建</li>
<li>策划案：阐明三点，系统的设计目的、系统的主要/次要流程、系统各功能的优先级（最关注项）</li>
</ul>
</li>
<li>.交互流程和信息构架-结构层：<ul>
<li>交互流程和信息架构（操作的流程，围绕（玩家）角色、任务、场景三要素）</li>
</ul>
</li>
<li>从抽象到具体-框架层：<ul>
<li>布局遵从习惯</li>
<li>覆盖尽可能多的场景和状态：有和无、最少和最多、80%和20%</li>
<li>选择合适的方式，而不一定是“最酷”的方式</li>
<li>优化交互输出，保证框架层实现度</li>
</ul>
</li>
<li>感知设计-表现层：<ul>
<li>目的是让框架层变得可以感知，交互设计师要让设计被视觉设计师“正确的感知”</li>
<li>围绕目的进行沟通</li>
</ul>
</li>
</ul>
</li>
<li>梳理紧急性、重要性</li>
</ul>
<p><em><a href="https://mp.weixin.qq.com/s/7t_WHdJljuOAu4YA6SnMtA" target="_blank" rel="noopener">原文：想要提升用户体验？ 先了解游戏交互设计这5个要素（含实例）</a></em>  </p>
<hr>
<p><em><code>to be continued...</code></em>  </p>
]]></content>
      <categories>
        <category>「Game」</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Notes</title>
    <url>/2019/10/29/Game-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>烂笔头</em></strong></p>
<p></font></center></p>
<a id="more"></a>


<hr>
<h1 id="逆水寒OL"><a href="#逆水寒OL" class="headerlink" title="逆水寒OL"></a>逆水寒OL</h1><h2 id="数值文档整理"><a href="#数值文档整理" class="headerlink" title="数值文档整理"></a>数值文档整理</h2><ul>
<li><a href="/2019/10/29/Game-Notes/%E8%A7%92%E8%89%B2%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7%E8%A1%A8.xlsb" title="角色基础属性表.xlsb">角色基础属性表.xlsb</a>  </li>
<li><a href="/2019/10/29/Game-Notes/%E8%A3%85%E5%A4%87%E5%B1%9E%E6%80%A7%E8%A1%A8.xlsb" title="装备属性表.xlsb">装备属性表.xlsb</a>

</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>防御计算公式：<br>伤害减免百分比 = （防御值/防御值+4300）* 100%</li>
</ul>
<h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><h2 id="经验（AP）成长要求，可充电距离"><a href="#经验（AP）成长要求，可充电距离" class="headerlink" title="经验（AP）成长要求，可充电距离"></a>经验（AP）成长要求，可充电距离</h2><table>
<thead>
<tr>
<th align="center">角色Lv.</th>
<th align="center">累计经验</th>
<th align="center">差额经验</th>
<th align="center">需要牌子</th>
<th align="center">可充电距离</th>
<th align="center">XM 容量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">10,000</td>
<td align="center">10,000</td>
<td align="center">-</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">30,000</td>
<td align="center">20,000</td>
<td align="center">-</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">70,000</td>
<td align="center">50,000</td>
<td align="center">-</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">150,000</td>
<td align="center">80,000</td>
<td align="center">-</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">300,000</td>
<td align="center">150,000</td>
<td align="center">-</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">600,000</td>
<td align="center">300,000</td>
<td align="center">-</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">1,200,000</td>
<td align="center">600,000</td>
<td align="center">-</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">2,400,000</td>
<td align="center">1,200,000</td>
<td align="center">1金4银</td>
<td align="center">2,250 km</td>
<td align="center">10,900</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">4,000,000</td>
<td align="center">1,600,000</td>
<td align="center">2金5银</td>
<td align="center">2,500 km</td>
<td align="center">11,700</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">6,000,000</td>
<td align="center">2,000,000</td>
<td align="center">4金6银</td>
<td align="center">2,750 km</td>
<td align="center">12,400</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">8,400,000</td>
<td align="center">2,400,000</td>
<td align="center">6金7银</td>
<td align="center">3,000 km</td>
<td align="center">13,000</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">12,000,000</td>
<td align="center">3,600,000</td>
<td align="center">1钛7金</td>
<td align="center">3,250 km</td>
<td align="center">13,500</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">17,000,000</td>
<td align="center">5,000,000</td>
<td align="center">2钛7金</td>
<td align="center">3,500 km</td>
<td align="center">13,900</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">24,000,000</td>
<td align="center">8,000,000</td>
<td align="center">3钛7金</td>
<td align="center">3,750 km</td>
<td align="center">14,200</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">40,000,000</td>
<td align="center">16,000,000</td>
<td align="center">2黑4钛7金</td>
<td align="center">4,000 km</td>
<td align="center">14,400</td>
</tr>
</tbody></table>
<ul>
<li>可充电距离 = 250 km × 等级</li>
</ul>
<img src="/2019/10/29/Game-Notes/ingress_1.png" class="" title="ingress经验门槛曲线">

<ul>
<li>经验门槛曲线：近似等比。9级前基本是升一级需要增加1整倍的累计经验，10-16级约为0.4~0.6倍。</li>
</ul>
<h2 id="Portal可Link距离（不含Link-Amp加成"><a href="#Portal可Link距离（不含Link-Amp加成" class="headerlink" title="Portal可Link距离（不含Link Amp加成"></a>Portal可Link距离（不含Link Amp加成</h2><table>
<thead>
<tr>
<th align="center">Portal Level</th>
<th align="center">Link距离</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">160 m</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2.560 km</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">12.96 km</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">40.96 km</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">100 km</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">207.36 km</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">384.16 km</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">655.36 km</td>
</tr>
</tbody></table>
<ul>
<li><p>公式： Portal Range = 160 m × （average resonator level）^ 4</p>
<ul>
<li>average resonator level = SUM(resonators)/8，不取整</li>
</ul>
</li>
</ul>
<h2 id="XMP威力"><a href="#XMP威力" class="headerlink" title="XMP威力"></a>XMP威力</h2><table>
<thead>
<tr>
<th align="center">XMP Level</th>
<th align="center">范围</th>
<th align="center">伤害</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">42 m</td>
<td align="center">150</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">48 m</td>
<td align="center">300</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">58 m</td>
<td align="center">500</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">72 m</td>
<td align="center">900</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">90 m</td>
<td align="center">1200</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">112 m</td>
<td align="center">1500</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">138 m</td>
<td align="center">1800</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">168 m</td>
<td align="center">2700</td>
</tr>
</tbody></table>
<h1 id="AKF-Arena-剑与远征"><a href="#AKF-Arena-剑与远征" class="headerlink" title="AKF Arena 剑与远征"></a>AKF Arena 剑与远征</h1><p>不要让玩家的投入打折（比如装备升级溢出补偿、经验返还），可以让玩家放心沉入游戏。</p>
<h1 id="不休的乌拉拉"><a href="#不休的乌拉拉" class="headerlink" title="不休的乌拉拉"></a>不休的乌拉拉</h1><h2 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h2><p>为了丰富游戏中后期的内容，分阶段开放了如下系统：  </p>
<table>
<thead>
<tr>
<th align="center">开放的系统</th>
<th align="center">开放等级</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">人物技能</td>
<td align="center">6</td>
<td align="center">分阶段开放4个技能栏，技能可升级</td>
</tr>
<tr>
<td align="center">装备强化</td>
<td align="center">12</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">人物属性加点</td>
<td align="center">14</td>
<td align="center">1级5点，可加3个维度</td>
</tr>
<tr>
<td align="center">宠物</td>
<td align="center">16</td>
<td align="center">捕捉、参战</td>
</tr>
<tr>
<td align="center">烹饪</td>
<td align="center">16</td>
<td align="center">诱捕宠物、加buff</td>
</tr>
<tr>
<td align="center">宠物研究</td>
<td align="center"></td>
<td align="center">提升宠物属性，间接提升人物属性</td>
</tr>
<tr>
<td align="center">秘境探险</td>
<td align="center">25</td>
<td align="center">过关开启武器附魔，附魔后才能进一步强化装备</td>
</tr>
<tr>
<td align="center">商店街</td>
<td align="center"></td>
<td align="center">使用贝壳、珍珠购买道具</td>
</tr>
<tr>
<td align="center">宠物牧场</td>
<td align="center"></td>
<td align="center">分阶段开放放置宠物的场地，提升属性</td>
</tr>
<tr>
<td align="center">武器宝石</td>
<td align="center"></td>
<td align="center">分阶段开放3个宝石孔</td>
</tr>
<tr>
<td align="center">宠物技能</td>
<td align="center"></td>
<td align="center">2主动，6被动，需要宠物研究开启技能栏</td>
</tr>
<tr>
<td align="center">宠物探险</td>
<td align="center"></td>
<td align="center">类似青蛙旅行</td>
</tr>
<tr>
<td align="center">咔嗒牌</td>
<td align="center">42</td>
<td align="center">集卡凑buff，类似自走棋</td>
</tr>
<tr>
<td align="center">玩具箱</td>
<td align="center">51</td>
<td align="center">对技能的强化</td>
</tr>
</tbody></table>
<h2 id="宝石数值"><a href="#宝石数值" class="headerlink" title="宝石数值"></a>宝石数值</h2><table>
<thead>
<tr>
<th align="center">宝石等级</th>
<th align="center">攻击<br>主武器</th>
<th align="center">命中<br>副武器</th>
<th align="center">生命<br>头饰</th>
<th align="center">防御<br>衣服</th>
<th align="center">格挡<br>护腕</th>
<th align="center">闪避<br>鞋子</th>
<th align="center">暴击<br>戒指</th>
<th align="center">破击<br>项链</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">85</td>
<td align="center">22</td>
<td align="center">395</td>
<td align="center">40</td>
<td align="center">29</td>
<td align="center">29</td>
<td align="center">22</td>
<td align="center">22</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">170</td>
<td align="center">44</td>
<td align="center">795</td>
<td align="center">85</td>
<td align="center">58</td>
<td align="center">58</td>
<td align="center">44</td>
<td align="center">44</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">300</td>
<td align="center">77</td>
<td align="center">1390</td>
<td align="center">150</td>
<td align="center">102</td>
<td align="center">102</td>
<td align="center">77</td>
<td align="center">77</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">470</td>
<td align="center">121</td>
<td align="center">2185</td>
<td align="center">240</td>
<td align="center">161</td>
<td align="center">161</td>
<td align="center">121</td>
<td align="center">121</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">690</td>
<td align="center">176</td>
<td align="center">3180</td>
<td align="center">350</td>
<td align="center">235</td>
<td align="center">235</td>
<td align="center">176</td>
<td align="center">176</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">945</td>
<td align="center">242</td>
<td align="center">4375</td>
<td align="center">485</td>
<td align="center">323</td>
<td align="center">323</td>
<td align="center">242</td>
<td align="center">242</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">1250</td>
<td align="center">319</td>
<td align="center">5765</td>
<td align="center">640</td>
<td align="center">426</td>
<td align="center">426</td>
<td align="center">319</td>
<td align="center">319</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">1595</td>
<td align="center">407</td>
<td align="center">7360</td>
<td align="center">815</td>
<td align="center">543</td>
<td align="center">543</td>
<td align="center">407</td>
<td align="center">407</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">1985</td>
<td align="center">507</td>
<td align="center">9150</td>
<td align="center">1015</td>
<td align="center">676</td>
<td align="center">676</td>
<td align="center">507</td>
<td align="center">507</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">2415</td>
<td align="center">617</td>
<td align="center">11140</td>
<td align="center">1235</td>
<td align="center">823</td>
<td align="center">823</td>
<td align="center">617</td>
<td align="center">617</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">2845</td>
<td align="center">727</td>
<td align="center">13130</td>
<td align="center">1455</td>
<td align="center">970</td>
<td align="center">970</td>
<td align="center">727</td>
<td align="center">727</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">3280</td>
<td align="center">837</td>
<td align="center">15115</td>
<td align="center">1680</td>
<td align="center">1117</td>
<td align="center">1117</td>
<td align="center">837</td>
<td align="center">837</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">3710</td>
<td align="center">948</td>
<td align="center">17105</td>
<td align="center">1900</td>
<td align="center">1264</td>
<td align="center">1264</td>
<td align="center">948</td>
<td align="center">948</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">4250</td>
<td align="center">1085</td>
<td align="center">19595</td>
<td align="center">2175</td>
<td align="center">1447</td>
<td align="center">1447</td>
<td align="center">1085</td>
<td align="center">1085</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">4790</td>
<td align="center">1223</td>
<td align="center">22080</td>
<td align="center">2450</td>
<td align="center">1631</td>
<td align="center">1631</td>
<td align="center">1223</td>
<td align="center">1223</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">5330</td>
<td align="center">1361</td>
<td align="center">24565</td>
<td align="center">2730</td>
<td align="center">1815</td>
<td align="center">1815</td>
<td align="center">1361</td>
<td align="center">1361</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">5925</td>
<td align="center">1513</td>
<td align="center">27315</td>
<td align="center">3035</td>
<td align="center">2018</td>
<td align="center">2018</td>
<td align="center">1513</td>
<td align="center">1513</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">6550</td>
<td align="center">1673</td>
<td align="center">30195</td>
<td align="center">3355</td>
<td align="center">2231</td>
<td align="center">2231</td>
<td align="center">1673</td>
<td align="center">1673</td>
</tr>
<tr>
<td align="center">19</td>
<td align="center">7195</td>
<td align="center">1838</td>
<td align="center">33180</td>
<td align="center">3685</td>
<td align="center">2451</td>
<td align="center">2451</td>
<td align="center">1838</td>
<td align="center">1838</td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">7845</td>
<td align="center">2004</td>
<td align="center">36165</td>
<td align="center">4015</td>
<td align="center">2672</td>
<td align="center">2672</td>
<td align="center">2004</td>
<td align="center">2004</td>
</tr>
</tbody></table>
<img src="/2019/10/29/Game-Notes/bxdwll_1.png" class="" title="不休的乌拉拉_宝石曲线">

<ul>
<li>近似等差，提升比例从2→1.1衰减</li>
</ul>
<h1 id="Battlefiled-1"><a href="#Battlefiled-1" class="headerlink" title="Battlefiled 1"></a>Battlefiled 1</h1><h2 id="枪"><a href="#枪" class="headerlink" title="枪"></a>枪</h2><ul>
<li>突击手<ul>
<li>M1918（壕沟战）：射速700，无脑糊脸，25/125子弹，1v2不太行。</li>
</ul>
</li>
<li>侦察兵<ul>
<li>绊雷：跑动敌人100伤害，走动78伤害。</li>
<li>G98（神枪手）：带支架，适合蹲，可75/150/300m调节，最大10倍镜。</li>
</ul>
</li>
</ul>
<h1 id="Batlefiled-5"><a href="#Batlefiled-5" class="headerlink" title="Batlefiled 5"></a>Batlefiled 5</h1><h2 id="枪-1"><a href="#枪-1" class="headerlink" title="枪"></a>枪</h2><ul>
<li>机枪伤害衰减：9m 25 → 50m 20 → 70m 18.5</li>
</ul>
<h3 id="突击兵"><a href="#突击兵" class="headerlink" title="突击兵"></a>突击兵</h3><ul>
<li>格韦尔1-5突击步枪<ul>
<li>适合新手，可单发/全自动</li>
<li>伤害不如stg44，射速比stg44快，近距离对战优势大</li>
<li>配合三倍镜在中近距离有稳定输出</li>
</ul>
</li>
</ul>
<h3 id="医疗兵"><a href="#医疗兵" class="headerlink" title="医疗兵"></a>医疗兵</h3><ul>
<li>索米KP/-31冲锋枪<ul>
<li>腰射可控性强，可单发/全自动，770射速</li>
<li>虽然伤害降低，但子弹初速度高，中近距离输出整体加强</li>
<li>建议新手走大弹夹，熟悉手感再换腰射六</li>
</ul>
</li>
<li>斯登冲锋枪<ul>
<li>射速540，全自动</li>
<li>属性平庸，适合新手适应冲锋枪</li>
</ul>
</li>
<li>MP40冲锋枪<ul>
<li>射速540</li>
<li>射速一般，但腰射准度和开镜准度借专长提高很多，适合大图中距离交火</li>
</ul>
</li>
</ul>
<h3 id="支援兵"><a href="#支援兵" class="headerlink" title="支援兵"></a>支援兵</h3><ul>
<li>刘易斯机枪<ul>
<li>精度和爆发不出色，但满级97子弹弹夹，可提供长时间的火力支援</li>
<li>后坐力略大于KE7，射速略高于布伦，但大幅低于升级后的KE7</li>
<li>长时间射击没有枪管冷却</li>
<li>三脚架搭配三倍镜是和中远距离</li>
</ul>
</li>
<li>KE7<ul>
<li>上手容易</li>
<li>弹夹稍小，升级后属性出色</li>
</ul>
</li>
<li>MG34<ul>
<li>固定式机枪，缺乏机动性，遭遇战反应力差</li>
<li>初始50发弹夹，670射速。升级后最大100的弹链，770的射速，不如MG42</li>
</ul>
</li>
<li>BERN布伦<ul>
<li>平庸，射速慢，弹夹小</li>
<li>精度高，后坐力低</li>
<li>推荐打法：升级后坐力，带三倍镜</li>
</ul>
</li>
<li>MG42<ul>
<li>大概是最好用的</li>
<li>初始981射速，可升级成1200射速或250弹链</li>
</ul>
</li>
<li>12G霰弹枪<ul>
<li>射速慢，弹一枪致死</li>
<li>后坐力动画幅度太大，遮挡屏幕</li>
<li>伤害8m 5→9m 3→24m 2</li>
</ul>
</li>
<li>M30<ul>
<li>强势，伤害 12m 5→ 13m 3→24m 2</li>
<li>自带步枪弹，配2倍镜机瞄，可以当半个狙</li>
</ul>
</li>
</ul>
<h3 id="侦察兵"><a href="#侦察兵" class="headerlink" title="侦察兵"></a>侦察兵</h3><ul>
<li>格位尔M95/40步枪<ul>
<li>伤害80→60</li>
<li>在中近距离的范围内有较小的子弹掉落</li>
<li>伤害比老李高，适合换手枪补刀</li>
<li>综合性能较高，适合玩家过度使用</li>
<li>近距离能打出80伤害，能打出击杀助攻，还这个距离很危险</li>
</ul>
</li>
<li>老李<ul>
<li>初始武器，但不一定适合新手</li>
<li>伤害60→55</li>
<li>射速快，但子弹初速慢，下坠大</li>
<li>技术上限高，遇到较多敌人时候，枪法硬还是有一战之力</li>
</ul>
</li>
<li>KragJorgensen<ul>
<li>伤害54→54</li>
<li>有个低阻弹专长，减少下坠，提高远距离爆头率</li>
<li>缺点伤害低，第二枪打到手腿可能50伤害打不死</li>
</ul>
</li>
<li>Kar98K<ul>
<li>伤害75→60</li>
<li>弹速快，还有低阻弹专长，下坠非常小</li>
<li>缺点射速慢</li>
</ul>
</li>
</ul>
<h2 id="武器专长"><a href="#武器专长" class="headerlink" title="武器专长"></a>武器专长</h2><ul>
<li>快速瞄准：瞄具瞄准的速度加快33%<ul>
<li>适合搭配狙击枪，提高射速，因为需要切镜上弹</li>
</ul>
</li>
<li>可变瞄准：远距离狙击时可以变更武器瞄准<ul>
<li>没什么用，不过有时候不得不点来激活下一个专长</li>
</ul>
</li>
<li>轻量化枪托：武器瞄准时的移动速度加快60%<ul>
<li>高倍镜（6）时合适，低倍镜时可能不便于瞄准 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>「Game」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Go の Command</title>
    <url>/2019/04/21/Go-Command/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>GO 命令</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>–&gt; <a href="https://golang.org/cmd/cgo/" target="_blank" rel="noopener">官方的命令文档</a> &lt;–  </p>
<h2 id="查看可用命令"><a href="#查看可用命令" class="headerlink" title="查看可用命令"></a>查看可用命令</h2><p>直接在终端中输入 <code>go help</code> 即可显示所有的 go 命令以及相应命令功能的简介，主要有：  </p>
<ul>
<li>build: 编译包和依赖</li>
<li>clean: 移除对象文件</li>
<li>doc: 显示包或者符号的文档</li>
<li>env: 打印go的环境信息</li>
<li>bug: 启动错误报告</li>
<li>fix: 运行go tool fix</li>
<li>fmt: 运行gofmt进行格式化</li>
<li>generate: 从processing source生成go文件</li>
<li>get: 下载并安装包和依赖</li>
<li>install: 编译并安装包和依赖</li>
<li>list: 列出包</li>
<li>run: 编译并运行go程序</li>
<li>test: 运行测试</li>
<li>tool: 运行go提供的工具</li>
<li>version: 显示go的版本</li>
<li>vet: 运行go tool vet</li>
</ul>
<h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><p>命令的使用方式：  <code>go command [args]</code> ，<code>go help &lt;command&gt;</code>  </p>
<p>在运行<code>go help</code>时，不仅仅打印了这些命令的基本信息，还给出了一些概念的帮助信息（<code>go help &lt;topic&gt;</code>）:  </p>
<ul>
<li>c: Go和c的相互调用</li>
<li>buildmode: 构建模式的描述</li>
<li>filetype: 文件类型</li>
<li>gopath: GOPATH环境变量</li>
<li>environment: 环境变量</li>
<li>importpath: 导入路径语法</li>
<li>packages: 包列表的描述</li>
<li>testflag: 测试符号描述</li>
<li>testfunc: 测试函数描述</li>
</ul>
<hr>
<h1 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a><code>go build</code></h1><p>类似其他静态，要执行 go 程序，需要先编译成可执行文件。  </p>
<p><code>go build</code>：用来编译 go 程序生成可执行文件。  </p>
<ul>
<li>但不是所有 go 程序都可以编译生成可执行文件，要生成可执行文件，go 程序需要满足两个条件（反之则不会生成任何文件，只是做检查性编译）：<ul>
<li>该 go 程序需要属于 main 包</li>
<li>在 main 包中必须还得包含 main() 函数</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run hello.<span class="keyword">go</span>   # 将会生成可执行文件 hello</span><br><span class="line">$ ./hello           # 运行可执行文件</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>加一些标记：  </p>
<ul>
<li>-v 标记，可以把命令执行过程中构建的包名（包含编译过程中依赖的包）打印出来，如果 go build 的是一个源码文件，则会打印出的包名为 command-line-arguments，这是编译源码文件时生成的虚拟包名，所以看到不用觉得奇怪。</li>
<li>-x 标记，可以打印编译期间所用到的所有 shell 命令。</li>
<li>-o 标记，用来指定生成文件的路径和名称。</li>
<li>-a 标记，强制重新编译。</li>
<li>-buildmode=shared 标记，这个参数可以指定当前编译生成的结果类型，如静态库和动态库。GO语言默认使用静态编译，好处是部署时非常简单，但使用动态库，可以减少分发包的大小，大家可以根据实际情况选择。注意，目前在windows下尚不支持编译成动态库。</li>
<li>更多参数，请使用 go build -h 或 go help build 查看。</li>
</ul>
<h1 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a><code>go run</code></h1><p><code>go run</code>：编译并运行，但不会产生中间文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run hello.<span class="keyword">go</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<h1 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a><code>go clean</code></h1><p>用于清除产生的可执行程序：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> clean    # 不加参数，可以删除当前目录下的所有可执行文件</span><br><span class="line">$ <span class="keyword">go</span> clean sourcefile.<span class="keyword">go</span>  # 会删除对应的可执行文件</span><br></pre></td></tr></table></figure>

<h1 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a><code>go fmt</code></h1><p>格式化代码。注意不包含代码包中的子代码包。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> fmt main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>更多信息，通过 <code>gofmt -h</code> 查看。  </p>
<h1 id="go-doc-amp-godoc"><a href="#go-doc-amp-godoc" class="headerlink" title="go doc &amp; godoc"></a><code>go doc</code> &amp; <code>godoc</code></h1><p>用于快速查看包文档，<code>go doc package</code> 命令将在中断中打印出指定 package 的文档。  </p>
<p>另外，<code>godoc</code> 可以启动我们自己的文档服务器：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ godoc -http=:<span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>然后我们就可与在浏览器 <code>localhost:8080</code> 中查看go文档了。  </p>
<h1 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a><code>go get</code></h1><p>用来安装第三方包，格式：<code>go get src</code>，从指定源上面下载或者更新指定的代码和依赖，并对他们进行编译和安装。  </p>
<p>eg.例如我们像使用 beego 来开发 web 应用，我们就需要获取 beego：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> get github.com/astaxie/beego</span><br></pre></td></tr></table></figure>

<p>这条命令将会自动下载安装 beego 以及它的依赖，然后我们就可以使用下面的方式使用:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/astaxie/beego"</span>   # 这里需要使用 src 下的完整路径</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    beego.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a><code>go install</code></h1><p>用来编译和安装 go 程序。与 build 命令进行对比：  </p>
<table>
<thead>
<tr>
<th></th>
<th>install</th>
<th>build</th>
</tr>
</thead>
<tbody><tr>
<td>生成的可执行文件路径</td>
<td>工作目录下的bin目录下</td>
<td>当前目录下</td>
</tr>
<tr>
<td>可执行文件的名字</td>
<td>与源码所在目录同名</td>
<td>默认与源程序同名，可以使用-o选项指定</td>
</tr>
<tr>
<td>依赖</td>
<td>将依赖的保安放到工作目录下的pkg文件夹下</td>
<td>-</td>
</tr>
</tbody></table>
<h1 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a><code>go test</code></h1><p>用来运行测试的命令，这种测试是以包围单位的。需要遵循一定的规则：</p>
<ul>
<li>测试源文件是名称以<code>_test.go</code>为后缀的</li>
<li>测试源文件内包含若干测试函数的源码文件</li>
<li>测试函数一般是以<code>Test</code>为名称前缀，并有一个类型为<code>testing.T</code>的参数</li>
</ul>
<h1 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a><code>go list</code></h1><p>不加任何标记直接使用，是显示指定包的导入路径，如 <code>go list net/http</code> 就显示 <code>net/http</code>。  </p>
<p>该命令加上 -json 标记可以显示完整信息。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> list -json time</span><br></pre></td></tr></table></figure>

<p>如果只想显示指定信息，可以使用 -f 标记，如 go list -f { {.GoFiles} } net/http 可以显示 net/http 包中的 GO 源码文件列表。（所以可以理解，默认的 go list 相当于 go list -f { {.ImportPath} }）  </p>
<h1 id="gofix"><a href="#gofix" class="headerlink" title="gofix"></a><code>gofix</code></h1><p>简单的说，这是一个当GO语言版本升级之后，把代码包中旧的语法更新成新版本语法的自动化工具。它是 go tool fix 的简单封装，它作用于代码包。  </p>
<p>当需要升级自己的项目或者升级下载的第三方代码包，可以使用此方法。（下载并升级代码包可以使用 go get -fix 命令 ）  </p>
<h1 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a><code>go vet</code></h1><p>静态检查工具，一般项目快完成时候进行优化时需要。  </p>
<h1 id="go-tool-pprof"><a href="#go-tool-pprof" class="headerlink" title="go tool pprof"></a><code>go tool pprof</code></h1><p>性能检查工具…  </p>
<h1 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a><code>go env</code></h1><p>用于打印GO语言的环境信息，如 GOPATH 是工作区目录，GOROOT 是GO语言安装目录，GOBIN 是通过 go install 命令生成可执行文件的存放目录（默认是当前工作区的 bin 目录下），GOEXE 为生成可执行文件的后缀。  </p>
<h1 id="转成汇编代码"><a href="#转成汇编代码" class="headerlink" title="转成汇编代码"></a>转成汇编代码</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool objdump -s <span class="string">"operate\.Login"</span> server</span><br></pre></td></tr></table></figure>

<p>上面的意思是，解析可执行文件server，将其中的 operate 包的 Login 方法转成汇编代码。  </p>
]]></content>
      <categories>
        <category>「语言」- Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 中常见错误</title>
    <url>/2019/03/11/Go-Common-Mistakes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Go 语言中的常见错误笔记</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li>永远不要使用形如 <code>var p*a</code> 声明变量，这会混淆指针声明和乘法运算（参考<a href="04.9.md">4.9小节</a>）</li>
<li>永远不要在<code>for</code>循环自身中改变计数器变量（参考<a href="05.4.md">5.4小节</a>）</li>
<li>永远不要在<code>for-range</code>循环中使用一个值去改变自身的值（参考<a href="05.4.md">5.4.4小节</a>）</li>
<li>永远不要将<code>goto</code>和前置标签一起使用（参考<a href="05.6.md">5.6小节</a>）</li>
<li>永远不要忘记在函数名（参考<a href="06.0.md">第6章</a>）后加括号()，尤其调用一个对象的方法或者使用匿名函数启动一个协程时</li>
<li>永远不要使用<code>new()</code>一个map，一直使用make（参考<a href="08.0.md">第8章</a>）</li>
<li>当为一个类型定义一个String()方法时，不要使用<code>fmt.Print</code>或者类似的代码（参考<a href="10.7.md">10.7小节</a>）</li>
<li>永远不要忘记当终止缓存写入时，使用<code>Flush</code>函数（参考<a href="12.2.md">12.2.3小节</a>）</li>
<li>永远不要忽略错误提示，忽略错误会导致程序奔溃（参考<a href="13.1.md">13.1小节</a>）</li>
<li>不要使用全局变量或者共享内存，这会使并发执行的代码变得不安全（参考<a href="14.1.md">14.1小节</a>）</li>
<li><code>println</code>函数仅仅是用于调试的目的</li>
</ul>
<p>最佳实践：对比以下使用方式：  </p>
<ul>
<li>使用正确的方式初始化一个元素是切片的映射，例如<code>map[type]slice</code>（参考<a href="08.1.md">8.1.3小节</a>）</li>
<li>一直使用逗号，ok或者checked形式作为类型断言（参考<a href="11.3.md">11.3小节</a>）</li>
<li>使用一个工厂函数创建并初始化自己定义类型（参考<a href="10.2.md">10.2小节</a>-<a href="18.4.md">18.4小节</a>）</li>
<li>仅当一个结构体的方法想改变结构体时，使用结构体指针作为方法的接受者，否则使用一个结构体值类型<a href="10.6.md">10.6.3小节</a></li>
</ul>
<h1 id="误用字符串"><a href="#误用字符串" class="headerlink" title="误用字符串"></a>误用字符串</h1><p>当需要对一个字符串进行频繁的操作时，谨记在go语言中字符串是不可变的（类似java和c#）。使用诸如<code>a += b</code>形式连接字符串效率低下，尤其在一个循环内部使用这种形式。这会导致大量的内存开销和拷贝。<strong>应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中。</strong> 例如以下的代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">    b.WriteString(str) <span class="comment">// 将字符串str写入缓存buffer</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> b.String()</span><br></pre></td></tr></table></figure>

<p>注意：由于编译优化和依赖于使用缓存操作的字符串大小，当循环次数大于15时，效率才会更佳。  </p>
<h1 id="发生错误时使用defer关闭一个文件"><a href="#发生错误时使用defer关闭一个文件" class="headerlink" title="发生错误时使用defer关闭一个文件"></a>发生错误时使用defer关闭一个文件</h1><p>如果你在一个for循环内部处理一系列文件，你需要使用defer确保文件在处理完毕后被关闭，例如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    <span class="keyword">if</span> f, err = os.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是错误的方式，当循环结束时文件没有关闭</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">// 对文件进行操作</span></span><br><span class="line">    f.Process(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在循环结尾处的defer没有执行，所以文件一直没有关闭！垃圾回收机制可能会自动关闭文件，但是这会产生一个错误，更好的做法是：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    <span class="keyword">if</span> f, err = os.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对文件进行操作</span></span><br><span class="line">    f.Process(data)</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    f.Close()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>defer仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。</strong>  </p>
<h1 id="何时使用new-和make"><a href="#何时使用new-和make" class="headerlink" title="何时使用new()和make()"></a>何时使用new()和make()</h1><ul>
<li>切片、映射和通道，使用make</li>
<li>数组、结构体和所有的值类型，使用new </li>
</ul>
<h1 id="不需要将一个指向切片的指针传递给函数"><a href="#不需要将一个指向切片的指针传递给函数" class="headerlink" title="不需要将一个指向切片的指针传递给函数"></a>不需要将一个指向切片的指针传递给函数</h1><p>切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。<br>因此应该这样做：</p>
<pre><code>func findBiggest( listOfNumbers []int ) int {}</code></pre><p>而不是：  </p>
<pre><code>func findBiggest( listOfNumbers *[]int ) int {}</code></pre><p><strong>当切片作为参数传递时，切记不要解引用切片。</strong>  </p>
<h1 id="使用指针指向接口类型"><a href="#使用指针指向接口类型" class="headerlink" title="使用指针指向接口类型"></a>使用指针指向接口类型</h1><p>查看如下程序：<code>nexter</code>是一个接口类型，并且定义了一个<code>next()</code>方法读取下一字节。函数<code>nextFew</code>将<code>nexter</code>接口作为参数并读取接下来的<code>num</code>个字节，并返回一个切片：这是正确做法。但是<code>nextFew2</code>使用一个指向<code>nexter</code>接口类型的指针作为参数传递给函数：当使用<code>next()</code>函数时，系统会给出一个编译错误：<strong>n.next undefined (type *nexter has no<br>field or method next)</strong> （译者注：n.next未定义（*nexter类型没有next成员或next方法））  </p>
<p>例 pointer_interface.go (不能通过编译):  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    “fmt”</span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> nexter <span class="keyword">interface</span> &#123;</span><br><span class="line">    next() <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFew1</span><span class="params">(n nexter, num <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        b[i] = n.next()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFew2</span><span class="params">(n *nexter, num <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        b[i] = n.next() <span class="comment">// 编译错误:n.next未定义（*nexter类型没有next成员或next方法）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(“Hello World!”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。</strong>  </p>
<h1 id="使用值类型时误用指针"><a href="#使用值类型时误用指针" class="headerlink" title="使用值类型时误用指针"></a>使用值类型时误用指针</h1><p>将一个值类型作为一个参数传递给函数或者作为一个方法的接收者，似乎是对内存的滥用，因为值类型一直是传递拷贝。但是另一方面，值类型的内存是在栈上分配，内存分配快速且开销不大。如果你传递一个指针，而不是一个值类型，go编译器大多数情况下会认为需要创建一个对象，并将对象移动到堆上，所以会导致额外的内存分配：因此当使用指针代替值类型作为参数传递时，我们没有任何收获。  </p>
<h1 id="误用协程和通道"><a href="#误用协程和通道" class="headerlink" title="误用协程和通道"></a>误用协程和通道</h1><p>在实际应用中，你不需要并发执行，或者你不需要关注协程和通道的开销，在大多数情况下，通过栈传递参数会更有效率。  </p>
<p>但是，如果你使用<code>break</code>、<code>return</code>或者<code>panic</code>去跳出一个循环，很有可能会导致内存溢出，因为协程正处理某些事情而被阻塞。在实际代码中，通常仅需写一个简单的过程式循环即可。<strong>当且仅当代码中并发执行非常重要，才使用协程和通道。</strong></p>
<h1 id="闭包和协程的使用"><a href="#闭包和协程的使用" class="headerlink" title="闭包和协程的使用"></a>闭包和协程的使用</h1><p>看下面代码：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 版本A:</span></span><br><span class="line">    <span class="keyword">for</span> ix := <span class="keyword">range</span> values &#123; <span class="comment">// ix是索引值</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(ix, <span class="string">" "</span>)</span><br><span class="line">        &#125;() <span class="comment">// 调用闭包打印每个索引值</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// 版本B: 和A版本类似，但是通过调用闭包作为一个协程</span></span><br><span class="line">    <span class="keyword">for</span> ix := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(ix, <span class="string">" "</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    time.Sleep(<span class="number">5e9</span>)</span><br><span class="line">    <span class="comment">// 版本C: 正确的处理方式</span></span><br><span class="line">    <span class="keyword">for</span> ix := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ix <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            fmt.Print(ix, <span class="string">" "</span>)</span><br><span class="line">        &#125;(ix)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    time.Sleep(<span class="number">5e9</span>)</span><br><span class="line">    <span class="comment">// 版本D: 输出值:</span></span><br><span class="line">    <span class="keyword">for</span> ix := <span class="keyword">range</span> values &#123;</span><br><span class="line">        val := values[ix]</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(val, <span class="string">" "</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">10 </span><span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>版本A调用闭包5次打印每个索引值，版本B也做相同的事，但是通过协程调用每个闭包。按理说这将执行得更快，因为闭包是并发执行的。如果我们阻塞足够多的时间，让所有协程执行完毕，版本B的输出是：<code>4 4 4 4 4</code>。为什么会这样？在版本B的循环中，<code>ix</code>变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，这是一个比较好的方式，当你运行这段代码时，你将看见每次循环都打印最后一个索引值<code>4</code>，而不是每个元素的索引值。因为协程可能在循环结束后还没有开始执行，而此时<code>ix</code>值是<code>4</code>。  </p>
<p>版本C的循环写法才是正确的：调用每个闭包时将<code>ix</code>作为参数传递给闭包。<code>ix</code>在每次循环时都被重新赋值，并将每个协程的<code>ix</code>放置在栈中，所以当协程最终被执行时，每个索引值对协程都是可用的。注意这里的输出可能是<code>0 2 1 3 4</code>或者<code>0 3 1 2 4</code>或者其他类似的序列，这主要取决于每个协程何时开始被执行。  </p>
<p>在版本D中，我们输出这个数组的值，为什么版本B不能而版本D可以呢？  </p>
<p>因为版本D中的变量声明是在循环体内部，所以在每次循环时，这些变量相互之间是不共享的，所以这些变量可以单独的被每个闭包使用。  </p>
<h1 id="糟糕的错误处理"><a href="#糟糕的错误处理" class="headerlink" title="糟糕的错误处理"></a>糟糕的错误处理</h1><h2 id="不要使用布尔值"><a href="#不要使用布尔值" class="headerlink" title="不要使用布尔值"></a>不要使用布尔值</h2><p>像下面代码一样，创建一个布尔型变量用于测试错误条件是多余的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> good <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 测试一个错误，`good`被赋为`true`或者`false`</span></span><br><span class="line">    <span class="keyword">if</span> !good &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"things aren’t good"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>立即检测一个错误：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">... err1 := api.Func1()</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免错误检测使代码变得混乱："><a href="#避免错误检测使代码变得混乱：" class="headerlink" title="避免错误检测使代码变得混乱："></a>避免错误检测使代码变得混乱：</h2><p>避免写出这样的代码：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">... err1 := api.Func1()</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"err: "</span> + err.Error())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err2 := api.Func2()</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，包括在一个初始化的<code>if</code>语句中对函数的调用。但即使代码中到处都是以<code>if</code>语句的形式通知错误（通过打印错误信息）。通过这种方式，很难分辨什么是正常的程序逻辑，什么是错误检测或错误通知。还需注意的是，大部分代码都是致力于错误的检测。通常解决此问题的好办法是尽可能以闭包的形式封装你的错误检测，例如下面的代码：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequestHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    err := <span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> req.Method != <span class="string">"GET"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">"expected GET"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> input := parseInput(req); input != <span class="string">"command"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">"malformed command"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以在此进行其他的错误检测</span></span><br><span class="line">    &#125; ()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            w.WriteHeader(<span class="number">400</span>)</span><br><span class="line">            io.WriteString(w, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        doSomething() ...</span><br></pre></td></tr></table></figure>

<p>这种方法可以很容易分辨出错误检测、错误通知和正常的程序逻辑<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.5.md" target="_blank" rel="noopener">更详细…</a>。  </p>
<h1 id="不能使用简短声明来设置字段的值"><a href="#不能使用简短声明来设置字段的值" class="headerlink" title="不能使用简短声明来设置字段的值"></a>不能使用简短声明来设置字段的值</h1><p>struct 的变量字段不能使用 := 来赋值以使用预定义的变量来避免解决：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    data.result, err := work()  <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">"info: %+v\n"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    <span class="keyword">var</span> err error   <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    data.result, err = work()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"info: %+v\n"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="显式类型的变量无法使用-nil-来初始化"><a href="#显式类型的变量无法使用-nil-来初始化" class="headerlink" title="显式类型的变量无法使用 nil 来初始化"></a>显式类型的变量无法使用 nil 来初始化</h1><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span> <span class="comment">// error: use of untyped nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="直接使用值为-nil-的-slice、map"><a href="#直接使用值为-nil-的-slice、map" class="headerlink" title="直接使用值为 nil 的 slice、map"></a>直接使用值为 nil 的 slice、map</h1><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    m[<span class="string">"one"</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h1><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 cap() 来检测分配空间的大小：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="string-类型的变量值不能为-nil"><a href="#string-类型的变量值不能为-nil" class="headerlink" title="string 类型的变量值不能为 nil"></a>string 类型的变量值不能为 nil</h1><p>不用 <code>nil</code> 初始化字符串  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="literal">nil</span>  <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;   <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span>    <span class="comment">// 字符串类型的零值是空串 ""</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &#123;</span><br><span class="line">        s = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="range-遍历-slice-和-array-时混淆了返回值"><a href="#range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="range 遍历 slice 和 array 时混淆了返回值"></a>range 遍历 slice 和 array 时混淆了返回值</h1><p>Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值。  </p>
<h1 id="slice-和-array-其实是一维数据"><a href="#slice-和-array-其实是一维数据" class="headerlink" title="slice 和 array 其实是一维数据"></a>slice 和 array 其实是一维数据</h1><ul>
<li>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。  </li>
<li>使用“独立”的切片分两步：  <ul>
<li>创建外部 slice</li>
<li>对每个内部 slice 进行内存分配。注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="keyword">int</span>, x)</span><br><span class="line">    <span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用“共享底层数组”的切片:  <ul>
<li>创建一个存放原始数据的容器 slice</li>
<li>创建其他的 slice</li>
<li>切割原始 slice 来初始化其他的 slice</li>
</ul>
</li>
</ul>
<h1 id="访问-map-中不存在的-key"><a href="#访问-map-中不存在的-key" class="headerlink" title="访问 map 中不存在的 key"></a>访问 map 中不存在的 key</h1><p>不能通过取出来的值来判断 key 是不是在 map 中。<br>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"2"</span>, <span class="string">"two"</span>: <span class="string">""</span>, <span class="string">"three"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">"two"</span>]; v == <span class="string">""</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key two is no entry"</span>)  <span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"2"</span>, <span class="string">"two"</span>: <span class="string">""</span>, <span class="string">"three"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := x[<span class="string">"two"</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key two is no entry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="string-类型的值是常量，不可更改"><a href="#string-类型的值是常量，不可更改" class="headerlink" title="string 类型的值是常量，不可更改"></a>string 类型的值是常量，不可更改</h1><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。<br>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">"T"</span>      <span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    xBytes := []<span class="keyword">byte</span>(x)</span><br><span class="line">    xBytes[<span class="number">0</span>] = <span class="string">'T'</span> <span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">    x = <span class="keyword">string</span>(xBytes)</span><br><span class="line">    fmt.Println(x)  <span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。  </p>
<p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    xRunes := []<span class="keyword">rune</span>(x)</span><br><span class="line">    xRunes[<span class="number">0</span>] = <span class="string">'我'</span></span><br><span class="line">    x = <span class="keyword">string</span>(xRunes)</span><br><span class="line">    fmt.Println(x)  <span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 的内建函数 <code>len()</code> 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。  </p>
<p>如果要得到字符串的字符数，可使用 “unicode/utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))   <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： RuneCountInString 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"é"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))  <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))   <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(<span class="string">"cafe\u0301"</span>)   <span class="comment">// café // 法文的 cafe，实际上是两个 rune 的组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在多行-array、slice、map-语句中缺少-号"><a href="#在多行-array、slice、map-语句中缺少-号" class="headerlink" title="在多行 array、slice、map 语句中缺少 , 号"></a>在多行 array、slice、map 语句中缺少 , 号</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>   <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;    </span><br><span class="line">    z := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="log-Fatal-和-log-Panic-不只是-log"><a href="#log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="log.Fatal 和 log.Panic 不只是 log"></a><code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h1><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 Fatal<em>()、Panic</em>() 时能做更多日志外的事，如中断程序的执行等：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"Fatal level log: log entry"</span>)     <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">"Nomal level log: log entry"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对内建数据结构的操作并不是同步的"><a href="#对内建数据结构的操作并不是同步的" class="headerlink" title="对内建数据结构的操作并不是同步的"></a>对内建数据结构的操作并不是同步的</h1><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。  </p>
<p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。  </p>
<h1 id="range-迭代-string-得到的值"><a href="#range-迭代-string-得到的值" class="headerlink" title="range 迭代 string 得到的值"></a>range 迭代 string 得到的值</h1><p>range 得到的索引是字符值（Unicode point / rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。  </p>
<p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">"A\xfe\x02\xff\x04"</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>, v)   <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4   // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>, v)   <span class="comment">// 0x41 0xfe 0x2 0xff 0x4   // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="range-迭代-map"><a href="#range-迭代-map" class="headerlink" title="range 迭代 map"></a>range 迭代 map</h1><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。  </p>
<p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>, <span class="string">"four"</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="switch-中的-fallthrough-语句"><a href="#switch-中的-fallthrough-语句" class="headerlink" title="switch 中的 fallthrough 语句"></a>switch 中的 fallthrough 语句</h1><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，不过你可以在 case 代码块末尾使用 fallthrough，强制执行下一个 case 代码块。也可以改写 case 为多条件判断。  </p>
<h1 id="自增和自减运算"><a href="#自增和自减运算" class="headerlink" title="自增和自减运算"></a>自增和自减运算</h1><p>多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>--</code> 只作为运算符而非表达式。  </p>
<h1 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h1><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 中用 <code>^</code> XOR 操作符来按位取反。<br>同时 <code>^</code> 也是按位异或（XOR）操作符。  </p>
<p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p>
<h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>优先级列表：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>

<h1 id="不导出的-struct-字段无法被-encode"><a href="#不导出的-struct-字段无法被-encode" class="headerlink" title="不导出的 struct 字段无法被 encode"></a>不导出的 struct 字段无法被 encode</h1><p>以小写字母开头的字段成员是无法被外部直接访问的，所以 <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := MyData&#123;<span class="number">1</span>, <span class="string">"two"</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, in) <span class="comment">// main.MyData&#123;One:1, two:"two"&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded, _ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(encoded))    <span class="comment">// &#123;"One":1&#125;    // 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded, &amp;out)</span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, out)    <span class="comment">// main.MyData&#123;One:1, two:""&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="程序退出时还有-goroutine-在执行"><a href="#程序退出时还有-goroutine-在执行" class="headerlink" title="程序退出时还有 goroutine 在执行"></a>程序退出时还有 goroutine 在执行</h1><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意。  </p>
<p>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。  </p>
<p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 kill 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)   <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;  <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="keyword">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] m =&gt; %v\n"</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] is done\n"</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>若函数 receiver 传参是传值方式，则无法修改参数的原有值</h1><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。  </p>
<p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num   <span class="keyword">int</span></span><br><span class="line">    key   *<span class="keyword">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span> <span class="title">pointerFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span> <span class="title">valueFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">"valueFunc.key"</span></span><br><span class="line">    this.items[<span class="string">"valueFunc"</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    key := <span class="string">"key1"</span></span><br><span class="line"></span><br><span class="line">    d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"num=%v  key=%v  items=%v\n"</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.pointerFunc() <span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">    fmt.Printf(<span class="string">"num=%v  key=%v  items=%v\n"</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.valueFunc()   <span class="comment">// 修改 key 和 items 的值，num 未修改成功</span></span><br><span class="line">    fmt.Printf(<span class="string">"num=%v  key=%v  items=%v\n"</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="struct、array、slice-和-map-的值比较"><a href="#struct、array、slice-和-map-的值比较" class="headerlink" title="struct、array、slice 和 map 的值比较"></a>struct、array、slice 和 map 的值比较</h1><p>可以使用相等运算符 == 来比较结构体变量，前提是两个结构体的成员都是可比较的类型。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num     <span class="keyword">int</span></span><br><span class="line">    fp      <span class="keyword">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">complex64</span></span><br><span class="line">    str     <span class="keyword">string</span></span><br><span class="line">    char    <span class="keyword">rune</span></span><br><span class="line">    yes     <span class="keyword">bool</span></span><br><span class="line">    events  &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref     *<span class="keyword">byte</span></span><br><span class="line">    raw     [<span class="number">10</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, v1 == v2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num    <span class="keyword">int</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span>      // 无法比较</span></span><br><span class="line">    doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span>      // 无法比较</span></span><br><span class="line">    m      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>    <span class="comment">// 无法比较</span></span><br><span class="line">    bytes  []<span class="keyword">byte</span>           <span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"a"</span>, <span class="string">"two"</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"two"</span>: <span class="string">"b"</span>, <span class="string">"one"</span>: <span class="string">"a"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(m1, m2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(s1, s2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="keyword">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"b1 == b2: "</span>, reflect.DeepEqual(b1, b2))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> <code>DeepEqual()</code> 并不总适合于比较 slice</p>
<p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code> 和 <code>strings.EqualFold()</code>  </p>
<p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 timing attacks，此时应使用 “crypto/subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数  </p>
<h1 id="在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>在 range 迭代 slice、array、map 时通过更新引用来更新元素</h1><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址。  </p>
<p>如果要修改原有元素的值，应该使用索引直接访问。  </p>
<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123; num <span class="keyword">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span> <span class="comment">// 直接使用指针更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])  <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="slice-中隐藏的数据"><a href="#slice-中隐藏的数据" class="headerlink" title="slice 中隐藏的数据"></a>slice 中隐藏的数据</h1><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。  </p>
<p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> <span class="params">(res []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>]) <span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="旧-slice"><a href="#旧-slice" class="headerlink" title="旧 slice"></a>旧 slice</h1><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。  </p>
<p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)   <span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)   <span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">    fmt.Println(s1)     <span class="comment">// [1 22 23]</span></span><br><span class="line">    fmt.Println(s2)     <span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)  <span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s1)     <span class="comment">// [1 22 23]    // 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">    fmt.Println(s2)     <span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="跳出-for-switch-和-for-select-代码块"><a href="#跳出-for-switch-和-for-select-代码块" class="headerlink" title="跳出 for-switch 和 for-select 代码块"></a>跳出 for-switch 和 for-select 代码块</h1><p>没有指定标签的 break 只会跳出 switch/select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块然后 <code>goto</code>。  </p>
<h1 id="defer-函数的参数值"><a href="#defer-函数的参数值" class="headerlink" title="defer 函数的参数值"></a>defer 函数的参数值</h1><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"result: "</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: 2</span></span><br></pre></td></tr></table></figure>

<h1 id="defer-函数的执行时机"><a href="#defer-函数的执行时机" class="headerlink" title="defer 函数的执行时机"></a>defer 函数的执行时机</h1><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。  </p>
<p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir := os.Args[<span class="number">1</span>]</span><br><span class="line">    start, err := os.Stat(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">        os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="keyword">string</span></span><br><span class="line">    filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="keyword">string</span>, fInfo os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"bad target:"</span>, target, <span class="string">"error:"</span>, err)   <span class="comment">//error:too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 f 资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法：defer延迟执行的函数写入匿名函数  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"bad target:"</span>, target, <span class="string">"error:"</span>, err)</span><br><span class="line">                <span class="keyword">return</span>  <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close() <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 f.Close() 来关闭。  </p>
<h1 id="失败的类型断言"><a href="#失败的类型断言" class="headerlink" title="失败的类型断言"></a>失败的类型断言</h1><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int], data: "</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int], data: "</span>, data)   <span class="comment">// [isn't a int], data:  0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int], data: "</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int], data: "</span>, data)   <span class="comment">// [not an int], data:  great</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用指针作为方法的-receiver"><a href="#使用指针作为方法的-receiver" class="headerlink" title="使用指针作为方法的 receiver"></a>使用指针作为方法的 receiver</h1><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。  </p>
<p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"name: "</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := data&#123;<span class="string">"one"</span>&#125;</span><br><span class="line">    d1.<span class="built_in">print</span>()  <span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> in printer = data&#123;<span class="string">"two"</span>&#125;</span><br><span class="line">    in.<span class="built_in">print</span>()  <span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data&#123;</span><br><span class="line">        <span class="string">"x"</span>: data&#123;<span class="string">"three"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">"x"</span>].<span class="built_in">print</span>()  <span class="comment">// m["x"] 是不可寻址的    // 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cannot use data literal (type data) as type printer in assignment:<br>data does not implement printer (print method has pointer receiver)<br>cannot call pointer method on m[“x”]<br>cannot take the address of m[“x”]</p>
</blockquote>
<h1 id="更新-map-字段的值"><a href="#更新-map-字段的值" class="headerlink" title="更新 map 字段的值"></a>更新 map 字段的值</h1><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data&#123;</span><br><span class="line">        <span class="string">"x"</span>: &#123;<span class="string">"Tom"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">"x"</span>].name = <span class="string">"Jerry"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"></span><br><span class="line">cannot assign to <span class="keyword">struct</span> field m[“x”].name in <span class="keyword">map</span></span><br></pre></td></tr></table></figure>

<p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []data&#123;&#123;<span class="string">"Tom"</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">"Jerry"</span></span><br><span class="line">    fmt.Println(s)  <span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新 map 中 struct 元素的字段值，有 2 个方法：  </p>
<ul>
<li>使用局部变量  </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data&#123;</span><br><span class="line">        <span class="string">"x"</span>: &#123;<span class="string">"Tom"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    r := m[<span class="string">"x"</span>]</span><br><span class="line">    r.name = <span class="string">"Jerry"</span></span><br><span class="line">    m[<span class="string">"x"</span>] = r</span><br><span class="line">    fmt.Println(m)  <span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用指向元素的 map 指针  </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]*data&#123;</span><br><span class="line">        <span class="string">"x"</span>: &#123;<span class="string">"Tom"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m[<span class="string">"x"</span>].name = <span class="string">"Jerry"</span>   <span class="comment">// 直接修改 m["x"] 中的字段</span></span><br><span class="line">    fmt.Println(m[<span class="string">"x"</span>]) <span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意下边这种误用：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]*data&#123;</span><br><span class="line">        <span class="string">"x"</span>: &#123;<span class="string">"Tom"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">"z"</span>].name = <span class="string">"what???"</span>  </span><br><span class="line">    fmt.Println(m[<span class="string">"x"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
</blockquote>
<h1 id="nil-interface-和-nil-interface-值"><a href="#nil-interface-和-nil-interface-值" class="headerlink" title="nil interface 和 nil interface 值"></a>nil interface 和 nil interface 值</h1><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil  </p>
<p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data *<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data, data == <span class="literal">nil</span>)  <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)  <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)  <span class="comment">// &lt;nil&gt; false  // data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的函数返回值类型是 interface，更要小心这个坑：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Good result: "</span>, res)   <span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T\n"</span>, res)         <span class="comment">// *struct &#123;&#125;   // res 不是 nil，它的值为 nil</span></span><br><span class="line">        fmt.Printf(<span class="string">"%v\n"</span>, res)         <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// 明确指明返回 nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Good result: "</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Bad result: "</span>, res)    <span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆栈变量"><a href="#堆栈变量" class="headerlink" title="堆栈变量"></a>堆栈变量</h1><p>你并不总是清楚你的变量是分配到了堆还是栈。  </p>
<p>在 C++ 中使用 new 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 new()、make() 来创建变量，变量为内存分配位置依旧归 Go 编译器管。  </p>
<p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C/C++ 中是不行的。  </p>
<p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置。  </p>
<h1 id="GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h1><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 / OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。  </p>
<p>Go 1.5 版本将可执行上下文的数量设置为 runtime.NumCPU() 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 GOMAXPROCS 环境变量或者动态的使用 runtime.GOMAXPROCS() 来调整。  </p>
<p>误区： <code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a href="https://golang.org/pkg/runtime/" target="_blank" rel="noopener">文档</a>  </p>
<p><code>GOMAXPROCS</code> 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())   <span class="comment">// 4</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">// 20</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="读写操作的重新排序"><a href="#读写操作的重新排序" class="headerlink" title="读写操作的重新排序"></a>读写操作的重新排序</h1><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序。  </p>
<p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。  </p>
<h1 id="优先调度"><a href="#优先调度" class="headerlink" title="优先调度"></a>优先调度</h1><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 for 循环：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"done !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。  </p>
<p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"not done !"</span>)   <span class="comment">// 并不内联执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"done !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用 runtime 包中的 Gosched() 来 手动启动调度器：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"done !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>「语言」- Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang in Action Notes</title>
    <url>/2019/03/19/Go-Action-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Go 语言应用 tips</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="ok-模式"><a href="#ok-模式" class="headerlink" title=",ok 模式"></a><code>,ok</code> 模式</h2><p>（1）在函数返回时检测错误  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, err := pack1.Func1(param1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(“Error %s in pack1.Func1 with parameter %v”, err.Error(), param1)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数Func1没有错误:</span></span><br><span class="line">Process(value)</span><br><span class="line"></span><br><span class="line">e.g.: os.Open(file) strconv.Atoi(str)</span><br></pre></td></tr></table></figure>

<p>这种模式也常用于通过<code>defer</code>使程序从<code>panic</code>中恢复执行。  </p>
<p>要实现简洁的错误检测代码，更好的方式是使用闭包，参考<a href="https://github.com/reitake/the-way-to-go_ZH_CN/blob/master/eBook/16.10.md" target="_blank" rel="noopener">第16.10.2小节</a></p>
<p>（2）检测映射中是否存在一个键值：key1在映射map1中是否有值？<a href="https://github.com/reitake/the-way-to-go_ZH_CN/blob/master/eBook/08.2.md" target="_blank" rel="noopener">参考</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> value, ok := map1[key1]; ok &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1不存在</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>（3）检测一个接口类型变量<code>varI</code>是否包含了类型<code>T</code>：类型断言 <a href="https://github.com/reitake/the-way-to-go_ZH_CN/blob/master/eBook/11.3.md" target="_blank" rel="noopener">参考</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> value, ok := varI.(T); ok &#123;</span><br><span class="line">    Process(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口类型varI没有包含类型T</span></span><br></pre></td></tr></table></figure>

<p>(4)检测一个通道 <code>ch</code> 是否关闭 <a href="https://github.com/reitake/the-way-to-go_ZH_CN/blob/master/eBook/14.3.md" target="_blank" rel="noopener">参考</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> input := <span class="keyword">range</span> ch &#123;</span><br><span class="line">     Process(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">input</span>, <span class="keyword">open</span> := &lt;-ch; !<span class="keyword">open</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 通道是关闭的</span></span><br><span class="line">    &#125;</span><br><span class="line">     Process(<span class="keyword">input</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="出于性能考虑的使用代码片段"><a href="#出于性能考虑的使用代码片段" class="headerlink" title="出于性能考虑的使用代码片段"></a>出于性能考虑的使用代码片段</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>（1）如何修改字符串中的一个字符：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str:=<span class="string">"hello"</span></span><br><span class="line">c:=[]<span class="keyword">byte</span>(str)</span><br><span class="line">c[<span class="number">0</span>]=<span class="string">'c'</span></span><br><span class="line">s2:= <span class="keyword">string</span>(c) <span class="comment">// s2 == "cello"</span></span><br></pre></td></tr></table></figure>

<p>（2）如何获取字符串的子串：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">substr := str[n:m]</span><br></pre></td></tr></table></figure>

<p>（3）如何使用<code>for</code>或者<code>for-range</code>遍历一个字符串：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gives only the bytes:</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">… = str[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gives the Unicode characters:</span></span><br><span class="line"><span class="keyword">for</span> ix, ch := <span class="keyword">range</span> str &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）如何获取一个字符串的字节数：<code>len(str)</code>  </p>
<p> 如何获取一个字符串的字符数：  </p>
<p> 最快速：<code>utf8.RuneCountInString(str)</code>   </p>
<p> <code>len([]rune(str))</code>   </p>
<p>（5）如何连接字符串：  </p>
<p> 最快速：<br><code>with a bytes.Buffer</code>（参考<a href="https://github.com/reitake/the-way-to-go_ZH_CN/blob/master/eBook/07.2.md" target="_blank" rel="noopener">章节7.2</a>）</p>
<p><code>Strings.Join()</code>（参考<a href="https://github.com/reitake/the-way-to-go_ZH_CN/blob/master/eBook/04.7.md" target="_blank" rel="noopener">章节4.7</a>）</p>
<p>使用<code>+=</code>：  </p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">"Hello "</span> </span><br><span class="line">str2 := <span class="string">"World!"</span></span><br><span class="line">str1 += str2 <span class="comment">//str1 == "Hello World!"</span></span><br></pre></td></tr></table></figure>

<p>（6）如何解析命令行参数：使用<code>os</code>或者<code>flag</code>包</p>
<p>（参考<a href="https://github.com/reitake/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_12/fileinput.go" target="_blank" rel="noopener">例12.4</a>）  </p>
<h3 id="数组-切片"><a href="#数组-切片" class="headerlink" title="数组 切片"></a>数组 切片</h3><p>创建：  </p>
<p><code>arr1 := new([len]type)</code>  </p>
<p><code>slice1 := make([]type, len)</code>  </p>
<p>初始化：  </p>
<p><code>arr1 := [...]type{i1, i2, i3, i4, i5}</code>  </p>
<p><code>arrKeyValue := [len]type{i1: val1, i2: val2}</code>  </p>
<p><code>var slice1 []type = arr1[start:end]</code>  </p>
<p>（1）如何截断数组或者切片的最后一个元素：  </p>
<p><code>line = line[:len(line)-1]</code>  </p>
<p>（2）如何使用<code>for</code>或者<code>for-range</code>遍历一个数组（或者切片）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">… = arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ix, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）如何在一个二维数组或者切片<code>arr2Dim</code>中查找一个指定值<code>V</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">found := <span class="literal">false</span></span><br><span class="line">Found: <span class="keyword">for</span> row := <span class="keyword">range</span> arr2Dim &#123;</span><br><span class="line">    <span class="keyword">for</span> column := <span class="keyword">range</span> arr2Dim[row] &#123;</span><br><span class="line">        <span class="keyword">if</span> arr2Dim[row][column] == V&#123;</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span> Found</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>创建：    <code>map1 := make(map[keytype]valuetype)</code>  </p>
<p>初始化：   <code>map1 := map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2}</code>  </p>
<p>（1）如何使用<code>for</code>或者<code>for-range</code>遍历一个映射：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）如何在一个映射中检测键<code>key1</code>是否存在：<code>val1, isPresent = map1[key1]</code>  </p>
<p>返回值：键<code>key1</code>对应的值或者<code>0</code>, <code>true</code>或者<code>false</code>  </p>
<p>（3）如何在映射中删除一个键：<code>delete(map1, key1)</code>  </p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>创建：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    field1 type1</span><br><span class="line">    field2 type2</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">ms := <span class="built_in">new</span>(struct1)</span><br></pre></td></tr></table></figure>

<p>初始化：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ms := &amp;struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">"Chris"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>当结构体的命名以大写字母开头时，该结构体在包外可见。<br>通常情况下，为每个结构体定义一个构建函数，并推荐使用构建函数初始化结构体（参考<a href="https://github.com/reitake/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_10/person.go" target="_blank" rel="noopener">例10.2</a>）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ms := Newstruct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">"Chris"</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Newstruct1</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">float32</span>, name <span class="keyword">string</span>)</span> *<span class="title">struct1</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;struct1&#123;n, f, name&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>（1）如何检测一个值<code>v</code>是否实现了接口<code>Stringer</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := v.(Stringer); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"implements String(): %s\n"</span>, v.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）如何使用接口实现一个类型分类函数：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"param #%d is a bool\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"param #%d is a float64\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"param #%d is an int\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"param #%d is nil\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"param #%d is a string\n"</span>, i)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"param #%d’s type is unknown\n"</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>如何使用内建函数<code>recover</code>终止<code>panic</code>过程（参考<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.3.md" target="_blank" rel="noopener">章节13.3</a>）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(g <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">"done"</span>)</span><br><span class="line">        <span class="comment">// Println executes normally even if there is a panic</span></span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"run time panic: %v"</span>, x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    log.Println(<span class="string">"start"</span>)</span><br><span class="line">    g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>（1）如何打开一个文件并读取：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">"input.dat"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"An error occurred on opening the inputfile\n"</span> +</span><br><span class="line">      <span class="string">"Does the file exist?\n"</span> +</span><br><span class="line">      <span class="string">"Have you got acces to it?\n"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  iReader := bufio.NewReader(file)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    str, err := iReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="comment">// error or EOF</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"The input was: %s"</span>, str)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>（2）如何通过切片读写文件：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(f *file.File)</span></span> &#123;</span><br><span class="line">  <span class="keyword">const</span> NBUF = <span class="number">512</span></span><br><span class="line">  <span class="keyword">var</span> buf [NBUF]<span class="keyword">byte</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> nr, er := f.Read(buf[:]); <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> nr &lt; <span class="number">0</span>:</span><br><span class="line">      fmt.Fprintf(os.Stderr, <span class="string">"cat: error reading from %s: %s\n"</span>,</span><br><span class="line">        f.String(), er.String())</span><br><span class="line">      os.Exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">case</span> nr == <span class="number">0</span>: <span class="comment">// EOF</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> nr &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> nw, ew := file.Stdout.Write(buf[<span class="number">0</span>:nr]); nw != nr &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"cat: error writing from %s: %s\n"</span>,</span><br><span class="line">          f.String(), ew.String())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协程（goroutine）与通道（channel）"><a href="#协程（goroutine）与通道（channel）" class="headerlink" title="协程（goroutine）与通道（channel）"></a>协程（goroutine）与通道（channel）</h3><p>出于性能考虑的建议：</p>
<p>实践经验表明，如果你使用并行运算获得高于串行运算的效率：在协程内部已经完成的大部分工作，其开销比创建协程和协程间通信还高。</p>
<p>1 出于性能考虑建议使用带缓存的通道：</p>
<p>使用带缓存的通道可以很轻易成倍提高它的吞吐量，某些场景其性能可以提高至10倍甚至更多。通过调整通道的容量，甚至可以尝试着更进一步的优化其性能。</p>
<p>2 限制一个通道的数据数量并将它们封装成一个数组：</p>
<p>如果使用通道传递大量单独的数据，那么通道将变成性能瓶颈。然而，将数据块打包封装成数组，在接收端解压数据时，性能可以提高至10倍。</p>
<p>创建：<code>ch := make(chan type,buf)</code></p>
<p>（1）如何使用<code>for</code>或者<code>for-range</code>遍历一个通道：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    <span class="comment">// do something with v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）如何检测一个通道<code>ch</code>是否关闭：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//read channel until it closes or error-condition</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> input, open := &lt;-ch; !open &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%s"</span>, input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用（1）自动检测。  </p>
<p>（3）如何通过一个通道让主程序等待直到协程完成：  </p>
<p>（信号量模式）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// Allocate a channel.</span></span><br><span class="line"><span class="comment">// Start something in a goroutine; when it completes, signal on the channel.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">    ch &lt;- <span class="number">1</span> <span class="comment">// Send a signal; value does not matter.</span></span><br><span class="line">&#125;()</span><br><span class="line">doSomethingElseForAWhile()</span><br><span class="line">&lt;-ch <span class="comment">// Wait for goroutine to finish; discard sent value.</span></span><br></pre></td></tr></table></figure>

<p>如果希望程序一直阻塞，在匿名函数中省略 <code>ch &lt;- 1</code>即可。  </p>
<p>（4）通道的工厂模板：以下函数是一个通道工厂，启动一个匿名函数作为协程以生产通道：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）通道迭代器模板：  </p>
<p>（6）如何限制并发处理请求的数量：参考<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.11.md" target="_blank" rel="noopener">章节14.11</a> </p>
<p>（7）如何在多核CPU上实现并行计算：参考<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.13.md" target="_blank" rel="noopener">章节14.13</a>  </p>
<p>（8）如何终止一个协程：<code>runtime.Goexit()</code>  </p>
<p>（9）简单的超时模板：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">1e9</span>) <span class="comment">// one second  </span></span><br><span class="line">    timeout &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="comment">// a read from ch has occurred</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">    <span class="comment">// the read from ch has timed out</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（10）如何使用输入通道和输出通道代替锁：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(in, out <span class="keyword">chan</span> *Task)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（11）如何在同步调用运行时间过长时将之丢弃：参考<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.5.md" target="_blank" rel="noopener">章节14.5</a> 第二个变体  </p>
<p>（12）如何在通道中使用计时器和定时器：参考<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.5.md" target="_blank" rel="noopener">章节14.5</a>  </p>
<p>（13）典型的服务器后端模型：参考<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.4.md" target="_blank" rel="noopener">章节14.4</a>  </p>
<h3 id="网络和网页应用"><a href="#网络和网页应用" class="headerlink" title="网络和网页应用"></a>网络和网页应用</h3><p><strong>模板：</strong>  </p>
<p>制作、解析并使模板生效：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strTempl = template.Must(template.New(<span class="string">"TName"</span>).Parse(strTemplateHTML))</span><br></pre></td></tr></table></figure>

<p>在网页应用中使用HTML过滤器过滤HTML特殊字符：  </p>
<p><code>{ {html .} }</code> 或者通过一个字段 <code>FieldName { { .FieldName |html } }</code>  </p>
<p>使用缓存模板（参考<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/15.7.md" target="_blank" rel="noopener">章节15.7</a>）  </p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如何在程序出错时终止程序：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Program stopping with error %v"</span>, err)</span><br><span class="line">   os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"ERROR occurred: "</span> + err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="出于性能考虑的最佳实践和建议"><a href="#出于性能考虑的最佳实践和建议" class="headerlink" title="出于性能考虑的最佳实践和建议"></a>出于性能考虑的最佳实践和建议</h3><p>（1）尽可能的使用<code>:=</code>去初始化声明一个变量（在函数内部）；  </p>
<p>（2）尽可能的使用字符代替字符串；  </p>
<p>（3）尽可能的使用切片代替数组；  </p>
<p>（4）尽可能的使用数组和切片代替映射（详见参考文献15）；  </p>
<p>（5）如果只想获取切片中某项值，不需要值的索引，尽可能的使用<code>for range</code>去遍历切片，这比必须查询切片中的每个元素要快一些；  </p>
<p>（6）当数组元素是稀疏的（例如有很多<code>0</code>值或者空值<code>nil</code>），使用映射会降低内存消耗；  </p>
<p>（7）初始化映射时指定其容量；  </p>
<p>（8）当定义一个方法时，使用指针类型作为方法的接收者；  </p>
<p>（9）在代码中使用常量或者标志提取常量的值； </p>
<p>（10）尽可能在需要分配大量内存时使用缓存；  </p>
<p>（11）使用缓存模板（参考<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/15.7.md" target="_blank" rel="noopener">章节15.7</a>）。  </p>
<h2 id="方法的接收者对照表"><a href="#方法的接收者对照表" class="headerlink" title="方法的接收者对照表"></a>方法的接收者对照表</h2><p>方法集：定义了一组关联到给定类型的值或者指针的方法。  </p>
<h3 id="从传递的值的角度看方法集"><a href="#从传递的值的角度看方法集" class="headerlink" title="从传递的值的角度看方法集"></a>从传递的值的角度看方法集</h3><table>
<thead>
<tr>
<th align="center">传递的值</th>
<th align="center">方法声明的接收者</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td align="center">(t T)</td>
</tr>
<tr>
<td align="center">*T</td>
<td align="center">(t T) 和 (t *T)</td>
</tr>
</tbody></table>
<ul>
<li>T 类型的值的方法集只包含了值接收者声明的方法</li>
<li>而指向 T 类型的指针的方法集既包含值接收者声明的方法，也包含指针接收者声明的方法</li>
</ul>
<h3 id="从接收者类型的角度来看方法集"><a href="#从接收者类型的角度来看方法集" class="headerlink" title="从接收者类型的角度来看方法集"></a>从接收者类型的角度来看方法集</h3><table>
<thead>
<tr>
<th align="center">方法声明的接收者</th>
<th align="center">传递的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">(t T)</td>
<td align="center">T 和 *T</td>
</tr>
<tr>
<td align="center">(t *T)</td>
<td align="center">*T</td>
</tr>
</tbody></table>
<ul>
<li>如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口</li>
<li>如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口</li>
</ul>
<hr>
<p><em><code>to be continued...</code></em>  </p>
]]></content>
      <categories>
        <category>「语言」- Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT(v7.7.2) 博客配置备忘</title>
    <url>/2020/03/04/Hexo-NexT-Config-7-7-2/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>好好的为何要折腾自己？</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="配置历史"><a href="#配置历史" class="headerlink" title="配置历史"></a>配置历史</h1><ul>
<li><a href="../../../../2019/03/27/Hexo-NexT-Config/">Hexo + NexT(v7.1.0) 博客配置备忘</a></li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>建站驱动：<code>Hexo</code> v4.2.0  </p>
<p>主题： <code>NexT</code>.<code>Pisces</code> v7.7.2  </p>
<p>站点配置文件：<code>/_config.yml</code>  </p>
<p>主题配置文件：<code>/themes/next7.7.2/_config.yml</code>  </p>
<hr>
<h1 id="与之前配置的方法有变动的"><a href="#与之前配置的方法有变动的" class="headerlink" title="与之前配置的方法有变动的"></a>与之前配置的方法有变动的</h1><h2 id="不显示文章信息中“评论数”三个字"><a href="#不显示文章信息中“评论数”三个字" class="headerlink" title="不显示文章信息中“评论数”三个字"></a>不显示文章信息中“评论数”三个字</h2><p>现在版本显示的是<code>Valine：</code>，改了下<code>/themes/next/layout/_macro/post.swig</code>也暂时没找到删去的办法，先放着罢。</p>
<h2 id="增加页脚显示网站运营时间功能"><a href="#增加页脚显示网站运营时间功能" class="headerlink" title="增加页脚显示网站运营时间功能"></a>增加页脚显示网站运营时间功能</h2><p>现在不需要去在<code>/themes/next/layout/_parrials/footer.swig</code>末尾新增内容了，现在NexT支持自定义风格。  </p>
<p>在<code>主题配置文件</code>中，开启自定义功能：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># Define custom file paths.</span><br><span class="line"># Create your custom files in site directory <span class="string">`source/_data`</span> and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.swig</span><br><span class="line">  #header: source/_data/header.swig</span><br><span class="line">  #sidebar: source/_data/sidebar.swig</span><br><span class="line">  #postMeta: source/_data/post-meta.swig</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.swig</span><br><span class="line">  footer: source/_data/footer.swig</span><br><span class="line">  #bodyEnd: source/_data/body-end.swig</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>然后去网站根目录的<code>/source/</code>下新建文件夹<code>_data</code>和文件<code>footer.swig</code>，在里面加入自定义的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-clock-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"sitetime"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">siteTime</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.setTimeout(<span class="string">"siteTime()"</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> seconds = <span class="number">1000</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> minutes = seconds * <span class="number">60</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> hours = minutes * <span class="number">60</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> days = hours * <span class="number">24</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> years = days * <span class="number">365</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> todayYear = today.getFullYear();</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> todayMonth = today.getMonth()+<span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> todayDate = today.getDate();</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> todayHour = today.getHours();</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> todayMinute = today.getMinutes();</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> todaySecond = today.getSeconds();</span></span><br><span class="line">    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span><br><span class="line">    year - 作为date对象的年份，为4位年份值</span><br><span class="line">    month - 0-11之间的整数，做为date对象的月份</span><br><span class="line">    day - 1-31之间的整数，做为date对象的天数</span><br><span class="line">    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span><br><span class="line">    minutes - 0-59之间的整数，做为date对象的分钟数</span><br><span class="line">    seconds - 0-59之间的整数，做为date对象的秒数</span><br><span class="line">    microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t1 = <span class="built_in">Date</span>.UTC(<span class="number">2019</span>,<span class="number">03</span>,<span class="number">07</span>,<span class="number">10</span>,<span class="number">00</span>,<span class="number">00</span>); <span class="comment">//建站时间</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> t2 = <span class="built_in">Date</span>.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> diff = t2-t1;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> diffYears = <span class="built_in">Math</span>.floor(diff/years);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> diffDays = <span class="built_in">Math</span>.floor((diff/days)-diffYears*<span class="number">365</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> diffHours = <span class="built_in">Math</span>.floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days)/hours);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> diffMinutes = <span class="built_in">Math</span>.floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours)/minutes);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> diffSeconds = <span class="built_in">Math</span>.floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"sitetime"</span>).innerHTML=<span class="string">" 已运行"</span>+diffYears+<span class="string">" 年 "</span>+diffDays+<span class="string">" 天 "</span>+diffHours+<span class="string">" 小时 "</span>+diffMinutes+<span class="string">" 分钟 "</span>+diffSeconds+<span class="string">" 秒 ~喵~"</span>;</span></span><br><span class="line"><span class="actionscript">  &#125;<span class="comment">/*建站不到1年，不想显示“0”年可以把year部分注释掉*/</span></span></span><br><span class="line">  siteTime();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="增加文章边框阴影"><a href="#增加文章边框阴影" class="headerlink" title="增加文章边框阴影"></a>增加文章边框阴影</h2><p>与上面类似，在<code>站点配置文件中</code>开启:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>

<p>然后在根目录下建立<code>/source/_data/styles.styl</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">// 主页文章添加阴影效果</span><br><span class="line"><span class="selector-class">.post-block</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">24px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">35px</span>;</span><br><span class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">24px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改新建文章模板"><a href="#修改新建文章模板" class="headerlink" title="修改新建文章模板"></a>修改新建文章模板</h2><p><code>/scaffolds/post.md</code>中修改内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&#123;&#123;</span> <span class="string">title</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">&#123;&#123;</span> <span class="string">date</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[tag1,</span> <span class="string">tag2]</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">分类名</span></span><br><span class="line"><span class="attr">permalink:</span>      <span class="string">//</span> <span class="string">文章自定义链接</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;center&gt;</span> <span class="string">&lt;font</span> <span class="string">color="#bababa"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">***首页展示的字***</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;/font&gt;&lt;/center&gt;</span></span><br><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>（写markdown的时候多加几个回车能避免很多问题……）</p>
<h2 id="修改文章末尾-tags-的符号（-改成图标）"><a href="#修改文章末尾-tags-的符号（-改成图标）" class="headerlink" title="修改文章末尾 tags 的符号（#改成图标）"></a>修改文章末尾 tags 的符号（<code>#</code>改成图标）</h2><p>不用去改<code>/themes/next/layout/_macro/post.swig</code>了，新版NexT意见在<code>主题配置文件</code>中集成了这个配置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># Use icon instead of the symbol # to indicate the tag at the bottom of the post</span><br><span class="line">tag_icon: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="调整网站字体大小"><a href="#调整网站字体大小" class="headerlink" title="调整网站字体大小"></a>调整网站字体大小</h2><p>新版的字体偏大，可以去<code>站点配置文件</code>中<code>enable</code>字体功能：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  # Uri of fonts host, e.g. https:<span class="comment">//fonts.googleapis.com (Default).</span></span><br><span class="line">  host:</span><br><span class="line"></span><br><span class="line">  # Font options:</span><br><span class="line">  # <span class="string">`external: true`</span> will load this font family from <span class="string">`host`</span> above.</span><br><span class="line">  # <span class="string">`family: Times New Roman`</span>. Without any quotes.</span><br><span class="line">  # <span class="string">`size: x.x`</span>. Use <span class="string">`em`</span> as unit. Default: <span class="number">1</span> (<span class="number">16</span>px)</span><br><span class="line"></span><br><span class="line">  # Global font settings used <span class="keyword">for</span> all elements inside &lt;body&gt;.</span><br><span class="line">  global:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family: Lato</span><br><span class="line">    size: <span class="number">0.875</span></span><br><span class="line"></span><br><span class="line">  # Font settings <span class="keyword">for</span> site title (.site-title).</span><br><span class="line">  title:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings <span class="keyword">for</span> headlines (&lt;h1&gt; to &lt;h6&gt;).</span><br><span class="line">  headings:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line"></span><br><span class="line">  # Font settings <span class="keyword">for</span> posts (.post-body).</span><br><span class="line">  posts:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family:</span><br><span class="line"></span><br><span class="line">  # Font settings <span class="keyword">for</span> &lt;code&gt; and code blocks.</span><br><span class="line">  codes:</span><br><span class="line">    external: <span class="literal">true</span></span><br><span class="line">    family:</span><br></pre></td></tr></table></figure>

<h2 id="返回顶部按钮放到右侧"><a href="#返回顶部按钮放到右侧" class="headerlink" title="返回顶部按钮放到右侧"></a>返回顶部按钮放到右侧</h2><p>暂时没在新版的<code>主题配置文件</code>中发现设置，目前的处理办法是在<code>\themes\next-7.7.2\source\css\_common\components\back-to-top.styl</code>中，将：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.back-to-top &#123;</span><br><span class="line">...</span><br><span class="line">  left: $b2t-position-right;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改为：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.back-to-top &#123;</span><br><span class="line">...</span><br><span class="line">  right: $b2t-position-right;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>站点地图：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br><span class="line">$ npm <span class="keyword">install</span> hexo-generator-baidu-sitemap <span class="comment">--save     //可选</span></span><br></pre></td></tr></table></figure>

<p>站内搜索（Local Search）：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-generator-<span class="keyword">search</span></span><br><span class="line">$ npm <span class="keyword">install</span> hexo-generator-searchdb</span><br></pre></td></tr></table></figure>


<p>部署工具：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>字数统计、文章阅读时间（如果需要，现在没装）：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-symbols-<span class="keyword">count</span>-<span class="built_in">time</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>「备忘」- Hexo配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + NexT(v7.0.1) 博客配置备忘</title>
    <url>/2019/03/27/Hexo-NexT-Config/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>个人 Blog 配置备忘</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="配置方案更新"><a href="#配置方案更新" class="headerlink" title="配置方案更新"></a>配置方案更新</h1><ul>
<li><a href="../../../../2020/03/04/Hexo-NexT-Config-7-7-2/">Hexo + NexT(v7.7.2) 博客配置备忘</a></li>
</ul>
<hr>
<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><p>建站驱动：<code>Hexo</code> v3.8.0  </p>
<p>主题： <code>NexT</code>.<code>Pisces</code> v7.0.1  </p>
<p>站点配置文件：<code>/_config.yml</code>  </p>
<p>主题配置文件：<code>/themes/next/_config.yml</code>  </p>
<h1 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h1><h2 id="选用主题"><a href="#选用主题" class="headerlink" title="选用主题"></a>选用主题</h2><p><code>站点配置文件</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span>     <span class="comment"># 这项改成这个</span></span><br></pre></td></tr></table></figure>

<h2 id="文章按更新时间排序"><a href="#文章按更新时间排序" class="headerlink" title="文章按更新时间排序"></a>文章按更新时间排序</h2><p>默认是按文章创建时间排序。要改成更新时间，去<code>站点配置文件</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-updated</span>    <span class="comment"># 这项改成这个</span></span><br></pre></td></tr></table></figure>

<h2 id="选用主题皮肤"><a href="#选用主题皮肤" class="headerlink" title="选用主题皮肤"></a>选用主题皮肤</h2><p><code>主题配置文件</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span>      <span class="comment"># 要哪个就取消注释哪个</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>


<h2 id="隐藏页脚-Hexo-和-NexT-的声明和版本"><a href="#隐藏页脚-Hexo-和-NexT-的声明和版本" class="headerlink" title="隐藏页脚 Hexo 和 NexT 的声明和版本"></a>隐藏页脚 Hexo 和 NexT 的声明和版本</h2><p><code>主题配置文件</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">copyright:</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------</span></span><br><span class="line"><span class="attr">powered:</span></span><br><span class="line">  <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>                        <span class="comment"># 这项改成false</span></span><br><span class="line">  <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">  <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>                        <span class="comment"># 这项改成false</span></span><br><span class="line">  <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">  <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># -------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<h2 id="sidebar-放到右侧"><a href="#sidebar-放到右侧" class="headerlink" title="sidebar 放到右侧"></a>sidebar 放到右侧</h2><p><code>主题配置文件</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available values: left | right (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="comment">#position: left</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span></span><br></pre></td></tr></table></figure>

<h2 id="增加返回顶部按钮、样式"><a href="#增加返回顶部按钮、样式" class="headerlink" title="增加返回顶部按钮、样式"></a>增加返回顶部按钮、样式</h2><p><code>主题配置文件</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Back to top in sidebar.</span></span><br><span class="line"><span class="attr">b2t:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line"><span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line"><span class="attr">onmobile:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Click any blank part of the page to close sidebar (only for Muse | Mist).</span></span><br><span class="line"><span class="attr">dimmer:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="配置侧边栏菜单内容"><a href="#配置侧边栏菜单内容" class="headerlink" title="配置侧边栏菜单内容"></a>配置侧边栏菜单内容</h2><p><code>主题配置文件</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p>目前启用主页、标签、分类、归档。<code>||</code>后面是<code>FontAwesome</code>样式的 icon 名字。</p>
<h2 id="增加站内搜索"><a href="#增加站内搜索" class="headerlink" title="增加站内搜索"></a>增加站内搜索</h2><p>在<code>hexo init</code>目录下安装插件：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">search</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p><code>站点配置文件</code>中末尾增加内容：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rtk: local search setting</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p><code>主题配置文件</code>中启用本地搜索：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>      <span class="comment"># 这项改成true来启用</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="主页侧边栏增加社交信息"><a href="#主页侧边栏增加社交信息" class="headerlink" title="主页侧边栏增加社交信息"></a>主页侧边栏增加社交信息</h2><p><code>主题配置文件</code>：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/xxx</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://instagram.com/xxx</span> <span class="string">||</span> <span class="string">instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">true</span>    <span class="comment"># 只显示图标</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>同样的，<code>||</code>后面是<code>FontAwesome</code>样式的 icon 名字。</p>
<h2 id="增加-Valine-评论功能"><a href="#增加-Valine-评论功能" class="headerlink" title="增加 Valine 评论功能"></a>增加 Valine 评论功能</h2><p>去 <a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a> 注册并创建一个免费应用，获得应用的<code>App ID</code>、<code>App Key</code>。在 <code>LeanCloud - 设置 - 安全中心 - Web 安全域名</code>中填上自己博客的地址。  </p>
<p>然后去<code>主题配置文件</code>内搜<code>Valine</code>，<code>enable</code>改成<code>true</code>，填上<code>App ID</code>和<code>App Key</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># More info available at https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">xxx</span> <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">xxx</span> <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier, See: https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">ヾﾉ≧∀≦)o</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># if false, comment count will only be displayed in post page, not in home page</span></span><br></pre></td></tr></table></figure>

<p>为了加快打开速度，去<code>/theme/next/layout/_third-party/comments/valine.swig</code>把：<br><code>//unpkg.com/valine/dist/Valine.min.js</code> 改成：<br><code>//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js</code>  </p>
<p><a href="https://www.jianshu.com/p/728a9594bb6c" target="_blank" rel="noopener">Valine 详细配置过程还可参见这里</a></p>
<h2 id="不显示文章信息中“评论数”三个字"><a href="#不显示文章信息中“评论数”三个字" class="headerlink" title="不显示文章信息中“评论数”三个字"></a>不显示文章信息中“评论数”三个字</h2><p>在<code>/themes/next/layout/_macro/post.swig</code>里，用注释符号把下面的第三行注释掉：  </p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">elif</span></span> (is_post() or theme.valine.comment_count) and theme.valine.enable and theme.valine.appid and theme.valine.appkey %&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; comments() &#125;&#125;</span></span><br><span class="line"><span class="xml">         </span><span class="comment">&#123;#&lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.comments_count') + __('symbol.colon') &#125;&#125;&lt;/span&gt;#&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(post.path) &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">#comments"</span> <span class="attr">itemprop</span>=<span class="string">"discussionUrl"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-comments-count valine-comment-count"</span> <span class="attr">data-xid</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(post.path) &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">itemprop</span>=<span class="string">"commentCount"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="增加页脚显示网站运营时间功能"><a href="#增加页脚显示网站运营时间功能" class="headerlink" title="增加页脚显示网站运营时间功能"></a>增加页脚显示网站运营时间功能</h2><p>在<code>/themes/next/layout/_parrials/footer.swig</code>末尾增加内容：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-item-icon"</span>&gt;</span><br><span class="line">    &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-clock-o"</span>&gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>span&gt;</span><br><span class="line">&lt;span id=<span class="string">"sitetime"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;script language="javascript"&gt;</span></span><br><span class="line"><span class="regexp">  function siteTime()&#123;</span></span><br><span class="line"><span class="regexp">    window.setTimeout("siteTime()", 1000);</span></span><br><span class="line"><span class="regexp">    var seconds = 1000;</span></span><br><span class="line"><span class="regexp">    var minutes = seconds * 60;</span></span><br><span class="line"><span class="regexp">    var hours = minutes * 60;</span></span><br><span class="line"><span class="regexp">    var days = hours * 24;</span></span><br><span class="line"><span class="regexp">    var years = days * 365;</span></span><br><span class="line"><span class="regexp">    var today = new Date();</span></span><br><span class="line"><span class="regexp">    var todayYear = today.getFullYear();</span></span><br><span class="line"><span class="regexp">    var todayMonth = today.getMonth()+1;</span></span><br><span class="line"><span class="regexp">    var todayDate = today.getDate();</span></span><br><span class="line"><span class="regexp">    var todayHour = today.getHours();</span></span><br><span class="line"><span class="regexp">    var todayMinute = today.getMinutes();</span></span><br><span class="line"><span class="regexp">    var todaySecond = today.getSeconds();</span></span><br><span class="line"><span class="regexp">    /</span>* <span class="built_in">Date</span>.UTC() -- 返回date对象距世界标准时间(UTC)<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日午夜之间的毫秒数(时间戳)</span><br><span class="line">    year - 作为date对象的年份，为<span class="number">4</span>位年份值</span><br><span class="line">    month - <span class="number">0</span><span class="number">-11</span>之间的整数，做为date对象的月份</span><br><span class="line">    day - <span class="number">1</span><span class="number">-31</span>之间的整数，做为date对象的天数</span><br><span class="line">    hours - <span class="number">0</span>(午夜<span class="number">24</span>点)<span class="number">-23</span>之间的整数，做为date对象的小时数</span><br><span class="line">    minutes - <span class="number">0</span><span class="number">-59</span>之间的整数，做为date对象的分钟数</span><br><span class="line">    seconds - <span class="number">0</span><span class="number">-59</span>之间的整数，做为date对象的秒数</span><br><span class="line">    microseconds - <span class="number">0</span><span class="number">-999</span>之间的整数，做为date对象的毫秒数 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    var t1 = Date.UTC(2019,03,07,10,00,00); /</span><span class="regexp">/建站时间</span></span><br><span class="line"><span class="regexp">    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);</span></span><br><span class="line"><span class="regexp">    var diff = t2-t1;</span></span><br><span class="line"><span class="regexp">    var diffYears = Math.floor(diff/y</span>ears);</span><br><span class="line">    <span class="keyword">var</span> diffDays = <span class="built_in">Math</span>.floor((diff/days)-diffYears*<span class="number">365</span>);</span><br><span class="line">    <span class="keyword">var</span> diffHours = <span class="built_in">Math</span>.floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days)/hours);</span><br><span class="line">    <span class="keyword">var</span> diffMinutes = <span class="built_in">Math</span>.floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours)/minutes);</span><br><span class="line">    <span class="keyword">var</span> diffSeconds = <span class="built_in">Math</span>.floor((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"sitetime"</span>).innerHTML=<span class="string">" 已运行"</span>+<span class="comment">/*diffYears+" 年 "+*/</span>diffDays+<span class="string">" 天 "</span>+diffHours+<span class="string">" 小时 "</span>+diffMinutes+<span class="string">" 分钟 "</span>+diffSeconds+<span class="string">" 秒 ~喵~"</span>;</span><br><span class="line">  &#125;<span class="comment">/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/</span></span><br><span class="line">  siteTime();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="增加页脚不蒜子的站点访问人次统计"><a href="#增加页脚不蒜子的站点访问人次统计" class="headerlink" title="增加页脚不蒜子的站点访问人次统计"></a>增加页脚不蒜子的站点访问人次统计</h2><p>（接上小节代码）在<code>/themes/next/layout/_parrials/footer.swig</code>末尾增加内容：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="regexp">/br&gt;</span></span><br><span class="line"><span class="regexp">&lt;!--这一段是不蒜子的访问量统计代码--&gt;</span></span><br><span class="line"><span class="regexp">&lt;script async src="/</span><span class="regexp">/busuanzi.ibruce.info/</span>busuanzi/<span class="number">2.3</span>/busuanzi.pure.mini.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;span class="</span>post-meta-item-icon<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;i class="</span>fa fa-paw<span class="string">"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="string">&lt;/span&gt;   // 猫爪图标</span></span><br><span class="line"><span class="string">&lt;span id="</span>busuanzi_container_site_pv<span class="string">"&gt;本站总访问量&lt;span id="</span>busuanzi_value_site_pv<span class="string">"&gt;&lt;/span&gt;次 &amp;nbsp;   &lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;span id="</span>busuanzi_container_site_uv<span class="string">"&gt;访客数&lt;span id="</span>busuanzi_value_site_uv<span class="string">"&gt;&lt;/span&gt;人次&lt;/span&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="增加文章阅读次数显示"><a href="#增加文章阅读次数显示" class="headerlink" title="增加文章阅读次数显示"></a>增加文章阅读次数显示</h2><p>在<code>/themes/next/layout/_macro/post.swig</code>的第一行中，增加一个<code>is_pv</code>字段：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>/themes/next/layout/_macro/post.swig</code>中增加一段代码：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> is_pv %&#125;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span class="post-meta-item-icon"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;i class="fa fa-file-o"&gt;&lt;/i</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span id="busuanzi_value_page_pv"&gt;&lt;/</span>span&gt;次阅读</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码塞的位置是：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span class="post-meta-item-icon"</span></span><br><span class="line"><span class="regexp">  &#123;% if not theme.post_meta.item_text %&#125; title="&#123;&#123; __('post.views') &#125;&#125;" &#123;% endif %&#125;&gt;</span></span><br><span class="line"><span class="regexp">  &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.post_views_icon &#125;&#125;"&gt;&lt;/i</span>&gt;</span><br><span class="line">  &#123;% <span class="keyword">if</span> theme.post_meta.item_text %&#125; &#123;&#123; __(<span class="string">'post.views'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &#123;% endif %&#125;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"busuanzi-value"</span> id=<span class="string">"busuanzi_value_page_pv"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> is_pv %&#125;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span class="post-meta-item-icon"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;i class="fa fa-file-o"&gt;&lt;/i</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span id="busuanzi_value_page_pv"&gt;&lt;/</span>span&gt;次阅读</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> config.symbols_count_time.symbols or config.symbols_count_time.time %&#125;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-symbolscount"</span>&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not theme.symbols_count_time.separated_meta %&#125;</span><br><span class="line">      &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后去<code>themes/next/layout/post.swig</code>（文章模板），给<code>render</code>方法放入参数<code>false</code>和<code>true</code>（分别对应<code>is_index</code>和<code>is_pv</code>：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  &lt;div id=<span class="string">"posts"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"posts-expand"</span>&gt;</span><br><span class="line">    &#123;&#123; post_template.render(page, <span class="literal">false</span>, <span class="literal">true</span>) &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#123;% endblock %&#125;</span></span><br></pre></td></tr></table></figure>

<p>再去<code>/themes/next/layout/index.swig</code>（首页模板），给<code>render</code>传入参数<code>true</code>和<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;section id=<span class="string">"posts"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"posts-expand"</span>&gt;</span><br><span class="line">    &#123;% <span class="keyword">for</span> post <span class="keyword">in</span> page.posts %&#125;</span><br><span class="line">      &#123;&#123; post_template.render(post, <span class="literal">true</span>,<span class="literal">false</span>) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  &lt;<span class="regexp">/section&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="增加文章边框阴影、取消文章间分割线"><a href="#增加文章边框阴影、取消文章间分割线" class="headerlink" title="增加文章边框阴影、取消文章间分割线"></a>增加文章边框阴影、取消文章间分割线</h2><p>在<code>\themes\next\source\css\_custom\custom.styl</code>文件中写入：  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">0px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">24px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">35px</span>;</span><br><span class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">24px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加了文章边框后，文章间的分割线就没必要存在了，所以干脆取消。  </p>
<p>在<code>/themes/next/source/css/_common/components/post/post-eof.styl</code>中把分割线高度改成<code>0px</code>,并把<code>margin</code>一行注释掉：  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> &#123;</span><br><span class="line">  .post-eof &#123;</span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">block</span>;</span><br><span class="line">    // margin: $post-eof-margin-top auto $post-eof-margin-bottom;</span><br><span class="line">    <span class="selector-tag">width</span>: 0%;</span><br><span class="line">    <span class="selector-tag">height</span>: 0<span class="selector-tag">px</span>;</span><br><span class="line">    background: $grey-light;</span><br><span class="line">    <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="首页展示文章开头，增加阅读全文按钮"><a href="#首页展示文章开头，增加阅读全文按钮" class="headerlink" title="首页展示文章开头，增加阅读全文按钮"></a>首页展示文章开头，增加<code>阅读全文</code>按钮</h2><p><code>主题配置文件</code>中：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>          <span class="comment"># 改成true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># If true, the read more button would be displayed in excerpt section.</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span>     <span class="comment"># 改成true</span></span><br></pre></td></tr></table></figure>

<h2 id="修改新建文章模板"><a href="#修改新建文章模板" class="headerlink" title="修改新建文章模板"></a>修改新建文章模板</h2><p><code>/scaffolds/post.md</code>中修改内容：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:           <span class="comment">// 文章标签</span></span><br><span class="line">categories:     <span class="comment">// 文章分类</span></span><br><span class="line">permalink:      <span class="comment">// 文章自定义链接</span></span><br><span class="line">---</span><br><span class="line">&lt;center&gt; &lt;font color="#bababa"&gt;***首页展示的字***&lt;/font&gt;&lt;br/&gt; &lt;/center&gt;</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="修改文章末尾-tags-的符号（-改成图标）"><a href="#修改文章末尾-tags-的符号（-改成图标）" class="headerlink" title="修改文章末尾 tags 的符号（#改成图标）"></a>修改文章末尾 tags 的符号（<code>#</code>改成图标）</h2><p>在<code>/themes/next/layout/_macro/post.swig中</code>，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。  </p>
<h2 id="SEO-相关"><a href="#SEO-相关" class="headerlink" title="SEO 相关"></a>SEO 相关</h2><h3 id="主题自带的-SEO-选项"><a href="#主题自带的-SEO-选项" class="headerlink" title="主题自带的 SEO 选项"></a>主题自带的 SEO 选项</h3><p>在<code>主题配置文件中</code>修改项：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seo:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p>安装：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-baidu-sitemap <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>在<code>站点配置文件</code>末尾加入内容：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rtk: sitemap setting</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>

<p>在<code>/source</code>中建一个<code>robots.txt</code>：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">User-<span class="string">agent:</span> *</span><br><span class="line"><span class="string">Allow:</span> /</span><br><span class="line"><span class="string">Allow:</span> <span class="regexp">/archives/</span></span><br><span class="line"><span class="string">Allow:</span> <span class="regexp">/categories/</span></span><br><span class="line"><span class="string">Allow:</span> <span class="regexp">/tags/</span> </span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/vendors/</span></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/js/</span></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/css/</span></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/fonts/</span></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/vendors/</span></span><br><span class="line"><span class="string">Disallow:</span> <span class="regexp">/fancybox/</span></span><br><span class="line"></span><br><span class="line"><span class="string">sitemap:</span> <span class="string">https:</span><span class="comment">//reitake.github.io/sitemap.xml</span></span><br></pre></td></tr></table></figure>

<h2 id="增加一个导航页面"><a href="#增加一个导航页面" class="headerlink" title="增加一个导航页面"></a>增加一个导航页面</h2><p>以目前的<a href="../../../../tools/">tools</a>页面为例:  </p>
<p>先在<code>主题配置文件</code>中的<code>menu</code>项增加需要的导航项：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  tools: /tools/ || gears    <span class="comment">// 图标icon去查Font-Awesome</span></span><br></pre></td></tr></table></figure>

<p>去<code>/themes/next/languages/zh-CN.yml</code>汉化：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  tools: 工具</span><br></pre></td></tr></table></figure>

<p>再新建一个page：    </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexo <span class="built_in">new</span> page tools</span><br></pre></td></tr></table></figure>

<p>这时，会在<code>source</code>文件夹内新建一个<code>tools</code>文件夹，其中包含了1个空的<code>index</code>文件夹（资源文件夹，可删除）和<code>index.md</code>。  </p>
<p><code>index.md</code>需要编辑front-matter：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">title: tools</span><br><span class="line">date: <span class="number">2019</span><span class="number">-12</span><span class="number">-24</span> <span class="number">00</span>:<span class="number">30</span>:<span class="number">28</span></span><br><span class="line"><span class="keyword">type</span>: <span class="string">"page"</span>   <span class="comment">// 这里的type种类见 /themes/next/layout，目前感觉page和post没区别</span></span><br></pre></td></tr></table></figure>

<p>然后像编辑post一样写内容，链接可采用相对路径形式，如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">- [Ingress任务图标分割工具 - Mission Banner Cropper](ingressmissionset/)</span><br><span class="line">- [在线给头像带上圣诞帽](christmashat/)</span><br></pre></td></tr></table></figure>

<p>最后，如果<code>tools</code>文件夹内的文件，不需要hexo渲染成html的，需要在<code>站点配置文件</code>的<code>skip_render</code>一项中增加不需要渲染的项目：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">  - <span class="string">'tools/christmashat/**'</span></span><br><span class="line">  - <span class="string">'tools/ingressmissionset/**'</span></span><br></pre></td></tr></table></figure>


<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><h2 id="文章边框"><a href="#文章边框" class="headerlink" title="文章边框"></a>文章边框</h2><p>加了文章边框后，首页看起来是不会干巴巴的了，但是在竖屏手机上看，可展示文章区域就窄了，体验不佳。（所以需要pad？</p>
<h2 id="百度抓取"><a href="#百度抓取" class="headerlink" title="百度抓取"></a>百度抓取</h2><p>目前 github 屏蔽了百度的抓取，所以就先没做<code>baidusitemap</code>和<code>百度站长</code>内容，以后不屏蔽了再说吧。</p>
<h1 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h1><h2 id="fontawesome-icon-显示不出来"><a href="#fontawesome-icon-显示不出来" class="headerlink" title="fontawesome icon 显示不出来"></a><code>fontawesome</code> icon 显示不出来</h2><p><code>主题配置文件中</code>，把这一项按 example 填上：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Internal version: 4.6.2</span></span><br><span class="line"><span class="comment"># See: https://fontawesome.com</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment"># fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css</span></span><br><span class="line"><span class="comment"># fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure>

<p>给了两个 example，试着 ping 了下，第一个 8 ms，第二个 280 ms，选用了第一个。  </p>
<p>ps. 看了下其他人的 NexT v5.x 的配置文件，这一项默认是空着的，但能显示出 icon，现在用的 v7.0.1 也是默认空着，但我这只有填上才能显示出来，不知道是不是八阿哥。  </p>
<h2 id="npm-install没反应"><a href="#npm-install没反应" class="headerlink" title="npm install没反应"></a><code>npm install</code>没反应</h2><p>把镜像网站替换成淘宝的。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ npm get registry  <span class="comment">//显示当前的镜像网站</span></span><br><span class="line">$ npm config set registry http:<span class="comment">//registry.npm.taobao.org    //更改镜像网站</span></span><br></pre></td></tr></table></figure>

<h2 id="hexo-d部署失败"><a href="#hexo-d部署失败" class="headerlink" title="hexo d部署失败"></a><code>hexo d</code>部署失败</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span><br><span class="line">(node:<span class="number">3908</span>) Warning: Accessing non-existent property <span class="string">'lineno'</span> of module exports inside circular dependency</span><br><span class="line">(Use <span class="string">`node --trace-warnings ...`</span> to show where the warning was created)</span><br><span class="line">(node:<span class="number">3908</span>) Warning: Accessing non-existent property <span class="string">'column'</span> of module exports inside circular dependency</span><br><span class="line">(node:<span class="number">3908</span>) Warning: Accessing non-existent property <span class="string">'filename'</span> of module exports inside circular dependency</span><br><span class="line">(node:<span class="number">3908</span>) Warning: Accessing non-existent property <span class="string">'lineno'</span> of module exports inside circular dependency</span><br><span class="line">(node:<span class="number">3908</span>) Warning: Accessing non-existent property <span class="string">'column'</span> of module exports inside circular dependency</span><br><span class="line">(node:<span class="number">3908</span>) Warning: Accessing non-existent property <span class="string">'filename'</span> of module exports inside circular dependency</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in <span class="number">94</span> ms</span><br><span class="line">INFO  <span class="number">0</span> files generated in <span class="number">22</span> ms</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">FATAL Something<span class="string">'s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span></span><br><span class="line"><span class="string">TypeError [ERR_INVALID_ARG_TYPE]: The "mode" argument must be integer. Received an instance of Object</span></span><br><span class="line"><span class="string">    at copyFile (fs.js:1890:10)</span></span><br></pre></td></tr></table></figure>

<p>原因：<code>node.js</code>版本是<code>v14.15.1</code>的，过高，要降级。  </p>
<p>Windows系统的话，可以卸载<code>node.js</code>，然后去<a href="https://nodejs.org/zh-cn/download/releases/" target="_blank" rel="noopener">下载历史版本的node.js</a>,比如<code>v12.14</code>。  </p>
]]></content>
      <categories>
        <category>「备忘」- Hexo配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>升级Hexo+NexT版本</title>
    <url>/2020/03/04/Hexo-NexT-update/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>为什么要手痒升级呢？</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="Update-Log"><a href="#Update-Log" class="headerlink" title="Update Log"></a>Update Log</h1><ul>
<li>升级时间：2020年3月<ul>
<li><code>Hexo</code>版本：v3.8.0 → v4.2.0</li>
<li><code>NexT</code>版本：v7.0.1 → v7.7.2</li>
</ul>
</li>
</ul>
<hr>
<h1 id="升级操作"><a href="#升级操作" class="headerlink" title="升级操作"></a>升级操作</h1><h2 id="升级思路"><a href="#升级思路" class="headerlink" title="升级思路"></a>升级思路</h2><p>因为目前对于本Blog的管理是：网页托管于<code>github</code>仓库，部署在<code>master</code>分支，Hexo和NexT的网站后台操作内容放在同一个仓库的<code>Hexo.source</code>分支。</p>
<p>计划先在本地升级Hexo和NexT，做好source搬迁、config配置等工作；然后在仓库中新建一个空的分支，把本地的后台文件复制进去，然后提交这个分支，今后维护新的后台分支就可以了。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="本地升级Hexo"><a href="#本地升级Hexo" class="headerlink" title="本地升级Hexo"></a>本地升级Hexo</h3><p>Hexo版本升级可以通过npm实现，相关命令如下：  </p>
<p>先全局升级<code>hexo-cli</code>：-g表示全局升级。<code>hexo</code>本身是一个静态博客生成工具，具备编译Markdown、拼接主题模板、生成 HTML、上传 Git 等基本功能。<code>hexo-cli</code>能够将这些功能封装为命令，提供给用户通过<code>hexo server / hexo deploy</code>等命令调用的模块。<code>CLI = Command Line Interface</code>命令行界面。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br></pre></td></tr></table></figure>

<h3 id="创建空分支"><a href="#创建空分支" class="headerlink" title="创建空分支"></a>创建空分支</h3><p>现在Github上创建分支是基于其他分支的，没法直接创建空的。</p>
<p>需要在创建的分支后，  </p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git rm -rf .</span><br></pre></td></tr></table></figure>

<p>不要漏了<code>.</code></p>
<p>然后考进来，commit。</p>
<h3 id="更新NexT"><a href="#更新NexT" class="headerlink" title="更新NexT"></a>更新NexT</h3><p>去<a href="https://github.com/theme-next/hexo-theme-next/releases" target="_blank" rel="noopener">Github-NexT</a>下载个新版，然后解压到<code>/theme/</code>下。</p>
<p>剩下的就慢慢调配置吧……</p>
]]></content>
      <categories>
        <category>「备忘」- Hexo配置</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>日本語 Learn Notes</title>
    <url>/2019/10/13/Japanese-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Nihongo</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="字"><a href="#字" class="headerlink" title="字"></a>字</h1><ul>
<li><code>平假名</code>：简化的汉字，类似草书</li>
<li><code>片假名</code>：汉字的一部分，类似楷体，用于外来语</li>
<li>k t p 行有送气/不送气的区别</li>
</ul>
<h2 id="清音（五十音）"><a href="#清音（五十音）" class="headerlink" title="清音（五十音）"></a>清音（五十音）</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">あ段</th>
<th align="center">い段</th>
<th align="center">う段</th>
<th align="center">え段</th>
<th align="center">お段</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><b>あ行</b></td>
<td align="center">あ<br>ア<br>a</td>
<td align="center">い<br>イ<br>i</td>
<td align="center">う<br>ウ<br>u</td>
<td align="center">え<br>エ<br>e</td>
<td align="center">お<br>オ<br>o</td>
</tr>
<tr>
<td align="center"><b>か行</b></td>
<td align="center">か<br>カ<br>ka</td>
<td align="center">き<br>キ<br>ki</td>
<td align="center">く<br>ク<br>ku</td>
<td align="center">け<br>ケ<br>ke</td>
<td align="center">こ<br>コ<br>ko</td>
</tr>
<tr>
<td align="center"><b>さ行</b></td>
<td align="center">さ<br>サ<br>sa</td>
<td align="center">し<br>シ<br>shi</td>
<td align="center">す<br>ス<br>su</td>
<td align="center">せ<br>セ<br>se</td>
<td align="center">そ<br>ソ<br>so</td>
</tr>
<tr>
<td align="center"><b>た行</b></td>
<td align="center">た<br>タ<br>ta</td>
<td align="center">ち<br>チ<br>chi</td>
<td align="center">つ<br>ツ<br>tsu</td>
<td align="center">て<br>テ<br>te</td>
<td align="center">と<br>ト<br>to</td>
</tr>
<tr>
<td align="center"><b>な行</b></td>
<td align="center">な<br>ナ<br>na</td>
<td align="center">に<br>ニ<br>ni</td>
<td align="center">ぬ<br>ヌ<br>nu</td>
<td align="center">ね<br>ネ<br>ne</td>
<td align="center">の<br>ノ<br>no</td>
</tr>
<tr>
<td align="center"><b>は行</b></td>
<td align="center">は<br>ハ<br>ha、wa(助词)</td>
<td align="center">ひ<br>ヒ<br>hi</td>
<td align="center">ふ<br>フ<br>fu</td>
<td align="center">ヘ<br>ヘ<br>he</td>
<td align="center">ほ<br>ホ<br>ho</td>
</tr>
<tr>
<td align="center"><b>ま行</b></td>
<td align="center">ま<br>マ<br>ma</td>
<td align="center">み<br>ミ<br>mi</td>
<td align="center">む<br>ム<br>mu</td>
<td align="center">め<br>メ<br>me</td>
<td align="center">も<br>モ<br>mo</td>
</tr>
<tr>
<td align="center"><b>や行</b></td>
<td align="center">や<br>ヤ<br>ya</td>
<td align="center"></td>
<td align="center">ゆ<br>ユ<br>yu</td>
<td align="center"></td>
<td align="center">よ<br>ヨ<br>yo</td>
</tr>
<tr>
<td align="center"><b>ら行</b></td>
<td align="center">ら<br>ラ<br>ra</td>
<td align="center">り<br>リ<br>ri</td>
<td align="center">る<br>ル<br>ru</td>
<td align="center">れ<br>レ<br>re</td>
<td align="center">ろ<br>ロ<br>ro</td>
</tr>
<tr>
<td align="center"><b>わ行</b></td>
<td align="center">わ<br>ワ<br>wa</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">を<br>ヲ<br>o</td>
</tr>
<tr>
<td align="center"><b>拨音</b></td>
<td align="center">ん<br>ン<br>n</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="浊音“、半浊音°"><a href="#浊音“、半浊音°" class="headerlink" title="浊音“、半浊音°"></a>浊音“、半浊音°</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">あ段</th>
<th align="center">い段</th>
<th align="center">う段</th>
<th align="center">え段</th>
<th align="center">お段</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><b>が行</b><br>k→g</td>
<td align="center">が<br>ガ<br>ga</td>
<td align="center">ぎ<br>ギ<br>gi</td>
<td align="center">ぐ<br>グ<br>gu</td>
<td align="center">げ<br>ゲ<br>ge</td>
<td align="center">ご<br>ゴ<br>go</td>
</tr>
<tr>
<td align="center"><b>ざ行</b><br>s→z</td>
<td align="center">ざ<br>ザ<br>za</td>
<td align="center">じ<br>ジ<br>ji</td>
<td align="center">ず<br>ズ<br>zu</td>
<td align="center">ぜ<br>ゼ<br>ze</td>
<td align="center">ぞ<br>ゾ<br>zo</td>
</tr>
<tr>
<td align="center"><b>だ行</b><br>t→d</td>
<td align="center">だ<br>ダ<br>da</td>
<td align="center">ぢ<br>ヂ<br>ji</td>
<td align="center">づ<br>ヅ<br>zu</td>
<td align="center">で<br>デ<br>de</td>
<td align="center">ど<br>ド<br>do</td>
</tr>
<tr>
<td align="center"><b>ば行</b><br>h→b</td>
<td align="center">ば<br>バ<br>ba</td>
<td align="center">び<br>ビ<br>bi</td>
<td align="center">ぶ<br>ブ<br>bu</td>
<td align="center">べ<br>ベ<br>be</td>
<td align="center">ぼ<br>ボ<br>bo</td>
</tr>
<tr>
<td align="center"><b>ぱ行</b><br>h→p</td>
<td align="center">ぱ<br>パ<br>pa</td>
<td align="center">ぴ<br>ピ<br>pi</td>
<td align="center">ぷ<br>プ<br>pu</td>
<td align="center">ぺ<br>ペ<br>pe</td>
<td align="center">ぽ<br>ポ<br>po</td>
</tr>
</tbody></table>
<h2 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">发音</th>
<th align="center">备注</th>
<th align="center">eg.</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><b>促音</b></td>
<td align="center">っ<br>ッ<br>双写促音后面这个假名的第一个辅音</td>
<td align="center">①出现か、た、ぱ在行假名之前，不发音，占一拍<br>②さ行之前，摩擦促音<br></td>
<td align="center">一回<br>いっかい<br>ikkai</td>
</tr>
</tbody></table>
<h2 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">あ段</th>
<th align="center">い段</th>
<th align="center">う段</th>
<th align="center">え段</th>
<th align="center">お段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">尾巴1</td>
<td align="center">あ<br>ア<br>a</td>
<td align="center">い<br>イ<br>i</td>
<td align="center">う<br>ウ<br>u</td>
<td align="center">い<br>イ<br>i</td>
<td align="center">う<br>ウ<br>u</td>
</tr>
<tr>
<td align="center">尾巴2<br>（极少）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">え<br>エ<br>e</td>
<td align="center">お<br>オ<br>o</td>
</tr>
<tr>
<td align="center">eg.</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">おねえさん<br>姐姐</td>
<td align="center">おおさか<br>大阪</td>
</tr>
</tbody></table>
<ul>
<li>片假名：ー（横写），竖写时候写❘</li>
<li>罗马音：重复</li>
</ul>
<h2 id="声调和语调"><a href="#声调和语调" class="headerlink" title="声调和语调"></a>声调和语调</h2><h3 id="声调"><a href="#声调" class="headerlink" title="声调"></a>声调</h3><p>两个主要原则：</p>
<ul>
<li>单词的第一个音节和第二个音节的音高一定不同。第一个音节低，则第二个就一定高，第一个音节高，则第二个就低。</li>
<li>一个单词的声调中，或没有下降，或只有一处下降。</li>
</ul>
<h3 id="语调"><a href="#语调" class="headerlink" title="语调"></a>语调</h3><ul>
<li>短语和陈述句：开始高，逐渐走低</li>
<li>疑问句句尾：升调</li>
</ul>
<hr>
<h1 id="文型"><a href="#文型" class="headerlink" title="文型"></a>文型</h1><ul>
<li>肯定句：<code>XXX は YYY です。</code>。<ul>
<li><code>は</code>：助词，读<code>wa</code>，表示前面是主体。</li>
</ul>
</li>
<li>否定句：<code>XXX は YYY じゃ（/でわ）ありません。</code>。<ul>
<li>上面是丁宁体。</li>
<li>普通体：<code>～じゃない。</code></li>
</ul>
</li>
<li>疑问句：<code>XXX は YYY ですか。</code><ul>
<li><code>か</code>：助词，表疑问。</li>
<li>回答：<ul>
<li>肯定回答：<code>はい，～です。</code></li>
<li>否定回答：<code>いいえ，～じゃありません。</code></li>
</ul>
</li>
</ul>
</li>
<li>也是：<code>XXX ま YYY です。</code></li>
<li>助词<code>の</code>：前后是名词。</li>
<li>各种指示词：</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">指事物<br>(单独)</th>
<th align="center">指事物<br>(接名词)</th>
<th align="center">指地方</th>
<th align="center">指事物、地方、人<br>(郑重、口语)</th>
<th align="center">这（那）样~</th>
<th align="center">这（那）样的~</th>
</tr>
</thead>
<tbody><tr>
<td align="center">こ系列<br>(自己范围内)</td>
<td align="center">これ</td>
<td align="center">この～</td>
<td align="center">ここ</td>
<td align="center">こちら/こっち</td>
<td align="center">こう</td>
<td align="center">こんな～</td>
</tr>
<tr>
<td align="center">そ系列<br>(对方范围内)</td>
<td align="center">それ</td>
<td align="center">その～</td>
<td align="center">そこ</td>
<td align="center">そちら/そっち</td>
<td align="center">そう</td>
<td align="center">そんな～</td>
</tr>
<tr>
<td align="center">あ系列<br>(其他范围内)</td>
<td align="center">あれ</td>
<td align="center">あの～</td>
<td align="center">あそこ</td>
<td align="center">あちら/あっち</td>
<td align="center">あう</td>
<td align="center">あんな～</td>
</tr>
<tr>
<td align="center">ど系列<br>(哪)</td>
<td align="center">どれ</td>
<td align="center">どの～</td>
<td align="center">どこ</td>
<td align="center">どちら/どっち</td>
<td align="center">どう</td>
<td align="center">どんな～</td>
</tr>
</tbody></table>
<ul>
<li>eg.<ul>
<li><code>ここは　XXX　です。</code></li>
<li><code>エレベーターは あそ こです。</code></li>
<li><code>これは どこのワイン ですか。</code></li>
<li><code>この ネクタイは いくら ですか。</code>：いくら　多少钱</li>
</ul>
</li>
<li>时间：<code>今，４時５分です。</code><ul>
<li>何時何分：<code>なんじなんぷん。</code></li>
</ul>
</li>
<li><code>わたしは 毎朝 ６時に 起きます</code>。<ul>
<li><code>起きます</code>：起床，动词结尾，用<code>ます</code>。</li>
<li><code>に</code>：助词，表示动作进行时间点。</li>
</ul>
</li>
<li><code>わたしは きのう 勉強しました。</code><ul>
<li><code>きのう</code>：昨天</li>
<li><code>勉強し</code>：看书</li>
</ul>
</li>
<li>动词：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">动词</th>
<th align="center">肯定形</th>
<th align="center">否定形</th>
</tr>
</thead>
<tbody><tr>
<td align="center">现在形</td>
<td align="center">勉強し<font color="red"><b>ます</b></font></td>
<td align="center">勉強し<font color="red"><b>ません</b></font></td>
</tr>
<tr>
<td align="center">过去形</td>
<td align="center">勉強し<font color="red"><b>ました</b></font></td>
<td align="center">勉強し<font color="red"><b>ませんでした</b></font></td>
</tr>
</tbody></table>
<ul>
<li><code>昼休み は　12時から 1時まで です。</code> <code>わたし は　9時から 5時まで 働きです。</code><ul>
<li><code>から</code>：助词，表示起点</li>
<li><code>まで</code>：助词，表示终点，是对于持续性的动作。若是瞬间性的，用<code>に</code>。</li>
</ul>
</li>
<li>移动方向：<code>わたし は 東京へ 行きます。</code> 我要去东京。<ul>
<li><code>へ</code>：助词，表示移动方向。助词时候读<code>e</code>。</li>
</ul>
</li>
<li>交通工具：<code>わたし は タクシーで うちへ 帰ります</code> 我搭计程车回家。<ul>
<li><code>で</code>：助词，表示交通工具。<code>バイクで</code>骑车。</li>
<li><code>歩いて</code>：步行是动作，不用<code>で</code>。</li>
</ul>
</li>
<li>动作伙伴：<code>わたし は 友達と 学校へ いきます。</code><ul>
<li><code>と</code>：助词，表示动作伙伴。</li>
<li><code>ひとりで</code>：一人で，这里で是助词，表行动单位。</li>
</ul>
</li>
<li><code>どこ (へ)も 行きませんでした。</code>：哪里都没有去。<ul>
<li>疑问词<code>き</code>否定句 可省了<code>へ</code>。</li>
<li><code>き</code>：助词，全否定，“都”。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h1><h2 id="字、短语"><a href="#字、短语" class="headerlink" title="字、短语"></a>字、短语</h2><ul>
<li>歳/才：さい</li>
<li>円：えん</li>
<li>昼休み：ひるやすみ，午休</li>
<li>働き：はたらき，工作</li>
<li>本：ほん，书。eg. 日本語の本</li>
<li>かばん：包，公文包</li>
<li>ノート：笔记本，本子。eg. デスノート 死亡笔记</li>
<li>ペン：pen，笔</li>
<li>傘：かさ，伞</li>
<li>靴：くつ，鞋子。二调词，第二个音之后要降调</li>
<li>新聞：しんぶん，报纸。日语中的新闻是ニュース</li>
<li>雑誌：ざっし，杂志</li>
<li>辞書：じしょ，词典</li>
<li>カメラ：照相机。日语中照片是写真しゃしん</li>
<li>テレビ：电视。日语中节目是番組ばんぐみ，</li>
<li>パソコン：个人电脑，personnel com</li>
<li>ラジオ：radio，电台。ラジオ番組</li>
<li>電話：でんわ，电话。日语中手机是携帯，けいたい</li>
<li>机：つくえ，桌子</li>
<li>いす：椅子</li>
<li>かぎ（鍵）：钥匙、锁</li>
<li>時計：とけい，钟，表</li>
<li>車：くるま，车</li>
<li>自転車：じてんしゃ，自行车</li>
<li>お土産：おみやげ，土特产，出去回来带的礼物</li>
<li>シルク：しるく，silk，丝绸</li>
<li>ハンカチ：手绢</li>
<li>会社：かいしゃ，公司</li>
<li>かた：（敬辞）位，人，他 あのかた</li>
<li>家族：かぞく，家人，家属</li>
<li>母：はは，我的母亲，父ちち 家父</li>
<li>お母さん：おかあさん，母亲，称呼别人的，或者没有外人的情况下叫自己的妈妈。</li>
<li>入口：いりぐち</li>
<li>出口：でぐち</li>
<li>受付：うけつけ，前台，服务台</li>
</ul>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li>0：れい/ぜろ</li>
<li>0.1：れいてんいち</li>
<li>2/3：さんぶんのに</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">万の位</th>
<th align="center">千の位</th>
<th align="center">百の位</th>
<th align="center">十の位</th>
<th align="center">一の位</th>
<th align="center">钱单位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">いちまん</td>
<td align="center"><font color="red"><b>〇</b></font>せん</td>
<td align="center"><font color="red"><b>〇</b></font>ひゃく</td>
<td align="center">じゅう</td>
<td align="center">いち</td>
<td align="center">日元：円えん</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">にまん</td>
<td align="center">にせん</td>
<td align="center">にひゃく</td>
<td align="center">にじゅう</td>
<td align="center">に</td>
<td align="center">元：げん</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">さんまん</td>
<td align="center">さん<font color="red"><b>ぜ</b></font>ん</td>
<td align="center">さん<font color="red"><b>び</b></font>ゃく</td>
<td align="center">さんじゅう</td>
<td align="center">さん</td>
<td align="center">美刀：ドル</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">よんまん</td>
<td align="center">よんせん</td>
<td align="center">よんひゃく</td>
<td align="center">よんじゅう</td>
<td align="center">よ(ん)</td>
<td align="center">香港刀：ホンコンドル</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">ごまん</td>
<td align="center">ごせん</td>
<td align="center">ごひゃく</td>
<td align="center">ごじゅう</td>
<td align="center">ご</td>
<td align="center">欧元：ユーロ</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">ろくまん</td>
<td align="center">ろくせん</td>
<td align="center"><font color="red"><b>ろっぴ</b></font>ゃく</td>
<td align="center">ろくじゅう</td>
<td align="center">ろく</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">ななまん</td>
<td align="center">ななせん</td>
<td align="center">ななひゃく</td>
<td align="center">ななじゅう</td>
<td align="center">なな</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">はちまん</td>
<td align="center"><font color="red"><b>はっ</b></font>せん</td>
<td align="center"><font color="red"><b>はっぴ</b></font>ゃく</td>
<td align="center">はちじゅう</td>
<td align="center">はち</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">きゅうまん</td>
<td align="center">きゅうせん</td>
<td align="center">きゅうひゃく</td>
<td align="center">きゅうじゅう</td>
<td align="center">きゅう</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>注意：  </p>
<ul>
<li>3的千、百有浊音变化，8的千、百有促音、半浊音变化</li>
<li>6的百位有促音、半浊音变化</li>
<li>306念的时候没有“零”</li>
<li>4円：よ円，4元：よん元，因为“円えん”是元音え开头，可以省略前面一个字的ん</li>
</ul>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">時</th>
<th align="center">分</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">いちじ</td>
<td align="center"><font color="red"><b>いっぷ</b></font>ん</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">にじ</td>
<td align="center">にふん</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">さんじ</td>
<td align="center">さん<font color="red"><b>ぷ</b></font>ん</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><font color="red"><b>よ</b></font>じ</td>
<td align="center">よん<font color="red"><b>ぷ</b></font>ん</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">ごじ</td>
<td align="center">ごふん</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">るくじ</td>
<td align="center"><font color="red"><b>ろっぷ</b></font>ん</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><font color="red"><b>しち</b></font>じ</td>
<td align="center">ななふん</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">はちじ</td>
<td align="center"><font color="red"><b>はっぷ</b></font>ん</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><font color="red"><b>く</b></font>じ</td>
<td align="center">きゅうふん</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">じゅうじ</td>
<td align="center"><font color="red"><b>じゅっぷ</b></font>ん<br>(<font color="red"><b>じっぷ</b></font>ん)</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">じゅういちじ</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">じゅうにじ</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>一点半：いじはん</li>
</ul>
<h2 id="何月なんがつ"><a href="#何月なんがつ" class="headerlink" title="何月なんがつ"></a>何月なんがつ</h2><table>
<thead>
<tr>
<th align="center">1月</th>
<th align="center">2月</th>
<th align="center">3月</th>
<th align="center">4月</th>
<th align="center">5月</th>
<th align="center">6月</th>
</tr>
</thead>
<tbody><tr>
<td align="center">いくぃがつ</td>
<td align="center">にがつ</td>
<td align="center">さんがつ</td>
<td align="center"><font color="red"><b>し</b></font>がつ</td>
<td align="center">ごがつ</td>
<td align="center">ろくがつ</td>
</tr>
<tr>
<td align="center">7月</td>
<td align="center">8月</td>
<td align="center">9月</td>
<td align="center">10月</td>
<td align="center">11月</td>
<td align="center">12月</td>
</tr>
<tr>
<td align="center"><font color="red"><b>しち</b></font>がつ</td>
<td align="center">はちがつ</td>
<td align="center"><font color="red"><b>く</b></font>がつ</td>
<td align="center">じゅうがつ</td>
<td align="center">じゅういちがつ</td>
<td align="center">じゅにちがつ</td>
</tr>
</tbody></table>
<h2 id="何日なんにち"><a href="#何日なんにち" class="headerlink" title="何日なんにち"></a>何日なんにち</h2><table>
<thead>
<tr>
<th align="center">1日</th>
<th align="center">2日</th>
<th align="center">3日</th>
<th align="center">4日</th>
<th align="center">5日</th>
<th align="center">6日</th>
<th align="center">7日</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ついたち</td>
<td align="center">ふつか</td>
<td align="center">みっか</td>
<td align="center">よっか</td>
<td align="center">いつが</td>
<td align="center">むいか</td>
<td align="center">なのか</td>
</tr>
<tr>
<td align="center">8日</td>
<td align="center">9日</td>
<td align="center">10日</td>
<td align="center">14日</td>
<td align="center">20日</td>
<td align="center">24日</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">ようか</td>
<td align="center">ここのか</td>
<td align="center">とおか</td>
<td align="center">じゅうよっか</td>
<td align="center">はつか</td>
<td align="center">にじゅうよっか</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">其他日</td>
<td align="center">17、27里的7</td>
<td align="center">19、29里的9</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">～日(にち)</td>
<td align="center">しち</td>
<td align="center">く</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="星期"><a href="#星期" class="headerlink" title="星期"></a>星期</h2><p>月曜日（げつようび，Ge tsu you bi）= 星期一<br>火曜日（かようび，Ka you bi）= 星期二<br>水曜日（すいようび，Su i you bi）= 星期三<br>木曜日（もくようび，Mo ku you bi）= 星期四<br>金曜日（きんようび，Kinn you bi）= 星期五<br>土曜日（どようび，Do you bi）= 星期六<br>日曜日（にちようび，Ni chi you bi）= 星期日  </p>
]]></content>
      <categories>
        <category>「语言」- 日语</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>Lightroom Learn Notes</title>
    <url>/2020/02/26/Lr-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>算是查漏补缺罢</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="照片管理、筛选和批量处理"><a href="#照片管理、筛选和批量处理" class="headerlink" title="照片管理、筛选和批量处理"></a>照片管理、筛选和批量处理</h1><h2 id="Ps与Lr调用文件机制的区别"><a href="#Ps与Lr调用文件机制的区别" class="headerlink" title="Ps与Lr调用文件机制的区别"></a>Ps与Lr调用文件机制的区别</h2><ul>
<li>Ps直接吃进照片进行处理</li>
<li>Lr建立索引</li>
<li>Lr的优势<ul>
<li>方便组图的甄选</li>
<li>快速统一风格</li>
<li>可分时段修图</li>
<li>可批量处理</li>
</ul>
</li>
</ul>
<h2 id="照片管理"><a href="#照片管理" class="headerlink" title="照片管理"></a>照片管理</h2><ul>
<li><code>文件夹</code>：对应电脑系统的文件夹</li>
<li><code>收藏夹</code>：虚拟的文件夹</li>
<li><code>筛选</code>：右键-设置色标-颜色，或者 选照片-按键盘上的数字键。然后用过滤器筛选。标星级同理。</li>
<li><code>色标</code>-<code>筛选</code>-<code>收藏</code>-<code>取消色标</code>，方便归类</li>
<li>导入照片时的选项：<ul>
<li><code>添加</code>：只建立索引</li>
<li><code>移动</code>：移动到右侧目标文件夹</li>
<li><code>复制</code>：复制到右侧目标文件夹</li>
</ul>
</li>
</ul>
<h2 id="照片的批量处理"><a href="#照片的批量处理" class="headerlink" title="照片的批量处理"></a>照片的批量处理</h2><ul>
<li><code>图库</code>界面，右侧<code>快速修改照片</code>，可多选照片</li>
</ul>
<hr>
<h1 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h1><p>关于亮度的统计标高，<code>横坐标</code>：0-255的亮度级别；<code>纵坐标</code>：像素数量。</p>
<hr>
<h1 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h1><p>整体调色。  </p>
<ul>
<li>常见曲线<ul>
<li>压暗、提亮、加强对比度（S型）</li>
</ul>
</li>
<li>胶片灰<ul>
<li>最暗点提亮，最亮点压暗（阴影、高光的细节丢失）</li>
<li>可以加个小S</li>
</ul>
</li>
<li>调色案例<ul>
<li>日系小清新<ul>
<li>GRB提亮</li>
<li>绿色阴影部分提亮</li>
<li>蓝色阴影部分提亮</li>
<li>红色给一点点青色 压暗</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="色调分离"><a href="#色调分离" class="headerlink" title="色调分离"></a>色调分离</h1><h2 id="色温色调"><a href="#色温色调" class="headerlink" title="色温色调"></a>色温色调</h2><ul>
<li>夜间照片<ul>
<li>色温↓</li>
<li>色调↓</li>
<li>提亮阴影</li>
<li>二次构图</li>
</ul>
</li>
<li>缺点：调色过于整体</li>
</ul>
<h2 id="分离色调"><a href="#分离色调" class="headerlink" title="分离色调"></a>分离色调</h2><p>针对不同亮度区域调色。  </p>
<ul>
<li>常见：高光青（190<del>220）、阴影黄绿（50</del>70）</li>
</ul>
<hr>
<h1 id="HSL"><a href="#HSL" class="headerlink" title="HSL"></a>HSL</h1><ul>
<li>针对颜色进行局部调色</li>
</ul>
<hr>
<h1 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h1><ul>
<li>亮度噪点、色彩噪点</li>
<li>去紫边</li>
</ul>
<hr>
<h1 id="视频参考"><a href="#视频参考" class="headerlink" title="视频参考"></a>视频参考</h1><h2 id="入门级"><a href="#入门级" class="headerlink" title="入门级"></a>入门级</h2><ul>
<li><a href="https://www.bilibili.com/video/av91781253" target="_blank" rel="noopener">照片管理、筛选与批量处理 | 泰罗</a></li>
<li><a href="https://www.bilibili.com/video/av93534402" target="_blank" rel="noopener">直方图与曝光调整 | 泰罗</a></li>
<li><a href="https://www.bilibili.com/video/BV1PE411T7im" target="_blank" rel="noopener">曲线入门 | 泰罗</a></li>
<li><a href="https://www.bilibili.com/video/BV1AQ4y1M7Xi" target="_blank" rel="noopener">色温色调、分离色调 | 泰罗</a></li>
<li><a href="https://www.bilibili.com/video/BV1ti4y1t7ss" target="_blank" rel="noopener">HSL入门 | 泰罗</a></li>
<li><a href="https://www.bilibili.com/video/BV1354y1R7md" target="_blank" rel="noopener">锐化、清晰度 | 泰罗</a></li>
<li><a href="https://www.bilibili.com/video/BV13541147rf" target="_blank" rel="noopener">LR其他 | 泰罗</a></li>
</ul>
]]></content>
      <categories>
        <category>「快门」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Lightroom</tag>
      </tags>
  </entry>
  <entry>
    <title>网站收藏</title>
    <url>/2019/09/26/Site-Bookmark/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>BOOKMARK</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Website</th>
<th>Remarks</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.latexlive.com/" target="_blank" rel="noopener">LaTeX公式编辑器</a></td>
<td><a href="https://www.latexlive.com/" target="_blank" rel="noopener">https://www.latexlive.com/</a></td>
<td>在线编辑</td>
</tr>
<tr>
<td><a href="https://www.slant.co/" target="_blank" rel="noopener">Slant</a></td>
<td><a href="https://www.slant.co/" target="_blank" rel="noopener">https://www.slant.co/</a></td>
<td>最好的…是什么？</td>
</tr>
<tr>
<td><a href="http://www.qiuziti.com/" target="_blank" rel="noopener">求字体</a></td>
<td><a href="http://www.qiuziti.com/" target="_blank" rel="noopener">http://www.qiuziti.com/</a></td>
<td>截图识别字体</td>
</tr>
<tr>
<td><a href="https://getitfree.cn/" target="_blank" rel="noopener">正版中国</a></td>
<td><a href="https://getitfree.cn/" target="_blank" rel="noopener">https://getitfree.cn/</a></td>
<td>正版软件&amp;免费&amp;优惠</td>
</tr>
<tr>
<td><a href="http://edit.foxitcloud.cn/" target="_blank" rel="noopener">福昕云编辑</a></td>
<td><a href="http://edit.foxitcloud.cn/" target="_blank" rel="noopener">http://edit.foxitcloud.cn/</a></td>
<td>在线编辑pdf</td>
</tr>
<tr>
<td><a href="https://www.onlinedoctranslator.com" target="_blank" rel="noopener">在线文档翻译</a></td>
<td><a href="https://www.onlinedoctranslator.com" target="_blank" rel="noopener">https://www.onlinedoctranslator.com</a></td>
<td>免费&amp;多语言翻译</td>
</tr>
<tr>
<td><a href="http://www.alltoall.net/" target="_blank" rel="noopener">在线文档转换</a></td>
<td><a href="http://www.alltoall.net/" target="_blank" rel="noopener">http://www.alltoall.net/</a></td>
<td>免费</td>
</tr>
<tr>
<td><a href="https://www.pdfpai.com/" target="_blank" rel="noopener">PDF派</a></td>
<td><a href="https://www.pdfpai.com/" target="_blank" rel="noopener">https://www.pdfpai.com/</a></td>
<td>PDF在线工具&amp;转换</td>
</tr>
<tr>
<td><a href="https://bccto.me/" target="_blank" rel="noopener">10分钟邮箱</a></td>
<td><a href="https://bccto.me/" target="_blank" rel="noopener">https://bccto.me/</a></td>
<td>-</td>
</tr>
<tr>
<td><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">在线短信接收</a></td>
<td><a href="https://www.pdflibr.com/" target="_blank" rel="noopener">https://www.pdflibr.com/</a></td>
<td>-</td>
</tr>
<tr>
<td><a href="https://ps.gaoding.com" target="_blank" rel="noopener">在线PS</a></td>
<td><a href="https://ps.gaoding.com" target="_blank" rel="noopener">https://ps.gaoding.com</a></td>
<td>-</td>
</tr>
<tr>
<td><a href="https://www.toolfk.com/" target="_blank" rel="noopener">TOOLFK</a></td>
<td><a href="https://www.toolfk.com/" target="_blank" rel="noopener">https://www.toolfk.com/</a></td>
<td>在线工具</td>
</tr>
</tbody></table>
<hr>
<h1 id="资讯类"><a href="#资讯类" class="headerlink" title="资讯类"></a>资讯类</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Website</th>
<th>Remarks</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://www.dapenti.com/blog/index.asp" target="_blank" rel="noopener">打喷嚏</a></td>
<td><a href="http://dapenti.com" target="_blank" rel="noopener">http://dapenti.com</a></td>
<td>每日新闻图卦</td>
</tr>
<tr>
<td><a href="http://bddn.cn/zb.htm" target="_blank" rel="noopener">全国电视直播</a></td>
<td><a href="http://bddn.cn/zb.htm" target="_blank" rel="noopener">http://bddn.cn/zb.htm</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.anyknew.com/" target="_blank" rel="noopener">Anyknew</a></td>
<td><a href="https://anyknew.com/" target="_blank" rel="noopener">https://anyknew.com/</a></td>
<td>热点资讯聚合</td>
</tr>
<tr>
<td><a href="http://guozhivip.com/rank" target="_blank" rel="noopener">果汁排行榜</a></td>
<td><a href="http://guozhivip.com/rank" target="_blank" rel="noopener">http://guozhivip.com/rank</a></td>
<td>资讯、排行榜聚合</td>
</tr>
<tr>
<td><a href="https://www.mvyxws.com/" target="_blank" rel="noopener">医学威视</a></td>
<td><a href="https://www.mvyxws.com/" target="_blank" rel="noopener">https://www.mvyxws.com/</a></td>
<td>短视频了解疾病</td>
</tr>
<tr>
<td><a href="https://readhub.cn" target="_blank" rel="noopener">Realhub</a></td>
<td><a href="https://readhub.cn" target="_blank" rel="noopener">https://readhub.cn</a></td>
<td>互联网新闻</td>
</tr>
<tr>
<td><a href="http://data.163.com/special/datablog/" target="_blank" rel="noopener">网易数读</a></td>
<td><a href="http://data.163.com/special/datablog/" target="_blank" rel="noopener">http://data.163.com/special/datablog/</a></td>
<td>大数据X图表</td>
</tr>
</tbody></table>
<hr>
<h1 id="学习类"><a href="#学习类" class="headerlink" title="学习类"></a>学习类</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Website</th>
<th>Remarks</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://zh.wikihow.com" target="_blank" rel="noopener">WikiHow</a></td>
<td><a href="https://zh.wikihow.com" target="_blank" rel="noopener">https://zh.wikihow.com</a></td>
<td>学各种小技巧</td>
</tr>
<tr>
<td><a href="https://github.com/guodongxiaren/README" target="_blank" rel="noopener">Markdown语法</a></td>
<td><a href="https://github.com/guodongxiaren/README" target="_blank" rel="noopener">https://github.com/guodongxiaren/README</a></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h1 id="游戏类"><a href="#游戏类" class="headerlink" title="游戏类"></a>游戏类</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Website</th>
<th>Remarks</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://trello.com/b/LvwOjrYP/ingress-medal-arts" target="_blank" rel="noopener">Ingress Medal Arts @trello</a></td>
<td><a href="https://trello.com/b/LvwOjrYP/ingress-medal-arts" target="_blank" rel="noopener">https://trello.com/b/LvwOjrYP/ingress-medal-arts</a></td>
<td>Ingress任务浏览</td>
</tr>
<tr>
<td><a href="https://www.giacintogarcea.com/ingress/tools/missionset/" target="_blank" rel="noopener">Ingress Mission Banner Cropper</a></td>
<td><a href="https://www.giacintogarcea.com/ingress/tools/missionset/" target="_blank" rel="noopener">https://www.giacintogarcea.com/ingress/tools/missionset/</a></td>
<td>Inress任务图标切割工具，备用地址：<a href="https://reitake.github.io/tools/ingressmissionset/">https://reitake.github.io/tools/ingressmissionset/</a></td>
</tr>
</tbody></table>
<hr>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Website</th>
<th>Remarks</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.rainymood.com/" target="_blank" rel="noopener">RainMode</a></td>
<td><a href="https://www.rainymood.com/" target="_blank" rel="noopener">https://www.rainymood.com/</a></td>
<td>白噪音</td>
</tr>
<tr>
<td><a href="https://www.airpano.com/" target="_blank" rel="noopener">AirPano</a></td>
<td><a href="https://www.airpano.com/" target="_blank" rel="noopener">https://www.airpano.com/</a></td>
<td>假装去旅游</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>「备忘」</category>
      </categories>
      <tags>
        <tag>网站</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>《经济学原理》笔记（宏观经济学）</title>
    <url>/2019/04/02/Macroeconomics-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>曼昆笔下的经典</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<ul>
<li>作者：尼可拉斯·格里高利·曼昆（N. Gregory Mankiw）  </li>
<li>出版社：北京大学出版社 </li>
<li><a href="/2019/04/01/Microeconomics-Notes/">微经笔记</a></li>
</ul>
<hr>
<p><strong>宏观经济学部分</strong></p>
<h1 id="第八篇-宏观经济学的数据"><a href="#第八篇-宏观经济学的数据" class="headerlink" title="第八篇 宏观经济学的数据"></a>第八篇 宏观经济学的数据</h1><h2 id="第23章-一国收入的衡量"><a href="#第23章-一国收入的衡量" class="headerlink" title="第23章 一国收入的衡量"></a>第23章 一国收入的衡量</h2><p>1.国内生产总值（GDP），衡量一国的总收入，又衡量总支出。对一个整体经济而言，收入比定等于支出</p>
<ul>
<li>GDP：在某一既定时期一个国家内生产的所有最终物品与劳务市场价值（gross domestic product）</li>
<li>GDP包括在经济中生产并在市场上合法出售的所有东西，不包括非法生产和销售的东西，不包括在家庭内生产和消费从而没有进入市场的东西</li>
<li>GDP只包括最终物品的价值</li>
<li>GDP既包括有形的物品，又包括无形的劳务</li>
<li>GDP包括现期生产的物品与劳务，不包括涉及过去生产的东西的交易</li>
<li>GDP衡量的生产价值局限于一个国家的地理范围内</li>
<li>GDP衡量某一特定时期内发生的生产的价值。季度GDP收入乘以4（有季度调整）</li>
</ul>
<p>2.其他收入衡量指标</p>
<ul>
<li>国民生产总值（GNP）：一国永久居民（国民）所赚到的总收入，包括本国公民在国外赚到的收入，不包括外国人在本国赚到的收入</li>
<li>国民生产净值（NNP）：一国居民的总收入（GNP）减折旧</li>
<li>国民收入：一国居民在物品雨劳务生产中赚到的总收入，不包括简介的企业税，但包括企业补贴</li>
<li>个人收入：家庭和非公司制企业得到的收入，不包括留存收益</li>
<li>个人可支配收入：家庭和非公司制企业中完成它们对政府的义务后剩下的收入</li>
</ul>
<p>3.GDP（Y），消费（C），投资（I），政府购买（G），净出口（NX）</p>
<ul>
<li>恒等式：Y＝C＋I＋G＋NX</li>
<li>消费：家庭除购买新住房之外用于物品与劳务的支出</li>
<li>投资：用于资本设备、存货和建筑物的支出，包括家庭用于购买新住房的支出</li>
<li>政府购买：地方、州和联邦政府用于物品与劳务的支出</li>
<li>净出口：外国人对国内生产的物品的支出（出口）减国内居民对外国物品的支出（进口）</li>
</ul>
<p>4.名义GDP、真实GDP</p>
<ul>
<li>名义GDP：按现期价格评价的物品与劳务的生产（按当年）</li>
<li>真实GDP：按不变价格评价物品与劳务的生产（按基年）</li>
<li>GDP平减指数＝名义GDP／真实GDP×100%，衡量相对于基年价格的现期物价水平</li>
<li>通货膨胀率：从一个时期到下一个时期某个物价水平衡量指标变动的百分比</li>
<li>第二年的通货膨胀率＝（第二年的GDP平减指数-第一年的GDP平减指数）/第一年的GDP平减指数×100%</li>
</ul>
<p>5.GDP是经济福利的一个良好衡量指标，因为人们对高收入的偏好大于低收入。但GDP并不是衡量福利的一个完美指标</p>
<h2 id="第24章-生活费用的衡量"><a href="#第24章-生活费用的衡量" class="headerlink" title="第24章 生活费用的衡量"></a>第24章 生活费用的衡量</h2><p>1.消费物价指数（CPI）：普通消费者所购买动物品与劳务的总费用的衡量指标</p>
<ul>
<li>计算CPI的五个步骤：<ul>
<li>（1）固定篮子；</li>
<li>（2）找出价格；</li>
<li>（3）计算这佚篮子东西的费用；</li>
<li>（4）选择基年并计算指数，消费物价指数＝当年一篮子物品／基年一篮子的价格×100；</li>
<li>（5）计算通货膨胀率，第二年的通货膨胀率＝（第二年CPI-第一年CPI）／第一年CPI×100%<br>生产物价指数（PPI）：企业购买的一篮子物品与劳务的费用的衡量指标</li>
</ul>
</li>
</ul>
<p>2.三个问题</p>
<ul>
<li>替代偏向</li>
<li>新产品的引进</li>
<li>无法衡量</li>
</ul>
<p>3.把T年的美元换算成今天的美元的公式</p>
<ul>
<li>今天的美元数量＝T年的美元数量×今天的物价水平／T年的物价水平</li>
<li>指数化：根据法律或美元数量的协议对通货膨胀的影响自动调整</li>
</ul>
<p>4.名义利率、真实利率</p>
<ul>
<li>名义利率：通常公布的，未根据通货膨胀的影响校正等利率（存款）</li>
<li>真实利率：根据通货膨胀等利率校正过的利率（购买力）</li>
<li>真实利率＝名义利率-通货膨胀率</li>
</ul>
<hr>
<h1 id="第九篇-长期中的真实经济"><a href="#第九篇-长期中的真实经济" class="headerlink" title="第九篇 长期中的真实经济"></a>第九篇 长期中的真实经济</h1><h2 id="第25章-生产与增长"><a href="#第25章-生产与增长" class="headerlink" title="第25章 生产与增长"></a>第25章 生产与增长</h2><p>1.生产率：每单位劳动投入所生产的物品和劳务的数量。生产率的决定因素：</p>
<ul>
<li>物质资本：用于生产物品与劳务的设备和建筑物存量</li>
<li>人力资本：工人通过教育、培训和经验而获得动知识雨技能</li>
<li>自然资源：由自然界提供的用于生产物品与劳务的投入</li>
<li>技术知识：社会对生产物品与劳务的最好方法的了解</li>
</ul>
<p>2.资本要收到受益递减的制约：随着资本存量的增加，由增加的一单位资本生产的额外产量减少</p>
<ul>
<li>在长期中，高储蓄率引起高水平的生产率和收入，但在这些变量中并没有高增长</li>
<li>追赶效益：开始时贫穷的国家倾向于比开始时富裕的国家增长更快的特征</li>
</ul>
<p>3.来自国外的投资：外国直接投资，外国有价证券投资</p>
<ul>
<li>经济增长和公共政策：储蓄和投资，来自国外的投资，教育，健康与营养，产权和政治稳定，自由贸易，研究与开发，人口增长</li>
<li>人口增长对经济增长有多种影响。一方面，更加迅速的人口增长会通过使自然资源供给紧张和减少每个工人可以得到的资本量而降低生产率。另一方面，更多的人口也可以提高技术进步的进度，因为会有更多的科学家和工程师。</li>
</ul>
<h2 id="第26章-储蓄、投资和金融体系"><a href="#第26章-储蓄、投资和金融体系" class="headerlink" title="第26章 储蓄、投资和金融体系"></a>第26章 储蓄、投资和金融体系</h2><p>1.金融体系：经济中促使一个人的储蓄与另一个人的投资相匹配大一组机构</p>
<ul>
<li>金融机构可以分两类：金融市场和金融中介机构</li>
</ul>
<p>2.金融市场：储蓄者可以借以直接向借款者提供资金的金融机构</p>
<ul>
<li>债券市场，债务筹资。债券（bond）：一种债务证明书。特点：<ul>
<li>（1）期限：短期、永久债券；</li>
<li>（2）信用风险：不能支付称为拖欠；</li>
<li>（3）税收待遇：市政债券不为利息纳税，利率低</li>
</ul>
</li>
<li>股票市场，股本筹资。股票（stock）：企业部分所有权的索取权。股票指数：计算出来的一组股票价格的平均数。</li>
</ul>
<p>3.金融中介机构：储蓄者可以借以间接地向借款者提供资金的金融机构</p>
<ul>
<li>银行</li>
<li>共同基金，向公众出售股份，并用收入来购买股票与债券组合的机构（资产组合）</li>
</ul>
<p>4.一些重要的恒等式</p>
<ul>
<li>Y＝C＋I＋G＋NX</li>
<li>封闭经济：不与其他经济相互家里的经济，NX＝0，Y＝C+I+G</li>
<li>国民储蓄（储蓄）：在用语消费和政府购买后剩下的一个经济中的总收入，用S表示，S＝Y-C-G=I</li>
<li>T：政府以税收对形式从家庭得到到数量减去以转移支付形式（例如社会保障和福利）返还给家庭的数量。S＝（Y-T-C）＋（T-G）</li>
<li>私人储蓄（Y-T-C）：家庭在支付了税收和消费之后剩下来的收入</li>
<li>公共储蓄（T-G）：政府在支付其支出后剩下来的税收收入。T大于G，预算盈余：税收收入大于政府支出的余额；T小于G，预算赤字：政府支出引起的税收收入短缺</li>
<li>S＝I：对整个经济而言，储蓄必定等于投资</li>
</ul>
<p>5.可贷资金市场：向储蓄的人借以提供资金，向借钱投资的人借以借贷资金的市场</p>
<ul>
<li>可贷资金：人们选择储蓄并贷出二不用于自己消费的所有收入，以及投资者选择为新投资项目筹集资金要借的数量</li>
<li>储蓄是可贷资金的来源，投资时可贷资金需求的来源，（真实）利率时借贷的价格</li>
<li>影响经济中储蓄与投资的各种政府政策：<ul>
<li>（1）储蓄激励：如果税法改革鼓励更多储蓄，则利率下降且投资增加；</li>
<li>（2）投资激励：如果税法改革鼓励更多投资，则利率上升且投资增加；</li>
<li>（3）政府预算赤字与盈余。挤出：政府借款所引起的投资减少。当政府通过预算赤字而减少国民储蓄时，利率就会上升且投资减少。预算盈余增加了可贷资金的供给，降低了利率，并刺激了投资。</li>
</ul>
</li>
</ul>
<h2 id="第27章-基本金融工具"><a href="#第27章-基本金融工具" class="headerlink" title="第27章 基本金融工具"></a>第27章 基本金融工具</h2><p>1.现值、未来值、复利</p>
<ul>
<li>现值：用现行利率产生一定量未来货币所需要的现在货币量</li>
<li>未来值：在现行利率既定时，现在货币量将带来到未来货币</li>
<li>复利：货币量的累积</li>
<li>如果r是利率，那么在N年后将得到的X量的现值时X/(1+r)^N，贴现</li>
<li>70规则：如果某个变量每年按x％增长，那么大约在70/x年后，该变量翻一番</li>
</ul>
<p>2.风险管理</p>
<ul>
<li>风险厌恶：不喜欢不确定性</li>
<li>保险市场受到制约其分摊风险能力的两类问题的困扰：<ul>
<li>（1）逆向选择：高风险的人比低风险的人更可能申请保险，因为高风险的人从保险到保护中获益更大；</li>
<li>（2）道德风险：人们在购买保险之后，对他们谨慎从事以避免风险对激励小了，因为保险公司将会补偿损失的大部分</li>
</ul>
</li>
<li>多元化：通过用大量不相关的小风险代替一种风险来降低风险</li>
<li>多元化可以消除企业特有风险（只影响一个公司的风险），但是不能消除市场风险（影响股市上所有公司的风险）</li>
</ul>
<p>3.资产评估</p>
<ul>
<li>基本面分析：为决定一家公司的价值而对其会计报表和未来前景进行对研究</li>
<li>三种方法：（1）自己阅读年报进行所有必要的研究；（2）依靠华尔街分析师的建议；（3）购买共同基金，它有进行基本面分析并提你做决策的基金经理</li>
</ul>
<p>4.有效市场假说：认为资产价格反应了关于一种资产价值的所有公开的，可获得但信息的理论</p>
<ul>
<li>信息有效：以理性方式反映所有可获得的信息的有关资产价格的描述</li>
<li>随机行走：一种变量变动的路径是不可预期的</li>
</ul>
<h2 id="第28章-失业"><a href="#第28章-失业" class="headerlink" title="第28章 失业"></a>第28章 失业</h2><p>1.失业问题分两类：长期失业问题，短期失业问题</p>
<ul>
<li>自然失业率：经济中正常情况下存在的失业量</li>
<li>周期性失业：失业量围绕自然失业率逐年波动，与经济活动的短期上升与下降密切相关</li>
</ul>
<p>2.劳动力：既包括就业者又包括失业者的工人总数</p>
<ul>
<li>劳动力＝就业者人数＋失业者人数</li>
<li>失业量：劳动力中失业者所占的百分比，失业率＝失业者人数／劳动力×100%</li>
<li>劳动力参工率：劳动力占成年人口到百分比，劳动力參工率＝劳动力／成年人口×100%</li>
</ul>
<p>3.大多数失业时短期的，而在任何一个既定时间所观察到动大多数失业又是长期的</p>
<p>4.摩擦性失业、结构性失业</p>
<ul>
<li>摩擦性失业：由于工人寻找最适合自己嗜好和技能的工作需要时间而引起的失业</li>
<li>结构性失业：由于某些劳动市场上可提供的工作岗位数量不足以为每个想工作的人提供工作而引起的失业</li>
<li>寻找工作：在工人的嗜好与技能既定时工人寻找适当工作的过程</li>
<li>失业保险：当工人失业时为他们提供部分收入保障的政府计划</li>
</ul>
<p>5.如果工资犹豫任何一个原因高于均衡水平，就会导致失业</p>
<p>6.失业原因：</p>
<ul>
<li>摩擦性</li>
<li>最低工资法</li>
<li>工会</li>
<li>效率工资理论</li>
</ul>
<hr>
<h1 id="第十篇-长期中的货币与物价"><a href="#第十篇-长期中的货币与物价" class="headerlink" title="第十篇 长期中的货币与物价"></a>第十篇 长期中的货币与物价</h1><h2 id="第29章-货币制度"><a href="#第29章-货币制度" class="headerlink" title="第29章 货币制度"></a>第29章 货币制度</h2><p>1.货币：经济中人们经常用于向其他人购买物品与劳务的一组资产</p>
<ul>
<li>货币在经济中的三种职能：<ul>
<li>（1）交换媒介：买者在购买物品与劳务时给予卖着的东西</li>
<li>（2）计价单位：人们用来表示价格和记录债务的标准</li>
<li>（3）价值储藏手段：人们可以用来把现在的购买力转化为未来的购买力的东西</li>
</ul>
</li>
<li>流动性：一种资产兑换为经济中交换媒介的容易程度</li>
</ul>
<p>2.商品货币：以有内在价值的商品为形式的货币</p>
<ul>
<li>内在价值：即使不做为货币，东西本身也具有价值</li>
<li>法定货币：没有内在价值，由政府法令确定作为通货使用的货币</li>
</ul>
<p>3.通货：公众手中持有的纸币钞票和铸币</p>
<ul>
<li>活期存款：储户可以通过开支票而随时支取都银行账户余额</li>
</ul>
<p>4.联邦储备、中央银行</p>
<ul>
<li>联邦储备（Fed）：美国中央银行</li>
<li>中央银行：为了监管银行体系和调节经济中的货币量而设计的机构</li>
<li>美联储两项工作：<ul>
<li>（1）管制银行并确保银行体系的正常运行；</li>
<li>（2）控制经济中可以得到的货币量，这种货币量称为货币供给</li>
</ul>
</li>
<li>货币政策：中央银行的决策者对货币供给的安排</li>
<li>美联储公开市场操作——买卖美国政府债券</li>
</ul>
<p>5.银行与货币供给</p>
<ul>
<li>准备金：银行得到但没有贷出去的存款</li>
<li>如果银行以准备金形式持有所有存款，银行就不影响货币供给</li>
<li>部分准备金银行：只把部分存款作为准备金的银行制度</li>
<li>准备金率：银行作为准备金持有的存款比例</li>
<li>当银行只把部分存款作为准备金时，银行就创造了货币</li>
<li>货币乘数：银行体系用1美元准备金所产生动货币量，是准备金率的倒数</li>
<li>因此，准备金率越高，每个存款银行贷出的款越少，货币乘数越小</li>
</ul>
<p>6.美联储控制货币的三种工具：</p>
<ul>
<li>公开市场操作：美联储买卖美国政府债券</li>
<li>法定准备金：关于银行必须根据起存款持有的最低准备金量点规定</li>
<li>贴现率：美联储向银行发放贷款的利率</li>
</ul>
<p>7.联邦基金利率：银行向另一家银行进行隔夜贷款时的利率</p>
<h2 id="第30章-货币增长与通货膨胀"><a href="#第30章-货币增长与通货膨胀" class="headerlink" title="第30章 货币增长与通货膨胀"></a>第30章 货币增长与通货膨胀</h2><p>1.在长期中，物价总水平调整到使货币需求等于货币供给的水平</p>
<p>2.货币数量论：一和认可得到的货币量决定物价水平，可得到的货币量多增长率决定通货膨胀率的理论</p>
<p>3.名义变量、真实变量</p>
<ul>
<li>名义变量：按货币单位衡量的变量</li>
<li>真实变量：按实物单位衡量的变量</li>
<li>古典二分法：名义变量和真实变量的理论比例</li>
<li>货币中性：认为货币供给变动并不影响真实变量的观点</li>
</ul>
<p>4.货币流通速度：货币易手的速度</p>
<ul>
<li>P：物价水平（GDP平减指数），Y：产量（真实GDP），M：货币量</li>
<li>货币流通速度：V＝（P×Y）/M</li>
<li>数量方程式：M×V＝P×Y</li>
<li>解释均衡物价水平和通货膨胀所需的所有因素：<ul>
<li>（1）货币流通速度一直是较为稳定的</li>
<li>（2）由于货币流通速度，所以当中央银行改变M时，它就引起名义产出值（P×V）当同比例变动</li>
<li>（3）一个经济的物品与劳务产量（Y）主要是由要素供给（劳动、物质资本、人力资本和自然资源）和可以得到的生产技术决定的，特别是，由于货币时中性的，所以它并不影响产量</li>
<li>（4）在产量（Y）由要素供给和技术决定的情况下，当中央银行改变货币供给（M），当引起P×V发生同比例变动时，这些变动反应在物价水平（P）当变动上</li>
</ul>
</li>
<li>因此，当中央银行迅速增加货币供给时，结果就是高通货膨胀率</li>
</ul>
<p>5.通货膨胀税：政府通过创造货币而筹集的收入</p>
<ul>
<li>就像是一种向每个持有货币的人征收的税</li>
</ul>
<p>6.费雪效应：名义利率对通货膨胀率所进行的一对一调整</p>
<ul>
<li>在长期中正确，短期中不成立，因通货膨胀不可预测</li>
<li>名义利率＝真实利率＋通货膨胀率</li>
</ul>
<p>7.通货膨胀的成本：</p>
<ul>
<li>皮鞋成本：当通货膨胀鼓励人们减少货币持有量时浪费的资源</li>
<li>菜单成本：改变价格的成本</li>
<li>相对价格变动与资源配置不当</li>
<li>通货膨胀引起的税收扭曲</li>
<li>混乱与不方便</li>
<li>未预期到的通货膨胀的特殊成本：任意的财富再分配</li>
</ul>
<hr>
<h1 id="第十一篇-开放经济的宏观经济学"><a href="#第十一篇-开放经济的宏观经济学" class="headerlink" title="第十一篇 开放经济的宏观经济学"></a>第十一篇 开放经济的宏观经济学</h1><h2 id="第31章-开放经济的宏观经济学：基本概念"><a href="#第31章-开放经济的宏观经济学：基本概念" class="headerlink" title="第31章 开放经济的宏观经济学：基本概念"></a>第31章 开放经济的宏观经济学：基本概念</h2><p>1.开放经济：与世界上其他经济自由交易的经济</p>
<ul>
<li>出口，进口，净出口（贸易余额），贸易盈余，贸易赤字，贸易平衡</li>
<li>净出口＝一国的出口值-一国的进口值</li>
<li>影响一国出口、进口和净出口的因素：<ul>
<li>（1）消费者对国内与国外物品的嗜好</li>
<li>（2）国内与国外物品的价格</li>
<li>（3）人们可以用国内通货购买国外通过的汇率</li>
<li>（4）国内与国外消费者的收入</li>
<li>（5）从一国向另一国运送物品到成本</li>
<li>（6）政府对国际贸易的政策</li>
</ul>
</li>
</ul>
<p>2.资本净流出：本国居民购买的外国资产减外国人购买的国内资产</p>
<ul>
<li>影响资本净流出的因素：<ul>
<li>（1）国外资产得到的真实利率</li>
<li>（2）国内资产得到的真实利率</li>
<li>（3）持有国外资产可以觉察到的经济与政治风险</li>
<li>（4）影响国外对国内资产所有权的政府政策</li>
</ul>
</li>
<li>资本净流出：NCO，净出口：NX</li>
<li>恒等式：NCO＝NX</li>
<li>对整个经济概括两个结论：<ul>
<li>（1）当异国游贸易盈余时（NX大于0），它出售给外国人的物品与劳务多余外国人购买的。用它从国外的物品与劳务的净销售中得到的外国通货做什么呢？它必定用它购买国外资产。因此，资本从一国流出（NCO大于0）</li>
<li>（2）当一国游贸易赤字时（NX小于0），它从国外人那里购买的物品与劳务多余外国人出售的。在世界市场上它如何为这些物品与劳务的净购买筹资呢？它必定在国外出售资产。因此，资本流入国内（NCO小于0）</li>
</ul>
</li>
</ul>
<p>3.Y＝C＋I＋G＋NX</p>
<ul>
<li>国民储蓄：S＝Y-C-G＝I＋NX（国内投资＋资本净流出）</li>
</ul>
<p>4.名义利率：一个人可以用一国通货交换另一国通货的比率</p>
<ul>
<li>升值：按所能购买到的外国通货衡量的一国通货的价值增加/坚挺</li>
<li>贬值：按所能购买到到外国通货衡量的一国通货的价值减少/疲软</li>
</ul>
<p>5.真实汇率：一个人可以用一国物品与劳务交换另一国物品与劳务的比率</p>
<ul>
<li>真实汇率＝名义汇率×国内价格／国外价格＝(e×p)/P^*<ul>
<li>e：美元和外国通货之间的名义汇率</li>
<li>P：美国一篮子物品与劳务的消费物价指数</li>
<li>P^*：国外一篮子物品与劳务的消费物价指数</li>
</ul>
</li>
<li>一国的真实汇率是其物品与劳务净出口的关键决定因素</li>
</ul>
<p>6.第一种汇率决定理论：购买力平价</p>
<ul>
<li>购买力平价：一种认为任何一单位通货应该在所有国家买到等量物品的汇率理论</li>
<li>告诉我们，两国通货之间的名义汇率取决于这两个国家的物价水平</li>
<li>如果1美元的购买力在国内和国外总是相同的，那么，真实汇率——国内物品和国外物品的相对价格——就不会改变</li>
<li>根据购买力平价理论，两国通货之间的名义汇率必然反映这两个国家的物价水平。（货币量）<br>购买力平价理论不总成立的两个原因：<ul>
<li>（1）许多物品是不容易进行贸易的</li>
<li>（2）即使是可贸易物品，当它们在不同国家生产时，也并不总能完成全替代</li>
</ul>
</li>
</ul>
<h2 id="第32章-开放经济的宏观经济理论"><a href="#第32章-开放经济的宏观经济理论" class="headerlink" title="第32章 开放经济的宏观经济理论"></a>第32章 开放经济的宏观经济理论</h2><p>1.在均衡利益时，人们想储蓄的量正好与合意的国内投资和资本净流出量平衡（可贷资金市场）</p>
<ul>
<li>在均衡的真实汇率时，由美国物品与劳务净出口所引起的外国人对美元的需求正好与美国资本净流出所引起的来自美国人的美元供给相平衡（外汇市场）</li>
<li>S＝I＋NCO</li>
<li>NCO＝NX</li>
</ul>
<p>2.在一个开放经济中，政府预算赤字提高了真实利率，挤出来国内投资，引起美元升值，并使贸易余额倾向于赤字</p>
<p>3.贸易政策并不影响贸易余额</p>
<ul>
<li>因此，贸易政策的微观经济影响大于宏观经济影响</li>
</ul>
<p>4.资本外逃：一国资产需求大量且突然减少</p>
<ul>
<li>导致利率上升，而通货贬值</li>
</ul>
<hr>
<h1 id="第十二篇-短期经济波动"><a href="#第十二篇-短期经济波动" class="headerlink" title="第十二篇 短期经济波动"></a>第十二篇 短期经济波动</h1><h2 id="第33章-总需求与总供给"><a href="#第33章-总需求与总供给" class="headerlink" title="第33章 总需求与总供给"></a>第33章 总需求与总供给</h2><p>1.衰退、萧条</p>
<ul>
<li>衰退：真实收入下降和失业增加的时期</li>
<li>萧条：严重的衰退</li>
</ul>
<p>2.关于经济波动的三个关键事实</p>
<ul>
<li>经济波动时无规律的且不可预测的</li>
<li>大多数宏观经济变量同时波动</li>
<li>随着产量减少，失业增加</li>
</ul>
<p>3.总需求与总供给模型：大多数经济学家用来解释经济活动围绕其长期趋势的短期波动大模型</p>
<ul>
<li>总需求曲线：表示在每一种物价水平时，家庭、企业、政府和外国客户想要购买的物品与劳务数量的曲线</li>
<li>总供给曲线：表示在每一种物价水平时，企业选择生产并销售的物品与劳务数量的曲线</li>
</ul>
<p>4.总需求曲线</p>
<ul>
<li>向右下方倾斜的原因：<ul>
<li>（1）物价水平与消费：财富效应。物价水平下降提高了货币的真实价值，并使消费者富有，这又鼓励他们更多地支出。消费者支出增加意味着物品与劳务需求量更大，反之亦然</li>
<li>（2）（重要）物价水平与投资：利率效应。物价水平下降降低了利率，鼓励更多的用于投资品的支出，从而增加了物品与劳务的需求量，反之亦然</li>
<li>（3）物价水平与净出口：汇率效应。当美国物价水平下降引起美国利率下降时，美元在外汇市场上的真实价值下降了。这种贬值刺激了美国净出口，从而增加了物品雨劳务的需求量，反之亦然</li>
</ul>
</li>
<li>总需求曲线移动原因：（1）消费；（2）投资；（3）政府购买；（4）净出口引起</li>
</ul>
<p>5.总供给曲线：在长期中，总供给曲线是垂直的；而在短期中，总供给曲线向右上方倾斜</p>
<ul>
<li>长期垂直：在长期，一个经济的物品与劳务生产（真实GDP）取决于它的劳动、资本和自然资源的供给，以及可得到的用语把这些生产要素变为物品与劳务的生产技术</li>
<li>自然产量率：一个经济在长期中当失业处于其正常率时达到的物品与劳务的生产</li>
<li>长期总供给曲线移动的原因：（1）劳动变动；（2）资本变动；（3）自然资源变动；（4）技术知识变动</li>
<li>短期总供给曲线向右上方倾斜解释：（1）黏性工资；（2）黏性价格；（3）对相对价格对错觉</li>
<li>预期物价水平上升减少了物品与劳务的供给量，并使短期总供给曲线向左移动，预期物价水平下降的增加了物品与劳务的供给量，并使短期总供给曲线向右移动</li>
</ul>
<p>6.关于总需求移动的情形有三个重要结论：</p>
<ul>
<li>（1）在短期中，总需求移动引起经济中物品与劳务产量的波动</li>
<li>（2）在长期中，总需求移动影物价总水平，但不影响产量</li>
<li>（3）影响总需求的决策者可以潜在地减缓经济波动的严重性</li>
</ul>
<p>7.关于总供给曲线移动的情形有两个重要结论：</p>
<ul>
<li>（1）总供给移动会引起滞涨——衰退（产量减少）与通货膨胀（物价上升）的结合</li>
<li>（2）那些能影响总需求的决策可以潜在地减缓对产量的不利影响，但是只能是以加剧通货膨胀问题为代价</li>
</ul>
<h2 id="第34章-货币政策和财政政策对总需求的影响"><a href="#第34章-货币政策和财政政策对总需求的影响" class="headerlink" title="第34章 货币政策和财政政策对总需求的影响"></a>第34章 货币政策和财政政策对总需求的影响</h2><p>1.流动性偏好理论：凯恩斯的理论，认为利率的调整使货币供给与货币需求平衡</p>
<ul>
<li>当美联储增加货币供给时，它降低了利率，增加了既定物价水平时的物品与劳务需求量，使总需求曲线向右移动。反之亦然</li>
<li>既可以根据货币供给，也可以根据利率来描述货币政策</li>
<li>旨在扩大总需求的货币政策变动既可以被描述为货币供给增加，也可以被描述为利率降低。反之亦然</li>
</ul>
<p>2.财政政策：政府决策者对政府支出和税收水平的确定</p>
<ul>
<li>乘数效应：当扩张性财政政策增加了收入，从而增加了消费支出时一切的总需求的额外变动</li>
<li>边际消费倾向（MPC）：家庭额外收入中用于消费的比例</li>
<li>乘数＝1＋MPC＋MPC^2＋……＝1/(1-MPC)</li>
<li>挤出效应：当扩张性财政政策引起利率上升，从而减少了投资支出时所引起的总需求减少</li>
<li>自动稳定器：当经济进入衰退时，决策者不必采取任何有意的行动就可以刺激总需求的财政政策变动</li>
</ul>
<h2 id="第35章-通货膨胀与失业之间的短期权衡取舍"><a href="#第35章-通货膨胀与失业之间的短期权衡取舍" class="headerlink" title="第35章 通货膨胀与失业之间的短期权衡取舍"></a>第35章 通货膨胀与失业之间的短期权衡取舍</h2><p>1.菲利普斯曲线：一条表示通货膨胀与失业之间短期权衡取舍的曲线</p>
<ul>
<li>菲利普斯曲线说明了，短期中出现的通货膨胀与失业的组合是犹豫总需求曲线的移动使经济沿着短期总供给曲线变动</li>
</ul>
<p>2.自然率假说：认为无论通货膨胀率如何，失业最重要回到其正常率或自然率的观点</p>
<p>3.供给冲击：直接改变企业的成本和价格，使经济中的总供给曲线移动，进而使菲利普斯曲线移动的事件</p>
<p>4.牺牲率：在通货膨胀减少一个百分点的过程中每年产量损失的百分点数，一半为5</p>
<ul>
<li>理性预期：当人们在预测未来时，可以充分运用它们所拥有的全部信息，包括有关政府政策的信息理论</li>
<li>反通货膨胀的时代取决于通货膨胀预期下降的速度。一些经济学家认为，可信任的第通货膨胀承诺可以通过引起预期的迅速调整而降低反通货膨胀的代价</li>
</ul>
<hr>
<h1 id="第十三篇-最后的思考"><a href="#第十三篇-最后的思考" class="headerlink" title="第十三篇 最后的思考"></a>第十三篇 最后的思考</h1><h2 id="第36章-宏观经济政策的五个争论问题"><a href="#第36章-宏观经济政策的五个争论问题" class="headerlink" title="第36章 宏观经济政策的五个争论问题"></a>第36章 宏观经济政策的五个争论问题</h2><p>1.货币政策与财政政策决策者应该试图稳定经济吗</p>
<ul>
<li>支持：认为经济本 hi 上时不稳的，并相信政府可以管理总需求，以便抵消内在掉不稳定性</li>
<li>批评：政策对经济的影响存在时滞，而且我们预期未来经济状况的能力是很差的，因此，稳定经济的努力可能以使经济不稳定而告终</li>
</ul>
<p>2.货币政策应该按规则制定二不是相机抉择</p>
<ul>
<li>支持：相机抉择的政策会饱受缺乏能力、滥用权力和政策前后不一致之苦</li>
<li>批评：相机抉择的政策在变化着的季节环境做出反应时较为灵活</li>
</ul>
<p>3.中央银行应该把零通货膨胀作为目标吗</p>
<ul>
<li>支出：通货膨胀有许多成本，而且即使有好处也很少。此外，消除通货膨胀的代价——压低产量和就业——知识暂时的。如果中央银行宣布一项可信的降低通货膨胀的计划，从而直接降低通货膨胀的预期，那么甚至连这种代价也可以减少</li>
<li>批评：温和的通货膨胀给社会带来很小的成本，而降低通货膨胀所必需的衰退则代价高昂</li>
</ul>
<p>4.政府应该平衡其预算吗</p>
<ul>
<li>支持：预算赤字通过增加子孙后代的税收并减少他们的收入而把不公正的负担加在他们身上</li>
<li>批评：赤字只是财政政策的一小部分</li>
</ul>
<p>5.应该为了鼓励储蓄而修改税法吗</p>
<ul>
<li>支持：我们的社会用许多方法抑制储蓄，例如对资本收入征收重税和减少那些积累了财富的人享有的补助</li>
<li>批评：许多刺激储蓄的变动主要是使富人受益，而这些富人并不需要减税。这种变化对私人储蓄只有微小的影响。通过降低政府预算赤字来增加公共储蓄可以提供更直接，更平等地增加国民储蓄的方法</li>
</ul>
]]></content>
      <categories>
        <category>「笔记」- 读书</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>《经济学原理》笔记（微观经济学）</title>
    <url>/2019/04/01/Microeconomics-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>曼昆笔下的经典</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<ul>
<li>作者：尼可拉斯·格里高利·曼昆（N. Gregory Mankiw）  </li>
<li>出版社：北京大学出版社 </li>
<li><a href="/2019/04/02/Macroeconomics-Notes/">宏经笔记</a></li>
</ul>
<hr>
<p><strong>微观经济学部分</strong></p>
<h1 id="第一篇-导言"><a href="#第一篇-导言" class="headerlink" title="第一篇 导言"></a>第一篇 导言</h1><h2 id="第1章-经济学十大原理"><a href="#第1章-经济学十大原理" class="headerlink" title="第1章 经济学十大原理"></a>第1章 经济学十大原理</h2><p>1.原理一：人们面临权衡取舍</p>
<p>2.原理二：某种东西的成本是为了得到它所放弃的东西</p>
<ul>
<li>机会成本（opportunity cost）：为了得到这种东西所放弃的东西</li>
</ul>
<p>3.原理三：理性人考虑边际量</p>
<ul>
<li>用边际变动来描述对现有行动计划的微小增量调整</li>
<li>当且仅当一种行为的边际利益大于边际利益的撒与边际成本时，一个理性决策者才会采取这种行为</li>
</ul>
<p>4.原理四：人们会对激励做出反应</p>
<ul>
<li>激励（incentive）：引起一个人做出某种行为的某种东西，诸如惩罚或奖励的预期</li>
</ul>
<p>5.原理五：贸易可以使每个人的状况都变得更好</p>
<p>6.原理六：市场通常是组织经济活动的一种好方法</p>
<p>7.原理七：政府有时可以改善市场效果</p>
<p>8.原理八：一国的生活水平取决于它生产物品与劳务的能力</p>
<ul>
<li>生产率：每一单位劳动投入所生产的物品与劳务数量</li>
</ul>
<p>9.原理九：当政府发行了过多货币时，物价上升</p>
<p>10.原理十：社会面临通货膨胀与失业之间的短期权衡取舍</p>
<ul>
<li>短期内：货币量上升→社会整体支出水平上升→物品与劳务需求上升→失业下降</li>
</ul>
<h2 id="第2章-像经济学家一样思考"><a href="#第2章-像经济学家一样思考" class="headerlink" title="第2章 像经济学家一样思考"></a>第2章 像经济学家一样思考</h2><p>1.模型一：循环流量图</p>
<p>2.模型二：生产可能性边界：一个图形，表明在生产要素和生产技术既定时，一个经济所能生产的产品的数量的各种组合</p>
<p>3.微观经济学：研究家庭和企业如何做出决策，以及它们如何在特定市场上相互交易</p>
<p>4.宏观经济学：研究整体经济现象</p>
<h2 id="第3章-相互依存性与贸易的好处"><a href="#第3章-相互依存性与贸易的好处" class="headerlink" title="第3章 相互依存性与贸易的好处"></a>第3章 相互依存性与贸易的好处</h2><p>1.绝对优势：用比另一个生产者更少的投入生产某种物品的能力</p>
<p>2.比较优势：一个生产者以低于另一个生产者的机会成本生产一种物品的行为</p>
<ul>
<li>一个人不可能在两种物品的生产商都拥有比较优势，因为倒数</li>
<li>专业化和贸易的好处不是基于绝对优势，而是基于比较优势</li>
</ul>
<p>3.贸易可以使社会上每个人都获益，因为它使人们可以专门从事他们具有比较优势的活动</p>
<p>4.对从贸易中获益的双方而言，他们进行贸易的价格是在两种机会成本之间</p>
<p>5.进口品与出口品</p>
<ul>
<li>进口品：在国外生产而在国内销售的物品。</li>
<li>出口品：在国内生产而在国外销售的物品。</li>
</ul>
<hr>
<h1 id="第二篇-市场如何运行"><a href="#第二篇-市场如何运行" class="headerlink" title="第二篇 市场如何运行"></a>第二篇 市场如何运行</h1><h2 id="第4章-供给与需求的市场力量"><a href="#第4章-供给与需求的市场力量" class="headerlink" title="第4章 供给与需求的市场力量"></a>第4章 供给与需求的市场力量</h2><p>1.市场、竞争市场</p>
<ul>
<li>市场：由某种物品或劳务的买者与卖者组成的一个群体</li>
<li>竞争市场：有许多买者与卖者，以至于每个人对市场的影响都微乎其微的市场<br>完全竞争假设：<ul>
<li>（1）可供销售的物品时完全一样的；</li>
<li>（2）买者和卖者人数众多；</li>
</ul>
</li>
</ul>
<p>2.需求量</p>
<ul>
<li>需求量：买者愿意并且能够购买的一种物品的数量</li>
<li>需求定理：认为在其他条件不变时，一种物品的价格上升，对该物品的需求量减少的观点</li>
<li>需求表：表示一种物品的价格与需求量之间关系的表格</li>
<li>需求曲线：表示一种物品的价格与需求量之间关系的图形</li>
<li>影响买者的变量：价格、收入、相关物品的价格、嗜好、预期、买者的数量</li>
</ul>
<p>3.总收益：一种物品的买者支付从而卖者得到的量，用该物品的价格乘以销量来计算（P×Q）</p>
<ul>
<li>一般规律：<ul>
<li>①当需求缺乏弹性（价格弹性小于1）时，价格和总收益同方向变动；</li>
<li>②当需求富有弹性（价格弹性大于1）时，价格和总收益反方向变动；</li>
<li>③如果需求是单位弹性的（价格弹性正好等于1），当价格变动时，总收益不变</li>
</ul>
</li>
</ul>
<p>4.在一条需求曲线上各店的需求价格弹性不一定是相同的</p>
<p>5.需求收入弹性=需求量变动百分比/收入变动百分比</p>
<ul>
<li>衡量一种物品需求量对消费者收入变动反应程度的指标</li>
</ul>
<p>6.需求的较差价格弹性=物品1的需求量变动百分比/物品2的价格变动百分比</p>
<ul>
<li>衡量一种物品需求量对另一种物品价格变动的反应程度的指标</li>
</ul>
<p>7.供给价格弹性=供给量变动百分比/价格变动百分比</p>
<ul>
<li>衡量一种物品供给量对其价格变动反应程度的指标</li>
<li>取决于卖者改变他们所生产的物品量的灵活性</li>
</ul>
<h2 id="第6章-供给、需求与政府决策"><a href="#第6章-供给、需求与政府决策" class="headerlink" title="第6章 供给、需求与政府决策"></a>第6章 供给、需求与政府决策</h2><p>1.价格上限与价格下限</p>
<ul>
<li>价格上限：出售一种物品的法定最高价格</li>
<li>价格下限：出售一种物品的法定最低价格</li>
</ul>
<p>2.当政府对竞争市场实行限制性价格上限时，就产生了物品的短缺，而且，卖着必须在大量潜在买者中配给稀缺物品</p>
<p>3.限制价格下限引起了过剩</p>
<p>4.税收归宿：税收负担在市场参与者之间进行分配的方式</p>
<ul>
<li>税收抑制了市场活动。当对一种物品征税时，该物品在新平衡时的销量减少了</li>
<li>买者与卖者分摊了税收负担。在新均衡时，买者为该物品支付的更多了，而卖者得到的更少了</li>
<li>对买者征税和对卖者征税是相同的。无论向谁征税，一旦市场达到新均衡，都是买者与卖者分摊税收负担</li>
</ul>
<p>5.一般结论：税收负担更多地落在缺乏弹性的市场一方身上</p>
<ul>
<li>因为市场的这一方较难通过改变购买量或销售量做出反应</li>
<li>税收归宿取决于攻击和需求的价格弹性</li>
</ul>
<hr>
<h1 id="第三篇-市场和福利"><a href="#第三篇-市场和福利" class="headerlink" title="第三篇 市场和福利"></a>第三篇 市场和福利</h1><h2 id="第7章-消费者、生产者与市场效率"><a href="#第7章-消费者、生产者与市场效率" class="headerlink" title="第7章 消费者、生产者与市场效率"></a>第7章 消费者、生产者与市场效率</h2><p>1.福利经济学：研究资源配置如何影响经济福利的一门学问</p>
<p>2.支付意愿、消费者剩余</p>
<ul>
<li>支付意愿：买者愿意为某种物品支付的最高量</li>
<li>消费者剩余：买者愿意为一种物品支付的量减去为此实际支付的量</li>
<li>需求曲线一下和价格以上的面积衡量一个市场上的消费者剩余</li>
</ul>
<p>3.成本、生产者剩余</p>
<ul>
<li>成本：卖者为了生产一种物品而必须放弃的每种东西的价值</li>
<li>生产者剩余：卖者出售一种物品得到的量减去其生产成本</li>
<li>价格之下和供给曲线以上的面积衡量一个市场上的生产者剩余</li>
</ul>
<p>4.总剩余=消费者剩余+生产者剩余=（买者的评价-买者支付的量）+（卖者得到的量-卖者的成本）=买者的评价-卖者的成本</p>
<ul>
<li>效率：资源配置使社会所有成员得到的总剩余最大化的性质</li>
<li>平等：在社会成员中平均地分配经济成果的特性</li>
</ul>
<p>5.自由市场</p>
<ul>
<li>自由市场吧物品的供给分配给对这些物品评价最高的买者，这种评价用买者的支付意愿来衡量</li>
<li>自由市场将物品需求分配给能够以最低成本生产这些商品的卖者</li>
<li>自由市场生产出使消费者剩余和生产者剩余的综合最大化的物品量</li>
</ul>
<h2 id="第8章-应用：赋税的代价"><a href="#第8章-应用：赋税的代价" class="headerlink" title="第8章 应用：赋税的代价"></a>第8章 应用：赋税的代价</h2><p>1.税收收入=税收规模×销售量（T×Q）</p>
<p>2.买者和卖者因税收遭受的损失大于政府筹集到的收入</p>
<ul>
<li>无谓损失：市场扭曲（如税收）引起的总剩余减少</li>
<li>税收引起无谓损失是因为它使买者和卖者不能实现某些贸易的好处</li>
</ul>
<p>3.供给和需求的弹性越大，税收的无谓损失也越大</p>
<ul>
<li>税收的无谓损失的增加要快于税收规模的加大</li>
<li>由于税收减少了市场规模，税收收入不会一致增加。税收收入起初随着税收规模的扩大而增加，但如果税收规模足够大，税收收入就会开始下降</li>
</ul>
<h2 id="第9章-国际贸易"><a href="#第9章-国际贸易" class="headerlink" title="第9章 国际贸易"></a>第9章 国际贸易</h2><p>1.世界的价格：一种物品在世界上所通行的价格</p>
<p>2.对出口国分析：</p>
<ul>
<li>当一国允许贸易并成为一种物品的出口者时，国内该物品生产者的状况变好了，而国内该物品的消费者的状况变坏了</li>
<li>从赢家收益超过了输家损失的意义上说，贸易使一国的经济福利增加了</li>
</ul>
<p>3.从进口国分析：</p>
<ul>
<li>当一国允许贸易并成为一种物品的进口者时，国内该物品消费者的状况变好了，而国内该物品生产者的状况变坏了</li>
<li>从赢家收益超过输家损失的意义上说，贸易使一国的经济福利增加了</li>
</ul>
<p>4.关税：对在国外生产而在国内销售的物品征收的一种税</p>
<ul>
<li>关税减少了进口量，并使国内市场向没有贸易时的均衡移动</li>
<li>由于关税提高了国内价格，国内卖者的状况变好了，而国内买者的状况变坏了。此外，政府收入增加了。</li>
</ul>
<p>5.国际贸易的其他好处</p>
<ul>
<li>增加了物品的多样性</li>
<li>通过规模经济降低了成本：一些物品只有大量生产时，才能以低成本生产，这种现象被称为规模经济</li>
<li>增加了竞争</li>
<li>加强了思想交流</li>
</ul>
<p>6.各种限制贸易的观点</p>
<ul>
<li>工作岗位论</li>
<li>国家安全论</li>
<li>幼稚产业论</li>
<li>不公平竞争性</li>
<li>作为讨价还价筹码的保护论</li>
</ul>
<hr>
<h1 id="第四篇-公共部门经济学"><a href="#第四篇-公共部门经济学" class="headerlink" title="第四篇 公共部门经济学"></a>第四篇 公共部门经济学</h1><h2 id="第10章-外部性"><a href="#第10章-外部性" class="headerlink" title="第10章 外部性"></a>第10章 外部性</h2><p>1.外部性：一个人的行为对旁观者福利的无补偿的影响</p>
<ul>
<li>正外部性，负外部性</li>
<li>外部性内在化：改变激励，已使人们考虑到自己行为的外部效应</li>
</ul>
<p>2.负的外部性使市场生产的数量大于社会合意的数量，正外部性使市场生产的数量小于社会合意的数量。为了解决这个问题，政府可以通过对有负外部性的物品征税并给予正外部性的物品补贴来使外部性内在化。</p>
<p>3.针对外部性的公共政策：</p>
<ul>
<li>命令与控制政策直接对行为进行管制</li>
<li>以市场为基础的政策提供激励，以促使私人决策者自己来解决问题</li>
</ul>
<p>4.矫正税：旨在引导私人决策者考虑负外部性引起的社会成本的税收</p>
<p>5.科斯定理：认为如果私人各方可以无成本的就资源配置进行协商，那么他们就可以自己解决外部性问题的一个命题</p>
<ul>
<li>科斯定理说明，私人经济主体可以解决他们之间的外部性问题。无论最初的权利如何分配，有关各方总可以达成一种协议，在这种协议中，每个人的状况都可以变好，而且，结果是有效率</li>
</ul>
<p>6.交易成本：各方在达成协议与遵守协议过程中所发生的成本</p>
<h2 id="第11章-公共物品和公共资源"><a href="#第11章-公共物品和公共资源" class="headerlink" title="第11章 公共物品和公共资源"></a>第11章 公共物品和公共资源</h2><p>1.排他性、竞争性</p>
<ul>
<li>排他性：一种物品具有可以阻止一个人使用该物品特性</li>
<li>消费中的竞争性：一个人使用一种一种物品将减少其他人对该物品的使用的特性<ul>
<li>①私人物品：既有排他性又有竞争性的物品</li>
<li>②公共物品：既无排他性又无竞争性的物品</li>
<li>③公共资源：有竞争性但无排他性的物品</li>
<li>④俱乐部物品：有排他性但无竞争性的物品</li>
</ul>
</li>
</ul>
<p>2.公共物品</p>
<ul>
<li>搭便车者：得到一种物品的利益但避免为此付费的人</li>
<li>三种最重要的公共物品：国防、基础研究、反贫困</li>
</ul>
<p>3.公共资源</p>
<ul>
<li>公地悲剧：一个寓言，说明从整个社会的角度看，为什么公共资源的使用大于合意的水平</li>
<li>一些重要的公共资源：清洁的空气和谁，拥挤的道路，鱼、鲸和其他野生动物</li>
</ul>
<p>4.在所有的情况下，市场没有有效地配置次元，是因为没有很好地建立产权。这就是说，某些有价值的东西并没有在法律上有权控制它的所有者</p>
<h2 id="第12章-公共物品和公共资源"><a href="#第12章-公共物品和公共资源" class="headerlink" title="第12章 公共物品和公共资源"></a>第12章 公共物品和公共资源</h2><p>1.预算赤字、预算盈余</p>
<ul>
<li>预算赤字：政府支出大于政府收入</li>
<li>预算盈余：政府收入大于政府支出</li>
</ul>
<p>2.联邦政府</p>
<ul>
<li>收入：个人所得税、社会保障税、公司所得税、其他</li>
<li>支出：社会保障、国防、收入保障、医疗保障、保健、净利息、其他</li>
</ul>
<p>3.州与地方政府</p>
<ul>
<li>收入：销售税、财产税、个人所得税、公司所得税、联邦政府</li>
<li>支出：教育、公共福利、高速公路、其他</li>
</ul>
<p>4.平均税率、边际税率</p>
<ul>
<li>平均税率：支付的总税收除以总收入</li>
<li>边际税率：增加1美元收入所支付的额外税收</li>
</ul>
<p>5.定额税：对每个人等量征收的税收</p>
<p>6.征税原则</p>
<ul>
<li>收益原则：认为人们应该根据他们从政府服务中得到的利益来纳税的思想</li>
<li>支付能力能力原则：认为应该根据一个人可以承受的负担来对这个人征税的思想</li>
<li>支付能力原则得出两个推论：纵向平等、横向平等</li>
<li>纵向平等：主张支付能力更强的纳税人应该缴纳更多税收的思想</li>
<li>横向平等：主张有相似支付能力的纳税人应该缴纳等量税收的思想</li>
<li>比例税：高收入纳税人和低收入纳税人缴纳收入中相同比例的税收</li>
<li>累退税：高收入纳税人缴纳的税收在收入中的比例低于低收入纳税人的税收</li>
<li>累进税：高收入纳税人缴纳的税收在收入中的比例高于低收入纳税人的税收</li>
</ul>
<hr>
<h1 id="第五篇-企业行为与产业组织"><a href="#第五篇-企业行为与产业组织" class="headerlink" title="第五篇 企业行为与产业组织"></a>第五篇 企业行为与产业组织</h1><h2 id="第13章-生产成本"><a href="#第13章-生产成本" class="headerlink" title="第13章 生产成本"></a>第13章 生产成本</h2><p>1.收益、成本</p>
<ul>
<li>总收益：企业出售其产品所得到的货币量</li>
<li>总成本：企业用于生产的投入品的市场价值</li>
<li>利润：总收益减去总成本</li>
<li>显性成本：需要企业支出货币的投入成本</li>
<li>隐性成本：不需要企业支出货币的投入成本</li>
<li>经济利润：总收益减总成本，包括显性成本和隐性成本</li>
<li>会计成本：总收益减总显性成本</li>
</ul>
<p>2.生产函数、边际量</p>
<ul>
<li>生产函数：用于生产一种物品的投入量与该物品产量之间的关系</li>
<li>边际产量：增加一单位投入所引起的产量增加</li>
<li>边际产量递减：一种投入的边际产量随着投入量增加而减少的特征</li>
</ul>
<p>3.成本</p>
<ul>
<li>固定成本：不随着产量变动而变动的成本</li>
<li>可变成本：随着产量变动而变动的成本</li>
<li>平均总成本：总成本除以产量，ATC=TC/Q</li>
<li>平均固定成本：固定成本除以产量，AFC</li>
<li>平均可变成本：可变成本除以产量，AVC</li>
<li>边际成本：额外一单位产量所引起的总成本的增加，MC=ΔTC/ΔQ</li>
<li>有效规模：是平均总成本最小的产量</li>
<li>只要边际成本小于平均成本，平均成本就下降；只要边际成本大于平均总成本，平均总成本就上升</li>
<li>边际成本曲线与平均总成本曲线相较于有效规模点</li>
<li>一个典型企业的成本曲线特征：<ul>
<li>①随着产量增加，边际成本最终要上升；</li>
<li>②平均成本总是U形的；</li>
<li>③边际成本曲线与平均成本曲线</li>
</ul>
</li>
</ul>
<p>4.规模经济</p>
<ul>
<li>规模经济：长期平均总成本随产量增加而减少的特性</li>
<li>规模不经济：长期平均总成本随产量增加而增加的特性</li>
<li>规模收益不变：长期平均总成本在产量变动时保持不变的特性</li>
<li>规模经济的产生式因为较高的产量水平允许在工人中实现专业化，而专业化可以使工人更精通某一项工作</li>
<li>规模不经济的产生是由于任何一个大型组织中固有的协调问题</li>
</ul>
<h2 id="第14章-竞争市场上的企业"><a href="#第14章-竞争市场上的企业" class="headerlink" title="第14章 竞争市场上的企业"></a>第14章 竞争市场上的企业</h2><p>1.竞争市场：有许多交易相同产品的买者和卖者，以至于每一个买者和卖者都是价格接受者的市场</p>
<ul>
<li>有时称为完全竞争市场</li>
<li>特点：<ul>
<li>①市场上有许多买者和许多卖者；</li>
<li>②各个卖者提供的物品大体上是相同的；</li>
<li>③企业可以自由地进入或退出市场</li>
</ul>
</li>
</ul>
<p>2.对所有企业而言，平均收益等于物品的价格；对竞争企业而言，边际收益等于物品的价格</p>
<p>3.利润最大化的三个一般规律：①如果边际收益大于边际成本，企业应该增加其产量；②如果边际成本大于边际收益，企业应该减少其产量；③在利润最大化的产量水平时，边际收益和边际成本正好相等</p>
<ul>
<li>在本质上，由于企业的边际成本曲线决定了企业在任何一种价格时愿意供给的物品数量，因此，边际成本曲线也是竞争企业的供给曲线</li>
</ul>
<p>4.停止经营、退出、沉没成本</p>
<ul>
<li>停止经营：短期决策，不可回避固定成本</li>
<li>退出：长期决策，可以回避固定成本</li>
<li>如果生产能得到的收益小于生产的可变成本，企业就会停止营业。竞争企业的短期供给曲线是边际成本曲线在平均可变成本曲线以上的那一部分</li>
<li>沉没成本：已经发生而且无法收回的成本</li>
<li>如果从生产中得到的收益小于他的总成本，企业就应退出市场。竞争企业的长期供给曲线是边际成本曲线位于平均总成本曲线之上的那一部分</li>
</ul>
<p>5.长期：有进入与退出的市场供给</p>
<ul>
<li>这种进入和退出过程结束时，仍然留在市场中的企业的经营利润必定为零。经营利润=（P-ATC）×Q</li>
<li>只有价格与平均总成本被推向相等时，进入与退出过程才结束</li>
<li>在可以自由进入与退出的竞争市场的长期均衡中，企业一定是在其有效规模上运营</li>
<li>由于企业在长期中必在短其中更容易进入和退出，所以长期供给曲线一般比短期供给曲线更富弹性</li>
</ul>
<p>6.需求变动在不同时间框架之内有不同影响</p>
<ul>
<li>在短期中，需求增加引起价格上升，并带来利润，而需求减少引起价格下降，并带来亏损</li>
<li>但如果企业可以自由进入和退出市场，那么，在长期中，企业数量自发调整，使市场回到零利润均衡</li>
</ul>
<h2 id="第15章-垄断"><a href="#第15章-垄断" class="headerlink" title="第15章 垄断"></a>第15章 垄断</h2><p>1.垄断企业：作为一种没有相近替代品的产品的唯一卖者的企业</p>
<ul>
<li>垄断垄断产生的根本原因：进入壁垒</li>
<li>进入壁垒有三个主要形成的原因：<ul>
<li>①资源垄断</li>
<li>②政府管制</li>
<li>③生产流程</li>
</ul>
</li>
</ul>
<p>2.自然垄断：由于一个企业能以低于两个或更多企业的成本向整个市场供给一种物品或劳务而产生的垄断</p>
<ul>
<li>随着市场的扩大，一个自然垄断市场可能会变成要给更具竞争性的市场</li>
</ul>
<p>3.垄断者的边际收益总是小于其他物品的价格</p>
<ul>
<li>当垄断者增加它销售数量时，这对总收益（P×Q）有种效应：①产量效应：Q增大，从而可能增加总收益；②价格效应：P降低，从而可能减少总收益</li>
<li>垄断者的利润最大化产量是由边际收益曲线与边际成本曲线的交点决定的</li>
<li>在竞争市场上，价格等于边际成本；在垄断市场上，价格大于边际成本</li>
</ul>
<p>4.垄断者生产的产量小于社会有效率的产量</p>
<p>5.价格歧视：以不同价格向不同顾客出售同一种物品的经营方。例子：电影票、飞机票价、折扣券、助学金、数量折扣。一般性结论：</p>
<ul>
<li>价格歧视是利润最大化垄断者的一种理性策略</li>
<li>价格歧视要求能根据支付意愿划分顾客。某些市场势力会阻止企业实现价格歧视（套利）</li>
<li>价格歧视可以增进经济福利</li>
</ul>
<p>6.政府决策者解决垄断四种方式：</p>
<ul>
<li>努力使垄断行业更有竞争性</li>
<li>管制垄断者行为</li>
<li>把一些私人垄断企业变为公有企业</li>
<li>不作为</li>
</ul>
<h2 id="第16章-垄断竞争"><a href="#第16章-垄断竞争" class="headerlink" title="第16章 垄断竞争"></a>第16章 垄断竞争</h2><p>1.不完全竞争：介于完全竞争和垄断的极端情况之间的某个位置。两种类型：</p>
<ul>
<li>①寡头：只有几个提供相似或相同产品的卖者的市场结构。集中效率：四家最大企业在市场总产量的百分比</li>
<li>②垄断竞争：存在许多出售相似但不相同产品的企业的市场结构。特性：1）许多卖者；2）产品差别；3）自由进入和退出</li>
</ul>
<p>2.垄断竞争市场上长期均衡的两个特点：</p>
<ul>
<li>正如在垄断市场上一样，价格大于边际成本</li>
<li>正如在计征市场上一样，价格等于平均总成本</li>
</ul>
<p>3.垄断竞争与完全竞争两个值得注意的差别：</p>
<ul>
<li>生产能力过剩</li>
<li>高于边际成本的价格加成</li>
</ul>
<p>4.垄断竞争市场并不具有完全竞争市场所具有的全部合意的福利特点，存在由高于边际成本的价格加成引起的垄断的标准无谓损失。实际上，决策者纠正这些无效率的能力是有限的</p>
<p>5.垄断竞争中固有的产品差别使企业使用广告与品牌。广告与品牌的批评者认为，企业用广告控制了消费者的偏好，并减少了竞争；广告与品牌的辩护辩护者则认为，企业用这些方向消费者提供信息，并使价格和产品质量的竞争更为激烈</p>
<h2 id="第17章-寡头"><a href="#第17章-寡头" class="headerlink" title="第17章 寡头"></a>第17章 寡头</h2><p>1.寡头：只有少数几个卖者提供相似或相同产品的市场结构</p>
<ul>
<li>博弈论：研究在策略状况下人们如何行为</li>
</ul>
<p>2.勾结、卡特尔、纳什均衡</p>
<ul>
<li>勾结：一个市场上的企业之间就生产的产量或收取的价格达成协议</li>
<li>卡特尔（cartel）：联合起来行事的企业集团</li>
<li>纳什均衡：相互作用的经济主体在假定所有其他主体所选策略为既定的情况下选择自己最优策略的状态</li>
<li>当寡头企业单独地选择利润最大化的产量时，它们生产的产量大于垄断但小于竞争的产量水平。寡头价格低于垄断价格，但高于竞争价格（竞争价格等于边际成本）</li>
</ul>
<p>3.随着寡头市场上卖者数量增加，寡头市场就越来越像竞争市场，其价格接近于边际成本，生产量接近于对社会有效率的水平</p>
<p>4.囚徒困境：两个被捕的囚徒之间的一种特殊“博弈”，说明为什么甚至在合作对双方都有利时，保持合作也是困难的</p>
<ul>
<li>占优策略：无论其他参与者选择什么策略，对一个参与者都为最优的策略</li>
<li>囚徒困境的其他例子：军备竞赛，公共资源</li>
</ul>
<p>５.决策者用饭托拉斯法来防止寡头从事减少竞争的行为。这些法律的适用性是有正义的，因为有些看来减少竞争的行为实际上可能有合理的经营目的</p>
<hr>
<h1 id="第六篇-劳动市场经济学"><a href="#第六篇-劳动市场经济学" class="headerlink" title="第六篇 劳动市场经济学"></a>第六篇 劳动市场经济学</h1><h2 id="第18章-生产要素市场"><a href="#第18章-生产要素市场" class="headerlink" title="第18章 生产要素市场"></a>第18章 生产要素市场</h2><p>１.生产要素：用于生产物品与劳务的投入。</p>
<ul>
<li>三大重要要素：劳动、土地、资本</li>
</ul>
<p>2.一个竞争性的，利润最大化企业雇佣的工人数要达到劳动的边际产量值等于工资的那一点</p>
<p>3.引起劳动需求曲线移动：产品价格、技术变革、其他要素的供给</p>
<p>4.引起劳动供给曲线移动：嗜好变动、可供选择的机会改变、移民</p>
<p>5.竞争市场上工资：</p>
<ul>
<li>①工资调整使劳动的供求平衡</li>
<li>②工资等于劳动的边际产量值</li>
<li>改变劳动供求的任何事件都必定使均衡工资和边际产量值等量变动，因为这两个量必定总是相等的</li>
</ul>
<p>6.资本：用于生产物品与劳动的设备和建筑物</p>
<h2 id="第19章-生产要素市场"><a href="#第19章-生产要素市场" class="headerlink" title="第19章 生产要素市场"></a>第19章 生产要素市场</h2><p>1.补偿性工资差别：为抵消不同工作的非货币特性而产生的工资差别</p>
<ul>
<li>人力资本：对人的投资的积累，如教育和在职培训</li>
</ul>
<p>2.工会、罢工、效率工资</p>
<ul>
<li>工会：与雇主谈判工资和工作条件的工人协会</li>
<li>罢工：工会有组织地从企业撤出劳动</li>
<li>效率工资：企业为了提高工人的生产率而支付的高于均衡工资的工资</li>
</ul>
<p>3.歧视：对仅仅由于种族、宗教、性别、年龄或其他个人特征不同的相似个人提供不同的机会</p>
<ul>
<li>竞争市场包含了一种能自发矫正雇主歧视的方法。只关心利润的企业进入市场倾向于消除歧视性工资差视。只有在顾客原以为维持歧视性做法进行支付或政府强制歧视时，竞争市场上的这种工资差别才能持续下去</li>
</ul>
<h2 id="第20章-收入不平等与贫困"><a href="#第20章-收入不平等与贫困" class="headerlink" title="第20章 收入不平等与贫困"></a>第20章 收入不平等与贫困</h2><p>1.通常的收入分配的判断标准是贫困率</p>
<ul>
<li>贫困率：家庭收入低于一个成为贫困线的绝对水平的人口百分比</li>
<li>贫困线：有联邦政府根据每个家庭规模决定的一种收入绝对水平，低于这一水平的家庭被认为处于贫困状态</li>
<li>事实：贫困与种族、年龄、家庭结构相关</li>
</ul>
<p>2.功利主义：一种政治哲学，根据这种政治哲学，政府应该选择使社会上所有人总效用最大化的政策</p>
<ul>
<li>效用：衡量幸福或满足程度的指标</li>
</ul>
<p>3.自由主义：一种政治哲学，根据这种政治哲学，政府应该选择必要的公正的政策。这种公正要由以为在“无知面纱”背后的无偏见者来评价</p>
<ul>
<li>最大最小准则：一种主张，认为政府的目标应该是使社会上状况最差的人的福利最大化</li>
<li>社会保险：旨在保护人们规避负面事件风险的政府政策</li>
</ul>
<p>4.自由至上主义：一种政治哲学，根据这种政治哲学，政府应该惩罚犯罪并实行自愿的协议，但不应该进行收入再分配</p>
<p>5.减少贫困的政策</p>
<ul>
<li>最低工资法</li>
<li>福利：补贴需要者收入的政府计划</li>
<li>负所得税：向高收入家庭征税并给低收入家庭补贴的税制</li>
<li>实物转移支付</li>
<li>反贫困计划和工作激励</li>
</ul>
<hr>
<h1 id="第七篇-深入研究的论题"><a href="#第七篇-深入研究的论题" class="headerlink" title="第七篇 深入研究的论题"></a>第七篇 深入研究的论题</h1><h2 id="第21章-消费者选择理论"><a href="#第21章-消费者选择理论" class="headerlink" title="第21章 消费者选择理论"></a>第21章 消费者选择理论</h2><p>1.预算约束线：对消费者可以支付得起的消费组合的限制</p>
<p>2.无差异曲线：一条表示给消费者相同满足程度的消费组合的曲线</p>
<ul>
<li>边际替代率：消费愿意以一种物品交换另一种物品的比率</li>
<li>无差异曲线的四个特征：①消费者对较高无差异曲线的偏好大于较低无差别曲线；②无差异曲线向下倾斜；③无差异曲线凸向原点</li>
<li>完全替代品：无差异曲线为直线的两种物品</li>
<li>完全互补品：无差异曲线为直角形的两种物品</li>
</ul>
<p>3.最优点：最高无差异曲线与预算约束线的切点</p>
<ul>
<li>消费者选择的两种物品组合要使边际替代率等于相对价格</li>
</ul>
<p>4.收入效应、替代效应</p>
<ul>
<li>收入效应：当一种价格变动使消费者移动到更高或更低无差异曲线时所引起的消费变动</li>
<li>替代效应：当一种价格变动使消费者沿着一条既定的无差异曲线变动到新边际替代率的一点时所引起的消费变动</li>
</ul>
<p>5.三种应用</p>
<ul>
<li>吉芬物品：价格上升引起需求量增加的物品</li>
<li>工资的影响：劳动供给曲线既可能向右上方倾斜，也可能向右下方倾斜</li>
<li>利率影响储蓄：利率上升，储蓄可增可减</li>
</ul>
<h2 id="第22章-微观经济学前沿"><a href="#第22章-微观经济学前沿" class="headerlink" title="第22章 微观经济学前沿"></a>第22章 微观经济学前沿</h2><p>1.信息不对称：获得知识的差别（隐蔽性行为，隐蔽性特例）</p>
<p>2.道德风险：一个没有收到完全监督的人从事不诚实或不合意行为的倾向</p>
<ul>
<li>代理人：一个为另一个人（称为委托人）完成某种行为的人</li>
<li>委托人：让另一个人（成为代理人）完成某种行为的人</li>
<li>雇主的反应：①更好地监督；②高工资；③延期支付</li>
</ul>
<p>3.逆向选择：从无信息一方的角度看，无法观察到的特征组合变为不合意的倾向</p>
<p>4.发信号、筛选</p>
<ul>
<li>发信号：有消息的一方向无信息的一方披露自己私人信息所采取的行为</li>
<li>筛选：无信息的一方所采取的引起有信息的一方披露信息的行动</li>
</ul>
<p>5.政治经济学：用经济学的分析方法研究政府</p>
<p>6.康多塞悖论：多数原则没有产生可传递的社会偏好</p>
<ul>
<li>侠义结论：当有两种以上的选择时明，确定议程会对民主选举结果又重大影响</li>
<li>广义结论：多数投票通过本身并没有告诉我们社会真正想要什么结果</li>
</ul>
<p>7.阿罗不可能性定理：一个数学结论，它表明在某些假设条件下，没有一种方案能把个人偏好加总为一组正确的社会偏好</p>
<p>8.中值选民定理：一个数学结论，表明如果要选民沿着一条线选一个点，而且，每个选民都想离他最偏好的点最近的点，那么，多数原则将选出中值选民最偏好的点</p>
<p>9.行为经济学：经济学中将心理学的观点考虑进来的分支学科</p>
<ul>
<li>人们犯下的系统性错误：①人们过分自信；②人们过分重视从现实生活中观察到的细枝末节；③人们不愿改变自己的观念</li>
<li>心理学和经济学的研究表明，人的决策比传统经济理论所假设的复杂。人们并不总是理性的，他们关心经济结果的公正性（即使对他们有不利的影响），而且，他们可能具有前后不一致性</li>
</ul>
]]></content>
      <categories>
        <category>「笔记」- 读书</category>
      </categories>
      <tags>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>Photography Basis Notes</title>
    <url>/2020/03/10/Photography-Basis-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>基础知识：查漏补缺总没错</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="色彩知识"><a href="#色彩知识" class="headerlink" title="色彩知识"></a>色彩知识</h1><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul>
<li><code>光</code>的一种特性<ul>
<li>电磁波中的可见光波段</li>
<li>不同颜色的本质是频率不同</li>
</ul>
</li>
<li><code>物质</code>的一种特性<ul>
<li>只反色自己颜色的光线，吸收其他颜色的光线</li>
<li>前提是入射光包含它自己的颜色</li>
</ul>
</li>
<li><code>人</code>的一种感觉<ul>
<li>环境：通过色彩环境判断（大脑对入射光的假设可能会有错觉）</li>
<li>时间：视觉暂留，跟上一时刻看到的颜色有关</li>
<li>同色对比识别：历史经验有关</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=k1rB1Y4isHs&list=PLhnwj_CftHvhwO8P0mytRNZzlgbtOvgf4" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="色彩模型"><a href="#色彩模型" class="headerlink" title="色彩模型"></a>色彩模型</h2><ul>
<li>如何描述颜色？<ul>
<li>色温法：建立在绝对黑体的概念上。<ul>
<li>低温：红色、黄色</li>
<li>高温：蓝色、白色</li>
<li>但仅能描述蓝色到黄色的变化，绿色到洋红的光线难以描述</li>
<li>色调：描述绿色到洋红</li>
<li>色温+色调对颜色的描述还是不足够准确，因此仅用于描述白平衡</li>
</ul>
</li>
</ul>
</li>
<li><code>HSB</code>模型<ul>
<li><code>H</code>：色相</li>
<li><code>S</code>：饱和度，颜色的纯度</li>
<li><code>B</code>：亮度</li>
<li>优点：与生活中的日常经验比较一致，容易理解</li>
<li>缺点：无法用于工程制造，难以找到某种材料精准控制这几种属性</li>
</ul>
</li>
<li><code>RGB</code>色彩模型<ul>
<li>Red、Green、Blue</li>
<li>用于：发光体制造、相机</li>
<li>优点：工程制造中只要控制三种颜色的亮度即可</li>
<li>缺点：仅能用于发光体</li>
</ul>
</li>
<li><code>CMYK</code>色彩模型<ul>
<li>青色<code>Cyan</code>、洋红<code>Magenta</code>、黄色<code>Yellow</code></li>
<li>用于：照片冲印、油墨印刷、打印机</li>
<li><code>RGB</code>、<code>CMYK</code>模型的局限：难以保证不同设备、不同厂商之间的颜色一致性；都是材料相关的</li>
</ul>
</li>
<li><code>Lab</code>色彩模型<ul>
<li>原意：试图摆脱颜色原材料对模型的影响，是纯数学的概念</li>
<li>横剖面：a绿色↔红色、b蓝色↔黄色</li>
<li>纵轴：L亮度</li>
<li>不能用于制造，仅用于数学描述颜色，可用于不同模型之间转换的中介</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=nBAXgf7NZIw" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="CMYK色彩模型"><a href="#CMYK色彩模型" class="headerlink" title="CMYK色彩模型"></a><code>CMYK</code>色彩模型</h2><ul>
<li>含义<ul>
<li><code>C</code>：青色，Cyan；只吸收红色</li>
<li><code>M</code>：洋红，Magenta；只吸收绿色</li>
<li><code>Y</code>：黄色，Yellow；只吸收蓝色</li>
<li><code>K</code>：黑色，Black</li>
</ul>
</li>
<li><code>GRB</code>是针对发光体的</li>
<li><code>CMYK</code>是针对反光的，反光体会吸收显色的所有颜色。</li>
<li>量加的越多，亮度越低</li>
<li><code>CMYK</code>通道下，颜色越深，代表墨水用的越多</li>
<li>用<code>黑色</code>墨水是从成本角度考虑，黑色很常用，不需要总是用CMY混合来做（对精度要求也高）</li>
<li><a href="https://www.youtube.com/watch?v=uVboug-wGGs" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="亮度矫正的Gamma"><a href="#亮度矫正的Gamma" class="headerlink" title="亮度矫正的Gamma"></a>亮度矫正的Gamma</h2><ul>
<li>Gamma：一种非线性的亮度信号的采集、非线性的亮度信号的还原</li>
<li>人眼：<ul>
<li>对亮度（灰阶）的感知曲线不是线性的</li>
<li>人眼感知到的50%的正灰色，一般对应18%的灰卡</li>
</ul>
</li>
<li>仪器：<ul>
<li>按照原始光强度采集→人眼看到的暗部点数少，人眼不敏感的亮部，采集点又过多</li>
</ul>
</li>
<li>解决方法：<ul>
<li>（1）等间距采样，提高采样点密度→raw格式图片<ul>
<li>给图片存储、处理带来大的挑战，不经济</li>
</ul>
</li>
<li>（2）非线性采样，人眼感受到等间距的灰阶→Gamma采样，jpeg图片</li>
</ul>
</li>
<li>而文件存储的是一个亮度序列，相应的，显示器也要非线性的显示该亮度序列，（反向的幂函数曲线）忠实得还原采集到的景象</li>
<li>Gamma即幂函数的角标，两条相反的幂函数曲线（采样+还原），实现线性的亮度采集和展示</li>
<li>常见Gamma如：<ul>
<li>办公环境：0.45/2.2</li>
<li>电源荧幕：0.38/1.8</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=Cbov0nhMDbY" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<hr>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><ul>
<li>离开画面光看直方图都是耍流氓</li>
<li>Raw格式宽容度比JPG高很多，拍摄时候不用过分在意临时预览时的高光警告</li>
<li><a href="https://www.youtube.com/watch?v=nUPxQLde8nc&list=PLhnwj_CftHvhwO8P0mytRNZzlgbtOvgf4&index=5" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="光圈和快门"><a href="#光圈和快门" class="headerlink" title="光圈和快门"></a>光圈和快门</h2><p>光圈和景深：</p>
<ul>
<li><code>光圈</code>：光通量；光圈的平方和进光量成反比</li>
<li>光圈越大，景深越小；产生的原因是人眼的弥散半径</li>
<li>拍摄距离越短，景深越小</li>
<li>焦距越长，景深越小</li>
<li>所以只有使用大光圈镜头，才能在不影响构图的情况下获得浅景深</li>
</ul>
<p>快门与曝光时间：</p>
<ul>
<li>快门结构：机械快门、电子快门</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=7bftNbx-E0k&list=PLhnwj_CftHvhwO8P0mytRNZzlgbtOvgf4&index=7" target="_blank" rel="noopener">讲解视频</a></p>
<hr>
<h1 id="构图相关"><a href="#构图相关" class="headerlink" title="构图相关"></a>构图相关</h1><h2 id="减法构图"><a href="#减法构图" class="headerlink" title="减法构图"></a>减法构图</h2><ul>
<li>目的：<ul>
<li>要有一个鲜明的主体</li>
<li>要把注意力引向主体</li>
<li>画面足够干净简洁</li>
</ul>
</li>
<li>拍照时三问吾身：<ul>
<li>这张照片主体是什么</li>
<li>如何把注意力集中到主体上</li>
<li>画面中还能减去什么</li>
</ul>
</li>
<li>突出主体的方法（构图）：<ul>
<li>布局：三分法、不同的视角（如仰拍）、引入不稳定因素……</li>
<li>大小：通过画面内元素大小的比较来突出主体</li>
<li>搭框：二次构图</li>
<li>光线：如逆光</li>
<li>汇聚：用线引道</li>
<li>焦点（景深）</li>
<li>重复：利用重复突出不重复的内容</li>
<li>延时（长曝光）</li>
<li>临态：捕捉临时状态</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=YqhSoriv6-c" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="后期评判标准"><a href="#后期评判标准" class="headerlink" title="后期评判标准"></a>后期评判标准</h2><ul>
<li>获得足够多的画面<code>细节</code><ul>
<li><code>细节</code>：落入<code>可见</code>范围内的对比度</li>
<li><code>亮度</code>：人对光强度的感受；弱光时，人眼对光强度变化的感知更敏感</li>
<li><code>对比度</code>：画面的亮度差</li>
<li><code>宽容度</code>：最大的对比度</li>
<li><code>“层次”</code>：对比度分辨率</li>
<li><code>“油润”</code>：对比度的致密变化</li>
</ul>
</li>
<li>保持<code>自然</code>的光影结构与颜色</li>
<li><a href="https://www.youtube.com/watch?v=uZQCa7pVsp0&list=PLhnwj_CftHvhwO8P0mytRNZzlgbtOvgf4&index=9" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="建立后期思路"><a href="#建立后期思路" class="headerlink" title="建立后期思路"></a>建立后期思路</h2><ul>
<li>问自己：怎样强化主体？</li>
<li>修正错误<ul>
<li>裁剪、拼接</li>
<li>去除噪声</li>
<li>调整曝光</li>
<li>纠正色偏</li>
<li>锐化</li>
</ul>
</li>
<li>突出主题<ul>
<li>恢复/隐藏细节</li>
<li>亮度重新分配</li>
<li>颜色重新分配</li>
</ul>
</li>
<li>个人风格<ul>
<li>色调</li>
<li>影调</li>
</ul>
</li>
<li>尽量还原人眼看到的真实</li>
<li><a href="https://www.youtube.com/watch?v=yHlasyGerbg&list=PLhnwj_CftHvhwO8P0mytRNZzlgbtOvgf4&index=10" target="_blank" rel="noopener">讲解视频1</a>、<a href="https://www.youtube.com/watch?v=4CPRwtzkFnU&list=PLhnwj_CftHvhwO8P0mytRNZzlgbtOvgf4&index=11" target="_blank" rel="noopener">讲解视频2</a></li>
</ul>
<hr>
<h1 id="器材相关"><a href="#器材相关" class="headerlink" title="器材相关"></a>器材相关</h1><h2 id="相机选择"><a href="#相机选择" class="headerlink" title="相机选择"></a>相机选择</h2><p>相机种类：</p>
<ul>
<li>按<code>光通路</code>来分：<ul>
<li><code>单反</code>：单一光路、所见即所得、成熟、省电、体积大</li>
<li><code>无反</code>（微单）：机身厚度小、耗电、现在可能画幅和镜头族规模不如微单，但应该是未来的主流</li>
<li><code>旁轴</code>：省电、存在视差、体积小、情怀</li>
</ul>
</li>
<li>按<code>传感器面积</code>来分：<ul>
<li><code>全画幅</code>：36x24 mm，画质更好，镜头焦距不需要折算，成本高</li>
<li><code>APS-C</code>：23.3x14.9（CANON），成本低，画质低，需要焦距折算</li>
<li>4/3英寸：17.3x13（Olympus）</li>
<li>1英寸：13.4x8.8（Sony Rx100）</li>
<li>1/2.3英寸：6.17x4.55（数码卡片机）</li>
<li>1/3英寸：6.17x4.55（iphone）</li>
<li><code>镜头焦距等效换算</code>：x1.6</li>
</ul>
</li>
<li>按<code>市场定位</code>来分：<ul>
<li><code>平衡机</code>：主流相机</li>
<li><code>像素机</code>：高像素，ISO微小下降</li>
<li><code>视频机</code>：Sony A7S M2为代表的，1000w像素</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=RqIRZ28zOfw&list=PLhnwj_CftHvhwO8P0mytRNZzlgbtOvgf4&index=6" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="镜头MTF曲线"><a href="#镜头MTF曲线" class="headerlink" title="镜头MTF曲线"></a>镜头MTF曲线</h2><p>MTF曲线 = 调制传递函数，Modular Transfer Function。广泛用于描述镜头成像素质。  </p>
<ul>
<li>横轴：距画面中心的距离，mm</li>
<li>纵轴：对比度的百分比，%</li>
<li>不同颜色曲线：对应不同线对（1mm内出现的黑白相间的条纹）<ul>
<li>实线：径向值，线对线的方向与就镜像方向相同</li>
<li>虚线：纵向值，线对线的方向与就镜像方向垂直</li>
<li>线对提高了，MTF曲线会下移</li>
</ul>
</li>
<li>MTF越高（上限100%），成像效果越好，反之则反</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=fWFN7pIruQk" target="_blank" rel="noopener">讲解视频</a></p>
]]></content>
      <categories>
        <category>「快门」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Photography</tag>
      </tags>
  </entry>
  <entry>
    <title>Photography Learn Notes</title>
    <url>/2019/10/15/Photography-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>主要是后期风格</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="后期风格"><a href="#后期风格" class="headerlink" title="后期风格"></a>后期风格</h1><h2 id="rkrkrk风"><a href="#rkrkrk风" class="headerlink" title="rkrkrk风"></a>rkrkrk风</h2><ul>
<li>低饱和，又不是纯黑白</li>
<li>分离色调：给整张图罩上冷色调<ul>
<li>阴影+蓝色</li>
</ul>
</li>
<li>HSL：<ul>
<li>明亮度：蓝色↓↓，天空变深邃</li>
<li>饱和度：杂七杂八的颜色↓，蓝色稍微↓，建筑相关的颜色不要↓太多</li>
</ul>
</li>
<li>曲线：<ul>
<li>RGB：暗部稍微抬起来一点，暗部会呈现出灰色的调子</li>
</ul>
</li>
<li>基本面板中：阴影看情况↑</li>
<li>如果画面偏青色，可以在红色曲线中，稍微抬一点点来中和</li>
<li><a href="https://www.bilibili.com/video/av82549357" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="日系"><a href="#日系" class="headerlink" title="日系"></a>日系</h2><ul>
<li>特点：<ul>
<li>肌肤极致干净</li>
<li>空气通透</li>
</ul>
</li>
<li>HSL调肤色，注意不要出现洋红</li>
<li>试一下把蓝原色色相左拉，偏青色，用来调整天空</li>
<li>调整环境色时候，可能影响到衣服，可以用蒙版抠掉衣服</li>
<li><a href="https://www.bilibili.com/video/av63366169" target="_blank" rel="noopener">参考视频1</a></li>
</ul>
<h2 id="光效感"><a href="#光效感" class="headerlink" title="光效感"></a>光效感</h2><ul>
<li>整体调整：曝光↑，白色↑，对比度↓，自然饱和度↑↑</li>
<li>镜像滤镜圈人物（圈的宽一点）：色温↑，色调↑（看皮肤），曝光↑，阴影↑</li>
<li>HSL：<ul>
<li>色相：紫色0，蓝色右 呈湖蓝</li>
<li>明亮度：对皮肤提亮，蓝色可适当↓</li>
<li>饱和度：皮肤↓，其他视情况</li>
</ul>
</li>
<li>自发光质感：复制图层，高斯模糊半径30，图层混合模式：柔光，不透明度70%</li>
<li>统一色调：新建图层，前景色选青蓝色，<code>Alt+Del</code>填充图层，蒙版，渐变调整蒙版（暗部不生效），黑色画笔涂抹人像</li>
<li>人造光：新建图层，<code>Alt+Del</code>填充黑色到图层，滤镜→灯光工厂，图层混合模式→滤色，<code>Ctrl+T</code>调整光效，不透明度调整</li>
<li><a href="https://www.bilibili.com/video/av11673847" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="日系街道调色"><a href="#日系街道调色" class="headerlink" title="日系街道调色"></a>日系街道调色</h2><ul>
<li>阴影↑↑，白色色阶↓，对比度↑（稍微加点层次），色温↓，曝光↑，鲜艳度↑</li>
<li>相机校准：蓝原色左滑→湖蓝色</li>
<li>HSL：<ul>
<li>饱和度：去洋红色、紫色，画面变干净；绿色↓，浅绿色↓，橙色↑一点点试试看。</li>
</ul>
</li>
<li>可不做锐化</li>
<li>降噪：大面积减少杂色，画面糊一些，会有动漫的感觉</li>
<li><a href="https://www.bilibili.com/video/av15448962" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="蓝色时间-温柔的蓝色"><a href="#蓝色时间-温柔的蓝色" class="headerlink" title="蓝色时间/温柔的蓝色"></a>蓝色时间/温柔的蓝色</h2><ul>
<li>蓝色时间：日出前、日落后</li>
<li>特点：街灯、车灯刚亮</li>
<li>相机校准：蓝色色相←，向青色调；绿原色色相可以试着→。过蓝的话可以试着用色温拉回来。</li>
<li>如果降低了整体饱和度，为了突出主题和氛围，可以在HSL中调高红、橙色的饱和度、亮度</li>
<li><a href="https://www.youtube.com/watch?v=ol2SXzVHjnE" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="电影感雨夜"><a href="#电影感雨夜" class="headerlink" title="电影感雨夜"></a>电影感雨夜</h2><ul>
<li>特点：<ul>
<li>引人共鸣</li>
<li>元素处在动态</li>
<li>画面质量高</li>
</ul>
</li>
<li>高光↓，阴影↑</li>
<li>色调曲线（也可色调分离）：高光中青色、暖色，阴影中蓝青色<ul>
<li>红色曲线：（下拉→青）阴影稍微下拉</li>
<li>蓝色曲线：阴影稍微上拉</li>
<li>绿色曲线：调氛围，只要一点点调整</li>
<li>RGB通道：暗部抬一点，提亮</li>
</ul>
</li>
<li>清晰度↑，鲜艳度↓一点点</li>
<li>裁剪：16:9、2.35:1</li>
<li><a href="https://www.bilibili.com/video/av59461978" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="蓝紫调夕阳逆光人像"><a href="#蓝紫调夕阳逆光人像" class="headerlink" title="蓝紫调夕阳逆光人像"></a>蓝紫调夕阳逆光人像</h2><ul>
<li>阴影↑，高光↓，自然饱和度↑↑。（剪影不这样）</li>
<li>色调分离：高光-红紫色，阴影-蓝色</li>
<li><a href="https://www.bilibili.com/video/av47883922" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="黑金风光"><a href="#黑金风光" class="headerlink" title="黑金风光"></a>黑金风光</h2><ul>
<li>思路：减少色相，只留红黄色，达到突出金光的目的。缺点：要求原片有大面积的灯光，风格千篇一律。</li>
<li>矫正，阴影↑，饱和度↑</li>
<li>HSL：<ul>
<li>饱和度：绿色、浅绿色、蓝色、紫色、洋红→0</li>
<li>色相：红色右拉，黄色左拉，达到画面统一橙色。（或者相机校准中，蓝原色色相左拉）</li>
</ul>
</li>
<li>色调分离/曲线：暗部增加蓝青色</li>
<li>提高对比度：渐变滤镜，压按四周，可选用范围遮罩工具</li>
<li><a href="https://www.bilibili.com/video/av38447794" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="星空"><a href="#星空" class="headerlink" title="星空"></a>星空</h2><ul>
<li>色温↓，色调看喜好</li>
<li>清晰度↑</li>
<li>径向滤镜竖向、横向，圈银河，内部清晰度↑，羽化值↑</li>
<li>渐变滤镜压暗前景曝光、饱和度</li>
<li>鲜艳度↑</li>
</ul>
<h2 id="雪景"><a href="#雪景" class="headerlink" title="雪景"></a>雪景</h2><ul>
<li>前期曝光调整：白加黑减，雪可加2/3、1档</li>
<li>照片特点：<ul>
<li>白（曝光↑）</li>
<li>雪花定格（快门速度↑ 1/800、1/1000、1/2000）</li>
<li>背景选择：深色，突出雪花</li>
</ul>
</li>
<li>后期<ul>
<li>思路一：曝光↑、色温↓、如果阴影都是背景，可以压暗阴影</li>
<li>思路二：水墨风，HSL中其他颜色饱和度↓，肤色提亮</li>
</ul>
</li>
<li><a href="https://www.bilibili.com/video/av75601819" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="童话风-油画感"><a href="#童话风-油画感" class="headerlink" title="童话风/油画感"></a>童话风/油画感</h2><ul>
<li>色彩校准：蓝原色色相↓ 黄色更黄一些，蓝色更青一些。蓝原色饱和度↑</li>
<li>色温↑，黄昏感觉</li>
<li>HSL：<ul>
<li>绿色饱和度↓，变得黄一些</li>
<li>橙色、黄色饱和度↑明亮度↑<ul>
<li>如果这步让人像脸部过亮了，用径向滤镜压暗</li>
</ul>
</li>
</ul>
</li>
<li>曲线：<ul>
<li>最亮的压暗，最暗的抬亮，让画面亮部和暗部都灰一些</li>
<li>小S曲线，对比度↑</li>
</ul>
</li>
<li>进PS加光晕<ul>
<li>可搭配插件：Alien Skin Exposure</li>
</ul>
</li>
<li><a href="https://www.bilibili.com/video/av70528221" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="明度建筑"><a href="#明度建筑" class="headerlink" title="明度建筑"></a>明度建筑</h2><ul>
<li>特征：<ul>
<li>金属光感：渐变塑光影</li>
<li>拉丝效果：模糊塑动感</li>
<li>流动天空：模糊仿流动</li>
</ul>
</li>
<li><a href="https://www.bilibili.com/video/av21522346" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="好莱坞青橙色调"><a href="#好莱坞青橙色调" class="headerlink" title="好莱坞青橙色调"></a>好莱坞青橙色调</h2><ul>
<li>步骤一：选肤色。选择人的皮肤，色彩范围，目标是保留肤色不变</li>
<li>步骤二：背景染色。纯色调整图层+柔光图层混合（蒙版羽化）</li>
<li>步骤三：阴影饱和度↓。色相饱和度图层，降低阴影部分的饱和度</li>
<li><a href="https://www.youtube.com/watch?v=EN3p-IzNiDA" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<hr>
<h1 id="后期技术"><a href="#后期技术" class="headerlink" title="后期技术"></a>后期技术</h1><h2 id="磨皮"><a href="#磨皮" class="headerlink" title="磨皮"></a>磨皮</h2><h3 id="中性灰、高低频"><a href="#中性灰、高低频" class="headerlink" title="中性灰、高低频"></a>中性灰、高低频</h3><ul>
<li>插件：DR4、Skinfiner</li>
<li>图章工具：去明显瑕疵</li>
<li>中性灰：去痘印、调光影结构</li>
<li>高低频：磨皮，保留高频细节。也可在高低频中去瑕疵</li>
<li><a href="https://www.bilibili.com/video/av61448879" target="_blank" rel="noopener">范例视频-高低频</a>、<a href="https://www.bilibili.com/video/av55985443" target="_blank" rel="noopener">范例视频-中性灰</a></li>
</ul>
<hr>
<h1 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h1><h2 id="向右曝光（vs宁欠勿曝）"><a href="#向右曝光（vs宁欠勿曝）" class="headerlink" title="向右曝光（vs宁欠勿曝）"></a>向右曝光（vs宁欠勿曝）</h2><ul>
<li>同时满足三个条件：<ul>
<li>RAW格式拍摄</li>
<li>拍照时尽量曝光增加</li>
<li>后期时蒋其调整回期望的亮度（压暗噪点）</li>
</ul>
</li>
<li>好处：提高画面信噪比，减少噪点</li>
<li>拍摄：<ul>
<li>参考1：评价曝光+1.3ev，白加黑减</li>
<li>参考2：点测最亮点测光增加10倍曝光（3.7ev）</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=uKDXQJR0WPY" target="_blank" rel="noopener">范例视频1</a>、<a href="https://www.youtube.com/watch?v=ln-JDN1mF3I" target="_blank" rel="noopener">范例视频2</a>、<a href="https://www.youtube.com/watch?v=syPdVOhuLak" target="_blank" rel="noopener">范例视频3</a></li>
</ul>
<h2 id="星空-1"><a href="#星空-1" class="headerlink" title="星空"></a>星空</h2><ul>
<li>时间选择：<ul>
<li>月相查询：月亮小的时候拍摄</li>
<li>月出、月落时间：月落后拍摄</li>
</ul>
</li>
<li>地点选择：<a href="https://www.lightpollutionmap.info" target="_blank" rel="noopener">光污染地图</a></li>
<li>银河方位：starwalk、星图</li>
<li>器材选择：广角、大光圈、三脚架、充电宝、手电筒、棉袄等</li>
<li>参数选择：<ul>
<li>对焦：无限远</li>
<li>光圈：最大</li>
<li>快门：500/焦距（一般30秒以内）（防星星拖尾）</li>
<li>感光度：被动决定</li>
</ul>
</li>
</ul>
<hr>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="wechat-朋友圈缩图机制"><a href="#wechat-朋友圈缩图机制" class="headerlink" title="wechat 朋友圈缩图机制"></a>wechat 朋友圈缩图机制</h2><ul>
<li>提前压缩成<code>短边1080p</code>有助于提升画质</li>
<li>提前压缩成<code>1 MB大小</code>无助于提升画质</li>
<li><code>长宽比</code>大于2:1时，能图片长边1080p的限制</li>
</ul>
<p>所以可以压像素，不压画质，或者做成类似2.35:1的宽图。</p>
]]></content>
      <categories>
        <category>「快门」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Photography</tag>
      </tags>
  </entry>
  <entry>
    <title>Adobe Camera Raw Notes</title>
    <url>/2020/03/10/Ps-ACR-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>思路跟 Lr 一样的</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h1><h2 id="获得通透的画面"><a href="#获得通透的画面" class="headerlink" title="获得通透的画面"></a>获得通透的画面</h2><ul>
<li><code>通透</code>：增加细节</li>
<li>途径：亮度再分配</li>
<li>关键：把画面中的大部分细节调整到人眼可见的亮度范围内</li>
<li>tips：调亮主影调、阴影的时候还可以尝试增加黑场（压低黑色）</li>
<li><a href="https://www.youtube.com/watch?v=sYj8cMlecJE&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=3" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="亮度再分配"><a href="#亮度再分配" class="headerlink" title="亮度再分配"></a>亮度再分配</h2><ul>
<li>工具：<code>ACR</code>中的基本调整滑块</li>
<li>原则：<ul>
<li>确保画面有正确的黑白场</li>
<li>提升暗部细节（在确保有黑场的条件下）</li>
<li>压暗亮部细节（在确保有白场的条件下）</li>
</ul>
</li>
<li>目的：获取可感知的细节，让细节落入人眼的可视范围内</li>
<li><a href="https://www.youtube.com/watch?v=bcy9MFub09o" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="精确白平衡"><a href="#精确白平衡" class="headerlink" title="精确白平衡"></a>精确白平衡</h2><ul>
<li>色温和色调可以确定一个点的颜色，相当于一对坐标</li>
<li><code>色温</code>：蓝色 ↔ 黄色</li>
<li><code>色调</code>：绿色 ↔ 洋红色</li>
<li>白平衡工具：<ul>
<li>吸取画面中原本应该是白色（中性灰：纯白-纯黑之间都可以）的点</li>
<li>原理：补色的原理。如果画面中的白色准了，那认为其他颜色也准了。</li>
<li>tips：尽量不要选白纸（有荧光粉）、眼睛（亚洲人、动物偏黄）</li>
</ul>
</li>
<li>JPG格式的白平衡调整色彩不可逆</li>
<li><a href="https://www.youtube.com/watch?v=5oEbQ6m2O5w&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=4" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="精确调色"><a href="#精确调色" class="headerlink" title="精确调色"></a>精确调色</h2><ul>
<li><code>饱和度</code>：<ul>
<li><code>自然饱和度</code>：用得多，更智能，会识别图中内容</li>
<li><code>饱和度</code>：全部调，不建议</li>
</ul>
</li>
<li><code>色调分离</code>：<ul>
<li>大部分电影：高光偏黄，阴影偏蓝 </li>
</ul>
</li>
<li><code>HSL</code>：调节不同颜色的色相、饱和度、明亮度<ul>
<li><code>灰度混合</code>：调整不同颜色会黑白照片亮度贡献的大小</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=2fde25zgXb8&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=5" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="渐变滤镜"><a href="#渐变滤镜" class="headerlink" title="渐变滤镜"></a>渐变滤镜</h2><ul>
<li>硬件：是一种灰度过度滤镜，用于控制天空</li>
<li>可适用于大光比的照片</li>
<li>可以渐变得使亮度再分配</li>
<li>eg：<ul>
<li>天空压暗、降低色温</li>
<li>地面提亮、暖色调、通透</li>
</ul>
</li>
<li>渐变滤镜的蒙版<code>（范围遮罩）</code>：<ul>
<li>颜色</li>
<li>明亮度</li>
<li>按住<code>Alt</code>可以看到蒙版作用范围：越亮→作用越强；越暗→作用越弱</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=l365G5c65kE&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=6" target="_blank" rel="noopener">范例视频1</a>、<a href="https://www.youtube.com/watch?v=OdlCFo5bNBU&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=9" target="_blank" rel="noopener">范例视频2</a></li>
</ul>
<h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><ul>
<li>去除紫边<ul>
<li><code>镜头校正</code>-<code>去边</code>-去除紫边或者绿边</li>
</ul>
</li>
<li>渐变滤镜</li>
<li>径向滤镜<ul>
<li>内部/外部</li>
</ul>
</li>
<li>亮度再分配</li>
<li>色彩快速调节</li>
<li>透视畸变矫正</li>
<li>ACR二次调用</li>
<li><a href="https://www.youtube.com/watch?v=_b6KALfwJyE&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=7" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="用亮度蒙版和ACR恢复天空细节"><a href="#用亮度蒙版和ACR恢复天空细节" class="headerlink" title="用亮度蒙版和ACR恢复天空细节"></a>用亮度蒙版和ACR恢复天空细节</h2><ul>
<li>目的：压暗天空，减少对近景的副作用，过度更自然</li>
<li><code>亮度蒙版</code>：借助画面原有的亮度信息来产生蒙版，通常由通道产生</li>
<li>选择主体、背景差别大的通道</li>
<li><code>亮度蒙版</code>操作：<ul>
<li>按住<code>Ctrl</code>并点击通道，创建亮度选区</li>
<li>蚁行线：亮度高于50%的选中</li>
<li>点回RGB通道，回到图层原始画面</li>
<li>保持选区不变，<code>调整</code>-<code>曲线</code>，此时曲线的蒙版就是刚选中的亮度蒙版</li>
<li>若有的近景受到了影响（如饱和度降低），可以双击蒙版，调整蒙版的羽化值，模糊蒙版</li>
</ul>
</li>
<li>ACR<code>去除薄雾</code>滑块：<ul>
<li>最有效的恢复天空细节的工具</li>
<li>还可以搭配滤镜加强调整</li>
<li>其他地方可以用亮度蒙版遮挡，不用担心对前景的影响</li>
<li>副作用：可能改变天空的颜色，需要调整<code>（自然）饱和度</code></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=7N7A0H7y4es&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=10" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<hr>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="RAW-格式"><a href="#RAW-格式" class="headerlink" title="RAW 格式"></a>RAW 格式</h2><ul>
<li>RAW：未经处理的原始数据</li>
<li>丰富的层次：16-bit</li>
<li>宽容度牛逼</li>
<li>私有色彩空间</li>
<li>没有设定黑白场</li>
<li>若操作<code>.jpg</code>，可以<code>图像</code>-<code>模式</code>-<code>16位通道</code></li>
<li><a href="https://www.youtube.com/watch?v=yZEp7wWqswA&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=1" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="ACR-简介"><a href="#ACR-简介" class="headerlink" title="ACR 简介"></a>ACR 简介</h2><ul>
<li>调用方式<ul>
<li>直接打开RAW文件</li>
<li><code>滤镜</code>-<code>Camera Raw滤镜</code></li>
</ul>
</li>
<li>重要设置<ul>
<li>最下放的链接：<code>色彩深度</code>设定成16位</li>
<li>色彩空间：需要由是否全链路色彩管理决定</li>
</ul>
</li>
<li>无损调节：配置存放于<code>.xmp</code>文件中</li>
<li><a href="https://www.youtube.com/watch?v=H5SBJcz2bVM&list=PLhnwj_CftHvhCdkgMKU8qAL4GlXaXmZ1o&index=2" target="_blank" rel="noopener">范例视频</a></li>
</ul>
]]></content>
      <categories>
        <category>「快门」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>Photoshop Skin Notes</title>
    <url>/2020/03/10/Ps-Skin-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Ps人像修饰</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="全流程"><a href="#全流程" class="headerlink" title="全流程"></a>全流程</h1><h2 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h2><ul>
<li><code>亮度再分配</code></li>
<li><code>液化微整形</code></li>
<li><code>去除皮肤瑕疵</code>：搭配黑白观察图层</li>
<li><code>去除眼袋皱纹</code></li>
<li><code>分频法磨皮</code></li>
<li><code>双曲线法上妆</code>：看起来像D&amp;B调整光影结构</li>
<li><code>美化眼睛</code></li>
<li><code>突出眼神光</code></li>
<li><code>美白牙齿</code></li>
<li><code>布光调色</code></li>
<li><a href="https://www.youtube.com/watch?v=pmOu-M3tTJg" target="_blank" rel="noopener">视频</a></li>
</ul>
<hr>
<h1 id="液化"><a href="#液化" class="headerlink" title="液化"></a>液化</h1><h2 id="人脸识别液化"><a href="#人脸识别液化" class="headerlink" title="人脸识别液化"></a>人脸识别液化</h2><p><code>滤镜</code>-<code>液化</code>，左侧倒三<code>脸部工具</code>  </p>
<p><a href="https://www.youtube.com/watch?v=D0qryIdIDxM" target="_blank" rel="noopener">范例视频1</a>、<a href="https://www.youtube.com/watch?v=bKLmy4o1IsU" target="_blank" rel="noopener">范例视频2</a></p>
<hr>
<h1 id="皮肤"><a href="#皮肤" class="headerlink" title="皮肤"></a>皮肤</h1><h2 id="高效定位瑕疵"><a href="#高效定位瑕疵" class="headerlink" title="高效定位瑕疵"></a>高效定位瑕疵</h2><ul>
<li>思路：黑白调整图层+通道</li>
<li><code>黑白</code>调整图层，降低红色、黄色通道</li>
<li>如果太暗了，可以再建立一个<code>曲线</code>提亮图层</li>
<li>新建一个图层，修饰皮肤</li>
<li><a href="https://www.youtube.com/watch?v=eoL1L7OBPsE" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<hr>
<h1 id="头发"><a href="#头发" class="headerlink" title="头发"></a>头发</h1><h2 id="变得光彩"><a href="#变得光彩" class="headerlink" title="变得光彩"></a>变得光彩</h2><ul>
<li>思路：头发高光更加明亮，适当压暗暗部</li>
<li><code>曲线</code>+蒙版，<code>Ctrl+I</code>反向蒙版→全黑</li>
<li><code>画笔</code>，前景色白色，硬度0，流量~20%，在高光位置涂抹</li>
<li>新建<code>曲线</code>+蒙版，阴影部分类似处理</li>
<li>混合颜色带</li>
<li><a href="https://www.youtube.com/watch?v=aLz5b7hRcOo" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<hr>
<h1 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h1><h2 id="增强-突出眼神光"><a href="#增强-突出眼神光" class="headerlink" title="增强/突出眼神光"></a>增强/突出眼神光</h2><p><strong>前期</strong>：人物面向光源。</p>
<p><strong>后期</strong>：</p>
<ul>
<li>思路：<ul>
<li>增加眼睛的对比度</li>
<li>曲线在这里并不合适，效果不明显，原因是亚洲人眼珠是深色的，眼神光也处于较暗的部分</li>
<li><strong>最优方法：锐化</strong></li>
</ul>
</li>
<li>选择眼珠（可配合使用<code>选择并遮住</code>功能）</li>
<li><code>滤镜</code>→<code>锐化</code>→<code>USM锐化</code><ul>
<li>关键是找到合适的半径</li>
</ul>
</li>
<li>可再使用不透明度调节强度</li>
<li><a href="https://www.youtube.com/watch?v=5GY3avbwAnA" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="去眼袋、皱纹"><a href="#去眼袋、皱纹" class="headerlink" title="去眼袋、皱纹"></a>去眼袋、皱纹</h2><ul>
<li><code>修补工具</code>选择眼袋，处理，结果会有点过</li>
<li>立刻<code>编辑</code>-<code>渐隐修补选区</code><ul>
<li>隐藏上一次调整工具的部分效果</li>
<li><code>Shift+Ctrl+F</code></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=lDX6toJLV1w" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<hr>
<h1 id="牙齿"><a href="#牙齿" class="headerlink" title="牙齿"></a>牙齿</h1><h2 id="自然地美白牙齿"><a href="#自然地美白牙齿" class="headerlink" title="自然地美白牙齿"></a>自然地美白牙齿</h2><ul>
<li>先选择出牙齿</li>
<li>调节色相：<code>色相/饱和度</code>，<code>着色</code>，饱和度不能调为0（因为人牙齿其实是有颜色的）</li>
<li>提亮牙齿的阴影，<code>曲线</code>，混合颜色带</li>
<li>给高光填充白色：<code>画笔</code>，混合颜色带</li>
<li>修整牙齿形状、位置：<code>液化</code></li>
<li><a href="https://www.youtube.com/watch?v=7cZjEJcYhkE" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<hr>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="Ps制作自然虚化的景深"><a href="#Ps制作自然虚化的景深" class="headerlink" title="Ps制作自然虚化的景深"></a>Ps制作自然虚化的景深</h2><ul>
<li>思路：ps的<code>镜头虚化</code>滤镜</li>
<li>选择人物<ul>
<li>快速选择+选择并遮住</li>
</ul>
</li>
<li>新建图层，填充人物选区为黑色</li>
<li>新建图层，填充一个渐变图层</li>
</ul>
]]></content>
      <categories>
        <category>「快门」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>Photoshop Basis Notes</title>
    <url>/2020/03/10/Ps-Basis-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Ps基础</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="Photoshop小白学习顺序"><a href="#Photoshop小白学习顺序" class="headerlink" title="Photoshop小白学习顺序"></a>Photoshop小白学习顺序</h1><ul>
<li>① 图片调整<ul>
<li>裁剪、图像大小、画布大小、图像旋转、保存</li>
</ul>
</li>
<li>② 亮度调整<ul>
<li>ACR基本调整（渐变滤镜、调整画笔、径向滤镜）、色阶、曲线、亮度对比度、曝光度、阴影高光</li>
<li>理论基础：图片构成、RAW、位深度、亮度、对比度、动态范围、直方图</li>
</ul>
</li>
<li>③ 颜色调整<ul>
<li>ACR白平衡、自然饱和度、色相/饱和度、曲线、ACR混色器、照片滤镜、颜色查找</li>
<li>进阶：色彩平衡、渐变映射、可选颜色、通道混合器、黑白</li>
</ul>
</li>
<li>④ 去除工具<ul>
<li>污点修复画笔、仿制图章、修补工具、内容识别填充</li>
</ul>
</li>
<li>⑤ 改变工具<ul>
<li>液化、内容感知移动、内容识别缩放、ACR光学纠正、ACR几何纠正</li>
<li>进阶：自由变换、透视变形、操控变形、消失点</li>
</ul>
</li>
<li>⑥ 计算工具<ul>
<li>锐化</li>
<li>进阶：模糊、高反差保留、匹配颜色、换填、Neural Filter、滤镜库</li>
<li>再进阶：图层混合、计算、应用图层</li>
</ul>
</li>
<li>⑦ 选择工具<ul>
<li>图层、蒙版、套索、快速选择、对象选择、魔棒、选择并遮住、钢笔、色相/饱和度、色彩范围、通道、焦点区域、图层样式</li>
</ul>
</li>
<li>辅助工具<ul>
<li>画笔、橡皮、习惯、剪贴蒙版、渐变填充、纯色、阈值、智能对象</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=fQDt5DxJbuU" target="_blank" rel="noopener">视频</a></li>
</ul>
<hr>
<h1 id="图层相关"><a href="#图层相关" class="headerlink" title="图层相关"></a>图层相关</h1><h2 id="常用的图层混合方式"><a href="#常用的图层混合方式" class="headerlink" title="常用的图层混合方式"></a>常用的图层混合方式</h2><p><code>图层混合</code>：基层+混合层 –混合方法–&gt; 混合层  </p>
<ul>
<li><code>正片叠底</code>：常用的变暗方式<ul>
<li>位于第二组，会变暗</li>
<li>理解：类似投影仪，在光路上再插入一张胶片，不透明的地方会更暗</li>
<li>效果：透明的地方不变，有颜色的地方会变暗</li>
<li>用途：产生逼真的阴影</li>
</ul>
</li>
<li><code>滤色(Screen)</code>：常用的变亮方式<ul>
<li>位于第三组，会变亮</li>
<li>理解：类似投影仪之旁，再放一个投影仪投影到同一个屏幕（Screen）上，两份的光，更亮了</li>
<li>用途：改善画面的光线环境，制造不同的氛围，如增加灯光</li>
</ul>
</li>
<li><code>叠加</code>：<code>正片叠底</code>+<code>滤色</code>，增加对比度<ul>
<li>原理：<ul>
<li>上层亮度大于50%灰色，采用滤色；上层亮度小于50%灰色，则采用正片叠底</li>
<li>高光→滤色；阴影→正片叠底</li>
</ul>
</li>
</ul>
</li>
<li><code>柔光</code>：更柔和的<code>叠加</code><ul>
<li>搭配渐变映射，为画面增加相应的色调</li>
</ul>
</li>
<li>tips：多考虑使用<code>混合颜色带</code></li>
<li><a href="https://www.youtube.com/watch?v=CRAFF3JCamM&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=7" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="通道的概念与应用"><a href="#通道的概念与应用" class="headerlink" title="通道的概念与应用"></a>通道的概念与应用</h2><ul>
<li>红绿蓝三通道：用灰度图像表达画面中三种颜色光的强度</li>
<li>用途：<ul>
<li>改变画面明暗关系（如提高天空层次感）：<ul>
<li>压暗天空的蓝色，突出白云的质感</li>
<li>红色通道用<code>明度</code>方式混合，新建图层，<code>图像</code>-<code>应用图像</code></li>
<li>可以考虑用蒙版处理地面是否被红色通道影响</li>
</ul>
</li>
<li>用通道进行选择（换天）:<ul>
<li>挑一个对比度最高的通道，拷贝一次</li>
<li><code>Ctrl+M</code>，把背景（如天空）附近的对比度狂拉，变成一个黑白二色图</li>
<li>按住<code>Ctrl</code>点选图层，所有白色部分会被选中，黑色部分不选中，灰色半选中，建立选区</li>
<li>选择天空图层，按下蒙版即可应用刚建立选区的蒙版</li>
<li>点击链条，可以调整天空位置而不一起拉动蒙版位置</li>
</ul>
</li>
<li>通道混合产生黑白图片</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=f44KuDU6Jb4&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=11" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<hr>
<h1 id="蒙版相关"><a href="#蒙版相关" class="headerlink" title="蒙版相关"></a>蒙版相关</h1><h2 id="蒙版的概念、应用于生成"><a href="#蒙版的概念、应用于生成" class="headerlink" title="蒙版的概念、应用于生成"></a>蒙版的概念、应用于生成</h2><ul>
<li><code>蒙版</code>：mask，遮罩<ul>
<li><code>黑色</code>：遮住，不显示</li>
<li><code>白色</code>：显示</li>
</ul>
</li>
<li>快捷键：<ul>
<li><code>\</code>：显示蒙版</li>
<li><code>Ctrl + I</code>：白色蒙版边黑色蒙版</li>
<li><code>Ctrl + Shift + I</code>：反选选区</li>
<li>按住<code>Alt</code>+选择蒙版：查看蒙版</li>
</ul>
</li>
<li>生成：<ul>
<li>对图层创建调整图层时，会自动生成全白色蒙版</li>
<li>有选区时候创建调整图层时，会根据选区自动创建蒙版</li>
<li><code>调整图层</code>-<code>阈值</code>-调动滑块，全选-<code>编辑</code>-<code>合并拷贝</code>，删除阈值图层，新建曲线调整图层，<code>Alt+点击</code>查看蒙版，<code>编辑</code>-<code>粘贴</code></li>
</ul>
</li>
<li>蒙版羽化：<ul>
<li>蒙版<code>属性</code>-<code>羽化</code></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=MWjpZvPDYDE&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=4" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="快速蒙版"><a href="#快速蒙版" class="headerlink" title="快速蒙版"></a>快速蒙版</h2><ul>
<li><code>快速蒙版（Q）</code><ul>
<li>可以双击快速蒙版的图标，设置蒙版的颜色和指示区域</li>
</ul>
</li>
<li>在蒙版上用画笔涂抹，进行增减选区</li>
<li>再按<code>Q</code>退出快速蒙版，获得选区</li>
<li>有选区情况下，创建蒙版，得到对应蒙版</li>
<li><a href="https://www.youtube.com/watch?v=-ZdgxnUH0DQ&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=16" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<hr>
<h1 id="曲线相关"><a href="#曲线相关" class="headerlink" title="曲线相关"></a>曲线相关</h1><h2 id="曲线和色阶的区别"><a href="#曲线和色阶的区别" class="headerlink" title="曲线和色阶的区别"></a>曲线和色阶的区别</h2><ul>
<li>色阶是曲线的子集</li>
<li>曲线调整更灵活</li>
<li>曲线中有<code>小手</code>工具很好用</li>
<li><a href="https://www.youtube.com/watch?v=cux1idmOAlA" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<h2 id="使用曲线调整对比度，同时保留细节"><a href="#使用曲线调整对比度，同时保留细节" class="headerlink" title="使用曲线调整对比度，同时保留细节"></a>使用曲线调整对比度，同时保留细节</h2><ul>
<li>S型曲线：增加对比度<ul>
<li>代价：高光和阴影部分的对比度被牺牲</li>
<li>斜率越大，对比度越大</li>
<li>操作：<ul>
<li>Ps用<code>阈值</code>图层获得图片高光和阴影的点（打标记）。目的是获得图片主体内容的亮度范围</li>
<li>然后去曲线工具，用吸管提取标记点的亮度，再提高这个范围的对比度</li>
</ul>
</li>
<li>进阶操作：<ul>
<li>用曲线吸管时按住<code>Shift</code>，在<code>RGB通道</code>中标记</li>
<li>曲线的<code>图层混合模式1</code>从<code>正常</code>改为<code>明度</code>，这样只影响亮度</li>
<li>然后分别调至<code>RGB通道</code>的曲线对比度。</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=8xsdTww52-E" target="_blank" rel="noopener">范例视频1</a></li>
<li><a href="https://www.youtube.com/watch?v=XnWqFnqEZQw" target="_blank" rel="noopener">范例视频2</a>：多通道调节对比度</li>
</ul>
<h2 id="曲线调色"><a href="#曲线调色" class="headerlink" title="曲线调色"></a>曲线调色</h2><ul>
<li>RGB的补色：<ul>
<li>红色 - 青色</li>
<li>绿色 - 洋红</li>
<li>蓝色 - 黄色</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=Hol0gBNA2GQ" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="分区光影重构"><a href="#分区光影重构" class="headerlink" title="分区光影重构"></a>分区光影重构</h2><p><code>Ps</code>操作：</p>
<ul>
<li>先<code>选区</code>，然后<code>创建曲线</code>，压暗/提亮，<code>混合模式</code>改为<code>明度</code>（只想改变亮度而不改变颜色）。压暗的程度可以用不透明度来调节。</li>
<li>双击曲线，在图层样式中调整混合颜色带，改变作用的区域（下一图层）。按住<code>Alt</code>键来分离小三角，使得过度不生硬。</li>
<li>可以<code>Ctrl+G</code>创建组，然后按住<code>Alt</code>键拖蒙版到组上行程组蒙版。</li>
<li>组中新建一个曲线来对亮部提亮。</li>
<li><a href="https://www.youtube.com/watch?v=eSHpOOraCDE&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=5" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<hr>
<h1 id="降噪相关"><a href="#降噪相关" class="headerlink" title="降噪相关"></a>降噪相关</h1><h2 id="4种后期降噪方法对比"><a href="#4种后期降噪方法对比" class="headerlink" title="4种后期降噪方法对比"></a>4种后期降噪方法对比</h2><p><code>Nik SW Dfine2</code> vs <code>Neat Image</code>（$39.9) vs <code>Ps减少杂色滤镜</code> vs <code>ACR减少杂色滤镜</code>  </p>
<p>评判好坏：去噪强，且保真  </p>
<p>噪声：彩色噪声、明度噪声<br>（人眼对颜色的敏感度小于对明度的，所以可以强力点进行颜色去噪）  </p>
<ul>
<li><code>Ps减少杂色滤镜</code>：<ul>
<li><code>Ps</code>-<code>滤镜</code>-<code>杂色</code>-<code>减少杂色</code></li>
<li>可以不考虑<code>锐化细节</code>滑块，因为有更好的锐化工具 </li>
<li><code>减少杂色</code>滑块：用于减少彩色噪声<ul>
<li>其实去除的并不彻底</li>
</ul>
</li>
<li><code>强度</code>滑块：用于控制明度噪声<ul>
<li>还需要用<code>保留细节</code>滑块来找回细节，但代价是恶化噪声</li>
</ul>
</li>
<li>高级：还可以对通道单独降噪，如拍摄蓝天时，噪声主要分布在红色通道中</li>
<li>小结：<ul>
<li>对颜色噪声去除并不彻底</li>
<li>算法对细节伤害过大，找回细节又会加重噪声</li>
<li>用户需要在强度和保留细节中找到平衡点（困难）</li>
</ul>
</li>
</ul>
</li>
<li><code>ACR减少杂色滤镜</code>：<ul>
<li><code>Ps</code>-<code>滤镜</code>-<code>Camera Raw滤镜</code>-<code>细节</code>-<code>减少杂色</code></li>
<li><code>明亮度</code>滑块：控制明度噪声<ul>
<li>太强后可能出现小皱褶</li>
</ul>
</li>
<li><code>颜色</code>滑块：控制颜色噪声<ul>
<li>要远好过<code>Ps</code></li>
<li>不需要保留过多<code>颜色细节</code>（因为人眼不敏感）</li>
</ul>
</li>
<li>小结：<ul>
<li>对颜色噪声的抑制很好</li>
<li>对亮度噪声仍需要找去噪和找细节的平衡点，同时用强力降噪时，可能出现奇怪的皱褶</li>
</ul>
</li>
</ul>
</li>
<li><code>Neat Image</code>:<ul>
<li><code>Ps</code>-<code>滤镜</code>-<code>Neat Image</code>-<code>Reuce Noise</code></li>
<li>算法策略：动态分析画面，找到某一补位原本没有任何细节，那么其上所有的内容都是噪声。然后对噪声进行建模，然后对画面进行处理。</li>
<li><code>Auto Profile</code>：自动分析，找没有细节只有噪声的部位。也可以手动自己选择部位。</li>
<li><code>Apply</code></li>
<li>或者也可以去<code>Noise Filter Setting</code>中设定过滤器的参数<ul>
<li>按住<code>左键</code>不松手，可以对比预览</li>
</ul>
</li>
<li>除了入门模式，还有高级模式，这里暂不讨论</li>
<li>小结：远好于ACR</li>
</ul>
</li>
<li><code>Nik Collection</code>：<ul>
<li><code>Ps</code>-<code>滤镜</code>-<code>Nik collection</code>-<code>Dfine2</code></li>
<li>自动分析照片，确定即可</li>
<li>算法策略与NI类似，会寻找多个位置</li>
<li>也可以<code>测量方式</code>改为手动，手动添加噪声区域，在点击<code>测量噪点</code>即可</li>
<li><code>降噪</code>页面中<ul>
<li>可分别控制明度噪点和颜色噪点</li>
<li>可以添加控制点对不同区域采用不同降噪强度</li>
</ul>
</li>
<li>小结：<ul>
<li>稍弱于NI，但强于ACR</li>
<li>免费，有中文版，功能会多一些</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=lKmJp7-jF5Y" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="USM极致锐化"><a href="#USM极致锐化" class="headerlink" title="USM极致锐化"></a>USM极致锐化</h2><p>锐化永远都是最后一步操作，再之后只有<code>保存</code>。</p>
<ul>
<li>锐化的感觉来自<code>边缘的反差</code></li>
<li>原理：<ul>
<li>原图-模糊图片=差值</li>
<li>原图+差值=锐化的图片</li>
</ul>
</li>
<li>参数：<ul>
<li><code>数量</code>：锐化的强度</li>
<li><code>半径</code>：粒度，画面细节的尺度，最重要的参数</li>
<li><code>阈值</code>：反差小于阈值，则不锐化</li>
</ul>
</li>
<li>调节策略：<ul>
<li>第一次锐化：强调肌肤纹理、皮肤细节<ul>
<li>放大图片看皮肤细节</li>
<li>数量500%，阈值0，缓慢调节找到合适的半径</li>
<li>这时候背景的噪点可能增加，需要缓慢增加阈值，提高画面信噪比</li>
</ul>
</li>
<li>第二次锐化：强调五官和轮廓<ul>
<li>复制图层</li>
<li>稍微缩小图片看整体</li>
<li>数量500%，阈值0，增加半径体现清晰轮廓（可能失真严重，但画面明暗对比与人物五官轮廓是吻合的）</li>
<li>适当降低数量</li>
</ul>
</li>
</ul>
</li>
<li>网上说的死参数都是耍流氓，要找适合自己图片的参数</li>
<li><a href="https://www.youtube.com/watch?v=GhkAR6h72Hc&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=6" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="精确控制锐化产生的光晕"><a href="#精确控制锐化产生的光晕" class="headerlink" title="精确控制锐化产生的光晕"></a>精确控制锐化产生的光晕</h2><ul>
<li>光晕产生的原因：<ul>
<li>锐化黑白信号：强化对比度</li>
<li>锐化彩色信号：调整了饱和度</li>
<li>人眼对亮光更敏感（相比暗），所以要想办法搞定变亮的光晕</li>
</ul>
</li>
<li>锐化过的图层（锐化前转换成<code>智能对象</code>），再复制一层，一个<code>变暗</code>混合，一个<code>变亮</code>混合，调整不透明度</li>
<li><code>变亮</code>的图层调整（减小）锐化半径</li>
<li>考虑采用蒙版，在<code>变亮</code>图层中，用黑色画笔，去除不适用锐化图层的部分（小流量涂抹）<ul>
<li>嘴唇可以考虑对暗部蒙版，去除暗部细节唇彩效果更好</li>
</ul>
</li>
<li>不锐化女性的皮肤：<ul>
<li><code>变亮</code>、<code>变暗</code>图层<code>Ctrl+G</code>成组</li>
<li>新建组蒙版，<code>Ctrl+I</code>蒙版反向（变黑，屏蔽所有锐化效果）</li>
<li>用白色画笔对需要锐化的地方涂抹（如眼睛、眉毛、头发、嘴唇……）</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=1WTDKh08kj8&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=28" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="用ACR进行局部锐化"><a href="#用ACR进行局部锐化" class="headerlink" title="用ACR进行局部锐化"></a>用ACR进行局部锐化</h2><ul>
<li><code>数量</code>滑块：调整锐化程度，按住<code>Alt</code>可以把画面变成黑白，避免颜色影响，打到最大</li>
<li><code>半径</code>滑块：决定锐化的颗粒度，按住<code>Alt</code>画面变成灰色，调节锐化的尺度，要找准半径（希望强调哪些细节？）</li>
<li><code>细节</code>滑块：对粒度小的颗粒进行锐化</li>
<li>适当降下锐化数量</li>
<li>此时背景噪声被加强</li>
<li>按住<code>Alt</code>键调节<code>蒙版</code>滑块，让背景变黑色（弱锐化），主体变白色（锐化程度高）</li>
<li><a href="https://www.youtube.com/watch?v=_TwTOHGA6ro" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<hr>
<h1 id="去污相关"><a href="#去污相关" class="headerlink" title="去污相关"></a>去污相关</h1><h2 id="仿制图章"><a href="#仿制图章" class="headerlink" title="仿制图章"></a>仿制图章</h2><ul>
<li>作用：原封不动仿制</li>
<li>属性：<ul>
<li>按住<code>Alt</code>采样</li>
<li><code>流量</code>：反复涂抹可增强效果</li>
<li><code>对齐</code>：第二次的起点是否相对移动</li>
<li>选择仿制图层</li>
</ul>
</li>
<li><code>窗口</code>-<code>仿制源</code>：可以调整角度（快捷键：<code>Alt+Shift+&lt;,&gt;</code>)</li>
<li>碰到有不希望被涂抹的锋利边缘时，可以先建立选区，在选区内涂抹，限制仿制作用的范围</li>
<li><a href="https://www.youtube.com/watch?v=xeqW283LZeI&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=8" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="复杂边缘物体的选择"><a href="#复杂边缘物体的选择" class="headerlink" title="复杂边缘物体的选择"></a>复杂边缘物体的选择</h2><ul>
<li><code>选择并遮住</code>功能</li>
<li>操作：<ul>
<li>选任意选择工具，点击上方这个功能</li>
<li>快速选择、边缘选择、使用画笔、套索来选择</li>
<li><code>快速选择</code>工具：优先考虑使用<ul>
<li>快速地、大概地选择，不用对边缘太考究</li>
<li>看边缘时，可以考虑把视图模式从<code>洋葱皮</code>改成<code>蚁行线</code>模式</li>
<li>按住<code>Alt</code>取消选择</li>
</ul>
</li>
<li><code>边缘修饰</code>画笔：<ul>
<li>沿着边缘粗线条得走一遍</li>
<li>看下<code>黑白选区</code>（快捷键：按<code>X</code>），非常完美</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=amVes-pM5yk&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=13" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<hr>
<h1 id="效果相关"><a href="#效果相关" class="headerlink" title="效果相关"></a>效果相关</h1><h2 id="可选颜色营造电影感"><a href="#可选颜色营造电影感" class="headerlink" title="可选颜色营造电影感"></a><code>可选颜色</code>营造电影感</h2><ul>
<li><code>可选颜色</code>：为某种颜色增加其他颜色<ul>
<li>选颜色中，白色、中性色、黑色指的是高光、中性、阴影</li>
</ul>
</li>
<li><code>电影感</code>：冷暖对冲<ul>
<li>阴影：蓝色、青色</li>
<li>高光、中性灰：暖色</li>
</ul>
</li>
<li>操作：<ul>
<li>改变暗调：对可选颜色的“黑色”，提高青色，掺绿色（减少洋红），掺入蓝色（降低黄色）；这时可能画面会发灰，需要增加黑场，在“黑色”中增加黑色</li>
<li>改变中间调：对可选颜色的“中性色”，增加红色（减少青色），洋红自己看看情况，增加黄色</li>
<li>考虑用蒙版提亮主题/压暗背景</li>
</ul>
</li>
<li>电影感不是那么容易获得的，是灯光、道具、服装、摄像、后期……一起贡献的结果</li>
<li><a href="https://www.youtube.com/watch?v=RsqBHN0x3zs&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=9" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="换天空-变生动"><a href="#换天空-变生动" class="headerlink" title="换天空 变生动"></a>换天空 变生动</h2><ul>
<li>拷贝天空到目标画面（新图层），可用蒙版把天空画面中的地面杂物抠掉</li>
<li>可利用<code>混合颜色带</code>把原图中、在天空范围内的东西找回来</li>
<li>处理地平线：拉一个渐变的图层，</li>
<li>对天空<code>Ctrl+G</code>产生一个组，新建组蒙版，拉一个渐变蒙版，完成画面拼接</li>
<li>处理画面自然：<ul>
<li>天空和地面亮度匹配：新建一个黑白的调整图层用于观察，在组中新建一个曲线调整图层提亮天空，使得天空比地面亮</li>
<li>天空和地面颜色匹配：复制一个天空图层，用高斯模糊抽象出天空颜色，拖到地面上，图层混合模式<code>柔光</code>，可借助蒙版框住范围</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=3XsJ-O9muDw&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=10" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<p>快速让蓝天生动：</p>
<ul>
<li>本质：提高蓝天中蓝色的深度（明暗）</li>
<li>工具：<code>黑白调整工具</code>，图层混和模式用<code>明度</code></li>
<li>调整通道<ul>
<li>蓝天：蓝色、青色</li>
<li>地面、沙滩：红色、黄色</li>
</ul>
</li>
<li>可搭配<code>色相/饱和度</code>工具调整色相、饱和度</li>
<li><a href="https://www.youtube.com/watch?v=OfzwLOorbA0&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=15" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="制作高对比度黑白图片（如肖像）"><a href="#制作高对比度黑白图片（如肖像）" class="headerlink" title="制作高对比度黑白图片（如肖像）"></a>制作高对比度黑白图片（如肖像）</h2><ul>
<li>用ACR亮度再分配，提高对比度，展现更多细节：人眼对黑白图片的色偏不敏感，所以调彩色图片的对比度时，不用太在意色彩失真</li>
<li>调用<code>黑白调整图层</code></li>
<li>还可以再搭配其他曲线</li>
<li>肖像照中背景通常是渐变的</li>
<li><a href="https://www.youtube.com/watch?v=llWQMNBrU9Y&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=12" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="保留细节放大图片"><a href="#保留细节放大图片" class="headerlink" title="保留细节放大图片"></a>保留细节放大图片</h2><ul>
<li><code>编辑</code>-<code>首选项</code>-<code>技术预览</code>-勾选<code>启用保留细节2.0放大</code></li>
<li><code>图像</code>-<code>图像大小</code>，<code>重新采样</code>：<code>保留细节2.0</code>，<code>减少杂色</code>看情况</li>
</ul>
<h2 id="秒变秋色"><a href="#秒变秋色" class="headerlink" title="秒变秋色"></a>秒变秋色</h2><ul>
<li><code>图像</code>-<code>模式</code>-<code>Lab颜色</code></li>
<li>创建曲线调整图层<ul>
<li><code>L通道</code>：亮度</li>
<li><code>a通道</code>：绿色-洋红</li>
<li><code>b通道</code>：蓝色-黄色</li>
</ul>
</li>
<li>在<code>a通道</code>把曲线反相</li>
<li>蒙版处理不需要调整的部分</li>
<li><a href="https://www.youtube.com/watch?v=N_LgMtViJaA&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=17" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="瞬间增加风格"><a href="#瞬间增加风格" class="headerlink" title="瞬间增加风格"></a>瞬间增加风格</h2><ul>
<li>建立<code>渐变映射</code>调整图层</li>
<li>图层混合方式：叠加、柔光、强光……</li>
<li>选择颜色带，Ps有预设的，没有的话：<code>齿轮按钮</code>-<code>照片色调</code></li>
<li><code>不透明度</code>调整风格的宽度</li>
<li>批量处理：复制渐变映射图层到其它图片，可以让其它图片也相同有风格</li>
<li><a href="https://www.youtube.com/watch?v=g3O_Xm3tkOI&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=18" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="智能拉直照片-amp-内容识别裁剪"><a href="#智能拉直照片-amp-内容识别裁剪" class="headerlink" title="智能拉直照片&amp;内容识别裁剪"></a>智能拉直照片&amp;内容识别裁剪</h2><ul>
<li><code>标尺</code>-画直线，<code>图像</code>-<code>图像旋转</code>-<code>任意角度</code><ul>
<li>可能需要损失图片中的元素</li>
</ul>
</li>
<li><code>裁剪</code>工具-水平尺<ul>
<li>可勾选<code>内容识别</code>，会自动填充一些画面</li>
<li>可裁剪扩大画面，确认时填充</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=EbsPJ_CMryQ&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=19" target="_blank" rel="noopener">范例视频1</a>、<a href="https://www.youtube.com/watch?v=eJIvZVoqXFg&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=20" target="_blank" rel="noopener">范例视频2</a></li>
</ul>
<h2 id="产生移轴模糊效果"><a href="#产生移轴模糊效果" class="headerlink" title="产生移轴模糊效果"></a>产生移轴模糊效果</h2><ul>
<li><code>滤镜</code>-<code>模糊画廊</code>-<code>移轴模糊...</code></li>
<li><a href="https://www.youtube.com/watch?v=Xb10rchpb94&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=21" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="改变任意颜色"><a href="#改变任意颜色" class="headerlink" title="改变任意颜色"></a>改变任意颜色</h2><ul>
<li><code>色相/饱和度</code>调整图层-<code>小手</code>按钮-吸取-调整</li>
</ul>
<h2 id="添加任意形状暗角"><a href="#添加任意形状暗角" class="headerlink" title="添加任意形状暗角"></a>添加任意形状暗角</h2><ul>
<li><code>曲线</code>调整图层-压暗</li>
<li><code>画笔</code>：硬度100%，黑色，调整大小，在蒙版上点一下</li>
<li>选择蒙版，<code>Ctrl+T</code>自由变换蒙版，也可右键-变形，回车</li>
<li>羽化拉上来</li>
<li>可以搭配图层混合颜色带，调整背景的氛围</li>
<li><a href="https://www.youtube.com/watch?v=yIBp_SWzDyY&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=23" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="内容识别缩放"><a href="#内容识别缩放" class="headerlink" title="内容识别缩放"></a>内容识别缩放</h2><ul>
<li>保证主体不变，缩放背景，调整构图</li>
<li><code>裁剪</code>扩大画布- </li>
<li><code>编辑</code>-<code>内容识别缩放</code></li>
<li>拖动画面即可</li>
<li>可以多次反复执行，对主体占比大的图进行调整</li>
<li><a href="https://www.youtube.com/watch?v=RNOKIebcDZA&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=24" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="内容识别填充"><a href="#内容识别填充" class="headerlink" title="内容识别填充"></a>内容识别填充</h2><ul>
<li><code>套索</code>勾选出要去掉的内容</li>
<li><code>编辑</code>-<code>填充</code>-内容识别</li>
<li>修饰细节</li>
</ul>
<h2 id="旋转模糊"><a href="#旋转模糊" class="headerlink" title="旋转模糊"></a>旋转模糊</h2><ul>
<li><code>滤镜</code>-<code>模糊画廊</code>-<code>旋转模糊</code></li>
<li>内圈：模糊大的内容</li>
<li>外圈：不模糊</li>
<li>搭配蒙版还原不需要模糊的部分</li>
</ul>
<h2 id="添加任意滤镜效果"><a href="#添加任意滤镜效果" class="headerlink" title="添加任意滤镜效果"></a>添加任意滤镜效果</h2><ul>
<li><code>色相/饱和度</code>调整图层</li>
<li>图层混合模式：柔光</li>
<li><code>浓度</code>：屏蔽部分滤镜效果</li>
</ul>
<h2 id="高级灰建筑图片"><a href="#高级灰建筑图片" class="headerlink" title="高级灰建筑图片"></a>高级灰建筑图片</h2><ul>
<li>简化画面元素，突出对比度，主要是建筑物的几何形体比较好</li>
<li><a href="https://www.youtube.com/watch?v=q6ORiya7dpQ&list=PLhnwj_CftHvjpQc6ytB7ynuVSQM6CSyO5&index=29" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="逼真的素描"><a href="#逼真的素描" class="headerlink" title="逼真的素描"></a>逼真的素描</h2><ul>
<li><a href="https://www.youtube.com/watch?v=aN4P2QsSAmw" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="创建光晕"><a href="#创建光晕" class="headerlink" title="创建光晕"></a>创建光晕</h2><ul>
<li>杂色+模糊+阈值生成随机亮点，变成光晕，给光晕上色</li>
<li><a href="https://www.youtube.com/watch?v=TKwWRN6lPQs" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<h2 id="渐变映射"><a href="#渐变映射" class="headerlink" title="渐变映射"></a>渐变映射</h2><ul>
<li>画面最暗、最亮，按亮度映射到其他颜色</li>
<li>通常借助<code>不透明度</code>、<code>柔光</code>混合</li>
<li><a href="https://www.youtube.com/watch?v=m9xCqORVkwI" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
<hr>
<h1 id="画笔相关"><a href="#画笔相关" class="headerlink" title="画笔相关"></a>画笔相关</h1><h2 id="流量和透明度的区别"><a href="#流量和透明度的区别" class="headerlink" title="流量和透明度的区别"></a>流量和透明度的区别</h2><ul>
<li><code>不透明度</code>：<ul>
<li>特性：和现实中笔的行为不一样，不松开鼠标重复涂抹，不会加深</li>
</ul>
</li>
<li><code>流量</code>：<ul>
<li>是离散绘制的</li>
<li>不松开鼠标，重复涂抹会加深，可能会一下子变得很深</li>
</ul>
</li>
<li><code>不透明度</code>和<code>流量</code>结合使用：<ul>
<li>可以重复涂抹加深，但深度有上限</li>
<li>松开鼠标后，再次涂抹还可叠加加深</li>
<li>方便控制颜色深度、均匀</li>
</ul>
</li>
<li>实际用处：<ul>
<li>D&amp;B修脸部光影结构，用低流量、低不透明度画笔在提亮和压暗蒙版上涂抹</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=GeXCT4QAayY" target="_blank" rel="noopener">范例视频</a></li>
</ul>
<hr>
<h1 id="抠图相关"><a href="#抠图相关" class="headerlink" title="抠图相关"></a>抠图相关</h1><h2 id="抠图思路"><a href="#抠图思路" class="headerlink" title="抠图思路"></a>抠图思路</h2><blockquote>
<p>抠图不是单纯的去描边，不一定要去建立选区。</p>
<p>首先想清楚你想要的干什么？</p>
<p>核心是利用画面的差异，灵活的选择工具。</p>
<p>随着科技的发展，AI工具将发挥更大的作用。</p>
</blockquote>
<p>选区、蒙版、黑白图片——是一码事。白——全选中，黑——全不选中，灰——部分选中。</p>
<ul>
<li>利用画面的差异：<ul>
<li>形状：<code>多边形套索</code></li>
<li>亮度：<ul>
<li><code>选择</code>-<code>色彩范围...</code>-<code>高光</code></li>
<li><code>调整曲线</code>+<code>混合颜色带</code></li>
<li>通道，<code>Ctrl</code>+单击通道，回到图层，新建<code>曲线</code>；通常需要对蒙版进行一定的<code>羽化</code>来屏蔽通道中的一些细节<ul>
<li>拓展：单击蒙版，<code>Ctrl+L</code>调节蒙版的色阶，即调整蒙版的效果</li>
</ul>
</li>
</ul>
</li>
<li>颜色：<ul>
<li><code>选择</code>-<code>色彩范围...</code></li>
<li><code>色相/饱和度</code>，小手的标记，色相、饱和度打到最大，调节色彩选中的范围。其实并没有新建选区，只是利用了ps的功能调整指定颜色的颜色</li>
<li>调节某个色彩的亮度：新建<code>黑白</code>调整，混合方式改为<code>明度</code>，调节颜色的滑块</li>
</ul>
</li>
<li>清晰度：<ul>
<li><code>滤镜</code>-<code>焦点区域...</code>，选择画面中合焦的区域</li>
</ul>
</li>
<li>饱和度：<ul>
<li>复制图层，<code>滤镜</code>-<code>其它</code>-<code>HSB/HSL...</code>，输入<code>RGB</code>，输出<code>HSB</code>，会把红绿蓝三个通道放成色相、饱和度、亮度。<code>Ctrl</code>+单击绿通道，可以建立关于饱和度的选区</li>
</ul>
</li>
<li>信息复杂程度：<ul>
<li>ACR中锐化功能的蒙版</li>
</ul>
</li>
</ul>
</li>
<li>人工智能选择主体<ul>
<li><code>快速选择工具</code>-<code>选择主体</code></li>
<li>高版本ps：<code>对象选择工具</code></li>
</ul>
</li>
<li>类似头发的边缘：<ul>
<li><code>选择并遮住...</code>-<code>调整边缘画笔</code></li>
<li><code>剪贴蒙版</code>去白边</li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=M78lAZOmvWc" target="_blank" rel="noopener">讲解视频</a></li>
</ul>
]]></content>
      <categories>
        <category>「快门」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title>SEO 学习笔记</title>
    <url>/2019/04/01/SEO-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>搜索引擎优化</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<ul>
<li><p>书名：《SEO实战密码》（第3版）</p>
</li>
<li><p>作者：昝辉 Zac</p>
</li>
<li><p>出版社：电子工业出版社</p>
</li>
</ul>
<hr>
<h1 id="1-SEO：Search-Engine-Optimization"><a href="#1-SEO：Search-Engine-Optimization" class="headerlink" title="1.SEO：Search Engine Optimization"></a>1.SEO：Search Engine Optimization</h1><ul>
<li>从自然搜索结果获得网站流量的技术和过程</li>
</ul>
<h1 id="2-优化："><a href="#2-优化：" class="headerlink" title="2.优化："></a>2.优化：</h1><ul>
<li>站内优化：网站结构，页面HTML代码等</li>
<li>站外优化：外部链接，参与互动等</li>
</ul>
<h1 id="3-搜索引擎工作原理"><a href="#3-搜索引擎工作原理" class="headerlink" title="3.搜索引擎工作原理"></a>3.搜索引擎工作原理</h1><p>爬行（→地址库）→抓取→预处理（索引）：提取文字；中文分词；去停止词；消除噪声；去重；正向/倒排索引；链接关系计算；特殊文件处理；质量判断→排名：搜索词处理；文件匹配；初始子集选择；相关性计算；过滤&amp;调整；排名显示；搜索缓存；查询&amp;点击日志</p>
<ul>
<li>高级搜索指令：“ ”；-；*；inurl:；inanchor:；intitle:；allintitle:；allinurl:；filetype:；site:；link:；related:</li>
</ul>
<h1 id="4-关键词选择核心原则："><a href="#4-关键词选择核心原则：" class="headerlink" title="4.关键词选择核心原则："></a>4.关键词选择核心原则：</h1><ul>
<li>搜索次数多</li>
<li>竞争程度小</li>
</ul>
<h1 id="5-核心关键词→拓展关键词"><a href="#5-核心关键词→拓展关键词" class="headerlink" title="5.核心关键词→拓展关键词"></a>5.核心关键词→拓展关键词</h1><h1 id="6-长尾关键词：较长，较具体，次数低"><a href="#6-长尾关键词：较长，较具体，次数低" class="headerlink" title="6.长尾关键词：较长，较具体，次数低"></a>6.长尾关键词：较长，较具体，次数低</h1><h1 id="7-竞争对手研究"><a href="#7-竞争对手研究" class="headerlink" title="7.竞争对手研究"></a>7.竞争对手研究</h1><ul>
<li>域名权重相关数据</li>
<li>网站优化情况</li>
<li>网站流量</li>
</ul>
<h1 id="8-网站结构优化"><a href="#8-网站结构优化" class="headerlink" title="8.网站结构优化"></a>8.网站结构优化</h1><ul>
<li>避免蜘蛛陷阱（Flash，Session ID，跳转，框架Frame，动态url，js链接等）</li>
</ul>
<h1 id="9-SEO过程："><a href="#9-SEO过程：" class="headerlink" title="9.SEO过程："></a>9.SEO过程：</h1><p>竞争对手究→SEO计划（诊断）→网站优化→外链建设→效果检测及流量分析→策略修改</p>
<h1 id="10-Google："><a href="#10-Google：" class="headerlink" title="10.Google："></a>10.Google：</h1><ul>
<li>熊猫算法：针对低质量内容</li>
<li>企鹅算法：针对垃圾和作弊网站</li>
</ul>
<h1 id="11-百度："><a href="#11-百度：" class="headerlink" title="11.百度："></a>11.百度：</h1><ul>
<li>绿萝算法：买卖链接、软文形式的垃圾链接</li>
<li>石榴算法：低质量页面、妨碍用户体验的</li>
</ul>
<h1 id="11-搜索引擎历史趋势：相关性→权威性→实用性"><a href="#11-搜索引擎历史趋势：相关性→权威性→实用性" class="headerlink" title="11.搜索引擎历史趋势：相关性→权威性→实用性"></a>11.搜索引擎历史趋势：相关性→权威性→实用性</h1><ul>
<li>内容为王</li>
</ul>
]]></content>
      <categories>
        <category>「笔记」- 读书</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言基础の笔记</title>
    <url>/2019/04/01/R-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>R语言基础の笔记</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="R-语言基础"><a href="#R-语言基础" class="headerlink" title="R 语言基础"></a>R 语言基础</h1><h2 id="1-一维数据结构-概念介绍"><a href="#1-一维数据结构-概念介绍" class="headerlink" title="1.一维数据结构-概念介绍"></a>1.一维数据结构-概念介绍</h2><ul>
<li>数据类型  <ul>
<li>character：字符型</li>
<li>numeric：数值型，指实数或小数</li>
<li>integer：整型</li>
<li>complex：复数型</li>
<li>logical：逻辑型</li>
</ul>
</li>
<li>数据结构<ul>
<li>向量（对应数值变量）、因子（对应分类变量）</li>
<li>矩阵（内部数据类型一致）、数据框（内部每个向量内数据类型一致）</li>
<li>数组（三维、更高维）、列表（可包含不同结构类型元素）</li>
</ul>
</li>
<li>向量<ul>
<li>c()</li>
<li>冒号操作符:</li>
<li>seq(from, to, by, lenth.out, along.with)<br>·提取子集</li>
<li>数字下标（正数、负数）</li>
<li>which()函数</li>
</ul>
</li>
<li>因子<ul>
<li>factor()</li>
<li>gl()</li>
</ul>
</li>
</ul>
<h2 id="2-一维数据结构-代码演示"><a href="#2-一维数据结构-代码演示" class="headerlink" title="2.一维数据结构-代码演示"></a>2.一维数据结构-代码演示</h2><ul>
<li>等号=跟&lt;-是一样的赋值操作符</li>
<li>(x=c(10,11,13,14))，最外的括号表示立即输出</li>
<li>Ctrl+Enter为单行执行</li>
<li>因子的水平（level）在R语言内部用数字表示</li>
<li>一维数据结构</li>
</ul>
<h2 id="3-二位数据结构——矩阵"><a href="#3-二位数据结构——矩阵" class="headerlink" title="3.二位数据结构——矩阵"></a>3.二位数据结构——矩阵</h2><ul>
<li>行和列</li>
<li>生成矩阵<ul>
<li>matrix()</li>
<li>由向量派生</li>
<li>由向量组合生成</li>
</ul>
</li>
<li>操作<ul>
<li>访问元素</li>
<li>行、列命名</li>
</ul>
</li>
<li>矩阵运算：向量运算按照矩阵运算统一<ul>
<li>加减运算</li>
<li>乘法运算：数乘、对应元素相乘、矩阵乘法</li>
<li>单位矩阵、对角矩阵</li>
<li>矩阵转置</li>
<li>矩阵的特征值和特征向量</li>
<li>矩阵的逆</li>
<li>求解线性方程组</li>
</ul>
</li>
</ul>
<h2 id="4-二位数据结构——数据框"><a href="#4-二位数据结构——数据框" class="headerlink" title="4.二位数据结构——数据框"></a>4.二位数据结构——数据框</h2><ul>
<li>记录和域</li>
<li>创建数据框 data.frame()</li>
<li>操作：</li>
<li>访问元素 $、[[]]</li>
<li>attach、detach</li>
<li>with、within</li>
<li>subset</li>
</ul>
<h2 id="5-高维数据结构——列表和数组"><a href="#5-高维数据结构——列表和数组" class="headerlink" title="5.高维数据结构——列表和数组"></a>5.高维数据结构——列表和数组</h2><ul>
<li>列表中：成分</li>
<li>创建列表：list()</li>
<li>操作：</li>
<li>列表成分names</li>
<li>[]、[[]]</li>
<li>数组：不同于其他语言的数组，是矩阵的延伸</li>
</ul>
<h2 id="6-数据类型转换"><a href="#6-数据类型转换" class="headerlink" title="6.数据类型转换"></a>6.数据类型转换</h2><ul>
<li>类型转换<ul>
<li>安全级别：字符&gt;数字&gt;布尔（更安全）</li>
<li>is.character、as.character…</li>
</ul>
</li>
<li>数据结构<ul>
<li>is.mastrix、as.mastrix…</li>
</ul>
</li>
</ul>
<h2 id="7-分支结构"><a href="#7-分支结构" class="headerlink" title="7.分支结构"></a>7.分支结构</h2><ul>
<li>if … else …结构<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>ifelse()函数，支持向量化计算<br><code>ifelse(b,u,v)</code>  </li>
</ul>
<h2 id="8-循环结构"><a href="#8-循环结构" class="headerlink" title="8.循环结构"></a>8.循环结构</h2><ul>
<li>for(n in x){…} （x是向量）</li>
<li>while(codition){…}</li>
<li>repeat{… break}</li>
<li>break、next</li>
</ul>
<h2 id="9-函数和包：代码重用"><a href="#9-函数和包：代码重用" class="headerlink" title="9.函数和包：代码重用"></a>9.函数和包：代码重用</h2><ul>
<li>自定义函数：(一类对象，可以随时创建）<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">myfun=<span class="keyword">function</span>(par1,par2..)&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>查看函数代码<ul>
<li>不带括号的函数名</li>
<li>page</li>
</ul>
</li>
<li>source函数加载文件（保存成.r文件）  </li>
</ul>
<p><code>source(&#39;E:/rTEST/06.function.r&#39;)</code></p>
<h2 id="10-向量化运算和apply家族"><a href="#10-向量化运算和apply家族" class="headerlink" title="10.向量化运算和apply家族"></a>10.向量化运算和apply家族</h2><ul>
<li>向量化运算<ul>
<li>+-*/四则运算</li>
<li>&lt;!=逻辑运算</li>
</ul>
</li>
<li>apply家族<ul>
<li>apply</li>
<li>sapply、lapply</li>
<li>mapply、tapply</li>
</ul>
</li>
</ul>
<hr>
<h1 id="建立对数据的感性认识"><a href="#建立对数据的感性认识" class="headerlink" title="建立对数据的感性认识"></a>建立对数据的感性认识</h1><h2 id="1-变量类型"><a href="#1-变量类型" class="headerlink" title="1.变量类型"></a>1.变量类型</h2><ul>
<li>连续变量（数值变量）</li>
<li>离散变量（名义变量、分类变量）</li>
</ul>
<h2 id="2-数据分布"><a href="#2-数据分布" class="headerlink" title="2.数据分布"></a>2.数据分布</h2><ul>
<li>分布就是概率</li>
<li>分布函数<ul>
<li>概率密度函数（PDF）</li>
<li>累计密度函数（CDF）</li>
<li><h2 id="3-连续变量的典型分布"><a href="#3-连续变量的典型分布" class="headerlink" title="3.连续变量的典型分布"></a>3.连续变量的典型分布</h2></li>
</ul>
</li>
<li>正态分布</li>
<li>中心极限定理</li>
<li>经验法则</li>
<li>切比雪夫定理</li>
</ul>
<h2 id="4-离散变量的典型分布"><a href="#4-离散变量的典型分布" class="headerlink" title="4.离散变量的典型分布"></a>4.离散变量的典型分布</h2><ul>
<li>0-1分布</li>
<li>二项分布</li>
<li>泊松分布（n很大，p很小时对二项分布的近似）</li>
</ul>
<h2 id="5-单变量的集中趋势描述"><a href="#5-单变量的集中趋势描述" class="headerlink" title="5.单变量的集中趋势描述"></a>5.单变量的集中趋势描述</h2><ul>
<li>集中趋势：一组数据向着一个中心靠拢的程度，也体现了数据中心点所在位置。</li>
<li>分类变量<ul>
<li>众数</li>
</ul>
</li>
<li>连续变量<ul>
<li>均值（算数平均数、几何平均数、加权平均数）</li>
<li>中位数</li>
<li>分位数</li>
</ul>
</li>
<li>被滥用的均值<ul>
<li>非单峰分布</li>
<li>极值的影响</li>
<li>简单的算术平均</li>
</ul>
</li>
</ul>
<h2 id="6-单变量的离散程度描述"><a href="#6-单变量的离散程度描述" class="headerlink" title="6.单变量的离散程度描述"></a>6.单变量的离散程度描述</h2><ul>
<li>离散程度：一组数据远离其中心的程度。<ul>
<li>集中趋势从数据中选“典型代表”，“代表是否够典型”由离散程度检验。</li>
</ul>
</li>
<li>离散统计量<ul>
<li>极差</li>
<li>方差、标准差</li>
<li>Z分数</li>
<li>变异系数</li>
</ul>
</li>
<li>偏度（Skewness）描述某变量取值分不对称性。<ul>
<li>对称（=0）</li>
<li>左偏（&lt;0）均值落于中位数左侧，极小值多</li>
<li>右偏（&gt;0）均值落于中位数右侧，极大值多</li>
</ul>
</li>
<li>峰度（Kurtosis）描述某变量所有取值分布形态陡缓程度。<ul>
<li>正态分布（0、3）</li>
<li>尖顶峰（&gt;0、3）</li>
<li>平定峰（&lt;0、3）</li>
</ul>
</li>
</ul>
<h2 id="7-双变量的统计描述"><a href="#7-双变量的统计描述" class="headerlink" title="7.双变量的统计描述"></a>7.双变量的统计描述</h2><ul>
<li>相关性：两个变量共同变化的趋势。（是否有线性关系，相关不代表因果，正/负不代表相关性强弱）<ul>
<li>正相关、负相关、线性无关</li>
<li>协方差 Cov(X,Y)=E[(X-E[X])(Y-E[Y])]=E[XY]-2E[Y]E[X]+E[X]E[Y]=E[XY]-E[X]E[Y]</li>
<li>相关系数 ρXY=Cov(X,Y)/(D(X)^0.5*D(Y)^0.5)  （-1~1之间）</li>
<li>协方差矩阵（对角线都是1，对称矩阵）</li>
</ul>
</li>
</ul>
<h2 id="8-产生符合特定分布的测试数据"><a href="#8-产生符合特定分布的测试数据" class="headerlink" title="8.产生符合特定分布的测试数据"></a>8.产生符合特定分布的测试数据</h2><ul>
<li>分布函数家族：*func()</li>
</ul>
<p>*：<br>    + r：随机分布函数<br>    + d：概率密度函数<br>    + p：累积分布函数<br>    + q：分位数函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.生成符合特定分布的数据</span></span><br><span class="line"><span class="comment">#   二项分布</span></span><br><span class="line"><span class="comment">#   x~(N,P)  N=100, P=0.7</span></span><br><span class="line">str(rbinom)</span><br><span class="line"></span><br><span class="line"><span class="comment">#   生成随机数</span></span><br><span class="line">x=rbinom(<span class="number">5</span>,<span class="number">1</span>,<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">x=rbinom(<span class="number">5</span>,<span class="number">100000</span>,<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#   得到概率</span></span><br><span class="line">y=dbinom(<span class="number">20</span>,<span class="number">100</span>,<span class="number">0.7</span>) <span class="comment">#100次实验中正好共发生20次的概率</span></span><br><span class="line">y=dbinom(<span class="number">60</span>:<span class="number">90</span>,<span class="number">100</span>,<span class="number">0.7</span>)</span><br><span class="line">sum(y)</span><br><span class="line"></span><br><span class="line">y=dbinom(<span class="number">0</span>:<span class="number">100</span>,<span class="number">100</span>,<span class="number">0.7</span>)</span><br><span class="line">plot(<span class="number">0</span>:<span class="number">100</span>,y,pch=<span class="number">16</span>) <span class="comment">#概率密度曲线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   得到累积概率</span></span><br><span class="line">y=pbinom(<span class="number">20</span>,<span class="number">100</span>,<span class="number">0.7</span>) <span class="comment">#100次实验中发生小于20次的概率</span></span><br><span class="line"></span><br><span class="line">pbinom(<span class="number">40</span>,<span class="number">100</span>,<span class="number">0.7</span>)-pbinom(<span class="number">20</span>,<span class="number">100</span>,<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#   累积函数密度曲线</span></span><br><span class="line">plot(<span class="number">0</span>:<span class="number">100</span>,pbinom(<span class="number">0</span>:<span class="number">100</span>,<span class="number">100</span>,<span class="number">0.7</span>),pch=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#   得到分位数</span></span><br><span class="line">x=pbinom(<span class="number">0.4</span>,<span class="number">100</span>,<span class="number">0.7</span>)</span><br></pre></td></tr></table></figure>

<h2 id="9-R的单变量统计函数"><a href="#9-R的单变量统计函数" class="headerlink" title="9.R的单变量统计函数"></a>9.R的单变量统计函数</h2><ul>
<li>均值：mean</li>
<li>中位数：median</li>
<li>分位数：quantile</li>
<li>方差：var</li>
<li>标准差：sd</li>
<li>频数表：table</li>
<li>峰度</li>
<li>偏度<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.单变量的描述统计</span></span><br><span class="line">str(airquality)</span><br><span class="line">summary(airquality)</span><br><span class="line"></span><br><span class="line">mean(airquality$Ozone,na.rm=<span class="literal">T</span>) <span class="comment">#变量中有NA（缺失值)时删除NA</span></span><br><span class="line">median(airquality$Ozone,na.rm=<span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line">mean(airquality$Temp,na.rm=<span class="literal">T</span>,trim=<span class="number">.01</span>) <span class="comment">#trim是按百分比裁剪极值</span></span><br><span class="line"></span><br><span class="line">temp100=rnorm(<span class="number">100</span>,<span class="number">30</span>,<span class="number">1</span>)</span><br><span class="line">w=<span class="number">1</span>:<span class="number">100</span></span><br><span class="line">(wtm=(weighted.mean(temp100,w,na.rm=<span class="literal">T</span>))) <span class="comment">#加权平均数</span></span><br><span class="line"></span><br><span class="line">x=c(<span class="number">.045</span>,<span class="number">.021</span>,<span class="number">.225</span>,<span class="number">.018</span>)</span><br><span class="line">(xm=mean(x))</span><br><span class="line">(xg=exp(mean(log(x)))) <span class="comment">#几何平均数</span></span><br><span class="line"></span><br><span class="line">(tmid=median(temp100,na.rm=<span class="literal">T</span>)) <span class="comment">#中位数</span></span><br><span class="line"></span><br><span class="line">quantile(airquality$Temp,na.rm=<span class="literal">T</span>) <span class="comment">#分位数</span></span><br><span class="line">quantile(airquality$Temp,probs=c(<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0.9</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(tv=var(temp100)) <span class="comment">#方差</span></span><br><span class="line">(ts=sd(temp100)) <span class="comment">#标准差</span></span><br><span class="line"></span><br><span class="line">fivenum(temp100)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义偏度、峰度计算函数</span></span><br><span class="line">apply(airquality[,c(-<span class="number">5</span>,-<span class="number">6</span>)],<span class="number">2</span>,FUN=mean,na.rm=<span class="literal">T</span>)</span><br><span class="line">sapply(airquality[,c(-<span class="number">5</span>,-<span class="number">6</span>)],FUN=mean,na.rm=<span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line">mysummary=<span class="keyword">function</span>(x,<span class="keyword">...</span>)&#123;</span><br><span class="line">  Av=mean(x,na.rm=<span class="literal">T</span>)</span><br><span class="line">  Sd=sd(x,na.rm=<span class="literal">T</span>)</span><br><span class="line">  N=length(x[!is.na(x)])</span><br><span class="line">  Sk=sum((x[!is.na(x)]-Av)^<span class="number">3</span>/Sd^<span class="number">3</span>)/N</span><br><span class="line">  Ku=sum((x[!is.na(x)]-Av)^<span class="number">3</span>/Sd^<span class="number">4</span>)/N-<span class="number">3</span></span><br><span class="line">  </span><br><span class="line">  result=c(avg=Av,sd=Sd,skew=Sk,kurt=Ku)</span><br><span class="line">  <span class="keyword">return</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sapply(airquality[,c(-<span class="number">5</span>,-<span class="number">6</span>)],FUN=mysummary,na.rm=<span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非单峰分布不能简单计算均值</span></span><br><span class="line">x=rnorm(<span class="number">100</span>,<span class="number">50</span>,<span class="number">6</span>)</span><br><span class="line">y=rnorm(<span class="number">200</span>,<span class="number">150</span>,<span class="number">8</span>)</span><br><span class="line">z=c(x,y)</span><br><span class="line">plot(density(z))</span><br><span class="line">abline(v=mean(z),col=<span class="number">3</span>,lw=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="10-R的双变量相关函数"><a href="#10-R的双变量相关函数" class="headerlink" title="10.R的双变量相关函数"></a>10.R的双变量相关函数</h2><ul>
<li>协方差：cov</li>
<li>相关系数：cor</li>
<li>确实值处理：行删除、配对删除<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.双变量的相关性</span></span><br><span class="line">cov(airquality[,-<span class="number">5</span>:-<span class="number">6</span>],use=<span class="string">'pairwise.complete.obs'</span>) <span class="comment">#配对删除</span></span><br><span class="line">cov(airquality[,-<span class="number">5</span>:-<span class="number">6</span>],use=<span class="string">'complete.obs'</span>) <span class="comment">#行删除</span></span><br><span class="line"></span><br><span class="line">cor(airquality[,-<span class="number">5</span>:-<span class="number">6</span>],use=<span class="string">'pairwise.complete.obs'</span>) <span class="comment">#配对删除</span></span><br><span class="line">cor(airquality[,-<span class="number">5</span>:-<span class="number">6</span>],use=<span class="string">'complete.obs'</span>) <span class="comment">#行删除</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="11-统计量的可视化"><a href="#11-统计量的可视化" class="headerlink" title="11.统计量的可视化"></a>11.统计量的可视化</h2><ul>
<li>散点图</li>
<li>盒线图</li>
<li>直方图</li>
<li>核密度图</li>
<li>柱状图、条形图</li>
<li>饼图</li>
<li>点图</li>
<li>散点图集<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 散点图</span></span><br><span class="line">plot(airquality$Ozone)</span><br><span class="line">plot(airquality$Ozone,airquality$Wind)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 箱线图</span></span><br><span class="line">boxplot(airquality$Temp)</span><br><span class="line">boxplot(airquality$Temp,horizontal = <span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">hist(airquality$Temp)</span><br><span class="line">hist(airquality$Temp,breaks=<span class="number">30</span>) <span class="comment">#横轴块数</span></span><br><span class="line">hist(airquality$Temp,prob=<span class="literal">T</span>) <span class="comment">#纵轴从频数变成频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 密度</span></span><br><span class="line">plot(density(airquality$Temp))</span><br><span class="line"></span><br><span class="line">hist(airquality$Temp,prob=<span class="literal">T</span>)</span><br><span class="line">lines(density(airquality$Temp),col=<span class="number">3</span>,lw=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱状图</span></span><br><span class="line">barplot(table(airquality$Month))</span><br><span class="line">barplot(table(airquality$Month),horiz = <span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 饼图</span></span><br><span class="line">pie(table(airquality$Month))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图集</span></span><br><span class="line">plot(airquality[,<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line">pairs(airquality[,<span class="number">1</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="数据的组织和整理——输入和输出"><a href="#数据的组织和整理——输入和输出" class="headerlink" title="数据的组织和整理——输入和输出"></a>数据的组织和整理——输入和输出</h1><h2 id="1-基本输入输出"><a href="#1-基本输入输出" class="headerlink" title="1.基本输入输出"></a>1.基本输入输出</h2><ul>
<li>输入<br>  1）readline<br>  2）edit、fix</li>
<li>输出<br>  1）print<br>  2）cat</li>
<li>输出重定向<br>  1）sink<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本输入输出</span></span><br><span class="line"><span class="comment">#   输入</span></span><br><span class="line">x=readline(<span class="string">'你好：'</span>)</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line">mydata=data.frame(name=character(<span class="number">0</span>),age=numeric(<span class="number">0</span>),height=numeric(<span class="number">0</span>))</span><br><span class="line">mydata=edit(mydata) <span class="comment">#注意要用=把临时变量赋回来</span></span><br><span class="line">mydata</span><br><span class="line"></span><br><span class="line">fix(mydata)</span><br><span class="line">mydata</span><br><span class="line"></span><br><span class="line"><span class="comment">#   输出</span></span><br><span class="line">x=rnorm(<span class="number">10</span>,<span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line">print(x) <span class="comment">#输出有编号，末尾自带换行符</span></span><br><span class="line">cat(x) <span class="comment">#更紧凑，无编号，可以打印到文件中</span></span><br><span class="line">print(x,digits=<span class="number">4</span>) <span class="comment">#输出格式</span></span><br><span class="line">print(<span class="string">'helloword 1'</span>);print(<span class="string">'welcome to R'</span>)</span><br><span class="line">cat(<span class="string">'hello world 1'</span>);cat(<span class="string">'welcome to R'</span>) <span class="comment">#输出末尾无换行符</span></span><br><span class="line">cat(format(x,digits=<span class="number">3</span>),<span class="string">'\n'</span>) <span class="comment">#输出格式，换行符</span></span><br><span class="line"></span><br><span class="line">cat(<span class="string">'hello world'</span>,file=<span class="string">'d:/app.log'</span>)</span><br><span class="line"></span><br><span class="line">sink(<span class="string">'d:/output.txt'</span>) <span class="comment">#执行后，之后的print、cat输出都会被重新向到文件中</span></span><br><span class="line">print(<span class="string">'hello'</span>)</span><br><span class="line">cat(<span class="string">'sdfjksdf'</span>,<span class="string">'\n'</span>)</span><br><span class="line">sink()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-模拟数据和自带数据集"><a href="#2-模拟数据和自带数据集" class="headerlink" title="2.模拟数据和自带数据集"></a>2.模拟数据和自带数据集</h2><ul>
<li>模拟数据</li>
<li>自带数据集<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 任意分布</span></span><br><span class="line"><span class="comment"># y=a*x+b+e</span></span><br><span class="line"><span class="comment"># x~N(0,2)</span></span><br><span class="line"><span class="comment"># e~N(0,1)</span></span><br><span class="line"><span class="comment"># b=0.5, a=2</span></span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">10</span>) <span class="comment"># 随机种子，用来产生相同的随机数</span></span><br><span class="line">x=rnorm(<span class="number">100</span>,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">e=rnorm(<span class="number">100</span>)</span><br><span class="line">y=<span class="number">2</span>*x+<span class="number">0.5</span>+e</span><br><span class="line">plot(x,y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机数</span></span><br><span class="line">(x=rbinom(<span class="number">5</span>,<span class="number">100</span>,<span class="number">0.7</span>))</span><br><span class="line">(x=rbinom(<span class="number">5</span>,<span class="number">100</span>,<span class="number">0.7</span>))</span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">10</span>)</span><br><span class="line">(x=rbinom(<span class="number">5</span>,<span class="number">100</span>,<span class="number">0.7</span>))</span><br><span class="line">(x=rbinom(<span class="number">5</span>,<span class="number">100</span>,<span class="number">0.7</span>))</span><br><span class="line">set.seed(<span class="number">10</span>)</span><br><span class="line">(x=rbinom(<span class="number">5</span>,<span class="number">100</span>,<span class="number">0.7</span>))</span><br><span class="line">(x=rbinom(<span class="number">5</span>,<span class="number">100</span>,<span class="number">0.7</span>)) <span class="comment"># 跟上面相同</span></span><br><span class="line"></span><br><span class="line">data(package=<span class="string">'datasets'</span>)</span><br><span class="line">data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统所有包中的数据集</span></span><br><span class="line">data(package=.packages(all.available = <span class="literal">T</span>))</span><br><span class="line"><span class="keyword">library</span>(arules)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-文件数据源"><a href="#3-文件数据源" class="headerlink" title="3.文件数据源"></a>3.文件数据源</h2><ul>
<li>文本文件：read.table read.csv read.delim</li>
<li>Excel文件：四种方法</li>
<li>SPSS文件：foreign::read.spss、Hmisc::spss.get<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件数据源</span></span><br><span class="line">getwd() <span class="comment">#查看当前工作目录</span></span><br><span class="line">setwd(<span class="string">'d:/'</span>) <span class="comment">#更改当前工作目录</span></span><br><span class="line">x=rnorm(<span class="number">1000</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">y=rnorm(<span class="number">1000</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">z=rnorm(<span class="number">1000</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">save(x,y,z,file=<span class="string">'xyz.Rdata'</span>)</span><br><span class="line">l=load(<span class="string">'xyz.Rdata'</span>)</span><br><span class="line">l <span class="comment"># l=变量名字列表</span></span><br><span class="line"></span><br><span class="line">x=read.table(<span class="string">'xyz.Rdata'</span>,header=<span class="literal">F</span>,seq=<span class="string">''</span>,comment.char=<span class="string">'@'</span>)</span><br><span class="line">x</span><br><span class="line">str(x)</span><br><span class="line">x=read.csv(<span class="string">'scan0.txt'</span>,header=<span class="literal">F</span>,seq=<span class="string">''</span>)</span><br><span class="line">x=read.delim(<span class="string">'scan0.txt'</span>,header=<span class="literal">F</span>) <span class="comment">#这几个red都一样，只是参数缺省值不同</span></span><br><span class="line">x=read.delim(<span class="string">'clipborad'</span>,header=<span class="literal">F</span>) <span class="comment">#从剪切板读</span></span><br><span class="line"></span><br><span class="line">write.table(x,<span class="string">'d:/scan2.txt'</span>,seq=<span class="string">','</span>,quote=<span class="literal">F</span>,col.names=<span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Excel文件</span></span><br><span class="line"><span class="comment">#   1.csv文件</span></span><br><span class="line"><span class="comment">#   2.剪切板+read.delim</span></span><br><span class="line"><span class="comment">#   3.xlsx扩展包</span></span><br><span class="line"><span class="comment">#   4.rodbc数据源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">library</span>(foreign) <span class="comment">#这个包提供了read.spss方法</span></span><br><span class="line">cars=read.spss(<span class="string">'d:/car_sales.sav'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">library</span>(Hmisc) <span class="comment">#简单方法，需要额外装这个包</span></span><br><span class="line">cust=spss.get(<span class="string">'d:/car_sales.csv'</span>,use.value.labels=<span class="literal">T</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-关系型数据库（MySQL）"><a href="#4-关系型数据库（MySQL）" class="headerlink" title="4.关系型数据库（MySQL）"></a>4.关系型数据库（MySQL）</h2><ul>
<li>ODBC方式（开放数据库连接（Open Database Connectivity）定义了访问数据库API的一个规范）</li>
<li>RMySQL方式<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#RMySQL</span></span><br><span class="line">install.packages(<span class="string">'RMySQL'</span>)</span><br><span class="line"><span class="keyword">library</span>(RMySQL)</span><br><span class="line">conn = dbConnect(MySQL(),dbname=<span class="string">'rtest'</span>,username=<span class="string">'rtest'</span>,password=<span class="string">'rtest'</span>,host=<span class="string">"192.168.1.100"</span>,port=<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line">dbListTables(conn)</span><br><span class="line">dbListFields(conn,<span class="string">'t_user'</span>)</span><br><span class="line">summary(MySQL(),verbose=<span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line">users=dbReadTable(conn,<span class="string">'t_user'</span>)</span><br><span class="line">str(users)</span><br><span class="line">users</span><br><span class="line"></span><br><span class="line">tmpUser=data.frame( name=paste(<span class="string">'user'</span>,<span class="number">1</span>:<span class="number">100</span>,sep=<span class="string">''</span>),</span><br><span class="line">                   age=rnorm(<span class="number">100</span>,<span class="number">50</span>,<span class="number">5</span>))</span><br><span class="line">tmpUser</span><br><span class="line">dbWriteTable(conn,<span class="string">'t_user'</span>,tmpUser,append=<span class="literal">T</span>,row.names=<span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dbWriteTable(conn,<span class="string">'t_stu'</span>,tmpUser,append=<span class="literal">T</span>)</span><br><span class="line">dbReadTable(conn,<span class="string">'t_stu'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res=dbGetQuery(conn,<span class="string">'select * from t_user where age&gt;10'</span>)</span><br><span class="line">res</span><br><span class="line"></span><br><span class="line">res=dbSendQuery(conn,<span class="string">'show databases'</span>) </span><br><span class="line">dl=fetch(res)  </span><br><span class="line">dl</span><br><span class="line"></span><br><span class="line">dbDisconnect(conn) <span class="comment"># 断开连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#RODBC    mysqlodbc驱动要装，system32文件下odbcad32.exe</span></span><br><span class="line">install.packages(<span class="string">'RODBC'</span>)</span><br><span class="line"><span class="keyword">library</span>(RODBC)</span><br><span class="line">conn=odbcConnect(<span class="string">"mysqlodbc"</span>)</span><br><span class="line">conn=odbcConnect(<span class="string">"mysqlodbc"</span>, uid=<span class="string">"rtest"</span>, pwd=<span class="string">'rtest'</span>)</span><br><span class="line">sqlTables(conn)</span><br><span class="line">users=sqlFetch(conn,<span class="string">'t_user'</span>)</span><br><span class="line">users</span><br><span class="line">str(users)</span><br><span class="line"></span><br><span class="line">users=sqlQuery(conn,<span class="string">'select * from t_user where age&gt;15'</span>)</span><br><span class="line">users</span><br><span class="line"> </span><br><span class="line">odbcClose(conn)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="数据的组织和整理——数据预处理（1）"><a href="#数据的组织和整理——数据预处理（1）" class="headerlink" title="数据的组织和整理——数据预处理（1）"></a>数据的组织和整理——数据预处理（1）</h1><h2 id="1-日期时间、字符串的处理"><a href="#1-日期时间、字符串的处理" class="headerlink" title="1.日期时间、字符串的处理"></a>1.日期时间、字符串的处理</h2><p>·日期和时间<br>    - Date：日期类<br>    - POSIXct：日期时间类，精确到秒。内部用数字表示</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 得到当前日期时间</span></span><br><span class="line">(di=Sys.Date())</span><br><span class="line">(d2=date())</span><br><span class="line"></span><br><span class="line">myDate=as.Date(<span class="string">'2007-08-09'</span>)</span><br><span class="line">class(myDate)</span><br><span class="line">mode(myDate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期转字符串</span></span><br><span class="line">as.character(myDate)</span><br><span class="line"></span><br><span class="line">dirDay=c(<span class="string">'01/05/1986'</span>,<span class="string">'08/11/1976'</span>)</span><br><span class="line">dates=as.Date(dirDay,<span class="string">'%m/%d/%Y'</span>)</span><br><span class="line">dates</span><br><span class="line"></span><br><span class="line">td=Sys.Date()</span><br><span class="line">format(td,format=<span class="string">'%B  %d %Y'</span>)</span><br><span class="line">format(td,format=<span class="string">'%A,%a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期转换成个数字</span></span><br><span class="line">as.integer(Sys.Date())</span><br><span class="line">as.integer(as.Date(<span class="string">'1970-1-1'</span>))</span><br><span class="line">as.integer(as.Date(<span class="string">'1970-1-2'</span>))</span><br><span class="line"></span><br><span class="line">sdate=as.Date(<span class="string">'1904-1-1'</span>)</span><br><span class="line">edate=as.Date(<span class="string">'2010-11-1'</span>)</span><br><span class="line">days=edate-sdate</span><br><span class="line">days</span><br><span class="line"></span><br><span class="line">ws=difftime(Sys.Date(),as.Date(<span class="string">'1956-10-12'</span>),units=<span class="string">'weeks'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把年月日拼成日期</span></span><br><span class="line">(d=ISOdate(<span class="number">2011</span>,<span class="number">10</span>,<span class="number">2</span>));class(d) <span class="comment"># ISOdate()可以拼成日期，类型是POSIXct</span></span><br><span class="line">as.Date(ISOdate(<span class="number">2011</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">ISOdate(<span class="number">2011</span>,<span class="number">2</span>,<span class="number">30</span>) <span class="comment">#不存在的日期返回NA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量转换成日期</span></span><br><span class="line">years=c(<span class="number">2010</span>,<span class="number">2011</span>,<span class="number">2012</span>,<span class="number">2013</span>,<span class="number">2014</span>,<span class="number">2015</span>)</span><br><span class="line">months=<span class="number">1</span></span><br><span class="line">days=c(<span class="number">15</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">19</span>,<span class="number">30</span>,<span class="number">3</span>)</span><br><span class="line">as.Date(ISOdate(years,months,days)) <span class="comment"># ISOdate()支持向量化运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取日期时间的一部分</span></span><br><span class="line">p=as.POSIXlt(Sys.Date())</span><br><span class="line">Sys.Date()</span><br><span class="line">p$year+<span class="number">1900</span> <span class="comment"># 年要+1900</span></span><br><span class="line">p$mon+<span class="number">1</span> <span class="comment"># 月要+1</span></span><br><span class="line">p$mday</span><br><span class="line">p$hour</span><br><span class="line">p$min</span><br><span class="line">p$sec</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串<ul>
<li>nchar(),length()</li>
<li>paste(),outer()</li>
<li>substr(),strsplit()</li>
<li>Sub(),gsub(),grep(),regexpr(),grepexpr()</li>
<li>POSIXlt：日期时间类，精确到秒。内部用列表表示</li>
<li>Sys.date(),date(),difftime(),ISOdate(),ISOdatetime()</li>
</ul>
</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x=<span class="string">'hello\rwld\n'</span></span><br><span class="line">cat(x) <span class="comment"># 会执行转义字符</span></span><br><span class="line">print(x) <span class="comment"># 不执行，都输出显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串长度</span></span><br><span class="line">nchar(x)</span><br><span class="line">length(x) <span class="comment"># 得到向量个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串拼接</span></span><br><span class="line">board=paste(<span class="string">'b'</span>,<span class="number">1</span>:<span class="number">4</span>,seq=<span class="string">'-'</span>)</span><br><span class="line">board</span><br><span class="line"></span><br><span class="line">mm=paste(<span class="string">'mm'</span>,<span class="number">1</span>:<span class="number">3</span>,seq=<span class="string">'-'</span>)</span><br><span class="line">mm</span><br><span class="line"></span><br><span class="line">outer(board,mm,paste,seq=<span class="string">':'</span>) <span class="comment"># outer向量配对</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拆分提取</span></span><br><span class="line">board</span><br><span class="line">substr(board,<span class="number">3</span>,<span class="number">3</span>) <span class="comment"># 第3个开始，第3个结束</span></span><br><span class="line">strsplit(board,<span class="string">'-'</span>,fixed=<span class="literal">T</span>) <span class="comment"># fixed抑制正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">sub(<span class="string">'-'</span>,<span class="string">'.'</span>,board,fixed=<span class="literal">T</span>) <span class="comment"># 只是修改了临时对象</span></span><br><span class="line">board</span><br><span class="line">mm</span><br><span class="line">sub(<span class="string">'m'</span>,<span class="string">'p'</span>,mm) <span class="comment"># sub替换第一个匹配项</span></span><br><span class="line">gsub(<span class="string">'m'</span>,<span class="string">'p'</span>,mm) <span class="comment"># gsub替换全部匹配项</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找</span></span><br><span class="line">mm=c(mm,<span class="string">'mm4'</span>)</span><br><span class="line">mm</span><br><span class="line">grep(<span class="string">'-'</span>,mm) <span class="comment"># 返回第几个元素包含'-'</span></span><br><span class="line">regexpr(<span class="string">'-'</span>,mm) <span class="comment"># 返返回位置信息</span></span><br></pre></td></tr></table></figure>

<h2 id="2-数据预处理概念"><a href="#2-数据预处理概念" class="headerlink" title="2.数据预处理概念"></a>2.数据预处理概念</h2><ul>
<li>数据预处理的意义<br>·数据质量<ul>
<li>准确性，完整性，一致性，冗余性，时效性……</li>
</ul>
</li>
<li>数据预处理的内容<ul>
<li>数据集成，数据转换，数据清洗，数据简约</li>
<li>数据清洗时又脏又累的活</li>
</ul>
</li>
</ul>
<h2 id="3-数据集成"><a href="#3-数据集成" class="headerlink" title="3.数据集成"></a>3.数据集成</h2><ul>
<li>merge #数据框合成</li>
<li>pylr::join # 包名::函数<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">(customer=data.frame(Id=c(<span class="number">1</span>:<span class="number">6</span>),State=c(rep(<span class="string">"北京"</span>,<span class="number">3</span>),rep(<span class="string">"上海"</span>,<span class="number">3</span>))))</span><br><span class="line">(ol=data.frame(Id=c(<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>),Product=c(<span class="string">'IPhone'</span>,<span class="string">'Vixo'</span>,<span class="string">'mi'</span>,<span class="string">'Note2'</span>)))</span><br><span class="line"></span><br><span class="line">merge(customer,ol,by=(<span class="string">'Id'</span>)) <span class="comment"># inner join</span></span><br><span class="line">merge(customer,ol,by=(<span class="string">'Id'</span>),all=<span class="literal">T</span>) <span class="comment"># full jion 全连接</span></span><br><span class="line">merge(customer,ol,by=(<span class="string">'Id'</span>),all.x=<span class="literal">T</span>) <span class="comment"># left outer jion 左连接</span></span><br><span class="line">merge(customer,ol,by=(<span class="string">'Id'</span>),all.y=<span class="literal">T</span>) <span class="comment"># right outer jion 右连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># union 去重 在df1和df2有相同的列名称下</span></span><br><span class="line">rbind(df1,df2) <span class="comment"># 不去重合并</span></span><br><span class="line"></span><br><span class="line">merge(df1,df2,all=<span class="literal">T</span>) <span class="comment"># 去重合并</span></span><br><span class="line">merge(df1,df2,by=(<span class="string">'id'</span>)) <span class="comment"># 显示id相同的行</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="4-数据转换"><a href="#4-数据转换" class="headerlink" title="4.数据转换"></a>4.数据转换</h2><ul>
<li>构造属性</li>
<li>规范化（极差化、标准化）</li>
<li>离散化</li>
<li>改善分布<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">str(airquality)</span><br><span class="line">head(airquality,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">airquality=airquality[order(airquality$Temp),]</span><br><span class="line"></span><br><span class="line">head(airquality,<span class="number">5</span>)</span><br><span class="line">tail(airquality,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造属性</span></span><br><span class="line">quantile(airquality$Temp,probs=c(<span class="number">0</span>,<span class="number">0.3</span>,<span class="number">0.6</span>,<span class="number">1.0</span>))</span><br><span class="line">airquality$isHot=ifelse(airquality$Temp&gt;<span class="number">80</span>,<span class="literal">T</span>,<span class="literal">F</span>)</span><br><span class="line">airquality=within(airquality,&#123;TempL=<span class="literal">NA</span></span><br><span class="line">TempL[Temp&gt;<span class="number">80</span>]=<span class="string">'Hot'</span></span><br><span class="line">TempL[Temp&gt;<span class="number">70</span>&amp;Temp&lt;=<span class="number">80</span>]=<span class="string">'Warm'</span></span><br><span class="line">TempL[Temp&lt;=<span class="number">70</span>]=<span class="string">'Cold'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">airquality$TempL</span><br><span class="line"></span><br><span class="line">airquality$TempL=factor(airquality$TempL,levels=c(<span class="string">'Cold'</span>,<span class="string">'Warm'</span>,<span class="string">'Hot'</span>,ordered=<span class="literal">TRUE</span>))</span><br><span class="line">unclass(airquality$TempL)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据规范化</span></span><br><span class="line">tmp=data.frame(TC=scale(airquality$Temp,scale=<span class="literal">F</span>),</span><br><span class="line">               TZ=scale(airquality$Temp))</span><br><span class="line">tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续变量变离散变量</span></span><br><span class="line">airquality=within(airquality,&#123;</span><br><span class="line">  TempL1=cut(Temp,breaks=c(<span class="number">56</span>,<span class="number">73</span>,<span class="number">81</span>,<span class="number">97</span>),include.lowest = <span class="literal">T</span>)</span><br><span class="line">&#125;)</span><br><span class="line">head(airquality,<span class="number">5</span>)</span><br><span class="line">airquality$TempL1</span><br><span class="line"></span><br><span class="line">airquality=within(airquality,&#123;</span><br><span class="line">  TempL1=cut(Temp,breaks=quantile(Temp,probs=c(<span class="number">0</span>,<span class="number">0.3</span>,<span class="number">0.7</span>,<span class="number">1</span>)),include.lowest = <span class="literal">T</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">table(airquality$TempL1)</span><br><span class="line">prop.table(table(airquality$TempL1))</span><br><span class="line"></span><br><span class="line"><span class="keyword">library</span>(Hmisc)</span><br><span class="line">airquality=within(airquality,&#123;</span><br><span class="line">  TempL3=cut2(Temp,g=<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="数据的组织和整理——数据预处理（2）"><a href="#数据的组织和整理——数据预处理（2）" class="headerlink" title="数据的组织和整理——数据预处理（2）"></a>数据的组织和整理——数据预处理（2）</h1><h2 id="1-发现缺失值"><a href="#1-发现缺失值" class="headerlink" title="1.发现缺失值"></a>1.发现缺失值</h2><ul>
<li>缺失值的表达方式：NA（没有数字）、NaN（无效的数字，如1/0）、Inf（正无穷）、-Inf（负无穷）</li>
<li>发现缺省值：summary(),is.na(),complete.case()</li>
<li>缺失值是否有业务含义</li>
<li>把不合理数据编码为确实值<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有意识到“缺失值问题”的时候就得到的答案</span></span><br><span class="line"><span class="keyword">library</span>(VIM)</span><br><span class="line"></span><br><span class="line">sleep.lm=lm(Dream~Sl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现缺失值</span></span><br><span class="line"><span class="comment">#   1.属性级别</span></span><br><span class="line">is.na(sleep$Sleep) <span class="comment"># 返回的是向量，可用于提取</span></span><br><span class="line"></span><br><span class="line">sleep$Sleep[is.na(sleep$Sleep)]</span><br><span class="line">sleep$Sleep[!(is.na(sleep$Sleep))]</span><br><span class="line"></span><br><span class="line">mean(is.na(sleep$Sleep)) <span class="comment">#缺失值比例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   2.记录级别</span></span><br><span class="line">complete.cases(sleep) <span class="comment">#在记录级别来识别</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据集拆分</span></span><br><span class="line">sleep.cleaned=sleep[complete.cases(sleep),] <span class="comment">#拆分出没有缺失值的数据</span></span><br><span class="line"><span class="comment">#sleep.cleaned=na.omit(sleep)</span></span><br><span class="line">sleep.cleaned=sleep[complete.cases(sleep),] <span class="comment">#拆分出有缺失值的数据</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-缺失值模式"><a href="#2-缺失值模式" class="headerlink" title="2.缺失值模式"></a>2.缺失值模式</h2><ul>
<li>完全随机缺失 Missing Completely At Random, MCAR（缺失跟其他变量、跟自己都没关系）</li>
<li>随机缺失 Missing At Random, MAR （缺失跟其他变量有关系，跟自己没关系）</li>
<li>非随机缺失 NMAR （既跟其他变量有关系，也跟自己有关系）</li>
<li>VIM包</li>
<li>mice包<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   3.概要信息</span></span><br><span class="line"><span class="keyword">library</span>(mice)</span><br><span class="line">md.pattern(sleep)</span><br><span class="line"></span><br><span class="line">aggr(sleep,number=<span class="literal">T</span>,prop=<span class="literal">F</span>)</span><br><span class="line">matrixplot(sleep)</span><br><span class="line">marginplot(sleep[,c(<span class="string">'Dream'</span>,<span class="string">'Sleep'</span>)])</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-删除确实值"><a href="#3-删除确实值" class="headerlink" title="3.删除确实值"></a>3.删除确实值</h2><ul>
<li>分析函数<ul>
<li>na.rm=T （=T计算这条函数时不考虑缺失值，但不是删除，=F包含缺失值）</li>
</ul>
</li>
<li>行删除<ul>
<li>na.omit</li>
</ul>
</li>
<li>配对删除  （多个分析中数据可能来自不同的数据集<ul>
<li>典型函数cor(data.use=”pairwise.complete.obs”)<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">na.omit(sleep) <span class="comment"># 整行删除</span></span><br><span class="line">cor(sleep,use=<span class="string">"pairwise.complete.obs"</span>) <span class="comment"># 配对删除</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="4-填补缺失值"><a href="#4-填补缺失值" class="headerlink" title="4.填补缺失值"></a>4.填补缺失值</h2><ul>
<li>简单抽样填补</li>
<li>均值填补</li>
<li>回归填补<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单随机抽样填充</span></span><br><span class="line">sub.index=which(is.na(sleep$Sleep)==<span class="literal">T</span>)</span><br><span class="line">sleep.clean=sleep[-sub.index,]</span><br><span class="line">sleep.na=sleep[sub.index,] <span class="comment"># 数据集的拆分</span></span><br><span class="line"></span><br><span class="line">sleep.na$Sleep=sample(sleep.clean$Sleep,</span><br><span class="line">                      nrow(sleep.na),replace = <span class="literal">T</span>) <span class="comment"># 抽样（抽样范围，抽样条数，有放回抽样）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值填充</span></span><br><span class="line">sub.index=which(is.na(sleep$Dleep)==<span class="literal">T</span>)</span><br><span class="line">sleep.clean=sleep[-sub.index,]</span><br><span class="line">sleep.na=sleep[sub.index,]</span><br><span class="line"></span><br><span class="line">sleep.na$Dream=mean(sleep.clean$Dream)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回归填充</span></span><br><span class="line">sub.index=which(is.na(sleep$Sleep)==<span class="literal">T</span>)</span><br><span class="line">sleep.clean=sleep[-sub.index,]</span><br><span class="line">sleep.na=sleep[sub.index,]</span><br><span class="line"></span><br><span class="line">sleep.lm=lm(Sleep~Gest+Exp,data=sleep)</span><br><span class="line">sleep.na$Sleep=round(predict(sleep.lm,sleep.na),<span class="number">2</span>) <span class="comment"># round(,2)保留小数点后两位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用哪两个变量做回归填充预测</span></span><br><span class="line">cor(cleep,use=<span class="string">"pairwise.complete.obs"</span>)</span><br><span class="line"><span class="keyword">library</span>(corrgram)</span><br><span class="line">corrgram(cor(sleep,use=<span class="string">"pairwise.complete.obs"</span>),</span><br><span class="line">         lower.panel.panel.conf,upper.panel=panel.pie) <span class="comment"># 看Sleep这一列，sleep跟哪两个相关性最强</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="数据可视化——基础绘图体系"><a href="#数据可视化——基础绘图体系" class="headerlink" title="数据可视化——基础绘图体系"></a>数据可视化——基础绘图体系</h1><h2 id="1-图形设备"><a href="#1-图形设备" class="headerlink" title="1.图形设备"></a>1.图形设备</h2><ul>
<li>图形设备<ul>
<li>pdf,png,jpeg,bmp</li>
<li>win.metafile,postscript</li>
<li>dev.off</li>
</ul>
</li>
<li>高水平绘图函数<ul>
<li>plot,pairs,hist</li>
</ul>
</li>
<li>低水平绘图函数  （需要依托于高水平函数）<ul>
<li>points,lines,text,abline,legend,title,axis<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">plot.women=<span class="keyword">function</span>()&#123;</span><br><span class="line">  plot(women$height,women$weight,</span><br><span class="line">      main=<span class="string">'height-weight'</span>,</span><br><span class="line">      xlab=<span class="string">'height'</span>,</span><br><span class="line">      ylab=<span class="string">'weight'</span>,</span><br><span class="line">      col=<span class="string">'red'</span>, <span class="comment"># 点颜色</span></span><br><span class="line">      pch=<span class="number">19</span>, <span class="comment"># 点的状态</span></span><br><span class="line">      xlim=c(<span class="number">0</span>,<span class="number">100</span>), <span class="comment">#x坐标范围</span></span><br><span class="line">      ylim=c(<span class="number">100</span>,<span class="number">200</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plot.line=<span class="keyword">function</span>()&#123;</span><br><span class="line">  lines(women$height,women$weight,col=<span class="string">'blue'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plot.women()</span><br><span class="line"></span><br><span class="line">pdf(<span class="string">'d:/women.pdf'</span>) <span class="comment"># 图都绘制到pdf设备中了</span></span><br><span class="line">plot.women()</span><br><span class="line">dev.off() <span class="comment"># 及时关闭文件设备</span></span><br><span class="line"></span><br><span class="line">plot.women()</span><br><span class="line">plot.line()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="2-数值型单变量的可视化（箱线图和直方图）"><a href="#2-数值型单变量的可视化（箱线图和直方图）" class="headerlink" title="2.数值型单变量的可视化（箱线图和直方图）"></a>2.数值型单变量的可视化（箱线图和直方图）</h2><ul>
<li>箱线图<ul>
<li>分组箱线图</li>
</ul>
</li>
<li>直方图<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 箱线图</span></span><br><span class="line">bp.info=boxplot(airquality$Ozone,main=<span class="string">'OZone'</span>,horizontal=<span class="literal">T</span>,axes=<span class="literal">T</span>) <span class="comment">#有返回值，horizontal方向，axes是否显示坐标轴</span></span><br><span class="line"></span><br><span class="line">abline(v=mean(airquality$Ozone,na.rm = <span class="literal">T</span>),col=<span class="string">'red'</span>,lty=<span class="string">'dotted'</span>)</span><br><span class="line"></span><br><span class="line">bp.info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组箱线图</span></span><br><span class="line">bp.info=boxplot(airquality$Ozone~airquality$Month,main=<span class="string">'OZone'</span>,horizontal=<span class="literal">T</span>,axes=<span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">ht.info=hist(airquality$Ozone,breaks = <span class="number">20</span>,freq = <span class="literal">F</span>) <span class="comment">#breaks=区间数量，freq=纵坐标频数/频率</span></span><br><span class="line"></span><br><span class="line">lines(density(airquality$Ozone,na.rm = <span class="literal">T</span>))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-数值型单变量的可视化（密度图和小提琴图）"><a href="#3-数值型单变量的可视化（密度图和小提琴图）" class="headerlink" title="3.数值型单变量的可视化（密度图和小提琴图）"></a>3.数值型单变量的可视化（密度图和小提琴图）</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">hist(airquality$Ozone,breaks = <span class="number">20</span>,freq = <span class="literal">F</span>) <span class="comment">#breaks=区间数量，freq=纵坐标频数/频率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 密度图</span></span><br><span class="line">lines(density(airquality$Ozone,na.rm = <span class="literal">T</span>)) <span class="comment">#核密度估计图</span></span><br><span class="line"></span><br><span class="line">omean=mean(airquality$Ozone,na.rm = <span class="literal">T</span>)</span><br><span class="line">osd=sd(airquality$Ozone,na.rm = <span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line">x=seq(from=min(airquality$Ozone,na.rm = <span class="literal">T</span>),</span><br><span class="line">      to=max(airquality$Ozone,na.rm = <span class="literal">T</span>),</span><br><span class="line">      length=<span class="number">1000</span>)</span><br><span class="line">y=dnorm(x,omean,osd)</span><br><span class="line">lines(x,y,col=<span class="string">'red'</span>,lwd=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小提琴图</span></span><br><span class="line"><span class="keyword">library</span>(vioplot)</span><br><span class="line">help(package=<span class="string">"vioplot"</span>)</span><br><span class="line">&lt;/code&gt;</span><br><span class="line"><span class="number">4.</span>离散型单变量的可视化</span><br><span class="line">·条形图和柱状图</span><br><span class="line">·分组条形图（柱状图）</span><br><span class="line">·堆叠条形图（柱状图）</span><br><span class="line">·饼图</span><br><span class="line">&lt;code&gt;</span><br><span class="line">score=read.csv(<span class="string">'d:/ReprotCard.txt'</span>,header=<span class="literal">T</span>,seq=<span class="string">' '</span>)</span><br><span class="line">score=na.omit(score) <span class="comment"># 干掉确实值</span></span><br><span class="line">nGrade=tapply(score$avScore,score$avScore,length)</span><br><span class="line">nGrade</span><br><span class="line">barplot(nGrade,names=c(<span class="string">'良'</span>,<span class="string">'中'</span>,<span class="string">'及格'</span>,<span class="string">'不及格'</span>),horiz=<span class="literal">F</span>) <span class="comment">#horiz=T条形图，=F柱状图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组柱状图</span></span><br><span class="line">nGradeBySex=table(score&amp;sex,score$avScore)</span><br><span class="line">nGradeBySex</span><br><span class="line">barplot(nGradeBySex,beside=<span class="literal">F</span>,col=(<span class="number">1</span>,<span class="number">2</span>),ylim=c(<span class="number">0</span>,<span class="number">20</span>)) <span class="comment">#beside=T分组柱状图，=F堆叠柱状图</span></span><br><span class="line">legend(<span class="string">'topright'</span>,c(<span class="string">'女'</span>,<span class="string">'男'</span>)，pch=c(<span class="number">15</span>,<span class="number">15</span>),col=c(<span class="number">1</span>,<span class="number">2</span>),horiz=<span class="literal">F</span>,cex=<span class="number">0.8</span>) <span class="comment"># 图例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 饼图</span></span><br><span class="line">score=read.csv(<span class="string">'d:/ReprotCard.txt'</span>,header=<span class="literal">T</span>,seq=<span class="string">' '</span>)</span><br><span class="line">score=na.omit(score)</span><br><span class="line">nGrade=table(score$avScore)</span><br><span class="line">pie(nGrade)</span><br><span class="line">pct=round(nGrade/length(score$avScore)*<span class="number">100</span>,<span class="number">2</span>)</span><br><span class="line">pct</span><br><span class="line">labs=paste(c(<span class="string">'良'</span>,<span class="string">'中'</span>,<span class="string">'及格'</span>,<span class="string">'不及格'</span>),pct,<span class="string">'%'</span>,seq=<span class="string">''</span>)</span><br><span class="line">labs</span><br><span class="line"><span class="keyword">library</span>(RcolorBrewer)</span><br><span class="line">pie(nGrade,labels=labs,main=<span class="string">'各等级比例'</span>，col=brewer.pal(length(nGrade),<span class="string">'Set1'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D饼图</span></span><br><span class="line"><span class="keyword">library</span>(plotrix)</span><br><span class="line">pie3D(nGrade,labels=labs,main=<span class="string">'各等级比例'</span>，col=brewer.pal(length(nGrade),<span class="string">'Set1'</span>),explode=<span class="number">0.2</span>)</span><br><span class="line">fan.plot(nGrade,labels=labs,main=<span class="string">'各等级比例'</span>，col=brewer.pal(length(nGrade),<span class="string">'Set1'</span>)) <span class="comment"># 扇形图</span></span><br><span class="line"></span><br><span class="line">par(mfrow=c(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">#窗口画布布局一行三列</span></span><br><span class="line">pie(nGrade,labels=labs,main=<span class="string">'各等级比例'</span>，col=brewer.pal(length(nGrade),<span class="string">'Set1'</span>))</span><br><span class="line">pie3D(nGrade,labels=labs,main=<span class="string">'各等级比例'</span>，col=brewer.pal(length(nGrade),<span class="string">'Set1'</span>),explode=<span class="number">0.2</span>)</span><br><span class="line">fan.plot(nGrade,labels=labs,main=<span class="string">'各等级比例'</span>，col=brewer.pal(length(nGrade),<span class="string">'Set1'</span>)) <span class="comment"># 扇形图</span></span><br></pre></td></tr></table></figure>


<h1 id="数据可视化——多变量关系可视化"><a href="#数据可视化——多变量关系可视化" class="headerlink" title="数据可视化——多变量关系可视化"></a>数据可视化——多变量关系可视化</h1><h2 id="1-双变量的可视化"><a href="#1-双变量的可视化" class="headerlink" title="1.双变量的可视化"></a>1.双变量的可视化</h2><ul>
<li>连续型双变量</li>
<li>连续型变量+离散型变量</li>
<li>离散型变量</li>
<li>散点图<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x=rnorm(<span class="number">1000</span>)</span><br><span class="line">y=rnorm(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">plot(x,y,cex=<span class="number">1</span>,pch=<span class="number">19</span>,col=<span class="string">'red'</span>,main=<span class="string">'XY散点图'</span>) <span class="comment">#cex点的大小，pch点的形状</span></span><br><span class="line"></span><br><span class="line">x=rbinom(<span class="number">10000</span>)</span><br><span class="line">y=rbinom(<span class="number">10000</span>,<span class="number">10</span>,<span class="number">0.1</span>) </span><br><span class="line">plot(x,y,cex=<span class="number">1</span>,pch=<span class="number">19</span>,col=<span class="string">'red'</span>,main=<span class="string">'XY散点图'</span>) <span class="comment"># 点重叠，丢失密度信息</span></span><br><span class="line"></span><br><span class="line">sunflowerplot(x,y,cex=<span class="number">1</span>,col=<span class="string">'red'</span>,main=<span class="string">'XY散点图'</span>) <span class="comment">#太阳花法</span></span><br><span class="line"></span><br><span class="line">plot(jitter(x),jitter(y),cex=<span class="number">1</span>,col=<span class="string">'red'</span>,main=<span class="string">'XY散点图'</span>) <span class="comment">#加入抖动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#install.packages('scatterplot3d')</span></span><br><span class="line"><span class="keyword">library</span>(scatterplot3d)</span><br><span class="line">s3d=scatterplot3d(airquality$Temp,airquality$Wind,airquality$Ozone</span><br><span class="line">                  highlight.3d=<span class="literal">TRUE</span>,col.axis=<span class="string">'blue'</span>,</span><br><span class="line">                  col.grid=<span class="string">"lightblue"</span>,angle=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">attach</span>(airquality)</span><br><span class="line">plot(Wind,Temp)</span><br><span class="line"><span class="comment"># 1.一元线性回归</span></span><br><span class="line">alm=lm(Temp~Wind)</span><br><span class="line">abline(alm$coefficients)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.局部加权回归</span></span><br><span class="line">alowess=loess(Temp~Wind)</span><br><span class="line"></span><br><span class="line">ord=order(Wind)</span><br><span class="line">lines(Wind[ord],alowess$fitted[ord],lwd=<span class="number">1</span>,col=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">detach</span>(airquality)</span><br></pre></td></tr></table></figure>
<h2 id="2-多变量的可视化"><a href="#2-多变量的可视化" class="headerlink" title="2.多变量的可视化"></a>2.多变量的可视化</h2></li>
<li>矩阵散点图</li>
<li>相关系数图<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矩阵散点图</span></span><br><span class="line">str(airquality)</span><br><span class="line">pairs(~Ozone+Solar.R+Wind+Temp,data=airquality)</span><br><span class="line">plot(~Ozone+Solar.R+Wind+Temp,data=airquality)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵散点图中加线</span></span><br><span class="line"><span class="keyword">library</span>(car)</span><br><span class="line">scatterplotMatrix(~Ozone+Solar.R+Wind+Temp,data=airquality,lty.smooth=<span class="number">2</span>,spread=<span class="literal">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#相关系数图</span></span><br><span class="line"><span class="keyword">library</span>(corrgram)</span><br><span class="line">corrgram(airquality[,c(-<span class="number">5</span>,-<span class="number">6</span>)],</span><br><span class="line">         lower.panel=panel.pie,</span><br><span class="line">         upper.panel=panel.conf,</span><br><span class="line">         text.panel=panel.txt)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3-分组可视化"><a href="#3-分组可视化" class="headerlink" title="3.分组可视化"></a>3.分组可视化</h2><ul>
<li>Lattice绘图体系<ul>
<li>面板和面板函数<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">unique(iris$Species)</span><br><span class="line"></span><br><span class="line">par(mfrow=c(<span class="number">2</span>,<span class="number">2</span>)) <span class="comment">#定义3行1列布局</span></span><br><span class="line"></span><br><span class="line">by(iris,iris$Species,FUN=<span class="keyword">function</span>(data)&#123;</span><br><span class="line">  plot(data$Sepal.Length,data$Sepal.Width,main=unique(data$Species))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Lattice包</span></span><br><span class="line"><span class="keyword">library</span>(lattice)</span><br><span class="line">head(iris,<span class="number">3</span>)</span><br><span class="line">xyplot(Sepal.Length~Sepal.Width,data=iris)</span><br><span class="line"></span><br><span class="line">plot(Sepal.Length~Sepal.Width,data=iris)</span><br><span class="line"></span><br><span class="line">xyplot(Sepal.Length~Sepal.Width,data=iris,groups=Species)</span><br><span class="line"></span><br><span class="line">xyplot(Sepal.Length~Sepal.Width | Species,data=iris) <span class="comment">#分组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 箱线图</span></span><br><span class="line">bwplot(Sepal.Length~Species,data=iris)</span><br><span class="line">bwplot(~Sepal.Length | Species,data=iris)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直方图</span></span><br><span class="line">histogram(~Sepal.Width | Species,data=iris)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密度图</span></span><br><span class="line">densityplot(~Sepal.Width | Species,data=iris) </span><br><span class="line">densityplot(~Sepal.Width,groups=Species,data=iris) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 带状图</span></span><br><span class="line">stripplot(Species~Sepal.Width,data=iris)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平行坐标图</span></span><br><span class="line">parallelplot(~iris[<span class="number">1</span>:<span class="number">4</span>] | Species,iris)</span><br><span class="line">parallelplot(~iris[<span class="number">1</span>:<span class="number">4</span>],groups=Species,iris,horizontal.axis = <span class="literal">F</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D图</span></span><br><span class="line">cloud(Ozone~Wind*Temp|Month,data=airquality)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="4-自定义面板函数实例"><a href="#4-自定义面板函数实例" class="headerlink" title="4.自定义面板函数实例"></a>4.自定义面板函数实例</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">panel.myplot=<span class="keyword">function</span>(x,y)&#123;</span><br><span class="line">  panel.grid(h=-<span class="number">1</span>,y=-<span class="number">1</span>) <span class="comment">#网格</span></span><br><span class="line">  panel.xyplot(x,y,pch=<span class="number">19</span>) <span class="comment">#散点图</span></span><br><span class="line">  panel.loess(x,y,col=<span class="string">'green'</span>,lwd=<span class="number">2</span>,lty=<span class="number">3</span>) <span class="comment">#局部加权回归</span></span><br><span class="line">  paney.lmline(x,y,col=<span class="string">'red'</span>,lwd=<span class="number">2</span>,lty=<span class="number">2</span>) <span class="comment">#线性回归</span></span><br><span class="line">  panel.rug(x,y) <span class="comment">#展示rug</span></span><br><span class="line">  panel.abline(h=mean(y),lwd=<span class="number">1</span>,lty=<span class="number">2</span>,col=<span class="string">'blue'</span>) <span class="comment">#y的均值线</span></span><br><span class="line">  panel.abline(v=mean(x),lwd=<span class="number">1</span>,lty=<span class="number">2</span>,col=<span class="string">'blue'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xyplot(Sepal.Length~Sepal.Width|Species,data=iris,</span><br><span class="line">       panel=panel.myplot,</span><br><span class="line">       layout=c(<span class="number">2</span>,<span class="number">2</span>),aspect=<span class="number">1.5</span>)</span><br><span class="line">ls(<span class="string">'package:lattice'</span>,pattern = <span class="string">'^panel.+'</span>)</span><br></pre></td></tr></table></figure>




<h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><h2 id="1-假设检验概述"><a href="#1-假设检验概述" class="headerlink" title="1.假设检验概述"></a>1.假设检验概述</h2><ul>
<li>什么是假设检验</li>
<li>假设检验的目的</li>
<li>两种误差：系统误差，随机误差</li>
<li>假设检验执行步骤<ul>
<li>简历要检验的假设，确定检验水准</li>
<li>选择并计算适宜的统计量</li>
<li>确定P值，做出推断<h2 id="2-t分布和t检验"><a href="#2-t分布和t检验" class="headerlink" title="2.t分布和t检验"></a>2.t分布和t检验</h2></li>
</ul>
</li>
<li>t分布的特点<ul>
<li>单峰，以0为中心，左右对称</li>
<li>分布形态和样本数量n有关</li>
<li>n -&gt; ∞时，逼近标准正态曲线</li>
<li>t曲线不是一条曲线，而是一簇曲线</li>
</ul>
</li>
<li>t检验是基于t分布的比较平均数的检验方法</li>
</ul>
]]></content>
      <categories>
        <category>「语言」</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>R语言</tag>
      </tags>
  </entry>
  <entry>
    <title>SPSS 学习笔记</title>
    <url>/2019/04/01/SPSS-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>统计产品与服务解决方案</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="1-数据分析职位介绍"><a href="#1-数据分析职位介绍" class="headerlink" title="1.数据分析职位介绍"></a>1.数据分析职位介绍</h2><ul>
<li>职位设置区别<ul>
<li>数据分析师（偏向宏观，决策依据）</li>
<li>数据挖掘工程师（偏向个体，偏技术）</li>
</ul>
</li>
<li>知识体系区别<ul>
<li>数据库：SQL</li>
<li>统计学：侧重描述统计、参数估计和统计推断</li>
<li>数据挖掘统计：数据总结、分类和回归、聚类分析、关联分析</li>
</ul>
</li>
<li>工具区别<ul>
<li>工具类：SQL、SPSS、STATS、Excel、Matleb、SAS</li>
<li>语言类：R、Python</li>
</ul>
</li>
</ul>
<h2 id="2-SPSS软件基础"><a href="#2-SPSS软件基础" class="headerlink" title="2.SPSS软件基础"></a>2.SPSS软件基础</h2><ul>
<li>SPSS软件概述：斯坦福三个研究生写的，后成立同名公司<ul>
<li>Statistical Package for the Social Science，社会科学统计软件包</li>
<li>2000年改名为Statistical Product and Service Solutions，同级产品和服务解决方案</li>
<li>SPSS是世界三大同级分析软件之一，2009年IBM以12亿美金收购SPSS公司</li>
</ul>
</li>
<li>和其他软件比较</li>
</ul>
<h1 id="数据的组织和管理"><a href="#数据的组织和管理" class="headerlink" title="数据的组织和管理"></a>数据的组织和管理</h1><h2 id="1-数据分类"><a href="#1-数据分类" class="headerlink" title="1.数据分类"></a>1.数据分类</h2><ul>
<li>按照数据存储格式<ul>
<li>数字</li>
<li>字符串</li>
<li>日期时间</li>
</ul>
</li>
<li>按代表的事物特征<ul>
<li>数值型</li>
<li>名义型</li>
<li>定序型</li>
</ul>
</li>
<li>按照数据角色<ul>
<li>输入</li>
<li>输出<h2 id="2-定义数据结构"><a href="#2-定义数据结构" class="headerlink" title="2.定义数据结构"></a>2.定义数据结构</h2></li>
</ul>
</li>
<li>变量名</li>
<li>变量类型、列宽、小数点</li>
<li>变量名标签</li>
<li>变量值表情</li>
<li>缺失数据</li>
<li>计量尺度</li>
<li>变量角色</li>
</ul>
<h2 id="3-数据的导入和编辑"><a href="#3-数据的导入和编辑" class="headerlink" title="3.数据的导入和编辑"></a>3.数据的导入和编辑</h2><ul>
<li>术语：个案和变量</li>
<li>从文件导入数据</li>
<li>录入数据</li>
<li>修改数据</li>
</ul>
<p>4.数据合并</p>
<ul>
<li>横向合并</li>
<li>纵向合并</li>
</ul>
<h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><h2 id="1-假设检验概述"><a href="#1-假设检验概述" class="headerlink" title="1.假设检验概述"></a>1.假设检验概述</h2><ul>
<li>什么是假设检验</li>
<li>假设检验的目的</li>
<li>两种误差：系统误差，随机误差</li>
<li>假设检验执行步骤<ul>
<li>简历要检验的假设，确定检验水准</li>
<li>选择并计算适宜的统计量</li>
<li>确定P值，做出推断</li>
</ul>
</li>
</ul>
<h2 id="2-t分布和t检验"><a href="#2-t分布和t检验" class="headerlink" title="2.t分布和t检验"></a>2.t分布和t检验</h2><ul>
<li>t分布的特点<ul>
<li>单峰，以0为中心，左右对称</li>
<li>分布形态和样本数量n有关</li>
<li>n -&gt; ∞时，逼近标准正态曲线</li>
<li>t曲线不是一条曲线，而是一簇曲线</li>
</ul>
</li>
<li>t检验是基于t分布的比较平均数的检验方法</li>
</ul>
<h2 id="3-单样本t检验实例解析"><a href="#3-单样本t检验实例解析" class="headerlink" title="3.单样本t检验实例解析"></a>3.单样本t检验实例解析</h2><p>【分析】-【比较平均值】-【单样本T检验】  </p>
<h2 id="4-两独立样本t检验实例解析"><a href="#4-两独立样本t检验实例解析" class="headerlink" title="4.两独立样本t检验实例解析"></a>4.两独立样本t检验实例解析</h2><p>【分析】-【比较平均值】-【独立样本T检验】  </p>
<h2 id="5-配对样本t检验实例解析"><a href="#5-配对样本t检验实例解析" class="headerlink" title="5.配对样本t检验实例解析"></a>5.配对样本t检验实例解析</h2><p>【分析】-【比较平均值】-【配对样本T检验】  </p>
<h1 id="数据的基本统计分析"><a href="#数据的基本统计分析" class="headerlink" title="数据的基本统计分析"></a>数据的基本统计分析</h1><h2 id="1-数据的集中趋势"><a href="#1-数据的集中趋势" class="headerlink" title="1.数据的集中趋势"></a>1.数据的集中趋势</h2><ul>
<li>均值</li>
<li>中位数</li>
<li>分位数</li>
<li>众数</li>
</ul>
<h2 id="2-数据的离散趋势"><a href="#2-数据的离散趋势" class="headerlink" title="2.数据的离散趋势"></a>2.数据的离散趋势</h2><ul>
<li>极差</li>
<li>四分位距</li>
<li>方差和标准差</li>
<li>标准分数（Z分数）<ul>
<li>Z=(X-X平均)/s</li>
<li>大于等于3则说明异常</li>
</ul>
</li>
<li>变异系数=标准差/均值</li>
</ul>
<h2 id="3-数据的分布形态"><a href="#3-数据的分布形态" class="headerlink" title="3.数据的分布形态"></a>3.数据的分布形态</h2><ul>
<li>偏态系数（左偏分布&lt;0，对称分布=0，右偏分布&gt;0，看尾巴）</li>
<li>峰态系数（正态分布=0，尖顶峰&gt;0，平顶峰&lt;0）</li>
</ul>
<h2 id="4-频数分析和描述统计实例解析"><a href="#4-频数分析和描述统计实例解析" class="headerlink" title="4. 频数分析和描述统计实例解析"></a>4. 频数分析和描述统计实例解析</h2><ul>
<li>数据的分布表<ul>
<li>频数</li>
<li>百分比</li>
<li>有效百分比（去掉缺失值）</li>
<li>累积百分比</li>
</ul>
</li>
<li>绘制统计图<ul>
<li>柱状图，饼图，直方图</li>
</ul>
</li>
<li>各种统计量</li>
</ul>
<p>【分析】-【描述统计】-【频率】/【描述】  </p>
<p>【数据】-【拆分文件】  #分组统计  </p>
<h2 id="5-交叉步（列联表）分析实例解析"><a href="#5-交叉步（列联表）分析实例解析" class="headerlink" title="5.交叉步（列联表）分析实例解析"></a>5.交叉步（列联表）分析实例解析</h2><ul>
<li>交叉表中的各项指标</li>
<li>交叉表分析的思想和结果解读</li>
</ul>
<p>【分析】-【描述统计】-【交叉表格】  </p>
<p>【数据】-【加权个案】 #加权拓展  </p>
<p>卡方检验  </p>
<h1 id="相关性分析概述"><a href="#相关性分析概述" class="headerlink" title="相关性分析概述"></a>相关性分析概述</h1><p>##1.相关性分析概述</p>
<ul>
<li>函数关系——对于的确定关系</li>
<li>统计关系：线性和非线性关系</li>
<li>线性关系：正线性关系、负线性关系</li>
<li>相关关系不是因果关系</li>
<li>相关关系的可视化</li>
</ul>
<p>2.线性关系的量化指标</p>
<ul>
<li>Pearson相关系数：两个数值变量间的相关性<ul>
<li>相关系数=X和Y的协方差/（X的方差·Y的方差）^1/2</li>
<li>X的样本方差=求和（x-x平均）^2/（n-1）</li>
<li>协方差=求和（x-x平均）（y-y平均）/（n-1）</li>
</ul>
</li>
<li>相关系数特点<ul>
<li>取值在[-1,1]，|相关系数r|越趋近于1则相关性越强</li>
<li>对称性，x和y、y和x相等</li>
<li>r值与x和y尺度无关</li>
<li>线性关系不是因果关系</li>
</ul>
</li>
<li>相关性强弱<ul>
<li>|r|&gt;0.8 高度相关</li>
<li>0.5&gt;|r|&gt;0.8 中度相关</li>
<li>0.3&gt;|r|&gt;0.5 低度相关</li>
<li>|r|&lt;0.3 相关程度极弱，可视为不相关</li>
</ul>
</li>
<li>相关系数的检验</li>
</ul>
<h2 id="3-相关性分析实例解析"><a href="#3-相关性分析实例解析" class="headerlink" title="3.相关性分析实例解析"></a>3.相关性分析实例解析</h2><p>【分析】-【相关】-【双相关】</p>
<h1 id="数据方差分析"><a href="#数据方差分析" class="headerlink" title="数据方差分析"></a>数据方差分析</h1><p>1.方差分析概述</p>
<ul>
<li>方差分析的基本思想<br>  把数据的全部变异——总变异分解成两个或多个组成部分，再做分析</li>
<li>方差分析的术语<br>  观测变量、控制变量、控制变量的水平</li>
<li>方差分析的应用<br>  两组或两组以上均数是否相等<br>  两个或多个元素的交互作用<br>  回归方程的线性假设检验</li>
</ul>
<h2 id="2-方差分析原理"><a href="#2-方差分析原理" class="headerlink" title="2.方差分析原理"></a>2.方差分析原理</h2><ul>
<li>总方差：反应全部个体的变异情况<br>  SS总=求和i求和j（Xij-X平均）^2<br>  v总=N-1  （自由度）</li>
<li>组内方差<br>  各组组内个体之间的变异<br>  属于随机误差</li>
<li>组间方差<br>  各组均数和总均数的差异<br>  除了随机误差，还可能有系统误差</li>
<li>F值</li>
</ul>
<h2 id="3-单因素方差分析实例解析"><a href="#3-单因素方差分析实例解析" class="headerlink" title="3.单因素方差分析实例解析"></a>3.单因素方差分析实例解析</h2><p>【分析】-【比较均值】-【单因素方差分析】</p>
<h1 id="一元线性回归概述"><a href="#一元线性回归概述" class="headerlink" title="一元线性回归概述"></a>一元线性回归概述</h1><h2 id="1-一元线性回归概述"><a href="#1-一元线性回归概述" class="headerlink" title="1.一元线性回归概述"></a>1.一元线性回归概述</h2><ul>
<li>概念介绍：只涉及到一个变量的回归，自变量和因变量之间是线性关系<br>  自变量、因变量</li>
<li>回归模型</li>
<li>回归系数的含义</li>
<li>回归系数的检验</li>
<li>回归方程的检验</li>
</ul>
<p>2.一元线性回归的原理</p>
<ul>
<li>最小二乘法<br>  因变量的变化来自于两个方面：自变量取值变化，自身因素（随机误差）</li>
<li>回归系数的检验<br>  T检验</li>
<li>回归方程的检验<br>  方差分析<br>  SST总平方和=SSR回归平方和+SSR残差平方和</li>
<li><ul>
<li>决定系数<br>反应模型的解释能力<br>反应回归直线的拟合程度<br>决定系数平方根等于相关系数<br>R^2=SSR/SST</li>
</ul>
</li>
</ul>
<h2 id="3-一元线性回归实例解析"><a href="#3-一元线性回归实例解析" class="headerlink" title="3.一元线性回归实例解析"></a>3.一元线性回归实例解析</h2><p>【分析】-【回归】-【线性】</p>
]]></content>
      <categories>
        <category>「笔记」- 软件</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>SPSS</tag>
      </tags>
  </entry>
  <entry>
    <title>拍照地小记</title>
    <url>/2020/12/22/Scenery/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>逛吃逛吃逛吃</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h1><h2 id="自然风景"><a href="#自然风景" class="headerlink" title="自然风景"></a>自然风景</h2><h3 id="茶叶博物馆"><a href="#茶叶博物馆" class="headerlink" title="茶叶博物馆"></a>茶叶博物馆</h3><ul>
<li>位置：西湖区龙井路</li>
<li>造访时间：2020年12月</li>
<li>小记：大片的茶叶植株，有起伏的小山坡</li>
<li>适合：古风、日系清新</li>
</ul>
<h2 id="人文"><a href="#人文" class="headerlink" title="人文"></a>人文</h2><h3 id="馒头山社区"><a href="#馒头山社区" class="headerlink" title="馒头山社区"></a>馒头山社区</h3><ul>
<li>位置：上城区梵天寺路</li>
<li>造访时间：2019年6月</li>
<li>同行：潘刀</li>
<li>适合：80年代复古风、夏日清新</li>
</ul>
<h3 id="小河直街"><a href="#小河直街" class="headerlink" title="小河直街"></a>小河直街</h3><ul>
<li>位置：拱墅区小河直街历史文化街区</li>
<li>造访时间：2019年7月、2020年12月</li>
<li>小记：小河、小巷、小铺、铜像</li>
<li>适合：古装、日常</li>
</ul>
<h3 id="白塔公园"><a href="#白塔公园" class="headerlink" title="白塔公园"></a>白塔公园</h3><ul>
<li>位置：上城区老复兴街</li>
<li>造访时间：2020年12月</li>
<li>小记：两三条火车轨道，火车餐车，老火车站台牌，银杏，会动的观光火车</li>
<li>适合：80年代风、日系清新、电商风</li>
</ul>
<h3 id="江墅铁路遗址公园"><a href="#江墅铁路遗址公园" class="headerlink" title="江墅铁路遗址公园"></a>江墅铁路遗址公园</h3><ul>
<li>位置：拱墅区登云路</li>
<li>造访时间：2019年7月</li>
<li>小记：很小很小的公园，很短很短的铁轨，就一个火车头在那，背景高楼容易入境</li>
<li>适合：电商风</li>
</ul>
<h1 id="省外"><a href="#省外" class="headerlink" title="省外"></a>省外</h1><h2 id="云南·丽江"><a href="#云南·丽江" class="headerlink" title="云南·丽江"></a>云南·丽江</h2><ul>
<li>造访时间：2021年1月</li>
<li>同行：众ZD同事</li>
<li>小记：<ul>
<li>古镇很大，夜景橙色灯光为主，有酒吧一条街；白天主要是石板路、古建筑</li>
<li>风大，雪山大索道没上去，去了海拔3400m的牦牛坪，可以眺望雪山</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>「备忘」</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>WeiboCat With Golang</title>
    <url>/2019/04/15/WeiboCat/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Jacky &amp; Jason</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="项目情况"><a href="#项目情况" class="headerlink" title="项目情况"></a>项目情况</h2><ul>
<li>项目名：<code>WeiboCat</code></li>
<li>想要实现的功能：每天定时在微博上发一张家里喵的图片</li>
<li>启动日期：2019年4月</li>
<li>项目代码地址：<a href="https://github.com/reitake/GoWeiboCat" target="_blank" rel="noopener">GitHub-GoWeiboCat</a></li>
</ul>
<h2 id="项目框架"><a href="#项目框架" class="headerlink" title="项目框架"></a>项目框架</h2><ul>
<li><input disabled="" type="checkbox"> 微博登录  </li>
<li><input disabled="" type="checkbox"> 微博发post</li>
<li><input checked="" disabled="" type="checkbox"> 本地图片文件夹管理</li>
<li><input checked="" disabled="" type="checkbox"> “闹钟”功能</li>
<li><input disabled="" type="checkbox"> 用.json作为config</li>
</ul>
<hr>
<h1 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h1><ul>
<li>SDK for Golang 的使用？</li>
<li>写自己的SDK？</li>
<li>OAuth2.0认证什么鬼啊？</li>
</ul>
<hr>
<h1 id="版本-Change-Log"><a href="#版本-Change-Log" class="headerlink" title="版本 Change Log"></a>版本 Change Log</h1><hr>
<h1 id="过程中踩到的坑"><a href="#过程中踩到的坑" class="headerlink" title="过程中踩到的坑"></a>过程中踩到的坑</h1><h2 id="movepic-go"><a href="#movepic-go" class="headerlink" title="movepic.go"></a>movepic.go</h2><h3 id="把图片改名成时间"><a href="#把图片改名成时间" class="headerlink" title="把图片改名成时间"></a>把图片改名成时间</h3><p>文件名不能包含<code>：</code>这个符号，否则用<code>os.Rename</code>改名不成功，提示错误：<code>The filename, directory name, or volume label syntax is incorrect.</code>。同样地，新文件名不能包含<code>*</code>、<code>\</code>、<code>/</code>等字符。  </p>
<p>正确的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">renameImage</span><span class="params">(folderPath <span class="keyword">string</span>, imageName <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    oldpath := folderPath + PTHSEP + imageName</span><br><span class="line">    fmt.Println(<span class="string">"oldpath:"</span>, oldpath)</span><br><span class="line">    newpath := folderPath + PTHSEP + time.Now().Format(<span class="string">"2006-01-02-15-04-05"</span>) + <span class="string">".png"</span></span><br><span class="line">    fmt.Println(<span class="string">"newpath:"</span>, newpath)</span><br><span class="line">    err := os.Rename(oldpath, newpath)</span><br><span class="line">    fmt.Println(<span class="string">"err:"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">newpath := folderPath + PTHSEP + time.Now().Format(<span class="string">"2006-01-02-15:04:05"</span>) + <span class="string">".png"</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="判断文件夹中是否有图片"><a href="#判断文件夹中是否有图片" class="headerlink" title="判断文件夹中是否有图片"></a>判断文件夹中是否有图片</h3><p>先用<code>ioutil.ReadDir(imagesFolderPath)</code>读取目录下文件，再根据拓展名判断是否是规定格式的图片，不是文件的剔除，剔除后，检查时候还存在剩余图片。  </p>
<p>此时应该用<code>len()</code>判断，而不是判断切片是否为<code>nil</code>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">images, err := ioutil.ReadDir(imagesFolderPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(images); &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.HasSuffix(strings.ToLower(images[i].Name()), <span class="string">".jpg"</span>) || strings.HasSuffix(strings.ToLower(images[i].Name()), <span class="string">".png"</span>) || strings.HasSuffix(strings.ToLower(images[i].Name()), <span class="string">".jpeg"</span>) &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        images = <span class="built_in">append</span>(images[:i], images[i+<span class="number">1</span>:]...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(images) == <span class="number">0</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"\"%s\"文件夹中未找到 .jpg/.png/.jpeg 后缀的图片！\n"</span>, IMAGESFOLDER)</span><br><span class="line">    err = errors.New(<span class="string">"图片库文件夹中未发现图片！"</span>)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>「语言」- Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Go项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/03/07/Hello-World/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong>Hexo 的初始文档</strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># or:</span></span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># or:</span></span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># need to install hexo-deployer-git first:</span></span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>「备忘」- Hexo配置</category>
      </categories>
  </entry>
  <entry>
    <title>《虚拟电厂——能源互联网的终极组态》笔记</title>
    <url>/2020/06/26/VPP-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Virtual Power Plants</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<ul>
<li>作者：艾芊  </li>
<li>出版社：科学出版社 </li>
</ul>
<hr>
<h1 id="第1章-虚拟电厂的起源、原动力与建设目标"><a href="#第1章-虚拟电厂的起源、原动力与建设目标" class="headerlink" title="第1章 虚拟电厂的起源、原动力与建设目标"></a>第1章 虚拟电厂的起源、原动力与建设目标</h1><h2 id="虚拟电厂的发展历程"><a href="#虚拟电厂的发展历程" class="headerlink" title="虚拟电厂的发展历程"></a>虚拟电厂的发展历程</h2><p>分布式能源：</p>
<ul>
<li>灵活、环保、经济</li>
<li>容量小、数量多、分布不均</li>
<li>电网稳定难题：潮流改变、线路阻塞、电压闪变、谐波影响等</li>
</ul>
<p>微网：分布式能源与用户<strong>就地</strong>应用  </p>
<p>虚拟电厂（virtual power plant，VPP）源于1997年Awerbuch博士的《虚拟公共设施：新兴产业的描述、技术及竞争力》：虚拟公共设施是独立且以市场为驱动的实体之间的一种灵活合作，这些实体不必拥有相应的资产而能够为消费者提供其所需要的高效能电力服务。  </p>
<p>虚拟电厂的核心：“聚合”、“通信”。  </p>
<p>主要研究四个方面：</p>
<ul>
<li>虚拟电厂的模型框架</li>
<li>虚拟电厂内部优化调度</li>
<li>虚拟电厂的运行控制</li>
<li>虚拟电厂参与市场竞价</li>
</ul>
<p>还需要解决：</p>
<ul>
<li>从资源角度：VPP发展过程中需合理定位资源功能<ul>
<li>识别配网侧可调控的分布式能源</li>
<li>分析各类分布式能源的技术经济性</li>
<li>结合具体的配电网运行约束，对潜在的分布式资源进行合理定位，明确其提供的服务类型、响应速度</li>
</ul>
</li>
<li>从技术角度看：需要研发配套的软硬件<ul>
<li>计量方面，需要配套的高级量测体系，包括智能电表、用户室内网、广域量测系统、量测数据管理系统等</li>
<li>运行决策方面，需要强大的可视化界面和运行决策支持平台，在区域配电网层面需要同步设计智能决策系统</li>
</ul>
</li>
<li>从管理的角度：需要激励各方积极参与<ul>
<li>需建立虚拟电厂运行相关参与方的合作机制，相关参与方包括分布式能源所有者、集成运营商、配电网或输电网运营者以及电力市场运营者，以保证各参与方的合理收益，时期保持长期的参与积极性</li>
<li>探索建立有利于调动电网企业参与积极性的激励机制，如电网企业收入与售电量脱钩机制，摇到和推动电网企业从售电服务向为电力用户提供精细化节点服务的转变，使其更好地发挥在优化供需双侧资源配置方面的作用</li>
</ul>
</li>
</ul>
<h2 id="虚拟电厂的应用现状"><a href="#虚拟电厂的应用现状" class="headerlink" title="虚拟电厂的应用现状"></a>虚拟电厂的应用现状</h2><p>VPP控制方式包括集中控制、分散控制、完全分散控制等，目前（2016年）<strong>集中控制型</strong>虚拟电厂仍占据全球市场的最大收益领域。  </p>
<p>按资产类型划分，2016年<strong>需求响应型</strong>虚拟电厂占据市场领域的最大份额，而<strong>混合资产型</strong>虚拟电厂（mixed-asset VPP)预计将在今后发展中呈现最快的增长率。</p>
<h3 id="国外虚拟电厂应用"><a href="#国外虚拟电厂应用" class="headerlink" title="国外虚拟电厂应用"></a>国外虚拟电厂应用</h3><p>2007年起，欧洲开展，参与国家包括德国、英国、西班牙、法国、丹麦等。  </p>
<p>北美较少使用“虚拟电厂”的概念，主要推进用户侧可控负荷的需求响应。  </p>
<p>亚太地区，澳大利亚和日本走在前面。  </p>
<h3 id="国内虚拟电厂应用"><a href="#国内虚拟电厂应用" class="headerlink" title="国内虚拟电厂应用"></a>国内虚拟电厂应用</h3><p>2015年上海黄浦区启动需求响应型虚拟电厂试点工作。  力争建设覆盖黄浦区超过200幢商业建筑、具备50MW需求侧响应（DR）容量，10MW自动需求响应（ADR）能力、2MW二次调频能力，以及年虚拟发电运行时间不小于50h的城区商业建筑虚拟电厂。  </p>
<p>2017年5月24日，基于世界上首套“大规模网荷友好互动系统”，江苏电网进行负荷型虚拟电厂的实战演练。目前，江苏全省毫秒级实时响应规模已达100万kW。  </p>
<p>2017年7月，江苏电力试点“橘猫虚拟电厂”，以“负荷众筹”形式邀请具负荷响应互动，并对参与响应的居民给予单词5元电费红包的奖励。  </p>
<p>在浙江省长兴县画溪街道，超威电力有限公司与浙能长兴发电有限公司联合发起建设虚拟电厂实际运营项目。  </p>
<h2 id="能源互联网背景下虚拟电厂发展原动力"><a href="#能源互联网背景下虚拟电厂发展原动力" class="headerlink" title="能源互联网背景下虚拟电厂发展原动力"></a>能源互联网背景下虚拟电厂发展原动力</h2><h3 id="环境驱动力"><a href="#环境驱动力" class="headerlink" title="环境驱动力"></a>环境驱动力</h3><p>随着可再生能源装机容量的继续增加和经济增速放缓，可再生能源消纳变得更加迫切。  </p>
<h3 id="经济驱动力"><a href="#经济驱动力" class="headerlink" title="经济驱动力"></a>经济驱动力</h3><p>可再生能源发电成本已接近或低于传统能源成本。太阳能光伏发电成本从2007年的6元/(kW.h)下降至2016年的0.5~0.6元/(kW.h)，预计未来10年内，将降至0.25元/(kW.h)。  </p>
<p>储能成本也在持续下降。电动汽车电池板，其锂电池已下降至400美元/(kW.h)，并预期将在2030下降到150美元/(kW.h)。  </p>
<h3 id="技术驱动力"><a href="#技术驱动力" class="headerlink" title="技术驱动力"></a>技术驱动力</h3><p>分布式能源、三联供机组、电动汽车、储能装置、可控负荷、智能建筑大量出现，电网内将出现越来越多的“产消者”。随着智能电表的普及和物联网技术的应用，大数据、云计算、分布式计算、人工智能等技术不断发展。电力及能源领域信息化程度的提高。  </p>
<h3 id="政策驱动力"><a href="#政策驱动力" class="headerlink" title="政策驱动力"></a>政策驱动力</h3><p>发展分布式能源是国家保障能源供应、优化能源结构、治理环境污染、建设生态文明的重大战略部署。  </p>
<ul>
<li>分布式电源发展</li>
<li>分布式电源交易</li>
<li>电价改革</li>
<li>需求侧管理</li>
</ul>
<h2 id="虚拟电厂建设目标"><a href="#虚拟电厂建设目标" class="headerlink" title="虚拟电厂建设目标"></a>虚拟电厂建设目标</h2><p>对能源互联网建设来说，虚拟电厂是连接零售市场与批发市场的智能化网络，首要目标是以最低的经济和环境成本保证电网平衡，同时帮助分布式能源所有商实现利润最大化。为效用公司和输电运营商带来更大效益。  </p>
<p>虚拟电厂的终极目标之一是，作为网络资源的协同共享体，能源服务提供者可以从这些资源中获取更多的价值，提高投资回报同时降低资产成本。  </p>
<hr>
<h1 id="第2章-虚拟电厂中的成员、特征与诉求"><a href="#第2章-虚拟电厂中的成员、特征与诉求" class="headerlink" title="第2章 虚拟电厂中的成员、特征与诉求"></a>第2章 虚拟电厂中的成员、特征与诉求</h1><h2 id="虚拟电厂概述"><a href="#虚拟电厂概述" class="headerlink" title="虚拟电厂概述"></a>虚拟电厂概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>是一系列分布式能源的集合，以传统发电厂的角色参与电力系统的运行</li>
<li>是对电网中各种能源进行综合管理的软件系统</li>
<li>也包括效能电厂，通过减少终端用电设备和装置的用电需求来产生“富余”的电能，即通过在用电需求方安装一些提高用电效能的设备，达到建设实际电厂的效果</li>
<li>在能源互联网建设提出之后，虚拟电厂可以看成是可以广域、动态地聚合多种能源的能源互联网</li>
<li>综上，可定义为：由可控机组、不可控机组（风、光等分布式能源）、储能设备、负荷、电动汽车、通信设备等聚合而成，并进一步考虑需求响应、不确定性要素，通过与控制中心、云中心、电力交易中心等进行信息通信，实现与大电网的能量交互</li>
<li>总而言之：可认为是分布式能源的聚合并参与电网运行的一种形式</li>
</ul>
<h3 id="虚拟电厂的外特性"><a href="#虚拟电厂的外特性" class="headerlink" title="虚拟电厂的外特性"></a>虚拟电厂的外特性</h3><ul>
<li>出力伸缩性。不确定性，需要配合合理的电网调度方法，实现与电网的安全交互</li>
<li>广域消纳性。广域调控以消纳随机性</li>
<li>源荷随机性。可视为一个正负变化的负荷</li>
<li>环境友好性</li>
</ul>
<h3 id="虚拟电厂的运行流程"><a href="#虚拟电厂的运行流程" class="headerlink" title="虚拟电厂的运行流程"></a>虚拟电厂的运行流程</h3><p>预测-提交计划-协调电价-制定发电计划-内部协调协议-订立发电合同-优化调整功率-数据保存与整理  </p>
<h3 id="虚拟电厂与微电网的区别"><a href="#虚拟电厂与微电网的区别" class="headerlink" title="虚拟电厂与微电网的区别"></a>虚拟电厂与微电网的区别</h3><ul>
<li>作用域不同</li>
<li>与配网连接点不同</li>
<li>与电网连接方式不同</li>
<li>运行方式不同，是否可孤岛</li>
<li>侧重功能不同</li>
</ul>
<h2 id="虚拟电厂的构成与分类"><a href="#虚拟电厂的构成与分类" class="headerlink" title="虚拟电厂的构成与分类"></a>虚拟电厂的构成与分类</h2><h3 id="虚拟电厂的构成"><a href="#虚拟电厂的构成" class="headerlink" title="虚拟电厂的构成"></a>虚拟电厂的构成</h3><p>主要由发电系统（家庭分布式能源、公用型分布式能源）、储能设备、通信系统三部分构成。  </p>
<h3 id="虚拟电厂的分类"><a href="#虚拟电厂的分类" class="headerlink" title="虚拟电厂的分类"></a>虚拟电厂的分类</h3><p>按照虚拟电厂涵盖的内部资源类型：</p>
<ul>
<li>需求响应虚拟电厂（DR-based VPP）：单纯由可调整负荷构成<ul>
<li>可控负荷：基于电价的可转移负荷、基于激励的可中断负荷</li>
<li>影响因素多，选择不一定理性，可作为辅助功能</li>
</ul>
</li>
<li>供应侧虚拟电厂（supply-side VPP）：单纯由发电单元构成<ul>
<li>由分布式发电机组、分布式储能装置、可直接控制的取暖及空调装置等组成</li>
</ul>
</li>
<li>混合资产虚拟电厂（mixed asset VPP）<ul>
<li>由分布式发电机组、储能及可控负荷等资源共同组成</li>
<li>通过能量管理系统的优化控制，实现更为安全、可靠、清洁的供电</li>
</ul>
</li>
</ul>
<h3 id="虚拟电厂内部资源特性"><a href="#虚拟电厂内部资源特性" class="headerlink" title="虚拟电厂内部资源特性"></a>虚拟电厂内部资源特性</h3><ul>
<li>风力发电特性<ul>
<li>切入风速、额定风速、切出风速</li>
<li>随机、变化迅速，非可调度电源，容量小</li>
<li>经电力电子装置实现并网，还可直接接入负荷</li>
<li>为消纳其随机性，可通过配置大量常规机组或利用地区间风电差异呈现出的互补性来实现</li>
</ul>
</li>
<li>光伏发电特性<ul>
<li>伏打效应</li>
<li>形式：并网发电、独立发电以及与风力互补发电方式</li>
<li>装置较为简单，无机械问题，便于维护，易于搭</li>
<li>受光照、温度、湿度影响，出力波动较大，强烈的随机性，为非可调度电源</li>
</ul>
</li>
<li>需求侧资源特性<ul>
<li>指能够针对市场电价信号或激励信号做出响应，并能够对正常电力消费模式进行调整的负荷资源，在电力系统中，一般通过需求响应参与变动</li>
<li>分为：<ul>
<li>价格型需求响应：用户根据实时电价及生活习惯，自住调整用电行为模式</li>
<li>激励型需求响应：供电公司直接通过电价折扣或高价补偿的方式，对电力用户直接给予奖励，从而引导电力用户参与电力平衡调整的过程</li>
</ul>
</li>
</ul>
</li>
<li>储能设备特性<ul>
<li>根据储能形式的区别：<ul>
<li>机械储能装置，如抽水蓄能装置、飞轮储能装置</li>
<li>化学储能装置（最常见），如铅酸蓄电池、钠硫蓄电池</li>
<li>电磁储能装置，如超级电容器储能装置、超导储能装置</li>
<li>变相储能</li>
</ul>
</li>
<li>电动汽车可视为一种特殊的储能设备</li>
</ul>
</li>
</ul>
<h3 id="虚拟电厂内部资源不确定性"><a href="#虚拟电厂内部资源不确定性" class="headerlink" title="虚拟电厂内部资源不确定性"></a>虚拟电厂内部资源不确定性</h3><ul>
<li>风力发电的不确定性<ul>
<li>风速特性可近似用韦布尔分布进行拟合</li>
</ul>
</li>
<li>光伏发电的不确定性<ul>
<li>与太阳辐射强度密切相关，一段时间内的太阳辐射强度可近似看成Beta分布</li>
</ul>
</li>
<li>多个间歇式分布电源输出功率的不确定性<ul>
<li>通过Copula理论构造多个间歇性分布式能源输出功率的联合分布数学模型<ul>
<li>确定各类分布式电源的边缘分布</li>
<li>选择最佳的Copula函数</li>
<li>校验选择的Copula函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="虚拟电厂的功能特性"><a href="#虚拟电厂的功能特性" class="headerlink" title="虚拟电厂的功能特性"></a>虚拟电厂的功能特性</h2><h3 id="商业型虚拟电厂"><a href="#商业型虚拟电厂" class="headerlink" title="商业型虚拟电厂"></a>商业型虚拟电厂</h3><ul>
<li>定义：从商业收益的角度出发，不考虑配电网的影响，对用户需求和发电潜力进行预测，将虚拟电厂中的分布式能源介入电力市场中，以优化和调度用电量，是分布式能源投资组合的一种灵活表述</li>
<li>输入与输出<ul>
<li>分布式电源输入（运行参数、边际成本、量测信息、负荷预测数据）+其他输入（市场智能、位置数据、网络建模）</li>
<li>输出订立合同、调度计划、参数、成本</li>
</ul>
</li>
<li>功能<ul>
<li>规划应用模拟所有有关能量和传播流动的费用、收益与约束</li>
<li>负荷预测</li>
<li>根据市场情报，优化潜在收入的有价证券，制作合同中的电力交换和远期市场，控制经营成本，并提交分布式能源进度、经营成本等信息至系统运营商</li>
<li>编制交易计划、确定市场价格、实现实时市场交易</li>
</ul>
</li>
</ul>
<h3 id="技术型虚拟电厂"><a href="#技术型虚拟电厂" class="headerlink" title="技术型虚拟电厂"></a>技术型虚拟电厂</h3><ul>
<li>定义：从系统管理的角度出发，由分布式能源和可控负荷共同组成，考虑分布式能源聚合对本地网络的实时影响，可以看成一个带有传输系统的发电厂，具有与其他和电网相连的电厂相同的表征参数</li>
<li>输入与输出<ul>
<li>分布式电源输入（调度计划、边际成本、运行参数）+其他输入（本地网络实时状态、符合参数、网络约束）</li>
<li>输出以电厂运行参数表征的聚合的分布式电源特性</li>
</ul>
</li>
<li>功能<ul>
<li>提供可视化操作界面，允许对系统做出贡献的分布式能源活动，同时增强分布式能源的可控性，提供系统以最低的成本运营</li>
<li>整合所有分布式能源的输入，为每个分布式能源建模（内容包括可控负荷、电网区域网络，以及变电站操作等）</li>
<li>提供发电管理，监督虚拟电厂所有的发电和存储机组，根据每个机组各自的控制方式和机组参数，此功能通过命令界面计算和传输机组的实际状态、机组的实际能量输出、机组启动/停止命令和机组能量设定点</li>
<li>在线优化和协调分布式能源</li>
<li>提供柔性负荷管理</li>
<li>负责制定发电时间表、限定发电上限、控制经营成本等</li>
<li>控制和监督所有发电机组、蓄能机组和柔性需求，同时提供保持电力交换的能量关系的控制能力</li>
<li>提供天气预测</li>
<li>提供发电预测和机组组合</li>
</ul>
</li>
</ul>
<h3 id="两类虚拟电厂间的配合"><a href="#两类虚拟电厂间的配合" class="headerlink" title="两类虚拟电厂间的配合"></a>两类虚拟电厂间的配合</h3><ul>
<li>商业型虚拟电厂通常与传统发电机组相互配合，参与电力市场竞争，共同实现最优发电计划</li>
<li>技术型虚拟电厂将聚合后的资源提供给系统运营商，实现以最低成本维持系统平衡</li>
<li>商业型虚拟电厂为技术型虚拟电厂提供资源信息、运行计划、运行参数等信息，技术型虚拟电厂接受这些信息后，利用其聚合的资源以及传统机组为输电系统提供服务</li>
</ul>
<h3 id="虚拟电厂与外部电网间的配合"><a href="#虚拟电厂与外部电网间的配合" class="headerlink" title="虚拟电厂与外部电网间的配合"></a>虚拟电厂与外部电网间的配合</h3><p>配合机制（3种）:  </p>
<ul>
<li>VPP扮演与传统发电厂相同的角色，由外部电网统一进行调度，从而制定虚拟电厂的调度计划</li>
<li>VPP在外部电网完成联合调度后，外部电网确定虚拟电厂的出力，虚拟电厂根据外部电网优化的结果作为约束，再进行内部优化，制定虚拟电厂内部资源的出力计划</li>
<li>VPP先进行内部优化，制定内部优化计划后上报给外部电网，外部电网根据虚拟电厂上报的调度计划进行优化，指定电网的运行计划</li>
</ul>
<h2 id="虚拟电厂的控制结构"><a href="#虚拟电厂的控制结构" class="headerlink" title="虚拟电厂的控制结构"></a>虚拟电厂的控制结构</h2><h3 id="集中控制方式"><a href="#集中控制方式" class="headerlink" title="集中控制方式"></a>集中控制方式</h3><p>通过控制协调中心（control coordination center，CCC）完全掌握涉及分布式运行的所有单位的信息，并可对所有发电或用电单元进行控制。<br>具有有限的可拓展性和兼容性。  </p>
<h3 id="分散控制方式"><a href="#分散控制方式" class="headerlink" title="分散控制方式"></a>分散控制方式</h3><p>分成多个层次。<br>改善CCC下的通信阻塞和兼容性差的问题。控制协调中心仍处于最顶端，以确保系统运行的安全性和整体运行的经济性。  </p>
<h3 id="完全分散控制方式"><a href="#完全分散控制方式" class="headerlink" title="完全分散控制方式"></a>完全分散控制方式</h3><p>是分散式的一种延伸。<br>出局交换与处理中心只提供市场价格、天气预报等信息，虚拟电厂被划分为相互独立的自治的智能子单元。<br>具有好的可拓展性和开放性，更适合参与电力市场。  </p>
<h2 id="虚拟电厂的投资模式"><a href="#虚拟电厂的投资模式" class="headerlink" title="虚拟电厂的投资模式"></a>虚拟电厂的投资模式</h2><h3 id="分布式能源投资相关市场主体概述"><a href="#分布式能源投资相关市场主体概述" class="headerlink" title="分布式能源投资相关市场主体概述"></a>分布式能源投资相关市场主体概述</h3><ul>
<li>政府等相关监管部门：制定合理的分布式能源融资政策、制定行业发展规范</li>
<li>分布式能源设备供应商：负责向寻你电厂提供所需的各类分布式能源设备</li>
<li>运行维护和节能服务公司</li>
<li>电网公司及用户</li>
</ul>
<h3 id="虚拟电厂投资主体"><a href="#虚拟电厂投资主体" class="headerlink" title="虚拟电厂投资主体"></a>虚拟电厂投资主体</h3><ul>
<li>单投资主体模式：内部的分布式能源均归虚拟电厂所有，即在分布式能源投建阶段采取独立投资的方式<ul>
<li>掌握分布式能源的全部信息，着眼于整体，通过外部市场运营和内部发电成本差价获利，整体的投资效益较好</li>
<li>需要大量投资资金及人力资源，需要具有一定的分布式电源建设能力，对主体要求较为严格</li>
</ul>
</li>
<li>多投资主题模式：内部的分布式能源各自归属不同的独立运营商，虚拟电厂进作为获得市场准入的第三方，即采取合作投资的方式<ul>
<li>VPP通过与独立运营商签订合同，已协商的固定电价从独立运营商购电，将够得的分布式电源发电量统一集中调度，不再掌握分布式电源的技术指标及发电成本等</li>
<li>不再关注分布式电源的发电效益，仅着眼与外部市场运营与合同电价之间的差价获利</li>
<li>通过与不同类别投资主体间的合作，可降低对虚拟电厂的资金要求等条件限制</li>
<li>各投资主体的效益相比但投资主体模式差，为保证整体发电的效率与质量，也应对不同投资主体间实现有效的协调安排</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第3章-虚拟电厂运行的关键技术"><a href="#第3章-虚拟电厂运行的关键技术" class="headerlink" title="第3章 虚拟电厂运行的关键技术"></a>第3章 虚拟电厂运行的关键技术</h1><h2 id="数据存储和大数据分析"><a href="#数据存储和大数据分析" class="headerlink" title="数据存储和大数据分析"></a>数据存储和大数据分析</h2><h3 id="数据清洗和数据存储技术"><a href="#数据清洗和数据存储技术" class="headerlink" title="数据清洗和数据存储技术"></a>数据清洗和数据存储技术</h3><ul>
<li>异常数据辨识<ul>
<li>数据来源：配电自动化系统、用电信息采集系统、负荷控制系统、用户集中抄表系统、电能质量监测系统和一些地市公司安装的其他监测系统</li>
<li>受设备、环境和运行等状态影响，异常数据特点较为复杂</li>
</ul>
</li>
<li>重复数据检测<ul>
<li>数据清洗的重要组成部分</li>
</ul>
</li>
<li>数据存储框架<ul>
<li>将结构化和非结构化混合组成的智能配用电数据按照资源、存储和查询等三个层级设计对其进行管理</li>
<li>资源层主要实现智能配用电大数据计算资源的虚拟化、标准化和负载均衡</li>
<li>存储层实现大数据的快速存储管理</li>
<li>查询层实现海量数据的快速检索</li>
</ul>
</li>
</ul>
<h3 id="数据挖掘技术"><a href="#数据挖掘技术" class="headerlink" title="数据挖掘技术"></a>数据挖掘技术</h3><ul>
<li>数据特征化</li>
<li>关联分析</li>
<li>分类分析</li>
<li>聚类分析</li>
<li>孤立点分析</li>
<li>演变分析</li>
</ul>
<h3 id="大数据分析在虚拟电厂中的应用"><a href="#大数据分析在虚拟电厂中的应用" class="headerlink" title="大数据分析在虚拟电厂中的应用"></a>大数据分析在虚拟电厂中的应用</h3><ul>
<li>基于关联规则挖掘的配电网运行可靠性分析</li>
<li>基于随机矩阵的配网异常事件快速发现</li>
</ul>
<h2 id="态势感知技术"><a href="#态势感知技术" class="headerlink" title="态势感知技术"></a>态势感知技术</h2><p>事态感知技术可以聚焦于实时感知虚拟电厂中不确定因素的变化，为虚拟电厂与竞价提供良好的数据资源。  </p>
<p>三个层次：</p>
<ul>
<li>一级态势感知：态势察觉，进行数据或信息收集，解决“环境中正在发生什么”的问题</li>
<li>二级态势感知：态势理解，通过数据分析获得认知，解决“为什么发生”的问题</li>
<li>三级态势感知：态势预测，基于前两级</li>
</ul>
<h3 id="态势察觉"><a href="#态势察觉" class="headerlink" title="态势察觉"></a>态势察觉</h3><ul>
<li>基本定义：获取被感知对象中的重要线索和元素，是态势感知中最基础的一层</li>
<li>典型应用场景</li>
</ul>
<h3 id="态势理解"><a href="#态势理解" class="headerlink" title="态势理解"></a>态势理解</h3><ul>
<li>基本定义：综合态势估计中得到数据和信息，形成安全态势的综合评估。潮流计算、状态估计是对运行态势进行安全分析、经济分析等评估的基础</li>
<li>典型应用场景</li>
</ul>
<h3 id="态势预测"><a href="#态势预测" class="headerlink" title="态势预测"></a>态势预测</h3><ul>
<li>基本定义：基于对态势察觉、理解的结果，对虚拟电厂中的不确定性变化，如负荷、分布式电源等进行安全风险评估；对系统运行状态进行安全预测</li>
<li>典型应用场景<ul>
<li>配网安全风险</li>
<li>基于安全与防范的配网预测预警</li>
</ul>
</li>
</ul>
<h2 id="云计算技术"><a href="#云计算技术" class="headerlink" title="云计算技术"></a>云计算技术</h2><h3 id="云计算定义和关键技术"><a href="#云计算定义和关键技术" class="headerlink" title="云计算定义和关键技术"></a>云计算定义和关键技术</h3><ul>
<li>云计算是一种可以调用的虚拟化资源池，这些资源池可以根据负载动态重新配置，已达到最优化使用的目的</li>
<li>用户与服务提供商事先约定服务等级协议，用户以用时付费模式使用服务</li>
<li>具有特点：服务资源池化、可拓展性、通过宽带网络调用、可度量性、可靠性</li>
<li>设备架设<ul>
<li>软件即服务（software-as-a-service，SAAS）</li>
<li>实用计算（utility computing）</li>
<li>网络服务</li>
<li>平台即服务</li>
<li>管理服务提供商（managed service provider，MSP）</li>
<li>商业服务平台</li>
<li>互联网整合</li>
</ul>
</li>
<li>资源管理技术<ul>
<li>云计算资源监控</li>
<li>云计算资源调度</li>
</ul>
</li>
<li>任务管理技术<ul>
<li>本地性</li>
<li>同步</li>
<li>公平性</li>
</ul>
</li>
</ul>
<h3 id="云平台介绍"><a href="#云平台介绍" class="headerlink" title="云平台介绍"></a>云平台介绍</h3><ul>
<li>Google云计算平台</li>
<li>IBM“蓝云”计算平台</li>
<li>Amazon弹性计算云平台</li>
</ul>
<h3 id="云计算特征比较和发展"><a href="#云计算特征比较和发展" class="headerlink" title="云计算特征比较和发展"></a>云计算特征比较和发展</h3><ul>
<li>云计算与网格计算的区别<ul>
<li>作业调度</li>
<li>资源分配</li>
</ul>
</li>
<li>云计算与超级计算机的区别</li>
<li>云计算未来发展<ul>
<li>大数据分析</li>
<li>混合云的发展方向</li>
</ul>
</li>
</ul>
<h2 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a>区块链技术</h2><h3 id="区块链技术原理"><a href="#区块链技术原理" class="headerlink" title="区块链技术原理"></a>区块链技术原理</h3><ul>
<li>区块链构成：由区块有序链接起来形成的一种数据结构，其中区块是指数据的集合，相关信息和记录都包括在里面，是形成区块链的基本单元<ul>
<li>区块头，链接到前面的区块</li>
<li>区块主体，记录信息</li>
</ul>
</li>
<li>区块链网络：点到点的网络，去中心化</li>
<li>区块链加密系统原理<ul>
<li>非对称加密算法解决用户之间的信任问题</li>
</ul>
</li>
</ul>
<h3 id="区块链基础模型"><a href="#区块链基础模型" class="headerlink" title="区块链基础模型"></a>区块链基础模型</h3><ul>
<li>数据层</li>
<li>网络层</li>
<li>共识层</li>
<li>激励层</li>
<li>合约层</li>
</ul>
<h3 id="区块链应用场景"><a href="#区块链应用场景" class="headerlink" title="区块链应用场景"></a>区块链应用场景</h3><ul>
<li>为虚拟发电资源的交易提供成本低廉、公开透明的系统平台</li>
<li>特点<ul>
<li>运行生态化</li>
<li>工作量认证公平化</li>
<li>智能合约化</li>
<li>信息透明化</li>
</ul>
</li>
</ul>
<h3 id="区块链存在的问题"><a href="#区块链存在的问题" class="headerlink" title="区块链存在的问题"></a>区块链存在的问题</h3><ul>
<li>安全问题<ul>
<li>51%攻击</li>
<li>非对称加密机制未来的风险</li>
<li>隐私保护的安全性风险</li>
</ul>
</li>
<li>效率问题</li>
<li>资源问题</li>
<li>博弈问题</li>
</ul>
<h2 id="多代理技术"><a href="#多代理技术" class="headerlink" title="多代理技术"></a>多代理技术</h2><h3 id="智能体基本理论"><a href="#智能体基本理论" class="headerlink" title="智能体基本理论"></a>智能体基本理论</h3><ul>
<li>智能体的概念及特点<ul>
<li>在与其他智能体共同存在协同处理的环境中能够自主的、持续地活动的实体</li>
<li>具有认识、目标和能力，并能单独火灾人的少许指导下进行推理决策的能动实体</li>
<li>自治性、社会能力、反应能力、自发行为</li>
</ul>
</li>
<li>智能体的表示与分类<ul>
<li>智能体 = 体系结构 + 程序</li>
<li>分类：<ul>
<li>反应式</li>
<li>慎思式</li>
<li>复合式</li>
</ul>
</li>
</ul>
</li>
<li>多智能体系统理论<ul>
<li>MAS定义与特点<ul>
<li>多智能体系统（multi-agent system，MAS）是由多个智能体组成的系统，是为了解决单个智能体不能够解决的复杂问题，由多个智能体协调、合作形成问题的求解网络</li>
<li>交互性、社会学、协作性、适应性、分布性，数据分布性或分散性，计算过程异步、并发或并行，每个智能体都具有不完全的信息和问题求解能力，不存在全局控制</li>
</ul>
</li>
<li>MAS的组织结构<ul>
<li>网状结构</li>
<li>发散结构</li>
<li>符合结构</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MAS实现和关键技术"><a href="#MAS实现和关键技术" class="headerlink" title="MAS实现和关键技术"></a>MAS实现和关键技术</h3><ul>
<li>MAS平台开发</li>
<li>MAS通信语言标准</li>
<li>MAS知识库模式</li>
</ul>
<h3 id="多代理技术典型应用场景"><a href="#多代理技术典型应用场景" class="headerlink" title="多代理技术典型应用场景"></a>多代理技术典型应用场景</h3><ul>
<li>MAS在协调优化中的应用<ul>
<li>电动汽车</li>
</ul>
</li>
<li>MAS在电力市场运营中的应用<ul>
<li>上级电力市场智能体</li>
<li>虚拟电厂机发电公司智能体</li>
<li>发电元件智能体</li>
</ul>
</li>
</ul>
<h2 id="物联网技术"><a href="#物联网技术" class="headerlink" title="物联网技术"></a>物联网技术</h2><h3 id="物联网基本概念"><a href="#物联网基本概念" class="headerlink" title="物联网基本概念"></a>物联网基本概念</h3><ul>
<li>核心和基础是互联网，并在互联网的基础上进行延伸和拓展</li>
<li>其用户端衍生和拓展到任何物品和物品之间，进行信息交换和通信</li>
</ul>
<h3 id="物联网框架"><a href="#物联网框架" class="headerlink" title="物联网框架"></a>物联网框架</h3><ul>
<li>感知层，是物联网的外部识别物体</li>
<li>网络层，信息的处理和传输</li>
<li>应用层，物联网的社会分工与行业需求的结合</li>
</ul>
<h3 id="物联网信息感知"><a href="#物联网信息感知" class="headerlink" title="物联网信息感知"></a>物联网信息感知</h3><ul>
<li>数据收集</li>
<li>数据清洗</li>
<li>数据压缩</li>
<li>数据聚集</li>
<li>数据融合</li>
</ul>
<h3 id="物联网信息交互"><a href="#物联网信息交互" class="headerlink" title="物联网信息交互"></a>物联网信息交互</h3><ul>
<li>用户与网络的信息交互</li>
<li>网络与内容的信息交互</li>
<li>用户与内容的信息交互</li>
</ul>
<h2 id="智能交互终端技术"><a href="#智能交互终端技术" class="headerlink" title="智能交互终端技术"></a>智能交互终端技术</h2><h3 id="智能交互用电技术架构"><a href="#智能交互用电技术架构" class="headerlink" title="智能交互用电技术架构"></a>智能交互用电技术架构</h3><ul>
<li>用户层</li>
<li>高级量测系统层</li>
<li>智能终端层</li>
<li>通信信息支撑层</li>
<li>智能用电互动化的综合性支撑平台</li>
<li>信息共享支撑</li>
</ul>
<h3 id="智能交互终端功能"><a href="#智能交互终端功能" class="headerlink" title="智能交互终端功能"></a>智能交互终端功能</h3><ul>
<li>数据采集与数据处理</li>
<li>故障检测和自愈功能</li>
<li>事件顺序记录功能</li>
</ul>
<hr>
<h1 id="第4章-虚拟电厂所依存的电力网络通信需求"><a href="#第4章-虚拟电厂所依存的电力网络通信需求" class="headerlink" title="第4章 虚拟电厂所依存的电力网络通信需求"></a>第4章 虚拟电厂所依存的电力网络通信需求</h1><h2 id="信息和通信技术"><a href="#信息和通信技术" class="headerlink" title="信息和通信技术"></a>信息和通信技术</h2><h3 id="通信的特点和要求"><a href="#通信的特点和要求" class="headerlink" title="通信的特点和要求"></a>通信的特点和要求</h3><ul>
<li>电力通信的特点<ul>
<li>要求有较高的可靠性和灵活性</li>
<li>传输信息量少但种类复杂、实时性强</li>
<li>具有较大的耐“冲击”性</li>
<li>电力系统通信网中有着种类繁多的通信手段和各种不同性质的设备、机型，它们通过不同的接口方式和不同的转接方式，构成了电力系统复杂的通信网络结构</li>
<li>通信范围点多面广</li>
<li>无人值守机房居多</li>
</ul>
</li>
<li>虚拟电厂中的通信要求<ul>
<li>数据量要求。智能电网通信系统不仅要考虑目前数据传输的需要，还要考虑系统升级的需要</li>
<li>实时性要求。要求变电站内部小于1ms，其他小于500ms；同步时间偏差小于1ms</li>
<li>环境适应性要求。设备多暴露于室外，环境恶劣</li>
<li>网络安全性要求</li>
<li>对通信的特殊要求：高综合性；高可靠性；公认的保准；高经济性</li>
</ul>
</li>
</ul>
<h3 id="虚拟电厂通信的设计原则"><a href="#虚拟电厂通信的设计原则" class="headerlink" title="虚拟电厂通信的设计原则"></a>虚拟电厂通信的设计原则</h3><ul>
<li>规划设计的统一性</li>
<li>安全可靠的开放性</li>
<li>充分考虑的拓展性</li>
</ul>
<h3 id="通信体系结构"><a href="#通信体系结构" class="headerlink" title="通信体系结构"></a>通信体系结构</h3><ul>
<li>虚拟电厂生产监控通信网。利用先进的通信技术，虚拟电厂生产调控网能够解决的主要问题有电力调度、电力设备在线实时监测、现场作业视频管理、户外设施防盗等</li>
<li>虚拟电厂配用电通信网。针对虚拟电厂用户的需求，主要用于用户电能信息采集、智能家居、无线传感安防、社区服务管理等。其利用先进的通信技术，对家庭用电设备进行统一监控与管理，对电能质量、家庭用电信息等数据进行采集和分析，指导用户进行合理用电，实现虚拟电厂与用户之间智能供、用电。此外，通过智能交互终端，可为用户提供家庭安防、社区服务、互联网等增值服务</li>
<li>虚拟电厂与常规配电网调控中心的通信网络。一般参照智能电网配电网的通信网络架构进行构建，将虚拟电厂作为一个有源可控客户端来处理</li>
</ul>
<h3 id="通信系统的设计"><a href="#通信系统的设计" class="headerlink" title="通信系统的设计"></a>通信系统的设计</h3><ul>
<li>虚拟电厂通信系统的设计</li>
<li>设计实例</li>
</ul>
<h2 id="通信网络"><a href="#通信网络" class="headerlink" title="通信网络"></a>通信网络</h2><h3 id="通信网络概述"><a href="#通信网络概述" class="headerlink" title="通信网络概述"></a>通信网络概述</h3><ul>
<li>指使用交换设备、传输设备将地理上分散的用户终端设备互连起来，实现通信和信息交换的系统</li>
<li>基本形式是在店与店之间坚立通信系统，而通信网则要求将许多的通信系统通过交换系统按一定拓扑结构组合在一起</li>
<li>三种要素<ul>
<li>终端设备（用户设备）</li>
<li>传输系统</li>
<li>交换设备</li>
</ul>
</li>
</ul>
<h3 id="宽带IP网络技术"><a href="#宽带IP网络技术" class="headerlink" title="宽带IP网络技术"></a>宽带IP网络技术</h3><ul>
<li>城域网概念与宽带IP技术<ul>
<li>城域网分为核心层、接入层以及汇聚层，电力通信城域网主要由中国网通公司管理</li>
<li>宽带IP（internet protocol）技术是电力通信城域网的平台基础</li>
</ul>
</li>
<li>IP数据网络在电网调度中的应用</li>
</ul>
<h3 id="4G通信网"><a href="#4G通信网" class="headerlink" title="4G通信网"></a>4G通信网</h3><ul>
<li>4G网络概念<ul>
<li>移动通信技术第四代，下行峰值100Mbits/s</li>
</ul>
</li>
<li>智能电网中4G的应用<ul>
<li>4G在配网自动化领域中通信的应用。配电网的自动化是通过综合自动化、通信以及计算机等相关的技术，对其采取智能化监控管理，进而确保配电网的环境与运行处于安全可靠的状态</li>
<li>4G在风电场通信中的应用。高山不受带宽束缚</li>
<li>智能变电站站内通信领域中4G通信的应用。能够解决传输带宽和加密传输的问题</li>
<li>电网实时监控中4G通信的应用</li>
</ul>
</li>
</ul>
<h2 id="通信设施与系统"><a href="#通信设施与系统" class="headerlink" title="通信设施与系统"></a>通信设施与系统</h2><h3 id="电力线载波"><a href="#电力线载波" class="headerlink" title="电力线载波"></a>电力线载波</h3><ul>
<li>载波通信基本原理<ul>
<li>电力线载波通信（power line carrier communication, PLCC)是以输电线路为载波型号的传输媒介的电力系统通信</li>
<li>利用现有电力线，通过载波方式将模拟或数字信号进行高速传输的技术</li>
<li>特点：不需要重新架设新网络，只要有电线就能传输</li>
<li>世界上所有电力部门优先采用的特有通信手段</li>
</ul>
</li>
<li>电力线载波通信系统的组成<ul>
<li>载波机的收发信端用高频电缆经滤波器（起阻抗匹配及工频电流接地作用）链接耦合电容器（起隔离工频高压的作用），将载波电流传送到输电线上，阻波器用以防止载波电流流向变电所母线侧，减小分流损失</li>
<li>载波电流与输电线的耦合方式分为相相耦合及相地耦合两类<ul>
<li>相相耦合：传输衰耗较小，但耦合投资较大</li>
<li>相地耦合：传输衰耗较大，但耦合设置投资较小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="电力线宽带"><a href="#电力线宽带" class="headerlink" title="电力线宽带"></a>电力线宽带</h3><ul>
<li>电力线宽带概述<ul>
<li>宽带电力线通信（broadband over power line communication，BPLC），指贷款限定在2~30MHz、通信速率在1Mbit/s以上的电力线载波通信</li>
<li>无需重新布线，利用现有配电网，再加上一些电力线载波局端、中继、终端设备以及附属装置</li>
<li>欧美两大阵营<ul>
<li>欧洲主要研究在Internet高速接入网上的应用</li>
<li>美国主要研究其在智能小区以及智能电网上的应用</li>
</ul>
</li>
</ul>
</li>
<li>电力线宽带通信系统结构组成与网络结构<ul>
<li>电力线宽带通信结构组成</li>
<li>网络结构：光纤到户（未来趋势）、光纤+低压网（目前最普遍）、中压+低压网、中压+无线通信网组网</li>
</ul>
</li>
</ul>
<h3 id="无线传感器网络"><a href="#无线传感器网络" class="headerlink" title="无线传感器网络"></a>无线传感器网络</h3><ul>
<li>无线传感器网络介绍<ul>
<li>无线传感器网络（wireless sensor networks，WSNs）是由部署在监测区域内大量传感器节点相互通信形成的多跳自组织网络系统，是物联网底层技术的重要技术形式</li>
<li>自组织、部署迅捷、高容错性、强隐蔽性</li>
</ul>
</li>
<li>WSNs在智能计量与智能家居中的应用<ul>
<li>通过为居民用户和工业、商业用户安装智能电表，采集更为安全和详细的计量信息，与分时电价措施配合，抑制峰值负荷，从而减少用电高峰负荷需要的增长</li>
<li>并能根据对负荷情况更细致、实时的掌握指导电网建设，减少电网扩容和建设费用</li>
<li>帮助电网企业有效定位和防止窃电</li>
</ul>
</li>
</ul>
<h2 id="高级量测系统"><a href="#高级量测系统" class="headerlink" title="高级量测系统"></a>高级量测系统</h2><h3 id="AMI的基本概念"><a href="#AMI的基本概念" class="headerlink" title="AMI的基本概念"></a>AMI的基本概念</h3><ul>
<li>高级量测系统（advanced metering infrastructure，AMI）是一个用来测量、手机、储存、分析和运用用户用电信息的完整的网络处理系统，由安装在用户端的智能电表，位于电力公司内的量测数据管理系统和链接它们的通信系统组成</li>
<li>AMI中的智能电表能按照预先设定的时间间隔记录用户的多种用电信息，吧这些信息通过通信网络传输到数据中心，并在根据不同的要求和目的，如用户计费，故障响应和需求侧管理等进行处理和分析，还能向电表发送信息，如要求更多的数据或对电表进行软件在线升级等</li>
</ul>
<h3 id="AMI的组成"><a href="#AMI的组成" class="headerlink" title="AMI的组成"></a>AMI的组成</h3><ul>
<li>4部分：智能电表、通信网络、量测数据管理系统（meter data management system，MDMS）和用户户内网络（home area network，HAN）</li>
<li>为了充分利用AMI取得的数据，需要为许多现有的应用系统建立应用接口，如负荷预测、故障响应、客户支持和系统运行</li>
<li>智能电表<ul>
<li>是可编程的电表，除了用于电能量记录，还可以实现很多功能</li>
<li>能根据预先设定的时间间隔测量和储存多种计量值（如电能量、有功功率、无功功率、电压等）</li>
<li>具有内置通信模块，能够接入双向通信系统和数据中心进行信息交流</li>
</ul>
</li>
<li>通信网络<ul>
<li>AMI采用固定的双向通信网络，能够每天多次读取智能电表，并能把表计信息（包括故障报警和装置干扰报警）近于实时地从电表传到数据中心</li>
</ul>
</li>
<li>量测数据管理系统<ul>
<li>MDNS是一个带有分析工具的数据库，通过与AMI自动数据收集系统（automation data collection system，ADCS）的配合使用，处理和储存电表的计量值</li>
<li>MDMS的一个基本功能是对AMI数据进行确认、编辑、估算，以确保即使通信网络中断和用户侧故障时，流向上述信息系统或软件的数据流也是完整和准确的</li>
<li>充分利用已收集的大量信息，是取得AMI效益的关键。许多电力公司计划整合现存信息系统的功能，并建立与MDMS的接口，已提高其功能水平</li>
</ul>
</li>
<li>用户户内网络<ul>
<li>HAN通过网关或用户入口吧智能电表和用户户内可控的电器或装置（如可编程的温控器）链接起来，是的用户能根据电力公司的需要，积极参与需求侧响应的电力市场</li>
<li>HAN中一个重要的设备是出于用户室内的户内显示器（indoor home display，IHD），它接收电表的计量值和电力公司的价格信息并把这些信息连续地、近于实时地显示给用户，使得用户及时和准确地了解用电情况、费用和市场信息</li>
<li>HAN的用户入口可以处在不同的设备商</li>
<li>HAN的计数范围目前仍在争论和发展之中，但其从网关到户内显示器之间的通信技术，主要是无线或电力线载波两种，主要的标准是ZigBee（无线，目前市场上接受度最高）、HomePlug（载波）和IPv6</li>
</ul>
</li>
</ul>
<h3 id="AMI和虚拟电厂"><a href="#AMI和虚拟电厂" class="headerlink" title="AMI和虚拟电厂"></a>AMI和虚拟电厂</h3><ul>
<li>虚拟电表实际上成为分布于网络上的系统传感器和测量点</li>
<li>利用其完整的通信设施和信息系统，AMI将为虚拟电厂提供系统范围的测量和可观性</li>
<li>通过双向通信，AMI将虚拟电厂种植中心和用户紧密连接，它既可以使用户直接参与到实时电力市场中，又促进电力公司与用户的配合互动</li>
<li>在北美，配电自动化的实施相对落后，因此电力公司吧AMI视为建立虚拟电厂的第一步</li>
</ul>
<h2 id="数据建模和网络协议"><a href="#数据建模和网络协议" class="headerlink" title="数据建模和网络协议"></a>数据建模和网络协议</h2><h3 id="IEC-61850数据建模"><a href="#IEC-61850数据建模" class="headerlink" title="IEC 61850数据建模"></a>IEC 61850数据建模</h3><ul>
<li>IEC 61850的基本概念<ul>
<li>是电力系统自动化领域唯一的全球通用标准</li>
<li>实现了智能变电站的工作运作标准化</li>
<li>使得智能变电站的工程实施变得规范、统一和透明</li>
<li>将变电站通信体系分为3层：站控层、间隔层、过程层</li>
</ul>
</li>
<li>IEC 61860在浙江南麂岛微电网工程中的应用</li>
</ul>
<h3 id="IEC-62326标准"><a href="#IEC-62326标准" class="headerlink" title="IEC 62326标准"></a>IEC 62326标准</h3><ul>
<li>产生背景<ul>
<li>主要目标是建立电力市场运营系统的通用信息模型及交换机制，涉及发电模型、电网物理模型和用户模型</li>
</ul>
</li>
<li>IEC 62325标准框架<ul>
<li>系列标准分为6个部分，共22个标准</li>
<li>第301部分是IEC 62325的核心模型</li>
</ul>
</li>
<li>核心标准IEC 62325-301</li>
<li>示例说明</li>
</ul>
<h3 id="IPv6网络层协议"><a href="#IPv6网络层协议" class="headerlink" title="IPv6网络层协议"></a>IPv6网络层协议</h3><ul>
<li>IPv6网络层协议<ul>
<li>是Internet协议的第6版</li>
<li>是由因特网工程任务组（Internet engineering task force，IETF）涉及的下一代Internet协议，目的是取代现有版本IPv4</li>
<li>巨大的地址空间、高度的灵活性和安全性、可动态地进行地址分配的特性以及完全的分布式结构有着巨大的价值和潜力</li>
</ul>
</li>
<li>智能电网（含虚拟电厂）IP地址需求</li>
<li>IPv6网络层协议在电力自动化系统中的应用<ul>
<li>需要大量公网和路由的IP地址</li>
<li>端对端通信方式的迫切需求</li>
<li>安全性问题更加复杂</li>
<li>IPv6为异构网络通信提供了可能的统一基础协议</li>
<li>随着中国售电侧放开的逐步实施，预期各类信息流和业务流的交互过程将更加复杂，IPv6有非常重要的应用价值</li>
</ul>
</li>
</ul>
<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><ul>
<li>TCP/IP概述<ul>
<li>中文译为传输控制协议/互联网络协议</li>
<li>规定了网络从连入因特网，及数据在设备间的传输的尺度</li>
<li>分为应用层、传输层、网络层和网络接口层4个层次<ul>
<li>接口层，协助IP数据在已有的网络介质上传输</li>
<li>网络层，保证IP数据报传输的可靠性</li>
<li>传输层，为应用层提供回话和数据报通信服务，只有TCP和用户数据报协议（user datagram protocol，UDP）</li>
<li>应用层，给用户提供大众化的应用程序，如文件传输协议（FTP）、简单邮件传输协议（SMTP）和超文本传输协议（HTTP）等</li>
</ul>
</li>
</ul>
</li>
<li>TCP/IP在微电网中的应用<ul>
<li>国网智能电网研究院光储联合微电网采用开放式分层分布结构，包含就地控制层、集中控制层、配电网调度层</li>
<li>通过TCP/IP将管理网络互联技术，使其将局域网和局域网、局域网和广域网、广域网和广域网、广域网和城域网以及城域网和城域网互联起来，构成更大范围的网络</li>
</ul>
</li>
</ul>
<h3 id="IEC-61970-CIM-CIS标准"><a href="#IEC-61970-CIM-CIS标准" class="headerlink" title="IEC 61970 CIM/CIS标准"></a>IEC 61970 CIM/CIS标准</h3><ul>
<li>IEC 61970标准概述<ul>
<li>是国际电工委员会指定的《能量管理系统应用程序接口（EMS-API）》系列国际标准</li>
<li>目的在于便于几成来自不同厂家的EMS内部的各种应用，便于将EMS于调度中心内部其他系统互联，以及便于实现不同调度中心EMS之间的模型转换</li>
<li>IEC 61970的核心部分是CIM，它采用面向对象的方法，结合同意建模语言，抽象描述了电力系统的各实体对象类、属性及相互关系，规定了应用程序接口的语义，为电力企业进行系统应用几成提供了工具</li>
</ul>
</li>
<li>风光储建模<ul>
<li>IEC 61970已经不满足当下的需求，需要针对分布式发电系统进行CIM拓展建模</li>
<li>分布式发电技术的建模可参考CIM16中已有火力发电系统和水利发电系统的建模方法</li>
<li>风力发电系统建模</li>
<li>光伏发电系统建模</li>
<li>储能系统建模</li>
</ul>
</li>
</ul>
<hr>
<h1 id="第5章-虚拟电厂的调控中心调度框架"><a href="#第5章-虚拟电厂的调控中心调度框架" class="headerlink" title="第5章 虚拟电厂的调控中心调度框架"></a>第5章 虚拟电厂的调控中心调度框架</h1><h2 id="新能源发电及负荷预测"><a href="#新能源发电及负荷预测" class="headerlink" title="新能源发电及负荷预测"></a>新能源发电及负荷预测</h2><h3 id="新能源发电预测"><a href="#新能源发电预测" class="headerlink" title="新能源发电预测"></a>新能源发电预测</h3><ul>
<li>合理预测新能源发电单元的出力是虚拟电厂优化决策出力申报的基础</li>
<li>风电机组出力与风速直接相关<ul>
<li>一般采用Weibull分布对风速进行建模</li>
</ul>
</li>
<li>光伏出力与光照强度直接相关<ul>
<li>多采用概率分布函数来模拟光照强度的分布，一般采用Beta分布函数</li>
</ul>
</li>
</ul>
<h3 id="负荷精细预测"><a href="#负荷精细预测" class="headerlink" title="负荷精细预测"></a>负荷精细预测</h3><ul>
<li>主要用户用电行为分析<ul>
<li>各类客户的日用电曲线存在一定的功率扰动</li>
<li>利用主成分方法剔除源数据中的非典型用电情况，提取用户典型用电特征</li>
<li>主成分分析方法可实现源数据降维，适用于处理海量用户数据</li>
<li>具体步骤<ul>
<li>数据预处理，构建客户负荷矩阵</li>
<li>计算样本相关系数矩阵</li>
<li>计算相关矩阵的特征值和特征向量</li>
<li>计算重要的主成分，描述客户的用电行为</li>
<li>制定分类规则</li>
</ul>
</li>
<li>基于各类用户的历史用电负荷数据，利用符号聚合近似（symbolic appro ximation，SAX）方法划分客户用电状态<ul>
<li>采集不同客户的用电行为曲线</li>
<li>利用符号聚合近似方法将不同用户的用电行为离散化</li>
<li>提出基于事件序列的马尔科夫模型，描述客户的用电行为模式，实现客户用电行为预测</li>
<li>利用K-L距离算法计算不同客户的用电行为模式相似度，并通过设定阈值实现客户分类</li>
</ul>
</li>
</ul>
</li>
<li>基于用户分类的负荷精细预测<ul>
<li>负荷的日周期性</li>
<li>负荷的周周期性</li>
<li>短期符合不仅具备周期性，也存在随机不确定性</li>
<li>不同类型的用户用电行为存在一定的规律，成为典型用电特征，通过对典型用电特征的分析可以实现用户的类型划分</li>
<li>将用户分类进行负荷预测，相对于对负荷整体预测可以大幅提升预测精度</li>
</ul>
</li>
</ul>
<h3 id="多时间尺度预测系统设计"><a href="#多时间尺度预测系统设计" class="headerlink" title="多时间尺度预测系统设计"></a>多时间尺度预测系统设计</h3><ul>
<li>系统总体结构设计<ul>
<li>从时间尺度上，涉及年度、月度、日前发电计划、日内发电计划滚动修整、在线校正控制等多个时间尺度的协调优化及控制</li>
<li>对虚拟电厂来讲，重点关注的预测时间尺度主要为日前预测、滚动预测和实时预测</li>
<li>调度中心根据日前24小时的预测数据，生成虚拟电厂日前调度计划；在日前预测数据的基础上，根据当日最新负荷及分布式电源出力，滚动优化修整日前预测的误差，以优化调度方案；在滚动预测结果的基础上，进行实时预测，预测下一时刻的数据。多时间尺度预测模型可以大大提高负荷及分布式电源预测精度</li>
</ul>
</li>
<li>预测方法<ul>
<li>灰色预测模型</li>
<li>线性回归预测模型</li>
<li>时间序列模型<ul>
<li>是目前广泛应用于电力系统中的一类最为景点的短期符合预测方法，事实证明这种方法可以取得较好的效果</li>
<li>基本思路是将历史负荷数据看成一个时间序列，构造能够描述事件序列变化过程的模型，在已知时间序列历史值的情况下，通过该模型预测时间序列未来的值</li>
<li>计算方法较为简单，数据需求极少，可以较好地体现短期内负荷变化的连续性</li>
<li>三种基本形式：自回归（autoregressive，AR）模型、移动平均（moving average，MA）模型和自回归-移动平均（ARMA）模型<ul>
<li>AR模型认为负荷预测值可以根据有限项历史值与意向当前干扰值通过线性组合确定，任意时刻的干扰项理论上永远存在邮箱</li>
<li>MA模型负荷的预测值可以由有限项历史干扰值与当前干扰值的线性组合确定</li>
<li>ARMA模型是AR模型和MA模型的组合，同时包含两个模型的特性，具有更好的灵活性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="考虑多需求侧资源的调度框架"><a href="#考虑多需求侧资源的调度框架" class="headerlink" title="考虑多需求侧资源的调度框架"></a>考虑多需求侧资源的调度框架</h2><h3 id="功率自平衡调节措施"><a href="#功率自平衡调节措施" class="headerlink" title="功率自平衡调节措施"></a>功率自平衡调节措施</h3><ul>
<li>通过分析源-荷之间的相关特效可以更好地发挥分布式电源的调节能力</li>
<li>随机矩阵理论（random matrix theory，RMT）通过比较随机的多为时间序列统计特性，可以体现实际数据中对随机的偏离程度，并揭示实际数据中整体关联的行为特性</li>
</ul>
<h2 id="计及储能的调度框架"><a href="#计及储能的调度框架" class="headerlink" title="计及储能的调度框架"></a>计及储能的调度框架</h2><ul>
<li>储能模型<ul>
<li>成本主要分两块：投资成本、运行维护</li>
<li>在满足储能设备电量平衡的基础上，根据电价的实际情况，电价低买高卖</li>
</ul>
</li>
<li>调度策略<ul>
<li>某一时间静态的最优出力极易受储能充放电功率限制以及容量限制</li>
<li>储能的调度策略对应预测系统多时间尺度特性</li>
<li>通过不断更新可再生能源输出功率和负荷需求的预测值，对储能电站采用实时调度、准实时调度和滚动调度三者相结合的调度策略，以达到消纳配电网有功功率差额波动的目的</li>
<li>约束条件：<ul>
<li>储能荷电状态约束，储能和电状态反映其剩余容量百分比，为延长其使用寿命</li>
<li>储能电站充放电功率的约束</li>
<li>储能电站调度循环约束，储能系统参与调度是一个动态过程，频繁充放电对于储能来说会造成不小损耗</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="计及需求响应的调度框架"><a href="#计及需求响应的调度框架" class="headerlink" title="计及需求响应的调度框架"></a>计及需求响应的调度框架</h3><ul>
<li>需求响应模型<ul>
<li>基于电价的需求侧响应一般包括3种方式：分时电价、实时电价、尖峰电价</li>
<li>基于激励的需求侧响应一般包括3中方式：直接负荷控制、可中断负荷、需求侧竞价</li>
</ul>
</li>
<li>调度策略<ul>
<li>考虑需求侧响应的调度策略出了需要考虑需求响应的成本，还要考虑用户的用电满意度</li>
</ul>
</li>
</ul>
<h3 id="考虑电动汽车充电行为的调度框架"><a href="#考虑电动汽车充电行为的调度框架" class="headerlink" title="考虑电动汽车充电行为的调度框架"></a>考虑电动汽车充电行为的调度框架</h3><ul>
<li>电动汽车集群响应模型<ul>
<li>大规模电动车的使用，必然会对电网的安全稳定与经济运行造成显著的影响</li>
<li>有必要对电动汽车的充电行为实行有效的引导或控制，以提高电网接纳电动车的安全性与可靠性</li>
<li>从群体的角度看待电动汽车，仅需要考虑电动汽车群体的总体特征，可以大大将低温低的维度，提高优化计算的效率</li>
<li>控制框架主要由电力批发市场、电动汽车代理商和电动汽车集群三个层次</li>
</ul>
</li>
<li>调度策略<ul>
<li>大规模电动汽车的无需充电会使区域负荷峰谷差增大，导致变压器等电力设备的利用率下降或要扩容</li>
<li>调度以区域内的负荷峰谷差最小化为目标</li>
<li>如果各个时段的电价区分度过小，电动汽车进行响应后获得的收益变化不明显，就会拒绝响应实时电价，因此一般来说，电价区分度越大，电动汽车响应的比例越高</li>
<li>为防止用户侧利益受损导致需求侧响应不灵敏，并平衡电动汽车用户和运营商的利益，实施实时电价前后的充电电价水平应该大致相当，即设置约束 平均电价保持不变</li>
</ul>
</li>
<li>含电动汽车的虚拟电厂调度框架<ul>
<li>虚拟电厂可以通过先进的协调控制技术、智能计量技术及信息通信技术聚合各类分布式电源、电动汽车、储能系统等不同类型的元件，并利用上层的软件算法实现不同元件的协调优化运行，从而促进资源的合理优化配置及利用</li>
<li>韩电动汽车的虚拟电厂通过模块化软件，对电动汽车集群控制参与电网运行，其作用域电动汽车代理商类似</li>
<li>电动汽车集群控制器是虚拟电厂调度电动汽车的核心器件，其功能模块包括历史数据存储、携程预测、用户需求管理、充放电功率预测等</li>
</ul>
</li>
</ul>
<h2 id="可视化技术在智能调度中的应用"><a href="#可视化技术在智能调度中的应用" class="headerlink" title="可视化技术在智能调度中的应用"></a>可视化技术在智能调度中的应用</h2><h3 id="可视化智能调度系统的设计"><a href="#可视化智能调度系统的设计" class="headerlink" title="可视化智能调度系统的设计"></a>可视化智能调度系统的设计</h3><ul>
<li>系统的总体设计思想<ul>
<li>调度员工作：监视电网、控制电网（分为处于调整目的的控制电网和电网紧急情况下的故障恢复）</li>
<li>要提高电网调度的自动化水平，必须从调度员的日常主要工作入手</li>
<li>通过可视化智能调度系统满足调度员如下需求：可视化展示、电网智能监视、电网状态评估、电网安全分析、辅助决策、操作安全校核</li>
</ul>
</li>
<li>系统实施的关键技术介绍<ul>
<li>模型图形共享与实时数据访问</li>
<li>电网状态监视与安全评估。电网状态监视采用快速扫描算法，实时扫描电网监视对象的关键数值，确定当前电网部件所处的状态，发现并报告异常状况</li>
<li>电网数据可视化方案与应用。OpenGL</li>
<li>面向主题的电网智能监视框架</li>
<li>电网操作安全校核与知识库</li>
<li>电网辅助决策匹配与验证</li>
</ul>
</li>
</ul>
<h3 id="可视化智能调度系统技术路线"><a href="#可视化智能调度系统技术路线" class="headerlink" title="可视化智能调度系统技术路线"></a>可视化智能调度系统技术路线</h3><ul>
<li>算法及体系结构设计<ul>
<li>以先进和使用为衡量标准，选择经过多年使用验证的算法或者符合本系统适用环境的算法和模型</li>
<li>开发过程中充分采用模块化的体系结构，具体表现在系统架构、模块组织、模块内设计几个层次</li>
</ul>
</li>
<li>软件开设计与开发<ul>
<li>面向对象的分析与设计（用贴近人的自然思维方式去分析、抽象、表达系统开发过程中的各种信息，能有效地控制系统开发的复杂性），面向对象方法提供了对象、类、继承、封装、多态等一系列机制，用于分析、抽象、简化、模拟实际的问题和系统</li>
</ul>
</li>
<li>人机交互界面及三维可视化平台设计<ul>
<li>在界面设计中充分考虑人机工程学因素</li>
<li>颜色、动画、图元尺寸、透视等</li>
</ul>
</li>
</ul>
<h3 id="系统各功能模块设计"><a href="#系统各功能模块设计" class="headerlink" title="系统各功能模块设计"></a>系统各功能模块设计</h3><ul>
<li>EMS模型同步模块<ul>
<li>研究商用数据库数据同步功能，利用外部程序控制数据库的功能，实现数据库同步，通过使用数据库链接和数据表快照可以达到数据单向同步的目的</li>
<li>首先在数据库同步程序所在节点机安装数据库客户端，并正确设置命名服务，分别指向数据库和目标数据库；然后在初始化过程中，初始化目标数据库，包括建立表空间、创建用户、创建智能调度专用数据表并初始化；在目标数据库上简历到源数据库的链接，然后所有需要单相同步的数据表建立快照<ul>
<li>EMS实时数据刷新模块</li>
</ul>
<ul>
<li>实时数据刷新模块是EMS实时数据库和分布式自动化接口（interface for distributed automation，IDA）实时数据库之间同步的工具</li>
</ul>
<ul>
<li>智能监视服务器模块</li>
</ul>
<ul>
<li>关于母线电压的监视</li>
<li>潮流输送断面的监视</li>
<li>关于关口的监视</li>
</ul>
<ul>
<li>操作安全校核模块</li>
</ul>
<ul>
<li>分为客户端和服务器<ul>
<li>客户端为人机交互界面的插件，将遥控指令发送到服务器后，接收并展示服务器的校验信息</li>
<li>服务器基于系统和潮流计算模块，收到客户端请求后获取状态估计的数据，进行拓扑计算和潮流分析，得到操作前后的运行状态，根据预定义的条件给出操作校核结果</li>
</ul>
</li>
</ul>
<ul>
<li>电网智能调度人机界面模块</li>
</ul>
<ul>
<li>主要完成以下功能：电网指示状态、电网告警事项显示、智能辅助决策方案展示、主题配置与切换、电网数据可视化展示</li>
</ul>
<ul>
<li>电网状态指示与告警事项显示</li>
</ul>
<ul>
<li>信息来自电网智能监视服务器，通信采用软总线永久管道方式，为了提高通信效率和时间响应速度，改数据通信采用推拉结合的互动机制，全量数据/增量数据分别发送</li>
</ul>
<ul>
<li>主体配置与显示</li>
</ul>
<ul>
<li>主题是可视化平台中表征电网一个侧面特征的图形、插件、渲染方式等信息的综合，主体的内容可以由用户自行设定，因此人机界面提供对主题的配置界面</li>
</ul>
<ul>
<li>人机互动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="可视化智能调度系统的实现"><a href="#可视化智能调度系统的实现" class="headerlink" title="可视化智能调度系统的实现"></a>可视化智能调度系统的实现</h3><ul>
<li>系统运行环境<ul>
<li>硬件环境：网络、数据库服务器、工作站、主频、网卡</li>
<li>软件环境：数据库服务器、工作站</li>
<li>开发环境：操作系统、开发工具、测试工具</li>
</ul>
</li>
<li>智能调度系统功能<ul>
<li>电网智能监视。针对地区调度员关注的能够表征电网安全状态的变量</li>
<li>电网状态评估。建立适用于地区电网的电网状态健康模型，根据取得的指标综合进行分析预警，得到电网在线安全状态</li>
<li>电网安全分析</li>
<li>电网调度辅助决策。出现特殊情况时（监视量达到或超过预警限值和电网故障）</li>
<li>电网操作安全校核。实现对预想操作的在线安全校核，考虑电网安全操作规则约束、自定义约束、潮流约束等，提供校核报告</li>
<li>电网经济运行<ul>
<li>无功分布统计与可视化展示</li>
<li>无功经济运行自动分析与辅助决策</li>
<li>主变经济运行</li>
</ul>
</li>
<li>电网数据可视化展示平台</li>
<li>高性能计算平台</li>
<li>系统维护<ul>
<li>数据库维护</li>
<li>图形维护</li>
<li>日常软件维护</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="云计算在智能调度中的应用"><a href="#云计算在智能调度中的应用" class="headerlink" title="云计算在智能调度中的应用"></a>云计算在智能调度中的应用</h2><h3 id="云计算及Hadoop技术"><a href="#云计算及Hadoop技术" class="headerlink" title="云计算及Hadoop技术"></a>云计算及Hadoop技术</h3><ul>
<li>云计算</li>
<li>Hadoop开源云计算框架<ul>
<li>Hadoop是一个开源的云计算平台，是Google现在使用的谷歌文件系统（Google file system，GFS）、MapReduce、Big Table的大数据处理系统的开源化版本</li>
<li>特点是适合大数据处理</li>
<li>是业界使用最广泛的云计算平台，其良好的平台易搭建性、可维护性以及对成本的地要求性都使其获得了足够强大的生存能力</li>
</ul>
</li>
</ul>
<h3 id="智能调度云体系结构"><a href="#智能调度云体系结构" class="headerlink" title="智能调度云体系结构"></a>智能调度云体系结构</h3><ul>
<li>我国调度宏观上分五级：国家级、区域级、省级、地区级、县级</li>
<li>智能电网调度的业务比较复杂，包括的业务种类非常多</li>
</ul>
<h3 id="智能调度运输局中心体系结构"><a href="#智能调度运输局中心体系结构" class="headerlink" title="智能调度运输局中心体系结构"></a>智能调度运输局中心体系结构</h3><ul>
<li>目前电网调度自动化系统的核心功能：<ul>
<li>智能检测设备的数据采集信息的收集与处理，以及其他系统产生的数据</li>
<li>数据的存储以及管理信息系统的运行与维护</li>
<li>各种应用数据的访问等几个方面</li>
</ul>
</li>
<li>电网调度系统的数据来源有许多方面，包括日常生产运行、电力市场的交易数据，办公自动化系统等众多业务系统的业务数据</li>
<li>智能电网要求新型的智能电网调度中心具有更强大的数据处理和存储能力，可以运行大规模的数据挖掘、决策分析等计算任务</li>
<li>智能云计算数据中心的建设应该满足以下几个重要目标<ul>
<li>整合现有电力系统IT资源</li>
<li>数据中心基础设施的高可靠性</li>
<li>网络结构的可拓展性</li>
<li>海量的存储能力和近似无限的计算能力</li>
</ul>
</li>
</ul>
<h3 id="智能调度运输局中心任务调度策略"><a href="#智能调度运输局中心任务调度策略" class="headerlink" title="智能调度运输局中心任务调度策略"></a>智能调度运输局中心任务调度策略</h3><p>(to be continued…)</p>
<hr>
<h1 id="第8章-互动机制、交易策略与结算——演化博弈"><a href="#第8章-互动机制、交易策略与结算——演化博弈" class="headerlink" title="第8章 互动机制、交易策略与结算——演化博弈"></a>第8章 互动机制、交易策略与结算——演化博弈</h1><h2 id="博弈论与市场规则的算法"><a href="#博弈论与市场规则的算法" class="headerlink" title="博弈论与市场规则的算法"></a>博弈论与市场规则的算法</h2><h3 id="博弈论概述"><a href="#博弈论概述" class="headerlink" title="博弈论概述"></a>博弈论概述</h3><ul>
<li>基本介绍<ul>
<li>研究决策主题的行为发生相互作用时（如竞争或者合作）的决策以及这种决策的均衡问题</li>
<li>根据参与者之间能否达成某些具有约束力的合作协议，博弈可以分为合作博弈与非合作博弈<ul>
<li>合作博弈：若干决策主体形成联盟，以最大联盟总收益为目标进行博弈，但需要保证利益分配中各联盟成员的收益至少不少于非合作博弈的情况，从而保证联盟的稳定性</li>
<li>非合作博弈：各博弈参与者没有签订任何有约束力的协议，每个决策者都以自身利益最大化为目标制定决策</li>
</ul>
</li>
<li>根据参与者是否同时采取行动，分为静态博弈与动态博弈</li>
<li>根据决策者对其他参与者的信息的掌握程度，分为完全信息博弈与不完全信息博弈</li>
<li>根据所有参与者之间的收益或效用之和是否为零，分为零和博弈与非零和博弈</li>
<li>演化博弈：假定演化的变化是由群体内的自然选择引起的基础上，通过具有频率依赖效应的选择行为进行演化以搜索演化稳定策略，并研究演化的过程。演化博弈论只要求博弈者具有有限理性</li>
</ul>
</li>
<li>表达形式<ul>
<li>元素：参与者、行动、信息、策略、支付、行动顺序</li>
</ul>
</li>
<li>纳什均衡：指一个由所有参与者的最优策略构成的策略集合<ul>
<li>当所有参与者都采取该策略集合中对应的策略时，没有一个参与者可以通过改变对应的策略获得效用的提升</li>
<li>不一定是最优解，而是一个最稳定解</li>
</ul>
</li>
<li>在电力市场中的应用<ul>
<li>在参与电力市场方面，虚拟电厂可以作为发电运营主体加入电力市场，通过调度决定所需的购售电量，影响电力市场整体的供需平衡，从而提高该虚拟电厂的收益</li>
<li>虚拟电厂常被视为多个分布式能源通过合作博弈形成的聚合体，而对外采用费合作博弈策略与其他虚拟电厂或电力市场运营主体参与市场竞争</li>
<li>多个微网或虚拟电厂之间也可以利用合作博弈构成最优交易联盟，直接进行售购电交易，只有通过夏普利值法等方法进行联盟内部的收益分配</li>
</ul>
</li>
</ul>
<h3 id="市场规则"><a href="#市场规则" class="headerlink" title="市场规则"></a>市场规则</h3><ul>
<li>建立市场机制的必要性<ul>
<li>参与主体角度<ul>
<li>主体：各类发电企业、售电企业、电网企业、电力用户、电力交易机构、电力调度机构和独立辅助服务提供者等</li>
<li>由于市场力的存在，某些发电商能够通过控制市场清算价格而获得超额利润</li>
<li>开放、自由的市场能够激发市场参与主体的竞争性</li>
</ul>
</li>
<li>市场角度<ul>
<li>具有垄断特性</li>
<li>市场价格上涨是市场力最直接的危害，降低了市场竞争的公平性</li>
<li>有效控制市场力是规避电力市场经营风险的重要途径</li>
<li>由于电力市场中运营主体的增多，这些运营主体之间也存在竞争和互动</li>
<li>在“互联网+”的推动下，能源互联网中出现了大量创新的商业模式，并衍生出碳交易、配额交易等市场</li>
</ul>
</li>
<li>市场规则的指导原则<ul>
<li>各国应该结合本国实际国情来指定市场规则</li>
<li>依据国家的有关法律、法规和该地区的电力市场实际运营情况，指定相应的市场规则</li>
<li>市场规则应该由国家能源局的地方监管部门负责组织指定，有关部门根据职能一发旅行监管职责</li>
<li>需要明确电力市场中参与主体的范围、参与市场的方式和市场范围</li>
<li>必须适应相应的区域电力市场运行阶段和时长运行的范围，不能损害市场成员的权益，不能影响市场秩序</li>
<li>考虑到可持续发展战略和新能源的开发，环境因素也应该纳入电力市场规则制定中，需要综合考虑电力企业的经济产生指标和环境治理能力，制定考虑环境因素的市场规则</li>
</ul>
</li>
</ul>
</li>
<li>市场准入规划<ul>
<li>指政府机构通过对企业的市场准入（包括数量、质量、期限及经营范围等）进行限制</li>
<li>市场准入规则规定了能进入市场的企业和商品</li>
<li>为保证电力供应的稳定性，需要设立退出规则，以限制企业的任意退出</li>
</ul>
</li>
<li>市场竞争规则<ul>
<li>反不正当竞争</li>
<li>反限制竞争</li>
<li>反垄断</li>
</ul>
</li>
<li>市场交易规则<ul>
<li>规范市场交易方式</li>
<li>规范市场交易行为</li>
<li>规范交易价格</li>
</ul>
</li>
</ul>
<h2 id="需求响应型虚拟电厂参与辅助服务市场"><a href="#需求响应型虚拟电厂参与辅助服务市场" class="headerlink" title="需求响应型虚拟电厂参与辅助服务市场"></a>需求响应型虚拟电厂参与辅助服务市场</h2><h3 id="辅助服务类型分析"><a href="#辅助服务类型分析" class="headerlink" title="辅助服务类型分析"></a>辅助服务类型分析</h3><ul>
<li>电力辅助服务是指为了保障电力系统安全、促进电力交易和保证电力供应，需要提供的除正常电能生产外的额外服务</li>
<li>目前国际上对辅助服务问题的研究在很多方面尚未达成共识，各国都按各自的模式实施相应的规则。辅助服务是相对电能生产、输送和交易的主市场而言的</li>
<li>辅助服务是为了平衡很短时期内较小的电能供需差异和应对系统突发事件而提供的，总的辅助服务容量相对于系统的总负荷量来说较小，一般不超过总电量的15%</li>
<li>现有的辅助服务种类大致有如下几种：<ul>
<li>备用</li>
<li>调频</li>
<li>无功</li>
<li>黑启动</li>
</ul>
</li>
</ul>
<h3 id="需求响应型虚拟电厂的特点"><a href="#需求响应型虚拟电厂的特点" class="headerlink" title="需求响应型虚拟电厂的特点"></a>需求响应型虚拟电厂的特点</h3><ul>
<li><code>广义的需求响应</code>：指电力用户根据价格信号或者通过激励，改变固有用电模式的行为</li>
<li>需求响应型虚拟电厂将来自众多电力用户削减负荷的能力视为虚拟出力，将需求响应资源视为在负荷侧接入系统的发电机组</li>
<li>按照机制，分为：<ul>
<li>基于价格的需求响应<ul>
<li>让消费者直接面对电价，自主做出调整</li>
<li>分时电价、尖峰电价、实时电价</li>
</ul>
</li>
<li>基于激励的需求响应<ul>
<li>直接采用激励的方式来激励和引导用户参与系统所需的符合削减，包括直接负荷控制、可中断负荷控制、需求侧竞价</li>
</ul>
</li>
</ul>
</li>
<li>提供辅助服务<ul>
<li>可中断负荷控制</li>
<li>直接负荷控制</li>
</ul>
</li>
</ul>
<h2 id="虚拟电厂参与电力能量市场"><a href="#虚拟电厂参与电力能量市场" class="headerlink" title="虚拟电厂参与电力能量市场"></a>虚拟电厂参与电力能量市场</h2><h3 id="虚拟电厂参与市场竞价"><a href="#虚拟电厂参与市场竞价" class="headerlink" title="虚拟电厂参与市场竞价"></a>虚拟电厂参与市场竞价</h3><ul>
<li>模式：<ul>
<li>日前市场<ul>
<li>目标函数：运行成本最小或经济效益最大</li>
</ul>
</li>
<li>日内市场<ul>
<li>目标函数：运行成本最小或经济效益最大</li>
</ul>
</li>
<li>实时市场<ul>
<li>目标函数：最小化调整成本</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="虚拟电厂市场竞价中不确定因素的处理"><a href="#虚拟电厂市场竞价中不确定因素的处理" class="headerlink" title="虚拟电厂市场竞价中不确定因素的处理"></a>虚拟电厂市场竞价中不确定因素的处理</h3><ul>
<li>不确定因素主要包括风、光等可再生能源机组出力的不确定性、负荷的不确定性、机组随机故障及电价的不确定性等</li>
<li>处理不确定性的理论有：模糊规划、随机规划、鲁棒优化等</li>
</ul>
<h3 id="基于多代理系统的虚拟电厂市场竞价结构"><a href="#基于多代理系统的虚拟电厂市场竞价结构" class="headerlink" title="基于多代理系统的虚拟电厂市场竞价结构"></a>基于多代理系统的虚拟电厂市场竞价结构</h3><ul>
<li>电力市场代理</li>
<li>传统电厂及虚拟电厂代理</li>
<li>分布式能源代理</li>
</ul>
<h3 id="不同市场模式下虚拟电厂市场竞价结构"><a href="#不同市场模式下虚拟电厂市场竞价结构" class="headerlink" title="不同市场模式下虚拟电厂市场竞价结构"></a>不同市场模式下虚拟电厂市场竞价结构</h3><ul>
<li>参与多种市场模式混合的电力市场模式</li>
<li>参与多时间尺度的市场</li>
</ul>
<h2 id="虚拟电厂与内部成员的互动博弈"><a href="#虚拟电厂与内部成员的互动博弈" class="headerlink" title="虚拟电厂与内部成员的互动博弈"></a>虚拟电厂与内部成员的互动博弈</h2><h3 id="虚拟电厂竞标的框架设计"><a href="#虚拟电厂竞标的框架设计" class="headerlink" title="虚拟电厂竞标的框架设计"></a>虚拟电厂竞标的框架设计</h3><ul>
<li>假设参与日前市场进行竞标，先根据历史数据得到第二天峰、光和负荷的预测值，虚拟电厂内部报价，协调，完成自身电量竞标，从而定制第二天的发电计划</li>
</ul>
<h3 id="虚拟电厂电量竞标博弈下层子模型（电量竞标）"><a href="#虚拟电厂电量竞标博弈下层子模型（电量竞标）" class="headerlink" title="虚拟电厂电量竞标博弈下层子模型（电量竞标）"></a>虚拟电厂电量竞标博弈下层子模型（电量竞标）</h3><ul>
<li>策略考虑为虚拟电厂内各个分布式电源的出力计划及弃电量、各个负荷的需求量及负荷调整量</li>
</ul>
<h3 id="虚拟电厂电价竞标博弈上层子模型（电价竞标）"><a href="#虚拟电厂电价竞标博弈上层子模型（电价竞标）" class="headerlink" title="虚拟电厂电价竞标博弈上层子模型（电价竞标）"></a>虚拟电厂电价竞标博弈上层子模型（电价竞标）</h3><ul>
<li>策略考虑为虚拟电厂分布式电源指定的电价及负荷电价</li>
</ul>
<h3 id="双层博弈模型求解"><a href="#双层博弈模型求解" class="headerlink" title="双层博弈模型求解"></a>双层博弈模型求解</h3><ul>
<li>对于上述建立的基于Stackelberg博弈的两个阶段的虚拟电厂竞标模型，其均衡解存在且唯一，可通过逆推归纳法进行求解。</li>
</ul>
<h2 id="不同虚拟电厂之间的互动博弈"><a href="#不同虚拟电厂之间的互动博弈" class="headerlink" title="不同虚拟电厂之间的互动博弈"></a>不同虚拟电厂之间的互动博弈</h2><p>提出一种虚拟电厂双层优化博弈模型，不仅强调上层虚拟电厂之间的博弈，下层分布式电源之间的博弈，也强调上下两层的均衡。  </p>
<h3 id="博弈框架的建立"><a href="#博弈框架的建立" class="headerlink" title="博弈框架的建立"></a>博弈框架的建立</h3><p>鉴于风光发电随机性，需要可控发电/用能代理（智能体）配合才能提高消纳水平，因此下层参与者可以组成一个虚拟电厂，采用“内部协同，外部协调竞争”的运行原则，内部智能体组成合作联盟，实现能源互补，提高总收益。上层为多虚拟电厂博弈竞价模型，根据需求和攻击的具体数值，制定多虚拟电厂直接交易策略。下层为虚拟电厂内部分布式能源之间的合作模型，以总成本最低为目标得到最优响应功率。</p>
<h3 id="虚拟电厂下层优化模型"><a href="#虚拟电厂下层优化模型" class="headerlink" title="虚拟电厂下层优化模型"></a>虚拟电厂下层优化模型</h3><h3 id="多虚拟电厂上层博弈交易模型"><a href="#多虚拟电厂上层博弈交易模型" class="headerlink" title="多虚拟电厂上层博弈交易模型"></a>多虚拟电厂上层博弈交易模型</h3><h2 id="虚拟电厂内部结算机制"><a href="#虚拟电厂内部结算机制" class="headerlink" title="虚拟电厂内部结算机制"></a>虚拟电厂内部结算机制</h2><h3 id="联盟博弈理论"><a href="#联盟博弈理论" class="headerlink" title="联盟博弈理论"></a>联盟博弈理论</h3><p>由于虚拟电厂内部的分布式电源以互补合作的方式运行，可以将其等效为一个合作博弈。  </p>
<h3 id="Shapley值方法的改进"><a href="#Shapley值方法的改进" class="headerlink" title="Shapley值方法的改进"></a>Shapley值方法的改进</h3><h3 id="评分机制"><a href="#评分机制" class="headerlink" title="评分机制"></a>评分机制</h3><h3 id="内部成员对结算机制的满意度"><a href="#内部成员对结算机制的满意度" class="headerlink" title="内部成员对结算机制的满意度"></a>内部成员对结算机制的满意度</h3><hr>
<h1 id="第9章-交易平台与商业模式"><a href="#第9章-交易平台与商业模式" class="headerlink" title="第9章 交易平台与商业模式"></a>第9章 交易平台与商业模式</h1><h2 id="能源市场交易平台"><a href="#能源市场交易平台" class="headerlink" title="能源市场交易平台"></a>能源市场交易平台</h2><ul>
<li>现阶段，国内外有不少能源市场交易中心和一些能源云平台的应用。随着国内电力市场改革的推进，已有国家级和各省级电力交易中心组织开展电力市场化交易业务。此外，不少企业和高校研发的能源云平台将用于远程采集监控、节能管理、运算分析等能源服务。</li>
<li>能源市场交易平台包括电力的批发、零售，以及天然气和冷热的销售与供应、虚拟电厂和电动汽车的购售电等。</li>
<li>将能源市场交易和能源云结合的综合能源市场交易平台，将在能源数据监测分析基础上完成各类能源信息服务产品的市场交易与结算。</li>
</ul>
<h3 id="数据资源层"><a href="#数据资源层" class="headerlink" title="数据资源层"></a>数据资源层</h3><ul>
<li>信息通信<ul>
<li>信息源包括能源资源信息、环境气象信息、能量生产实时信息、能量输配实时信息、负荷及需求实时信息、业务交易实时信息、相关方行为实时信息等</li>
</ul>
</li>
<li>数据中心</li>
</ul>
<h3 id="任务协调层"><a href="#任务协调层" class="headerlink" title="任务协调层"></a>任务协调层</h3><ul>
<li>成员管理<ul>
<li>参与能源市场：能源的生产者、服务者、消费者</li>
<li>能源市场交易平台：一般浏览者、注册用户、系统管理员</li>
</ul>
</li>
<li>交易管理<ul>
<li>负责能源交易的开展、计算和发布工作</li>
<li>交易申报模块为多个市场主体提供数据申报与报价递送功能，包括能源供应企业和能源用户或零售商报价</li>
<li>以电力市场交易为例，交易流程可分为双边协调交易和集中竞价交易</li>
</ul>
</li>
<li>合同管理<ul>
<li>合同管理模块负责制定、执行及评估能源市场交易相关的各类合同和协议，为其提供全过程的技术支持</li>
</ul>
</li>
</ul>
<h3 id="分析决策层"><a href="#分析决策层" class="headerlink" title="分析决策层"></a>分析决策层</h3><ul>
<li>规则与算法库<ul>
<li>能源市场交易平台的核心业务是交易，完整规范的规则与算法库是保证交易顺利开展的基础</li>
</ul>
</li>
<li>在线动态分析</li>
<li>安全校核</li>
</ul>
<h2 id="能源需求侧管理平台"><a href="#能源需求侧管理平台" class="headerlink" title="能源需求侧管理平台"></a>能源需求侧管理平台</h2><p>指政府通过采取有效的激励和引导措施使能源供需双方在事宜的运作方式下共同对用能市场进行管理，已达到改变用能方式、提高能效和功能可靠性的目的。  </p>
<h3 id="感知与通信层"><a href="#感知与通信层" class="headerlink" title="感知与通信层"></a>感知与通信层</h3><ul>
<li>测控层</li>
<li>数据传输与共享</li>
<li>客户终端</li>
</ul>
<h3 id="数据域算法库"><a href="#数据域算法库" class="headerlink" title="数据域算法库"></a>数据域算法库</h3><ul>
<li>用能基础信息<ul>
<li>负荷分析</li>
<li>负荷率分析</li>
<li>电量分析</li>
<li>三相平衡度分析</li>
</ul>
</li>
<li>用能异常情况分析</li>
<li>电能质量数据分析</li>
<li>线损与变损数据</li>
<li>综合碳排放数据</li>
</ul>
<h3 id="用户服务层"><a href="#用户服务层" class="headerlink" title="用户服务层"></a>用户服务层</h3><ul>
<li>能源管控<ul>
<li>在线监测、负荷管理、分布式电源控制</li>
</ul>
</li>
<li>节能争端</li>
<li>委托管理</li>
</ul>
<h2 id="能源云技术"><a href="#能源云技术" class="headerlink" title="能源云技术"></a>能源云技术</h2><h3 id="多微机集群模式"><a href="#多微机集群模式" class="headerlink" title="多微机集群模式"></a>多微机集群模式</h3><ul>
<li>集群概念<ul>
<li>微型计算机集群，建成集群，是一种计算机系统，它通过一组松散集成的计算机软件或硬件片接起来高度紧密地协作完成计算工作</li>
</ul>
</li>
<li>多微机集群在虚拟电厂平台中的应用</li>
</ul>
<h3 id="组件技术"><a href="#组件技术" class="headerlink" title="组件技术"></a>组件技术</h3><ul>
<li>组件技术及其特点<ul>
<li>组件技术是一种软件开发技术，是指将复杂的应用软件拆分成一系列软件单元，及组件，这些组件具有可行性实现，易于开发、理解和调整等特点</li>
</ul>
</li>
<li>组建平台架构</li>
</ul>
<h3 id="多智能代理技术"><a href="#多智能代理技术" class="headerlink" title="多智能代理技术"></a>多智能代理技术</h3><ul>
<li>多代理技术及其应用场景</li>
<li>虚拟电厂典型场景下的代理分类</li>
</ul>
<h3 id="三维可视化人机界面"><a href="#三维可视化人机界面" class="headerlink" title="三维可视化人机界面"></a>三维可视化人机界面</h3><ul>
<li>三维可视化技术</li>
<li>虚拟电厂平台的三维可视化需求</li>
</ul>
<h2 id="商业模式与案例分析"><a href="#商业模式与案例分析" class="headerlink" title="商业模式与案例分析"></a>商业模式与案例分析</h2><h3 id="虚拟电厂商业模式"><a href="#虚拟电厂商业模式" class="headerlink" title="虚拟电厂商业模式"></a>虚拟电厂商业模式</h3><ul>
<li>虚拟电厂作为售电主体</li>
<li>虚拟电厂作为虚拟电源商</li>
<li>虚拟电厂作为辅助服务提供者</li>
<li>虚拟电厂作为电动汽车聚合商</li>
</ul>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ul>
<li>Next Kraftwerke公司<ul>
<li>德国大型虚拟电厂运营商</li>
</ul>
</li>
<li>AGL能源公司<ul>
<li>澳大利亚最大的综合能源服务商</li>
</ul>
</li>
<li>Stem公司<ul>
<li>美国</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>「笔记」- 读书</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>能源</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang pkg Notes</title>
    <url>/2019/03/20/Golang-pkg/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Go 语言常用包笔记</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="bufio-包"><a href="#bufio-包" class="headerlink" title="bufio 包"></a><code>bufio</code> 包</h1><p>实现了带缓存的 I/O 操作。  </p>
<h2 id="Read-相关函数"><a href="#Read-相关函数" class="headerlink" title="Read 相关函数"></a>Read 相关函数</h2><h3 id="NewReaderSize、NewReader"><a href="#NewReaderSize、NewReader" class="headerlink" title="NewReaderSize、NewReader"></a>NewReaderSize、NewReader</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>

<p>NewReaderSize 将 rd 封装成一个带缓存的 bufio.Reader 对象，缓存大小由 size 指定（如果小于 16 则会被设置为 16）。  </p>
<p>如果 rd 的基类型就是有足够缓存的 bufio.Reader 类型，则直接将 rd 转换为基类型返回。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>

<p>NewReader 相当于 NewReaderSize(rd, 4096)。  </p>
<p>bufio.Reader 实现了如下接口：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">io.Reader</span><br><span class="line">io.WriterTo</span><br><span class="line">io.ByteScanner</span><br><span class="line">io.RuneScanner</span><br></pre></td></tr></table></figure>

<h3 id="Peek"><a href="#Peek" class="headerlink" title="Peek"></a>Peek</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>Peek 返回缓存的一个切片，该切片引用缓存中前 n 个字节的数据，该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之前是有效的。如果切片长度小于 n，则返回一个错误信息说明原因。如果 n 大于缓存的总大小，则返回 ErrBufferFull。  </p>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>Read 从 b 中读出数据到 p 中，返回读出的字节数和遇到的错误。  </p>
<p>如果缓存不为空，则只能读出缓存中的数据，不会从底层 io.Reader中提取数据，如果缓存为空，则：  </p>
<p>1、len(p) &gt;= 缓存大小，则跳过缓存，直接从底层 io.Reader 中读出到 p 中。  </p>
<p>2、len(p) &lt; 缓存大小，则先将数据从底层 io.Reader 中读取到缓存中，再从缓存读取到 p 中。  </p>
<h3 id="Buffered"><a href="#Buffered" class="headerlink" title="Buffered"></a>Buffered</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>Buffered 返回缓存中未读取的数据的长度。  </p>
<h3 id="Discard"><a href="#Discard" class="headerlink" title="Discard"></a>Discard</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Discard</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(discarded <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>Discard 跳过后续的 n 个字节的数据，返回跳过的字节数。  </p>
<p>如果结果小于 n，将返回错误信息。  </p>
<p>如果 n 小于缓存中的数据长度，则不会从底层提取数据。  </p>
<h3 id="ReadSlice"><a href="#ReadSlice" class="headerlink" title="ReadSlice"></a>ReadSlice</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadSlice</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ReadSlice 在 b 中查找 delim 并返回 delim 及其之前的所有数据。  </p>
<p>该操作会读出数据，返回的切片是已读出的数据的引用，切片中的数据在下一次读取操作之前是有效的。  </p>
<p>如果找到 delim，则返回查找结果，err 返回 nil。  </p>
<p>如果未找到 delim，则：  </p>
<p>1、缓存不满，则将缓存填满后再次查找。  </p>
<p>2、缓存是满的，则返回整个缓存，err 返回 ErrBufferFull。  </p>
<p>如果未找到 delim 且遇到错误（通常是 io.EOF），则返回缓存中的所有数据和遇到的错误。<br>因为返回的数据有可能被下一次的读写操作修改，所以大多数操作<strong>应该使用 ReadBytes 或 ReadString，它们返回的是数据的拷贝</strong>。  </p>
<h3 id="ReadLine"><a href="#ReadLine" class="headerlink" title="ReadLine"></a>ReadLine</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadLine</span><span class="params">()</span> <span class="params">(line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadLine 是一个低水平的行读取原语，大多数情况下，应该使用</span></span><br><span class="line"><span class="comment">// ReadBytes('\n') 或 ReadString('\n')，或者使用一个 Scanner。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ReadLine 通过调用 ReadSlice 方法实现，返回的也是缓存的切片。用于</span></span><br><span class="line"><span class="comment">// 读取一行数据，不包括行尾标记（\n 或 \r\n）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 只要能读出数据，err 就为 nil。如果没有数据可读，则 isPrefix 返回</span></span><br><span class="line"><span class="comment">// false，err 返回 io.EOF。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果找到行尾标记，则返回查找结果，isPrefix 返回 false。</span></span><br><span class="line"><span class="comment">// 如果未找到行尾标记，则：</span></span><br><span class="line"><span class="comment">// 1、缓存不满，则将缓存填满后再次查找。</span></span><br><span class="line"><span class="comment">// 2、缓存是满的，则返回整个缓存，isPrefix 返回 true。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 整个数据尾部“有一个换行标记”和“没有换行标记”的读取结果是一样。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果 ReadLine 读取到换行标记，则调用 UnreadByte 撤销的是换行标记，</span></span><br><span class="line"><span class="comment">// 而不是返回的数据。</span></span><br></pre></td></tr></table></figure>

<h3 id="ReadBytes、ReadString"><a href="#ReadBytes、ReadString" class="headerlink" title="ReadBytes、ReadString"></a>ReadBytes、ReadString</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ReadBytes 功能同 ReadSlice，只不过返回的是缓存的拷贝。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ReadString 功能同 ReadBytes，只不过返回的是字符串。  </p>
<h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Reset</span><span class="params">(r io.Reader)</span></span></span><br></pre></td></tr></table></figure>

<p>Reset 将 b 的底层 Reader 重新指定为 r，同时丢弃缓存中的所有数据，复位<br>所有标记和错误信息。 bufio.Reader。  </p>
<h3 id="示例1：Peek、Read、Discard、Buffered"><a href="#示例1：Peek、Read、Discard、Buffered" class="headerlink" title="示例1：Peek、Read、Discard、Buffered"></a>示例1：Peek、Read、Discard、Buffered</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sr := strings.NewReader(<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"</span>)</span><br><span class="line">    buf := bufio.NewReaderSize(sr, <span class="number">0</span>)</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(buf.Buffered()) <span class="comment">// 0</span></span><br><span class="line">    s, _ := buf.Peek(<span class="number">5</span>)</span><br><span class="line">    s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>] = <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d   %q\n"</span>, buf.Buffered(), s) <span class="comment">// 16   "abcDE"</span></span><br><span class="line"></span><br><span class="line">    buf.Discard(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n, err := <span class="number">0</span>, error(<span class="literal">nil</span>); err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        n, err = buf.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">"%d   %q   %v\n"</span>, buf.Buffered(), b[:n], err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5   "bcDEFGHIJK"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 0   "LMNOP"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 6   "QRSTUVWXYZ"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 0   "123456"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 0   "7890"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 0   ""   EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例2：ReadLine"><a href="#示例2：ReadLine" class="headerlink" title="示例2：ReadLine"></a>示例2：ReadLine</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sr := strings.NewReader(<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ\n1234567890"</span>)</span><br><span class="line">    buf := bufio.NewReaderSize(sr, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, isPrefix, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, <span class="literal">false</span>, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, isPrefix, err = buf.ReadLine()</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %t   %v\n"</span>, line, isPrefix, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFGHIJKLMNOP"   true   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// "QRSTUVWXYZ"   false   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// "1234567890"   false   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// ""   false   EOF</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部有一个换行标记</span></span><br><span class="line">    buf = bufio.NewReaderSize(strings.NewReader(<span class="string">"ABCDEFG\n"</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, isPrefix, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, <span class="literal">false</span>, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, isPrefix, err = buf.ReadLine()</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %t   %v\n"</span>, line, isPrefix, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFG"   false   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// ""   false   EOF</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部没有换行标记</span></span><br><span class="line">    buf = bufio.NewReaderSize(strings.NewReader(<span class="string">"ABCDEFG"</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, isPrefix, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, <span class="literal">false</span>, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, isPrefix, err = buf.ReadLine()</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %t   %v\n"</span>, line, isPrefix, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFG"   false   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// ""   false   EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例3：ReadSlice"><a href="#示例3：ReadSlice" class="headerlink" title="示例3：ReadSlice"></a>示例3：ReadSlice</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 尾部有换行标记</span></span><br><span class="line">    buf := bufio.NewReaderSize(strings.NewReader(<span class="string">"ABCDEFG\n"</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, err = buf.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %v\n"</span>, line, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFG\n"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// ""   EOF</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部没有换行标记</span></span><br><span class="line">    buf = bufio.NewReaderSize(strings.NewReader(<span class="string">"ABCDEFG"</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, err = buf.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %v\n"</span>, line, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFG"   EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Write-相关函数"><a href="#Write-相关函数" class="headerlink" title="Write 相关函数"></a>Write 相关函数</h2><h3 id="NewWriterSize、NewWriter"><a href="#NewWriterSize、NewWriter" class="headerlink" title="NewWriterSize、NewWriter"></a>NewWriterSize、NewWriter</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(wr io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="comment">// NewWriterSize 将 wr 封装成一个带缓存的 bufio.Writer 对象，</span></span><br><span class="line"><span class="comment">// 缓存大小由 size 指定（如果小于 4096 则会被设置为 4096）。</span></span><br><span class="line"><span class="comment">// 如果 wr 的基类型就是有足够缓存的 bufio.Writer 类型，则直接将</span></span><br><span class="line"><span class="comment">// wr 转换为基类型返回。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="comment">// NewWriter 相当于 NewWriterSize(wr, 4096)</span></span><br></pre></td></tr></table></figure>

<p>bufio.Writer 实现了如下接口：  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">io</span><span class="selector-class">.Writer</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReaderFrom</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ByteWriter</span></span><br></pre></td></tr></table></figure>

<h3 id="WriteString"><a href="#WriteString" class="headerlink" title="WriteString"></a>WriteString</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>WriteString 功能同 Write，只不过写入的是字符串。  </p>
<h3 id="WriteRune"><a href="#WriteRune" class="headerlink" title="WriteRune"></a>WriteRune</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(size <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>WriteRune 向 b 写入 r 的 UTF-8 编码，返回 r 的编码长度。  </p>
<h3 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Flush 将缓存中的数据提交到底层的 io.Writer 中。</p>
<h3 id="Available"><a href="#Available" class="headerlink" title="Available"></a>Available</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Available</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>Available 返回缓存中未使用的空间的长度。  </p>
<h3 id="Buffered-1"><a href="#Buffered-1" class="headerlink" title="Buffered"></a>Buffered</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>Buffered 返回缓存中未提交的数据的长度。  </p>
<h3 id="Reset-1"><a href="#Reset-1" class="headerlink" title="Reset"></a>Reset</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span></span></span><br></pre></td></tr></table></figure>
<p>Reset 将 b 的底层 Writer 重新指定为 w，同时丢弃缓存中的所有数据，复位所有标记和错误信息。相当于创建了一个新的 bufio.Writer。  </p>
<h3 id="示例1：Available、Buffered、WriteString、Flush"><a href="#示例1：Available、Buffered、WriteString、Flush" class="headerlink" title="示例1：Available、Buffered、WriteString、Flush"></a>示例1：Available、Buffered、WriteString、Flush</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    buf := bufio.NewWriterSize(os.Stdout, <span class="number">0</span>)</span><br><span class="line">    fmt.Println(buf.Available(), buf.Buffered()) <span class="comment">// 4096 0</span></span><br><span class="line"></span><br><span class="line">    buf.WriteString(<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>)</span><br><span class="line">    fmt.Println(buf.Available(), buf.Buffered()) <span class="comment">// 4070 26</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存后统一输出，避免终端频繁刷新，影响速度</span></span><br><span class="line">    buf.Flush() <span class="comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="type-ReadWriter"><a href="#type-ReadWriter" class="headerlink" title="type ReadWriter"></a>type ReadWriter</h2><p>ReadWriter 集成了 bufio.Reader 和 bufio.Writer。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Reader</span><br><span class="line">    *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReadWriter</span><span class="params">(r *Reader, w *Writer)</span> *<span class="title">ReadWriter</span></span></span><br></pre></td></tr></table></figure>
<p>NewReadWriter 将 r 和 w 封装成一个 bufio.ReadWriter 对象。  </p>
<h2 id="type-Scanner"><a href="#type-Scanner" class="headerlink" title="type Scanner"></a>type Scanner</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Scanner <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// Scanner 提供了一个方便的接口来读取数据，例如遍历多行文本中的行。Scan 方法会通过</span></span><br><span class="line"><span class="comment">// 一个“匹配函数”读取数据中符合要求的部分，跳过不符合要求的部分。“匹配函数”由调</span></span><br><span class="line"><span class="comment">// 用者指定。本包中提供的匹配函数有“行匹配函数”、“字节匹配函数”、“字符匹配函数”</span></span><br><span class="line"><span class="comment">// 和“单词匹配函数”，用户也可以自定义“匹配函数”。默认的“匹配函数”为“行匹配函</span></span><br><span class="line"><span class="comment">// 数”，用于获取数据中的一行内容（不包括行尾标记）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Scanner 使用了缓存，所以匹配部分的长度不能超出缓存的容量。默认缓存容量为 4096 -</span></span><br><span class="line"><span class="comment">// bufio.MaxScanTokenSize，用户可以通过 Buffer 方法指定自定义缓存及其最大容量。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Scan 在遇到下面的情况时会终止扫描并返回 false（扫描一旦终止，将无法再继续）：</span></span><br><span class="line"><span class="comment">// 1、遇到 io.EOF</span></span><br><span class="line"><span class="comment">// 2、遇到读写错误</span></span><br><span class="line"><span class="comment">// 3、“匹配部分”的长度超过了缓存的长度</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果需要对错误进行更多的控制，或“匹配部分”超出缓存容量，或需要连续扫描，则应该</span></span><br><span class="line"><span class="comment">// 使用 bufio.Reader</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScanner</span><span class="params">(r io.Reader)</span> *<span class="title">Scanner</span></span></span><br></pre></td></tr></table></figure>
<p>NewScanner 创建一个 Scanner 来扫描 r，默认匹配函数为 ScanLines。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Buffer</span><span class="params">(buf []<span class="keyword">byte</span>, max <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>Buffer 用于设置自定义缓存及其可扩展范围，如果 max 小于 len(buf)，则 buf 的尺寸将固定不可调。Buffer 必须在第一次 Scan 之前设置，否则会引发 panic。  </p>
<p>默认情况下，Scanner 会使用一个 4096 - bufio.MaxScanTokenSize 大小的内部缓存。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Split</span><span class="params">(split SplitFunc)</span></span></span><br></pre></td></tr></table></figure>
<p>Split 用于设置“匹配函数”，这个函数必须在调用 Scan 前执行。  </p>
<h2 id="type-SplitFunc"><a href="#type-SplitFunc" class="headerlink" title="type SplitFunc"></a>type SplitFunc</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// SplitFunc 用来定义“匹配函数”，data 是缓存中的数据。atEOF 标记数据是否读完。</span></span><br><span class="line"><span class="comment">// advance 返回 data 中已处理的数据的长度。token 返回找到的“匹配部分”，“匹配</span></span><br><span class="line"><span class="comment">// 部分”可以是缓存的切片，也可以是自己新建的数据（比如 bufio.errorRune）。“匹</span></span><br><span class="line"><span class="comment">// 配部分”将在 Scan 之后通过 Bytes 和 Text 反馈给用户。err 返回错误信息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果在 data 中无法找到一个完整的“匹配部分”则应返回 (0, nil, nil)，以便告诉</span></span><br><span class="line"><span class="comment">// Scanner 向缓存中填充更多数据，然后再次扫描（Scan 会自动重新扫描）。如果缓存已</span></span><br><span class="line"><span class="comment">// 经达到最大容量还没有找到，则 Scan 会终止并返回 false。</span></span><br><span class="line"><span class="comment">// 如果 data 为空，则“匹配函数”将不会被调用，意思是在“匹配函数”中不必考虑</span></span><br><span class="line"><span class="comment">// data 为空的情况。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果 err != nil，扫描将终止，如果 err == ErrFinalToken，则 Scan 将返回 true，</span></span><br><span class="line"><span class="comment">// 表示扫描正常结束，如果 err 是其它错误，则 Scan 将返回 false，表示扫描出错。错误</span></span><br><span class="line"><span class="comment">// 信息可以在 Scan 之后通过 Err 方法获取。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SplitFunc 的作用很简单，从 data 中找出你感兴趣的数据，然后返回，同时返回已经处理</span></span><br><span class="line"><span class="comment">// 的数据的长度。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Scan</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<p>Scan 开始一次扫描过程，如果匹配成功，可以通过 Bytes() 或 Text() 方法取出结果，如果遇到错误，则终止扫描，并返回 false。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>Bytes 将最后一次扫描出的“匹配部分”作为一个切片引用返回，下一次的 Scan 操作会覆盖本次引用的内容。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Text</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>Text 将最后一次扫描出的“匹配部分”作为字符串返回（返回副本）。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Err 返回扫描过程中遇到的非 EOF 错误，供用户调用，以便获取错误信息。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanBytes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>ScanBytes 是一个“匹配函数”用来找出 data 中的单个字节并返回。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanRunes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>ScanRunes 是一个“匹配函数”，用来找出 data 中单个 UTF8 字符的编码。如果 UTF8 编码错误，则 token 会返回 “\xef\xbf\xbd”（即：U+FFFD），但只消耗 data 中的一个字节。  </p>
<p>这使得调用者无法区分“真正的U+FFFD字符”和“解码错误的返回值”。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanLines</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ScanLines 是一个“匹配函数”，用来找出 data 中的单行数据并返回（包括空行）。  </p>
<p>行尾标记可以是 \n 或 \r\n（返回值不包含行尾标记）  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanWords</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ScanWords 是一个“匹配函数”，用来找出 data 中以空白字符分隔的单词。  </p>
<p>空白字符由 unicode.IsSpace 定义。  </p>
<h3 id="示例1：扫描"><a href="#示例1：扫描" class="headerlink" title="示例1：扫描"></a>示例1：扫描</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 逗号分隔的字符串，最后一项为空</span></span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">"1,2,3,4,"</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    <span class="comment">// 定义匹配函数（查找逗号分隔的字符串）</span></span><br><span class="line">    onComma := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">','</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>, data[:i], <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atEOF &#123;</span><br><span class="line">            <span class="comment">// 告诉 Scanner 扫描结束。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, data, bufio.ErrFinalToken</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 告诉 Scanner 没找到匹配项，让 Scan 填充缓存后再次扫描。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定匹配函数</span></span><br><span class="line">    scanner.Split(onComma)</span><br><span class="line">    <span class="comment">// 开始扫描</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%q "</span>, scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否因为遇到错误而结束</span></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintln(os.Stderr, <span class="string">"reading input:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例2：待检查扫描"><a href="#示例2：待检查扫描" class="headerlink" title="示例2：待检查扫描"></a>示例2：待检查扫描</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">"1234 5678 1234567901234567890 90"</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    <span class="comment">// 自定义匹配函数</span></span><br><span class="line">    split := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取一个单词</span></span><br><span class="line">        advance, token, err = bufio.ScanWords(data, atEOF)</span><br><span class="line">        <span class="comment">// 判断其能否转换为整数，如果不能则返回错误</span></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; token != <span class="literal">nil</span> &#123;</span><br><span class="line">            _, err = strconv.ParseInt(<span class="keyword">string</span>(token), <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里包含了 return 0, nil, nil 的情况</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置匹配函数</span></span><br><span class="line">    scanner.Split(split)</span><br><span class="line">    <span class="comment">// 开始扫描</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Invalid input: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="bytes-包"><a href="#bytes-包" class="headerlink" title="bytes 包"></a><code>bytes</code> 包</h1><p>对于传入 []byte 的函数，都不会修改传入的参数，返回值要么是参数的副本，要么是参数的切片。  </p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="将s中所有字符修改为大写（小写、标题）格式返回"><a href="#将s中所有字符修改为大写（小写、标题）格式返回" class="headerlink" title="将s中所有字符修改为大写（小写、标题）格式返回"></a>将s中所有字符修改为大写（小写、标题）格式返回</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用指定的映射表将-s-中的所有字符修改为大写（小写、标题）格式返回"><a href="#使用指定的映射表将-s-中的所有字符修改为大写（小写、标题）格式返回" class="headerlink" title="使用指定的映射表将 s 中的所有字符修改为大写（小写、标题）格式返回"></a>使用指定的映射表将 s 中的所有字符修改为大写（小写、标题）格式返回</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpperSpecial</span><span class="params">(_case unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLowerSpecial</span><span class="params">(_case unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitleSpecial</span><span class="params">(_case unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="将-s-中的所有单词的首字符修改为-Title-格式返回"><a href="#将-s-中的所有单词的首字符修改为-Title-格式返回" class="headerlink" title="将 s 中的所有单词的首字符修改为 Title 格式返回"></a>将 s 中的所有单词的首字符修改为 Title 格式返回</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>BUG: 不能很好的处理以 Unicode 标点符号分隔的单词  </p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="比较两个-byte的字典顺序"><a href="#比较两个-byte的字典顺序" class="headerlink" title="比较两个[]byte的字典顺序"></a>比较两个[]byte的字典顺序</h3><p>nil 参数相当于空[]byte</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>a &lt;  b 返回 -1<br>a == b 返回 0<br>a &gt;  b 返回 1</p>
<h3 id="判断a、b是否相等"><a href="#判断a、b是否相等" class="headerlink" title="判断a、b是否相等"></a>判断a、b是否相等</h3><p>nil 相当于空[]byte  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<h3 id="判断s，t是否相似"><a href="#判断s，t是否相似" class="headerlink" title="判断s，t是否相似"></a>判断s，t是否相似</h3><p>忽略大写、小写、标题三种格式的区别。<br>参考 <code>unicode.SimpleFold</code> 函数  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EqualFold</span><span class="params">(s, t []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><h3 id="去掉-s-左右两边包含在cutset中的字符（返回s的切片）"><a href="#去掉-s-左右两边包含在cutset中的字符（返回s的切片）" class="headerlink" title="去掉 s 左右两边包含在cutset中的字符（返回s的切片）"></a>去掉 s 左右两边包含在cutset中的字符（返回s的切片）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="去掉s两边符合f要求的字符（返回s的切片）"><a href="#去掉s两边符合f要求的字符（返回s的切片）" class="headerlink" title="去掉s两边符合f要求的字符（返回s的切片）"></a>去掉s两边符合f要求的字符（返回s的切片）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeftFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRightFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="去掉s两边的空白-unicode-IsSpace-（返回s的切片）"><a href="#去掉s两边的空白-unicode-IsSpace-（返回s的切片）" class="headerlink" title="去掉s两边的空白(unicode.IsSpace)（返回s的切片）"></a>去掉s两边的空白(unicode.IsSpace)（返回s的切片）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="去掉-s-的前缀-prefix（后缀-suffix）（返回-s-的切片）"><a href="#去掉-s-的前缀-prefix（后缀-suffix）（返回-s-的切片）" class="headerlink" title="去掉 s 的前缀 prefix（后缀 suffix）（返回 s 的切片）"></a>去掉 s 的前缀 prefix（后缀 suffix）（返回 s 的切片）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<h2 id="拆合"><a href="#拆合" class="headerlink" title="拆合"></a>拆合</h2><h3 id="Split按seq分割"><a href="#Split按seq分割" class="headerlink" title="Split按seq分割"></a>Split按seq分割</h3><p>Split 以 sep 为分隔符将 s 切分成多个子串，结果不包含分隔符。<br>如果 sep 为空，则将 s 切分成 Unicode 字符列表。<br>SplitN 可以指定切分次数 n，超出 n 的部分将不进行切分。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitN</span><span class="params">(s, sep []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="SplitAfter"><a href="#SplitAfter" class="headerlink" title="SplitAfter"></a>SplitAfter</h3><p>功能同 Split，只不过结果包含分隔符（在各个子串尾部）。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfter</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfterN</span><span class="params">(s, sep []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Fields-空白符分割"><a href="#Fields-空白符分割" class="headerlink" title="Fields 空白符分割"></a>Fields 空白符分割</h3><p>以连续空白为分隔符将 s 切分成多个子串，结果不包含分隔符。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="以符合-f-的字符为分隔符将-s-切分成多个子串，结果不包含分隔符"><a href="#以符合-f-的字符为分隔符将-s-切分成多个子串，结果不包含分隔符" class="headerlink" title="以符合 f 的字符为分隔符将 s 切分成多个子串，结果不包含分隔符"></a>以符合 f 的字符为分隔符将 s 切分成多个子串，结果不包含分隔符</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FieldsFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Join，sep为连接符"><a href="#Join，sep为连接符" class="headerlink" title="Join，sep为连接符"></a>Join，sep为连接符</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(s [][]<span class="keyword">byte</span>, sep []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="把子串b重复count次吼返回"><a href="#把子串b重复count次吼返回" class="headerlink" title="把子串b重复count次吼返回"></a>把子串b重复count次吼返回</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(b []<span class="keyword">byte</span>, count <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := []<span class="keyword">byte</span>(<span class="string">"  Hello   World !  "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, bytes.Split(b, []<span class="keyword">byte</span>&#123;<span class="string">' '</span>&#125;))</span><br><span class="line">    <span class="comment">// ["" "" "Hello" "" "" "World" "!" "" ""]</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, bytes.Fields(b))</span><br><span class="line">    <span class="comment">// ["Hello" "World" "!"]</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bytes.ContainsRune([]<span class="keyword">byte</span>(<span class="string">" !"</span>), r)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, bytes.FieldsFunc(b, f))</span><br><span class="line">    <span class="comment">// ["Hello" "World"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2><h3 id="判断前缀、后缀"><a href="#判断前缀、后缀" class="headerlink" title="判断前缀、后缀"></a>判断前缀、后缀</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<h3 id="是否包含子串subslice-或字符r"><a href="#是否包含子串subslice-或字符r" class="headerlink" title="是否包含子串subslice 或字符r"></a>是否包含子串subslice 或字符r</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(b, subslice []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsRune</span><span class="params">(b []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<h3 id="是否包含chars中任一字符"><a href="#是否包含chars中任一字符" class="headerlink" title="是否包含chars中任一字符"></a>是否包含chars中任一字符</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(b []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<h3 id="查找子串seq（字节c、字符r）在s中第一次出现的位置"><a href="#查找子串seq（字节c、字符r）在s中第一次出现的位置" class="headerlink" title="查找子串seq（字节c、字符r）在s中第一次出现的位置"></a>查找子串seq（字节c、字符r）在s中第一次出现的位置</h3><p>找不到则返回-1  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s []<span class="keyword">byte</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="查找chars中任一字符在s中第一次出现的位置"><a href="#查找chars中任一字符在s中第一次出现的位置" class="headerlink" title="查找chars中任一字符在s中第一次出现的位置"></a>查找chars中任一字符在s中第一次出现的位置</h3><p>找不到则返回-1  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="查找符合f的字符在s中第一次出现的位置"><a href="#查找符合f的字符在s中第一次出现的位置" class="headerlink" title="查找符合f的字符在s中第一次出现的位置"></a>查找符合f的字符在s中第一次出现的位置</h3><p>找不到则返回-1  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="功能同上，只不过查找最后一次出现的位置"><a href="#功能同上，只不过查找最后一次出现的位置" class="headerlink" title="功能同上，只不过查找最后一次出现的位置"></a>功能同上，只不过查找最后一次出现的位置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexByte</span><span class="params">(s []<span class="keyword">byte</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="获取seq在s中出现的次数（不重叠）"><a href="#获取seq在s中出现的次数（不重叠）" class="headerlink" title="获取seq在s中出现的次数（不重叠）"></a>获取seq在s中出现的次数（不重叠）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h3 id="s中前n个old替换为new，n-lt-0则替换全部"><a href="#s中前n个old替换为new，n-lt-0则替换全部" class="headerlink" title="s中前n个old替换为new，n&lt;0则替换全部"></a>s中前n个old替换为new，n&lt;0则替换全部</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="将-s-中的字符替换为-mapping-r-的返回值"><a href="#将-s-中的字符替换为-mapping-r-的返回值" class="headerlink" title="将 s 中的字符替换为 mapping(r) 的返回值"></a>将 s 中的字符替换为 mapping(r) 的返回值</h3><p>如果 mapping 返回负值，则丢弃该字符  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> []<span class="title">byte</span>) []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="将s转换为-rune类型返回"><a href="#将s转换为-rune类型返回" class="headerlink" title="将s转换为[]rune类型返回"></a>将s转换为[]rune类型返回</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runes</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">rune</span></span></span><br></pre></td></tr></table></figure>

<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><h3 id="type-Reader"><a href="#type-Reader" class="headerlink" title="type Reader"></a>type Reader</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>将 b 包装成 bytes.Reader 对象。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(b []<span class="keyword">byte</span>)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>
<p>bytes.Reader 实现了如下接口：  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReadSeeker</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReaderAt</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.WriterTo</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ByteScanner</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.RuneScanner</span></span><br></pre></td></tr></table></figure>
<p>返回未读取部分的数据长度：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>返回底层数据的总长度，方便ReadAt使用，返回值永远不变：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int64</span></span></span><br></pre></td></tr></table></figure>
<p>将底层数据切换为 b，同时复位所有标记（读取位置等信息）  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Reset</span><span class="params">(b []<span class="keyword">byte</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b1 := []<span class="keyword">byte</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line">    b2 := []<span class="keyword">byte</span>(<span class="string">"Hello 世界！"</span>)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>)</span><br><span class="line">    rd := bytes.NewReader(b1)</span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf) <span class="comment">// "Hello "</span></span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf) <span class="comment">// "World!"</span></span><br><span class="line"></span><br><span class="line">    rd.Reset(b2)</span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf) <span class="comment">// "Hello "</span></span><br><span class="line">    fmt.Printf(<span class="string">"Size:%d, Len:%d\n"</span>, rd.Size(), rd.Len())</span><br><span class="line">    <span class="comment">// Size:15, Len:9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Buffer"><a href="#type-Buffer" class="headerlink" title="type Buffer"></a>type Buffer</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>将 buf 包装成 bytes.Buffer 对象：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBuffer</span><span class="params">(buf []<span class="keyword">byte</span>)</span> *<span class="title">Buffer</span></span></span><br></pre></td></tr></table></figure>
<p>将 s 转换为 []byte 后，包装成 bytes.Buffer 对象：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBufferString</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Buffer</span></span></span><br></pre></td></tr></table></figure>
<p>Buffer 本身就是一个缓存（内存块），没有底层数据，缓存的容量会根据需要自动调整。大多数情况下，使用 new(Buffer) 就足以初始化一个 Buffer 了。  </p>
<p>bytes.Buffer 实现了如下接口：  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReadWriter</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReaderFrom</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.WriterTo</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ByteWeriter</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ByteScanner</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.RuneScanner</span></span><br></pre></td></tr></table></figure>
<p>未读取部分的数据长度：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>缓存的容量：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>读取前 n 字节的数据并以切片形式返回，如果数据长度小于 n，则全部读取。<br>切片只在下一次读写操作前合法。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Next</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>读取第一个 delim 及其之前的内容，返回遇到的错误（一般是 io.EOF）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>写入 r 的 UTF-8 编码，返回写入的字节数和 nil。<br>保留 err 是为了匹配 bufio.Writer 的 WriteRune 方法。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>写入 s，返回写入的字节数和 nil：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>引用未读取部分的数据切片（不移动读取位置）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>返回未读取部分的数据字符串（不移动读取位置）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>自动增加缓存容量，以保证有 n 字节的剩余空间。<br>如果 n 小于 0 或无法增加容量则会 panic。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>将数据长度截短到 n 字节，如果 n 小于 0 或大于 Cap 则 panic：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Truncate</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>重设缓冲区，清空所有数据（包括初始内容）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Reset</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>eg.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rd := bytes.NewBufferString(<span class="string">"Hello World!"</span>)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 获取数据切片</span></span><br><span class="line">    b := rd.Bytes()</span><br><span class="line">    <span class="comment">// 读出一部分数据，看看切片有没有变化</span></span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, rd.String()) <span class="comment">// World!</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n\n"</span>, b)         <span class="comment">// Hello World!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一部分数据，看看切片有没有变化</span></span><br><span class="line">    rd.Write([]<span class="keyword">byte</span>(<span class="string">"abcdefg"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, rd.String()) <span class="comment">// World!abcdefg</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n\n"</span>, b)         <span class="comment">// Hello World!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再读出一部分数据，看看切片有没有变化</span></span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, rd.String()) <span class="comment">// abcdefg</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, b)           <span class="comment">// Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="errors-包"><a href="#errors-包" class="headerlink" title="errors 包"></a><code>errors</code> 包</h1><p>Go 语言使用 error 类型来返回函数执行过程中遇到的错误，如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。  </p>
<p>其实 error 只是一个接口，定义如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以用任何类型去实现它（只要添加一个 Error() 方法即可），也就是说，error 可以是任何类型，这意味着，函数返回的 error 值实际可以包含任意信息，不一定是字符串（当然字符串是必须的）。  </p>
<p>error 不一定表示一个错误，它可以表示任何信息，比如 io 包中就用 error 类型的 io.EOF 表示数据读取结束，而不是遇到了什么错误。再比如 path/filepath 包中用 error 类型的 filepath.SkipDir 表示跳过当前目录，继续遍历下一个目录，而不是遇到了什么错误。  </p>
<h2 id="error-New-函数"><a href="#error-New-函数" class="headerlink" title="error.New()函数"></a><code>error.New()</code>函数</h2><p>errors 包实现了一个最简单的 error 类型，只包含一个字符串，它可以记录大多数情况下遇到的错误信息。errors 包的用法也很简单，只有一个 New 函数，用于生成一个最简单的 error 对象：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串 text 包装成一个 error 对象返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>eg：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> 遇到错误 &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"遇到了某某错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义error类型"><a href="#自定义error类型" class="headerlink" title="自定义error类型"></a>自定义<code>error</code>类型</h2><p>如果你的程序需要记录更多的错误信息，比如时间、数值等信息，可以声明一个自定义的 error 类型。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span> &#123;</span><br><span class="line">    err   <span class="keyword">string</span></span><br><span class="line">    time  time.Time</span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %d 次。时间：%v"</span>, m.err, m.count, m.time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newErr</span><span class="params">(s <span class="keyword">string</span>, i <span class="keyword">int</span>)</span> *<span class="title">myError</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;myError&#123;</span><br><span class="line">        err:   s,</span><br><span class="line">        time:  time.Now(),</span><br><span class="line">        count: i,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">return</span> newErr(<span class="string">"遇到某某情况"</span>, count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> err := SomeFunc(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="fmt-包"><a href="#fmt-包" class="headerlink" title="fmt 包"></a><code>fmt</code> 包</h1><p>实现了格式化I/O函数。<a href="http://docscn.studygolang.com/pkg/fmt/" target="_blank" rel="noopener">文档</a>  </p>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><p>通用占位符：  </p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">v</span></span>  值的默认格式。当打印结构体时，“加号”标记（%+v）会添加字段名</span><br><span class="line"><span class="tag">%<span class="selector-id">#v</span></span>　相应值的Go语法表示</span><br><span class="line"><span class="tag">%<span class="selector-tag">T</span></span>  相应值的类型的Go语法表示</span><br><span class="line"><span class="tag">%</span>%  字面上的百分号，并非值的占位符</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Sample <span class="keyword">struct</span> &#123;</span><br><span class="line">    a   <span class="keyword">int</span></span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Sample)</span><br><span class="line">    s.a = <span class="number">1</span></span><br><span class="line">    s.str = <span class="string">"hello"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, *s)　<span class="comment">//&#123;1 hello&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *s) <span class="comment">//  &#123;a:1 str:hello&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, *s) <span class="comment">// main.Sample&#123;a:1, str:"hello"&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, *s)   <span class="comment">//  main.Sample</span></span><br><span class="line">    fmt.Printf(<span class="string">"%%\n"</span>, s.a) <span class="comment">//  %  %!(EXTRA int=1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布尔值：  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">%t</span>   <span class="literal">true</span> <span class="string">或</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>整数值：  </p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">b</span></span>  二进制表示</span><br><span class="line"><span class="tag">%<span class="selector-tag">c</span></span>  相应Unicode码点所表示的字符</span><br><span class="line"><span class="tag">%<span class="selector-tag">d</span></span>  十进制表示</span><br><span class="line"><span class="tag">%<span class="selector-tag">o</span></span>  八进制表示</span><br><span class="line"><span class="tag">%<span class="selector-tag">q</span></span>  单引号围绕的字符字面值，由Go语法安全地转义</span><br><span class="line"><span class="tag">%<span class="selector-tag">x</span></span>  十六进制表示，字母形式为小写 a-f</span><br><span class="line"><span class="tag">%<span class="selector-tag">X</span></span>  十六进制表示，字母形式为大写 A-F</span><br><span class="line"><span class="tag">%<span class="selector-tag">U</span></span>  Unicode格式：U+1234，等同于 "U+%04X"</span><br></pre></td></tr></table></figure>
<p>浮点及复数：  </p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">b</span></span>  无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat中的 'b' 转换格式一致。例如 -123456p-78</span><br><span class="line"><span class="tag">%<span class="selector-tag">e</span></span>  科学计数法，例如 -1234.456e+78</span><br><span class="line"><span class="tag">%<span class="selector-tag">E</span></span>  科学计数法，例如 -1234.456E+78</span><br><span class="line"><span class="tag">%<span class="selector-tag">f</span></span>  有小数点而无指数，例如 123.456</span><br><span class="line"><span class="tag">%<span class="selector-tag">g</span></span>  根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</span><br><span class="line"><span class="tag">%<span class="selector-tag">G</span></span>  根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</span><br></pre></td></tr></table></figure>
<p>字符串和bytes的slice表示：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">s</span></span>  字符串或切片的无解译字节</span><br><span class="line"><span class="tag">%<span class="selector-tag">q</span></span>  双引号围绕的字符串，由Go语法安全地转义</span><br><span class="line"><span class="tag">%<span class="selector-tag">x</span></span>  十六进制，小写字母，每字节两个字符</span><br><span class="line"><span class="tag">%<span class="selector-tag">X</span></span>  十六进制，大写字母，每字节两个字符</span><br></pre></td></tr></table></figure>
<p>指针：  </p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">p</span></span>  十六进制表示，前缀 0x</span><br></pre></td></tr></table></figure>
<p>这里没有 ‘u’ 标记。若整数为无符号类型，他们就会被打印成无符号的。类似地，这里也不需要指定操作数的大小（int8，int64）。  </p>
<p>对于％ｖ来说默认的格式是：  </p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">bool:                    %t</span><br><span class="line"><span class="keyword">int</span>, int8 etc.:          %d</span><br><span class="line">uint, uint8 etc.:        %d, %x <span class="keyword">if</span> printed with %#v</span><br><span class="line">float32, complex64, etc: %g</span><br><span class="line"><span class="keyword">string</span>:                  %s</span><br><span class="line">chan:                    %p</span><br><span class="line">pointer:                 %p</span><br></pre></td></tr></table></figure>
<p>对于复合对象，里面的元素使用如下规则进行打印：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">struct:</span>             &#123;field0 field1 ...&#125;</span><br><span class="line">array, <span class="string">slice:</span>       [elem0  elem1 ...]</span><br><span class="line"><span class="string">maps:</span>               map[<span class="string">key1:</span>value1 <span class="string">key2:</span>value2]</span><br><span class="line">pointer to <span class="string">above:</span>   &amp;&#123;&#125;, &amp;[], &amp;map[]</span><br></pre></td></tr></table></figure>
<p>宽度和精度：<br>宽度是在％之后的值，如果没有指定，则使用该值的默认值，精度是跟在宽度之后的值，如果没有指定，也是使用要打印的值的默认精度．例如：％９.２f，宽度９，精度２  </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">%f:   <span class="built_in"> default </span>width,<span class="built_in"> default </span>precision</span><br><span class="line">%9f    width 9,<span class="built_in"> default </span>precision</span><br><span class="line">%.2f  <span class="built_in"> default </span>width, precision 2</span><br><span class="line">%9.2f  width 9, precision 2</span><br><span class="line">%9.f   width 9, precision 0</span><br></pre></td></tr></table></figure>
<p>对数值而言，宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。但对于 %g/%G 而言，精度为所有数字的总数。例如，对于123.45，格式 %6.2f会打印123.45，而 %.4g 会打印123.5。%e 和 %f 的默认精度为6；但对于 %g 而言，它的默认精度为确定该值所必须的最小位数。  </p>
<p>对大多数值而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。对字符串而言，精度为输出的最大字符数，如果必要的话会直接截断。  </p>
<p>宽度是指”必要的最小宽度”. 若结果字符串的宽度超过指定宽度时, 指定宽度就会失效。  </p>
<p>其他标志：  </p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">+   总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。</span><br><span class="line">-   左对齐</span><br><span class="line">#   备用格式：为八进制添加前导 <span class="number">0</span>（%#o），为十六进制添加前导 <span class="number">0</span>x（%#x）或<span class="number">0</span>X（%#X），为 %p（%#p）去掉前导 <span class="number">0</span>x；对于 %q，若 strconv.CanBackquote</span><br><span class="line">    返回 true，就会打印原始（即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的Unicode编码形式（如字符 x 会被打印成 U+<span class="number">0078</span> <span class="string">'x'</span>）。</span><br><span class="line"><span class="string">' '</span> （空格）为数值中省略的正负号留出空白（% d）；以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</span><br><span class="line"><span class="number">0</span>   填充前导的<span class="number">0</span>而非空格；对于数字，这会将填充移到正负号之后</span><br></pre></td></tr></table></figure>
<p>对于每一个 Printf 类的函数，都有一个 Print 函数，该函数不接受任何格式化，它等价于对每一个操作数都应用 %v。另一个变参函数 Println 会在操作数之间插入空白，并在末尾追加一个换行符  </p>
<p>格式化错误：  </p>
<p>如果给占位符提供了无效的实参（如将一个字符串提供给％d），便会出现格式化错误．所有的错误都始于“%!”，有时紧跟着单个字符（占位符），并以小括号括住的描述结尾。  </p>
<h2 id="Scanning"><a href="#Scanning" class="headerlink" title="Scanning"></a>Scanning</h2><p>一组类似的函数通过扫描已格式化的文本来产生值。  </p>
<p>Scan、Scanf 和 Scanln 从os.Stdin 中读取；<br>Fscan、Fscanf 和 Fscanln 从指定的 io.Reader 中读取；<br>Sscan、Sscanf 和 Sscanln 从实参字符串中读取。<br>Scanln、Fscanln 和 Sscanln在换行符处停止扫描，且需要条目紧随换行符之后；<br>Scanf、Fscanf 和 Sscanf需要输入换行符来匹配格式中的换行符；<br>其它函数则将换行符视为空格。  </p>
<p>Scanf、Fscanf 和 Sscanf 根据格式字符串解析实参，类似于 Printf。例如，%x会将一个整数扫描为十六进制数，而 %v 则会扫描该值的默认表现格式。  </p>
<p>格式化类似于 Printf，但也有例外，如下所示：  </p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">%p 没有实现</span><br><span class="line">%T 没有实现</span><br><span class="line">%e %E %f %F %g %G 都完全等价，且可扫描任何浮点数或复合数值</span><br><span class="line">%s 和 %v 在扫描字符串时会将其中的空格作为分隔符</span><br><span class="line">标记 <span class="comment"># 和 + 没有实现</span></span><br></pre></td></tr></table></figure>
<p>在输入Scanf中，宽度可以理解成输入的文本（％5s表示输入５个字符），而Scanf没有精度这种说法（没有%5.2f，只有 %5f）  </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Errorf 根据于格式说明符进行格式化，并将字符串作为满足 error 的值返回，其返回类型是error(功能同Sprintf，只不过把结果字符串包装成error类型).  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := fmt.Errorf(<span class="string">"%s%d"</span>, <span class="string">"error:"</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(a)</span><br></pre></td></tr></table></figure>
<h3 id="Fprint、Fprintf、Fprintln"><a href="#Fprint、Fprintf、Fprintln" class="headerlink" title="Fprint、Fprintf、Fprintln"></a>Fprint、Fprintf、Fprintln</h3><p>对于每一个 Printf 类的函数，都有一个 Print 函数，该函数不接受任何格式化，它等价于对每一个操作数都应用 %v。另一个变参函数 Println 会在操作数之间插入空白，并在末尾追加一个换行符  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>　</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Fprint 使用其操作数的默认格式进行格式化并写入到 w。当两个连续的操作数均不为字符串时，它们之间就会添加空格。它返回写入的字节数以及任何遇到的错误。<br>Fprintf 根据于格式说明符进行格式化并写入到 w。它返回写入的字节数以及任何遇到的写入错误。<br>Fprintln 使用其操作数的默认格式进行格式化并写入到 w。其操作数之间总是添加空格，且总在最后追加一个换行符。它返回写入的字节数以及任何遇到的错误。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="string">"asdf"</span></span><br><span class="line">    fmt.Fprintln(os.Stdout, a)          <span class="comment">//asdf</span></span><br><span class="line">    fmt.Fprintf(os.Stdout, <span class="string">"%.2s\n"</span>, a) <span class="comment">//as</span></span><br><span class="line">    fmt.Fprint(os.Stdout, a)            <span class="comment">//asdf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fscan、Fscanf、Fscanln"><a href="#Fscan、Fscanf、Fscanln" class="headerlink" title="Fscan、Fscanf、Fscanln"></a>Fscan、Fscanf、Fscanln</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Fscan 扫描从 r 中读取的文本，并将连续由空格分隔的值存储为连续的实参。换行符计为空格。它返回成功扫描的条目数。若它少于实参数，err 就会报告原因。<br>Fscanf 扫描从 r 中读取的文本，并将连续由空格分隔的值存储为连续的实参，其格式由 format 决定。它返回成功解析的条目数。<br>Fscanln 类似于 Sscan，但它在换行符处停止扫描，且最后的条目之后必须为换行符或 EOF。<br>注：Fscan类的也是由空格进行分割的．  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">"hello 1"</span>)</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">    fmt.Fscanln(r, &amp;a, &amp;b)</span><br><span class="line">    fmt.Println(a, b)　　　　　　　　 <span class="comment">//hello 1</span></span><br><span class="line">    r1 := strings.NewReader(<span class="string">"helloworld 2"</span>)</span><br><span class="line">    fmt.Fscanf(r1, <span class="string">"hello%s%d"</span>, &amp;a, &amp;b) 　</span><br><span class="line">    fmt.Println(a, b)　　　　　　　　<span class="comment">//world 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Print、Printf、Println"><a href="#Print、Printf、Println" class="headerlink" title="Print、Printf、Println"></a>Print、Printf、Println</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Print 使用其操作数的默认格式进行格式化并写入到标准输出。当两个连续的操作数均不为字符串时，它们之间就会添加空格。它返回写入的字节数以及任何遇到的错误。<br>Printf 根据格式说明符进行格式化并写入到标准输出。它返回写入的字节数以及任何遇到的写入错误。<br>使用其操作数的默认格式进行格式化并写入到标准输出。其操作数之间总是添加空格，且总在最后追加一个换行符。它返回写入的字节数以及任何遇到的错误。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"hello,world!"</span></span><br><span class="line">    fmt.Println(s)     <span class="comment">//hello,world!</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, s)    <span class="comment">//hello,world!</span></span><br><span class="line">    fmt.Print(s)           <span class="comment">//hello,world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于 <code>Fprint(os.Stdout,...)</code>  </p>
<h3 id="Scan、Scanf、Scanln"><a href="#Scan、Scanf、Scanln" class="headerlink" title="Scan、Scanf、Scanln"></a>Scan、Scanf、Scanln</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Scan 扫描从标准输入中读取的文本，并将连续由空格分隔的值存储为连续的实参。换行符计为空格。它返回成功扫描的条目数。若它少于实参数，err 就会报告原因。<br>Scanf 扫描从标准输入中读取的文本，并将连续由空格分隔的值存储为连续的实参，其格式由 format 决定。它返回成功扫描的条目数。<br>Scanln 类似于 Scan，但它在换行符处停止扫描，且最后的条目之后必须为换行符或 EOF。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;a, &amp;b)   <span class="comment">// 2,1</span></span><br><span class="line">    fmt.Println(a, b)        <span class="comment">//输出２　１</span></span><br><span class="line">    fmt.Scanf(<span class="string">"%s%d"</span>, &amp;a, &amp;b)　<span class="comment">//2 1</span></span><br><span class="line">    fmt.Println(a, b)　　<span class="comment">//输出２　１</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sprint、Sprintf、Sprintln"><a href="#Sprint、Sprintf、Sprintln" class="headerlink" title="Sprint、Sprintf、Sprintln"></a>Sprint、Sprintf、Sprintln</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>Sprint 使用其操作数的默认格式进行格式化并返回其结果字符串。当两个连续的操作数均不为字符串时，它们之间就会添加空格。<br>Sprintf 根据于格式说明符进行格式化并返回其结果字符串。<br>Sprintln 使用其操作数的默认格式进行格式化并写返回其结果字符串。其操作数之间总是添加空格，且总在最后追加一个换行符。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := fmt.Sprintf(<span class="string">"%s,%d"</span>, <span class="string">"hello"</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(a)       <span class="comment">//hello,1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sscan、Sscanf、Sscanln"><a href="#Sscan、Sscanf、Sscanln" class="headerlink" title="Sscan、Sscanf、Sscanln"></a>Sscan、Sscanf、Sscanln</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="keyword">string</span>, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Sscan 扫描实参 string，并将连续由空格分隔的值存储为连续的实参。换行符计为空格。它返回成功扫描的条目数。若它少于实参数，err 就会报告原因。<br>Scanf 扫描实参 string，并将连续由空格分隔的值存储为连续的实参，其格式由 format 决定。它返回成功解析的条目数。<br>Sscanln 类似于 Sscan，但它在换行符处停止扫描，且最后的条目之后必须为换行符或 EOF。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    fmt.Sscan(<span class="string">"hello 1"</span>, &amp;a, &amp;b) <span class="comment">//hello 1</span></span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">    fmt.Sscanf(<span class="string">"helloworld 2 "</span>, <span class="string">"hello%s%d"</span>, &amp;a, &amp;c) <span class="comment">//world 2</span></span><br><span class="line">    fmt.Println(a, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="type-1"><a href="#type-1" class="headerlink" title="type"></a>type</h2><h3 id="type-Formatter"><a href="#type-Formatter" class="headerlink" title="type Formatter"></a>type Formatter</h3><p>用于实现对象的自定义格式输出  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Formatter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Format 用来处理当对象遇到 c 标记时的输出方式（c 相当于 %s 中的 s）</span></span><br><span class="line">    <span class="comment">// f 用来获取占位符的宽度、精度、扩展标记等信息，同时实现最终的输出</span></span><br><span class="line">    <span class="comment">// c 是要处理的标记</span></span><br><span class="line">    Format(f State, c <span class="keyword">rune</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-GoStringer"><a href="#type-GoStringer" class="headerlink" title="type GoStringer"></a>type GoStringer</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> GoStringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// GoString 获取对象的 Go 语法文本形式（以 %#v 格式输出的文本）</span></span><br><span class="line">    GoString() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-ScanState"><a href="#type-ScanState" class="headerlink" title="type ScanState"></a>type ScanState</h3><p>ScanState 会返回扫描状态给自定义的 Scanner<br>Scanner 可能会做字符的实时扫描<br>或者通过 ScanState 获取以空格分割的 token  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ScanState <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// ReadRune 从输入对象中读出一个 Unicode 字符</span></span><br><span class="line">    <span class="comment">//world 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 Scanln、Fscanln 或 Sscanln 中调用该方法<br>该方法会在遇到 ‘\n’ 或读取超过指定的宽度时返回 EOFReadRune() (r rune, size int, err error)<br>UnreadRune 撤消最后一次的 ReadRune 操作UnreadRune() error<br>SkipSpace 跳过输入数据中的空格<br>在 Scanln、Fscanln、Sscanln 操作中，换行符会被当作 EOF<br>在其它 Scan 操作中，换行符会被当作空格SkipSpace()<br>如果参数 skipSpace 为 true，则 Token 会跳过输入数据中的空格<br>然后返回满足函数 f 的连续字符，如果 f 为 nil，则使用 !unicode.IsSpace 来代替 f<br>在 Scanln、Fscanln、Sscanln 操作中，换行符会被当作 EOF<br>在其它 Scan 操作中，换行符会被当作空格<br>返回的 token 是一个切片，返回的数据可能在下一次调用 Token 的时候被修改Token(skipSpace bool, f func(rune) bool) (token []byte, err error)<br>Width 返回宽度值以及宽度值是否被设置Width() (wid int, ok bool)<br>因为 ReadRune 已经通过接口实现，所以 Read 可能永远不会被 Scan 例程调用<br>一个 ScanState 的实现，可能会选择废弃 Read 方法，而使其始终返回一个错误信息Read(buf []byte) (n int, err error)}</p>
<h3 id="type-Scanner-1"><a href="#type-Scanner-1" class="headerlink" title="type Scanner"></a>type Scanner</h3><p>Scanner 由任何拥有 Scan 方法的值实现，它将输入扫描成值的表示，并将其结果存储到接收者中，该接收者必须为可用的指针。Scan 方法会被 Scan、Scanf 或 Scanln 的任何实现了它的实参所调用。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Scanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    Scan(state ScanState, verb <span class="keyword">rune</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-State"><a href="#type-State" class="headerlink" title="type State"></a>type State</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write 函数用于打印出已格式化的输出。</span></span><br><span class="line">    Write(b []<span class="keyword">byte</span>) (ret <span class="keyword">int</span>, err error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Width 返回宽度选项的值以及它是否已被设置。</span></span><br><span class="line">    Width() (wid <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Precision 返回精度选项的值以及它是否已被设置。</span></span><br><span class="line">    Precision() (prec <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flag 返回标记 c（一个字符）是否已被设置。</span></span><br><span class="line">    Flag(c <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Stringer"><a href="#type-Stringer" class="headerlink" title="type Stringer"></a>type Stringer</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// String 获取对象的文本形式</span></span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="net-http-包"><a href="#net-http-包" class="headerlink" title="net/http 包"></a><code>net/http</code> 包</h1><p><a href="http://docscn.studygolang.com/pkg/net/http/" target="_blank" rel="noopener">文档</a>  </p>
<p>http包包含http客户端和服务端的实现,利用Get,Head,Post,以及PostForm实现HTTP或者HTTPS的请求。  </p>
<p>当客户端使用完response body后必须使用close对其进行关闭：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        ErrHeaderTooLong        = &amp;ProtocolError&#123;<span class="string">"header too long"</span>&#125;</span><br><span class="line">        ErrShortBody            = &amp;ProtocolError&#123;<span class="string">"entity body too short"</span>&#125;</span><br><span class="line">        ErrNotSupported         = &amp;ProtocolError&#123;<span class="string">"feature not supported"</span>&#125;</span><br><span class="line">        ErrUnexpectedTrailer    = &amp;ProtocolError&#123;<span class="string">"trailer header without chunked transfer encoding"</span>&#125;</span><br><span class="line">        ErrMissingContentLength = &amp;ProtocolError&#123;<span class="string">"missing ContentLength in HEAD response"</span>&#125;</span><br><span class="line">        ErrNotMultipart         = &amp;ProtocolError&#123;<span class="string">"request Content-Type isn't multipart/form-data"</span>&#125;</span><br><span class="line">        ErrMissingBoundary      = &amp;ProtocolError&#123;<span class="string">"no multipart boundary param in Content-Type"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        ErrWriteAfterFlush = errors.New(<span class="string">"Conn.Write called after Flush"</span>)</span><br><span class="line">        ErrBodyNotAllowed  = errors.New(<span class="string">"http: request method or response status code does not allow body"</span>)</span><br><span class="line">        ErrHijacked        = errors.New(<span class="string">"Conn has been hijacked"</span>)</span><br><span class="line">        ErrContentLength   = errors.New(<span class="string">"Conn.Write wrote more than the declared Content-Length"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125; <span class="comment">//默认客户端,被Get,Head以及Post使用</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = NewServeMux()<span class="comment">//Serve使用的默认ServeMux</span></span><br><span class="line"><span class="keyword">var</span> ErrBodyReadAfterClose = errors.New(<span class="string">"http: invalid Read on closed Body"</span>)<span class="comment">//当读取一个request或者response body是在这个body已经关闭之后,便会返回该错误.这种错误主要发生情况是:当http handler调用writeheader或者write关于responsewrite之后进行读操作.</span></span><br><span class="line"><span class="keyword">var</span> ErrHandlerTimeout = errors.New(<span class="string">"http: Handler timeout"</span>)<span class="comment">//超时错误</span></span><br><span class="line"><span class="keyword">var</span> ErrLineTooLong = internal.ErrLineTooLong<span class="comment">//当读取格式错误的分块编码时便会出现该错误.</span></span><br><span class="line"><span class="keyword">var</span> ErrMissingFile = errors.New(<span class="string">"http: no such file"</span>)<span class="comment">//当利用FormFile进行文件请求时,如果文件不存在或者请求中没有该文件就会出现该错误.</span></span><br><span class="line"><span class="keyword">var</span> ErrNoCookie = errors.New(<span class="string">"http: named cookie not present"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNoLocation = errors.New(<span class="string">"http: no Location header in response"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanonicalHeaderKey</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span>//返回<span class="title">header</span> <span class="title">key</span>的规范化形式,规范化形式是以"-"为分隔符,每一部分都是首字母大写,其他字母小写.例如"<span class="title">accept</span>-<span class="title">encoding</span>" 的标准化形式是 "<span class="title">Accept</span>-<span class="title">Encoding</span>".</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DetectContentType</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">string</span>//检查给定数据的内容类型<span class="title">Content</span>-<span class="title">Type</span>,最多检测512<span class="title">byte</span>数据,如果有效的话,该函数返回一个<span class="title">MIME</span>类型,否则的话,返回一个"<span class="title">application</span>/<span class="title">octet</span>-<span class="title">stream</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Error</span><span class="params">(w ResponseWriter, error <span class="keyword">string</span>, code <span class="keyword">int</span>)</span>//利用指定的错误信息和<span class="title">Http</span> <span class="title">code</span>来响应请求,其中错误信息必须是纯文本.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFound</span><span class="params">(w ResponseWriter, r *Request)</span>//返回<span class="title">HTTP404</span> <span class="title">not</span> <span class="title">found</span>错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span>//将<span class="title">handler</span>按照指定的格式注册到<span class="title">DefaultServeMux</span>,<span class="title">ServeMux</span>解释了模式匹配规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)//同上，主要用来实现动态文件内容的展示，这点与<span class="title">ServerFile</span><span class="params">()</span>不同的地方。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span>//监听<span class="title">TCP</span>网络地址<span class="title">addr</span>然后调用具有<span class="title">handler</span>的<span class="title">Serve</span>去处理连接请求.通常情况下<span class="title">Handler</span>是<span class="title">nil</span>,使用默认的<span class="title">DefaultServeMux</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr <span class="keyword">string</span>, certFile <span class="keyword">string</span>, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span>//该函数与<span class="title">ListenAndServe</span>功能基本相同,二者不同之处是该函数需要<span class="title">HTTPS</span>连接.也就是说,必须给该服务<span class="title">Serve</span>提供一个包含整数的秘钥的文件,如果证书是由证书机构签署的,那么证书文件必须是服务证书之后跟着<span class="title">CA</span>证书.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeFile</span><span class="params">(w ResponseWriter, r *Request, name <span class="keyword">string</span>)</span>//利用指定的文件或者目录的内容来响应相应的请求.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCookie</span><span class="params">(w ResponseWriter, cookie *Cookie)</span>//给<span class="title">w</span>设定<span class="title">cookie</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StatusText</span><span class="params">(code <span class="keyword">int</span>)</span> <span class="title">string</span>//对于<span class="title">http</span>状态码返回文本表示,如果这个<span class="title">code</span>未知,则返回空的字符串.</span></span><br></pre></td></tr></table></figure>

<p>eg.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// http.NotFound(w, r)//用于设置404问题</span></span><br><span class="line">    <span class="comment">// http.Error(w, "404 page not found", 404) //状态码需和描述相符</span></span><br><span class="line"></span><br><span class="line">    http.ServeFile(w, r, <span class="string">"1.txt"</span>) <span class="comment">//将1.txt中内容在w中显示.</span></span><br><span class="line">    cookie := &amp;http.Cookie&#123;</span><br><span class="line">        Name:  http.CanonicalHeaderKey(<span class="string">"uid-test"</span>), <span class="comment">//Name值为Uid-Test</span></span><br><span class="line">        Value: <span class="string">"1234"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    r.AddCookie(cookie)</span><br><span class="line">    fmt.Println(r.Cookie(<span class="string">"uid-test"</span>)) <span class="comment">//&lt;nil&gt; http: named cookie not present</span></span><br><span class="line">    fmt.Println(r.Cookie(<span class="string">"Uid-Test"</span>)) <span class="comment">//Uid-Test=1234 &lt;nil&gt;</span></span><br><span class="line">    fmt.Println(r.Cookies())          <span class="comment">//[Uid-Test=1234]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    stat := http.StatusText(<span class="number">200</span>)</span><br><span class="line">    fmt.Println(stat) <span class="comment">//状态码200对应的状态OK</span></span><br><span class="line"></span><br><span class="line">    stringtype := http.DetectContentType([]<span class="keyword">byte</span>(<span class="string">"test"</span>))</span><br><span class="line">    fmt.Println(stringtype) <span class="comment">//text/plain; charset=utf-8</span></span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/test"</span>, Test)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxBytesReader</span><span class="params">(w ResponseWriter, r io.ReadCloser, n <span class="keyword">int64</span>)</span> <span class="title">io</span>.<span class="title">ReadCloser</span>//该函数类似于<span class="title">io</span>.<span class="title">LimitReader</span>但是该函数是用来限制请求体的大小.与<span class="title">io</span>.<span class="title">LimitReader</span>不同的是,该函数返回一个<span class="title">ReaderCloser</span>,当读超过限制时,返回一个<span class="title">non</span>-<span class="title">EOF</span>,并且当<span class="title">Close</span>方法调用时,关闭底层的<span class="title">reader</span>.该函数组织客户端恶意发送大量请求,浪费服务器资源.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseHTTPVersion</span><span class="params">(vers <span class="keyword">string</span>)</span> <span class="params">(major, minor <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span>//解析<span class="title">http</span>字符串版本进行解析,"<span class="title">HTTP</span>/1.0" 返回 <span class="params">(1, 0, <span class="literal">true</span>)</span>//注解析的字符串必须以<span class="title">HTTP</span>开始才能够正确解析，<span class="title">HTTP</span>区分大小写，其他诸如<span class="title">http</span>或者<span class="title">Http</span>都不能够正确解析。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseTime</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="params">(t time.Time, err error)</span>//解析时间头<span class="params">(例如data:header)</span>,解析格式如下面三种<span class="params">(HTTP/1.1中允许的)</span>:<span class="title">TimeFormat</span>, <span class="title">time</span>.<span class="title">RFC850</span>, <span class="title">and</span> <span class="title">time</span>.<span class="title">ANSIC</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProxyFromEnvironment</span><span class="params">(req *Request)</span> <span class="params">(*url.URL, error)</span>//该函数返回一个指定请求的代理<span class="title">URL</span>,这是由环境变量<span class="title">HTTP_PROXY</span>,<span class="title">HTTPS_PROXY</span>以及<span class="title">NO_PROXY</span>决定的,对于<span class="title">https</span>请求,<span class="title">HTTPS_PROXY</span>优先级高于<span class="title">HTTP_PROXY</span>,环境值可能是一个<span class="title">URL</span>或者一个<span class="title">host</span>:<span class="title">port</span>,其中这两种类型都是<span class="title">http</span>调度允许的,如果不是这两种类型的数值便会返回错误.如果在环境中没有定义代理或者代理不应该用于该请求<span class="params">(定义为NO_PROXY)</span>,将会返回一个<span class="title">nil</span> <span class="title">URL</span>和一个<span class="title">nil</span> <span class="title">error</span>.作为一个特例,如果请求<span class="title">rul</span>是"<span class="title">localhost</span>",无论有没有<span class="title">port</span>,那么将返回一个<span class="title">nil</span> <span class="title">rul</span>和一个<span class="title">nil</span> <span class="title">error</span>.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProxyURL</span><span class="params">(fixedURL *url.URL)</span> <span class="title">func</span><span class="params">(*Request)</span> <span class="params">(*url.URL, error)</span>//返回一个用于传输的代理函数,该函数总是返回相同的<span class="title">URL</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Redirect</span><span class="params">(w ResponseWriter, r *Request, urlStr <span class="keyword">string</span>, code <span class="keyword">int</span>)</span>//返回一个重定向的<span class="title">url</span>给指定的请求,这个重定向<span class="title">url</span>可能是一个相对请求路径的一个相对路径.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(l net.Listener, handler Handler)</span> <span class="title">error</span>//该函数接受<span class="title">listener</span> <span class="title">l</span>的传入<span class="title">http</span>连接,对于每一个连接创建一个新的服务协程,这个服务协程读取请求然后调用<span class="title">handler</span>来给他们响应.<span class="title">handler</span>一般为<span class="title">nil</span>,这样默认的<span class="title">DefaultServeMux</span>被使用.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeContent</span><span class="params">(w ResponseWriter, req *Request, name <span class="keyword">string</span>, modtime time.Time, content io.ReadSeeker)</span>//该函数使用提供的<span class="title">ReaderSeeker</span>提供的内容来恢复请求,该函数相对于<span class="title">io</span>.<span class="title">Copy</span>的优点是可以处理范围类请求,设定<span class="title">MIME</span>类型,并且处理了<span class="title">If</span>-<span class="title">Modified</span>-<span class="title">Since</span>请求.如果未设定<span class="title">content</span>-<span class="title">type</span>类型,该函数首先通过文件扩展名来判断类型,如果失效的话,读取<span class="title">content</span>的第一块数据并将他传递给<span class="title">DetectContentType</span>进行类型判断.<span class="title">name</span>可以不被使用,更进一步说,他可以为空并且不在<span class="title">respone</span>中返回.如果<span class="title">modtime</span>不是0时间,该时间则体现在<span class="title">response</span>的最后一次修改的<span class="title">header</span>中,如果请求包括一个<span class="title">If</span>-<span class="title">Modified</span>-<span class="title">Since</span> <span class="title">header</span>,该函数利用<span class="title">modtime</span>来决定是否发送该<span class="title">content</span>.该函数利用<span class="title">Seek</span>功能来决定<span class="title">content</span>的大小.</span></span><br></pre></td></tr></table></figure>

<h3 id="type-Client"><a href="#type-Client" class="headerlink" title="type Client"></a><strong>type Client</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client<span class="comment">//Client是一个http客户端,默认客户端(DefaultClient)将使用默认的发送机制的客户端.Client的Transport字段一般会含有内部状态(缓存TCP连接),因此Client类型值应尽量被重用而不是创建新的。多个协程并发使用Clients是安全的.</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Transport指定执行独立、单次HTTP请求的机制如果Transport为nil,则使用DefaultTransport。</span></span><br><span class="line">    Transport RoundTripper</span><br><span class="line">    <span class="comment">// CheckRedirect指定处理重定向的策略,如果CheckRedirect非nil,client将会在调用重定向之前调用它。</span></span><br><span class="line">    <span class="comment">// 参数req和via是将要执行的请求和已经执行的请求（时间越久的请求优先执行),如果CheckRedirect返回一个错误,</span></span><br><span class="line">　　 <span class="comment">//client的GetGet方法不会发送请求req,而是回之前得到的响应和该错误。</span></span><br><span class="line">    <span class="comment">// 如果CheckRedirect为nil，会采用默认策略：在连续10次请求后停止。</span></span><br><span class="line">    CheckRedirect <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span> <span class="title">error</span></span></span><br><span class="line">    <span class="comment">// Jar指定cookie管理器,如果Jar为nil,在请求中不会发送cookie,在回复中cookie也会被忽略。</span></span><br><span class="line">    Jar CookieJar</span><br><span class="line">    <span class="comment">// Timeout指定Client请求的时间限制,该超时限制包括连接时间、重定向和读取response body时间。</span></span><br><span class="line">    <span class="comment">// 计时器会在Head,Get,Post或Do方法返回后开始计时并在读到response.body后停止计时。</span></span><br><span class="line">　　<span class="comment">// Timeout为零值表示不设置超时。</span></span><br><span class="line">    <span class="comment">// Client的Transport字段必须支持CancelRequest方法,否则Client会在尝试用Head,Get,Post或Do方法执行请求时返回错误。</span></span><br><span class="line">    <span class="comment">// Client的Transport字段默认值（DefaultTransport）支持CancelRequest方法。</span></span><br><span class="line">    Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client的方法：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(resp *Response, err error)</span>//<span class="title">Do</span>发送<span class="title">http</span>请求并且返回一个<span class="title">http</span>响应,遵守<span class="title">client</span>的策略,如重定向,<span class="title">cookies</span>以及<span class="title">auth</span>等.错误经常是由于策略引起的,当<span class="title">err</span>是<span class="title">nil</span>时,<span class="title">resp</span>总会包含一个非<span class="title">nil</span>的<span class="title">resp</span>.<span class="title">body</span>.当调用者读完<span class="title">resp</span>.<span class="title">body</span>之后应该关闭它,如果<span class="title">resp</span>.<span class="title">body</span>没有关闭,则<span class="title">Client</span>底层<span class="title">RoundTripper</span>将无法重用存在的<span class="title">TCP</span>连接去服务接下来的请求,如果<span class="title">resp</span>.<span class="title">body</span>非<span class="title">nil</span>,则必须对其进行关闭.通常来说,经常使用<span class="title">Get</span>,<span class="title">Post</span>,或者<span class="title">PostForm</span>来替代<span class="title">Do</span>.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">//利用get方法请求指定的url.Get请求指定的页面信息，并返回实体主体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Head</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">//利用head方法请求指定的url，Head只返回页面的首部。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Post</span><span class="params">(url <span class="keyword">string</span>, bodyType <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">//利用post方法请求指定的URl,如果body也是一个io.Closer,则在请求之后关闭它</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">PostForm</span><span class="params">(url <span class="keyword">string</span>, data url.Values)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">//利用post方法请求指定的url,利用data的key和value作为请求体.</span></span><br></pre></td></tr></table></figure>

<p>http中Client客户端的参数设定解析如上面描述所示，Client具有Do，Get，Head，Post以及PostForm等方法。 其中Do方法可以对Request进行一系列的设定，而其他的对request设定较少。如果Client使用默认的Client，则其中的Get，Head，Post以及PostForm方法相当于默认的http.Get,http.Post,http.Head以及http.PostForm函数。举例说明其用法。其中Get，Head，Post以及PostForm用法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    requestUrl := <span class="string">"http://www.baidu.com"</span></span><br><span class="line">    <span class="comment">// request, err := http.Get(requestUrl)</span></span><br><span class="line">    <span class="comment">// request, err := http.Head(requestUrl)</span></span><br><span class="line">    postvalue := url.Values&#123;</span><br><span class="line">        <span class="string">"username"</span>: &#123;<span class="string">"xiaoming"</span>&#125;,</span><br><span class="line">        <span class="string">"address"</span>:  &#123;<span class="string">"beijing"</span>&#125;,</span><br><span class="line">        <span class="string">"subject"</span>:  &#123;<span class="string">"Hello"</span>&#125;,</span><br><span class="line">        <span class="string">"from"</span>:     &#123;<span class="string">"china"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// request, err := http.PostForm(requestUrl, postvalue)</span></span><br><span class="line"></span><br><span class="line">    body := bytes.NewBufferString(postvalue.Encode())</span><br><span class="line">    request, err := http.Post(requestUrl, <span class="string">"text/html"</span>, body)  <span class="comment">//Post方法</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> request.Body.Close()</span><br><span class="line">    fmt.Println(request.StatusCode)</span><br><span class="line">    <span class="keyword">if</span> request.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">        rb, err := ioutil.ReadAll(request.Body)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(rb)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(rb))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Do方法可以灵活的对request进行配置，然后进行请求。利用http.Client以及http.NewRequest来模拟请求。模拟request中带有cookie的请求。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">// "encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    request, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://www.baidu.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    cookie := &amp;http.Cookie&#123;Name: <span class="string">"userId"</span>, Value: strconv.Itoa(<span class="number">12345</span>)&#125;</span><br><span class="line"></span><br><span class="line">    request.AddCookie(cookie) <span class="comment">//request中添加cookie</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置request的header</span></span><br><span class="line">    request.Header.Set(<span class="string">"Accept"</span>, <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Accept-Charset"</span>, <span class="string">"GBK,utf-8;q=0.7,*;q=0.3"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip,deflate,sdch"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.8"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Cache-Control"</span>, <span class="string">"max-age=0"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>)</span><br><span class="line"></span><br><span class="line">    response, err := client.Do(request)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">    fmt.Println(response.StatusCode)</span><br><span class="line">    <span class="keyword">if</span> response.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">        r, err := ioutil.ReadAll(response.Body)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(r))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-CloseNotifier-接口"><a href="#type-CloseNotifier-接口" class="headerlink" title="type CloseNotifier 接口"></a><strong>type CloseNotifier 接口</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CloseNotifier<span class="comment">//该接口被ResponseWriter用来实时检测底层连接是否已经断开.如果客户端已经断开连接,该机制可以在服务端响应之前取消二者之间的长连接.</span></span><br><span class="line"><span class="keyword">type</span> CloseNotifier <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// 当客户端断开连接时,CloseNotifier接受一个通知</span></span><br><span class="line">        CloseNotify() &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CloseNotifier经常被ResponseWriter用来检测底层连接是否已经断开，举例如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    http.ServeFile(w, r, <span class="string">"test.go"</span>)</span><br><span class="line">    <span class="keyword">var</span> closenotify http.CloseNotifier</span><br><span class="line">    closenotify = w.(http.CloseNotifier)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-closenotify.CloseNotify():</span><br><span class="line">        fmt.Println(<span class="string">"cut"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Duration(<span class="number">100</span>) * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/test"</span>, Test)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-ConnState-int"><a href="#type-ConnState-int" class="headerlink" title="type ConnState int"></a><strong>type ConnState int</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ConnState <span class="comment">//表示客户端连接服务端的状态  </span></span><br><span class="line"><span class="keyword">type</span> ConnState <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>其中ConnState常用状态变量如下:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// StateNew代表一个新的连接，将要立刻发送请求。</span></span><br><span class="line">    <span class="comment">// 连接从这个状态开始，然后转变为StateAlive或StateClosed。</span></span><br><span class="line">    StateNew ConnState = <span class="literal">iota</span></span><br><span class="line">    <span class="comment">// StateActive代表一个已经读取了请求数据1到多个字节的连接。</span></span><br><span class="line">    <span class="comment">// 用于StateAlive的Server.ConnState回调函数在将连接交付给处理器之前被触发，</span></span><br><span class="line">    <span class="comment">// 等到请求被处理完后，Server.ConnState回调函数再次被触发。</span></span><br><span class="line">    <span class="comment">// 在请求被处理后，连接状态改变为StateClosed、StateHijacked或StateIdle。</span></span><br><span class="line">    StateActive</span><br><span class="line">    <span class="comment">// StateIdle代表一个已经处理完了请求、处在闲置状态、等待新请求的连接。</span></span><br><span class="line">    <span class="comment">// 连接状态可以从StateIdle改变为StateActive或StateClosed。</span></span><br><span class="line">    StateIdle</span><br><span class="line">    <span class="comment">// 代表一个被劫持的连接。这是一个终止状态，不会转变为StateClosed。</span></span><br><span class="line">    StateHijacked</span><br><span class="line">    <span class="comment">// StateClosed代表一个关闭的连接。</span></span><br><span class="line">    <span class="comment">// 这是一个终止状态。被劫持的连接不会转变为StateClosed。</span></span><br><span class="line">    StateClosed</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ConnState)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>  //状态的字符形式表示</span></span><br><span class="line">fmt.Println(http.StateActive)          <span class="comment">//active</span></span><br><span class="line">fmt.Println(http.StateActive.String()) <span class="comment">//active</span></span><br></pre></td></tr></table></figure>

<h3 id="type-Cookie-struct"><a href="#type-Cookie-struct" class="headerlink" title="type Cookie struct"></a><strong>type Cookie struct</strong></h3><p>type Cookie//常用SetCooker用来给http的请求或者http的response设置cookie  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name       <span class="keyword">string</span>  <span class="comment">//名字</span></span><br><span class="line">        Value      <span class="keyword">string</span>  <span class="comment">//值</span></span><br><span class="line">        Path       <span class="keyword">string</span>   <span class="comment">//路径</span></span><br><span class="line">        Domain     <span class="keyword">string</span>   </span><br><span class="line">        Expires    time.Time <span class="comment">//过期时间</span></span><br><span class="line">        RawExpires <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// MaxAge=0 意味着 没有'Max-Age'属性指定.</span></span><br><span class="line">        <span class="comment">// MaxAge&lt;0 意味着 立即删除cookie</span></span><br><span class="line">        <span class="comment">// MaxAge&gt;0 意味着设定了MaxAge属性,并且其单位是秒</span></span><br><span class="line">        MaxAge   <span class="keyword">int</span></span><br><span class="line">        Secure   <span class="keyword">bool</span></span><br><span class="line">        HttpOnly <span class="keyword">bool</span></span><br><span class="line">        Raw      <span class="keyword">string</span></span><br><span class="line">        Unparsed []<span class="keyword">string</span> <span class="comment">// 未解析的属性值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func (c *Cookie) String() string//该函数返回cookie的序列化结果。如果只设置了Name和Value字段，序列化结果可用于HTTP请求的Cookie头或者HTTP回复的Set-Cookie头；如果设置了其他字段，序列化结果只能用于HTTP回复的Set-Cookie头。  </p>
<p>type CookieJar//在http请求中，CookieJar管理存储和使用cookies.Cookiejar的实现必须被多协程并发使用时是安全的.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CookieJar <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// SetCookies 处理从url接收到的cookie,是否存储这个cookies取决于jar的策略和实现</span></span><br><span class="line">        SetCookies(u *url.URL, cookies []*Cookie)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cookies 返回发送到指定url的cookies</span></span><br><span class="line">        Cookies(u *url.URL) []*Cookie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Dir-string"><a href="#type-Dir-string" class="headerlink" title="type Dir string"></a><strong>type Dir string</strong></h3><p>type Dir//使用一个局限于指定目录树的本地文件系统实现一个文件系统.一个空目录被当做当前目录”.”  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Dir <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dir)</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(File, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="type-File-接口"><a href="#type-File-接口" class="headerlink" title="type File 接口"></a><strong>type File 接口</strong></h3><p>type File //File是通过FileSystem的Open方法返回的,并且能够被FileServer实现.该方法与*os.File行为表现一样.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">        io.Closer</span><br><span class="line">        io.Reader</span><br><span class="line">        Readdir(count <span class="keyword">int</span>) ([]os.FileInfo, error)</span><br><span class="line">        Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">        Stat() (os.FileInfo, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type FileSystem 接口</strong>  </p>
<p>type FileSystem//实现了对一系列指定文件的访问,其中文件路径之间通过分隔符进行分割.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FileSystem <span class="keyword">interface</span> &#123;</span><br><span class="line">        Open(name <span class="keyword">string</span>) (File, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Flusher-接口"><a href="#type-Flusher-接口" class="headerlink" title="type Flusher 接口"></a><strong>type Flusher 接口</strong></h3><p>type Flusher //responsewriters允许http控制器将缓存数据刷新入client.然而如果client是通过http代理连接服务器,这个缓存数据也可能是在整个response结束后才能到达客户端.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Flusher <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// Flush将任何缓存数据发送到client</span></span><br><span class="line">        Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Handler-接口"><a href="#type-Handler-接口" class="headerlink" title="type Handler 接口"></a><strong>type Handler 接口</strong></h3><p>type Handler //实现Handler接口的对象可以注册到HTTP服务端，为指定的路径或者子树提供服务。ServeHTTP应该将回复的header和数据写入ResponseWriter接口然后返回。返回意味着该请求已经结束，HTTP服务端可以转移向该连接上的下一个请求。  </p>
<p>//如果ServeHTTP崩溃panic,那么ServeHTTP的调用者假定这个panic的影响与活动请求是隔离的,二者互不影响.调用者恢复panic,将stack trace记录到错误日志中,然后挂起这个连接.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">        ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>func FileServer(root FileSystem) Handler // FileServer返回一个使用FileSystem接口提供文件访问服务的HTTP处理器。可以使用httpDir来使用操作系统的FileSystem接口实现。其主要用来实现静态文件的展示。  </p>
<p>func NotFoundHandler() Handler //返回一个简单的请求处理器,该处理器对任何请求都会返回”404 page not found”  </p>
<p>func RedirectHandler(url string, code int) Handler//使用给定的状态码将它接受到的任何请求都重定向到给定的url  </p>
<p>func StripPrefix(prefix string, h Handler) Handler//将请求url.path中移出指定的前缀,然后将省下的请求交给handler h来处理,对于那些不是以指定前缀开始的路径请求,该函数返回一个http 404 not found 的错误.  </p>
<p>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler //具有超时限制的handler,该函数返回的新Handler调用h中的ServerHTTP来处理每次请求,但是如果一次调用超出时间限制,那么就会返回给请求者一个503服务请求不可达的消息,并且在ResponseWriter返回超时错误.  </p>
<p>其中FileServer经常和StripPrefix一起连用，用来实现静态文件展示，举例如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">"/test/"</span>, http.FileServer(http.Dir(<span class="string">"/home/work/"</span>))) <span class="comment">///home/work/test/中必须有内容</span></span><br><span class="line">    http.Handle(<span class="string">"/download/"</span>, http.StripPrefix(<span class="string">"/download/"</span>, http.FileServer(http.Dir(<span class="string">"/home/work/"</span>))))</span><br><span class="line">    http.Handle(<span class="string">"/tmpfiles/"</span>, http.StripPrefix(<span class="string">"/tmpfiles/"</span>, http.FileServer(http.Dir(<span class="string">"/tmp"</span>)))) <span class="comment">//127.0.0.1:9999/tmpfiles/访问的本地文件/tmp中的内容</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-HandlerFunc"><a href="#type-HandlerFunc" class="headerlink" title="type HandlerFunc"></a><strong>type HandlerFunc</strong></h3><p>type HandlerFunc//HandlerFunc type是一个适配器，通过类型转换我们可以将普通的函数作为HTTP处理器使用。如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure>

<p>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) //ServeHttp调用f(w,r)  </p>
<p>type Header//代表在http header中的key-value对  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span>//将<span class="title">key</span>,<span class="title">value</span>组成键值对添加到<span class="title">header</span>中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span>  //<span class="title">header</span>中删除对应的<span class="title">key</span>-<span class="title">value</span>对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span> //获取指定<span class="title">key</span>的第一个<span class="title">value</span>,如果<span class="title">key</span>没有对应的<span class="title">value</span>,则返回"",为了获取一个<span class="title">key</span>的多个值,用<span class="title">CanonicalHeaderKey</span>来获取标准规范格式.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span> //给一个<span class="title">key</span>设定为相应的<span class="title">value</span>.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span>//利用线格式来写<span class="title">header</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">WriteSubset</span><span class="params">(w io.Writer, exclude <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> <span class="title">error</span>//利用线模式写<span class="title">header</span>,如果<span class="title">exclude</span>不为<span class="title">nil</span>,则在<span class="title">exclude</span>中包含的<span class="title">exclude</span>[<span class="title">key</span>] == <span class="title">true</span>不被写入.</span></span><br></pre></td></tr></table></figure>

<h3 id="type-Hijacker-接口"><a href="#type-Hijacker-接口" class="headerlink" title="type Hijacker 接口"></a><strong>type Hijacker 接口</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Hijacker <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// Hijack让调用者接管连接,在调用Hijack()后,http server库将不再对该连接进行处理,对于该连接的管理和关闭责任将由调用者接管.</span></span><br><span class="line">        Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="comment">//conn表示连接对象，bufrw代表该连接的读写缓存对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HiJack</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    hj, ok := w.(http.Hijacker)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        http.Error(w, <span class="string">"webserver doesn't support hijacking"</span>, http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn, bufrw, err := hj.Hijack()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    bufrw.WriteString(<span class="string">"Now we're speaking raw TCP. Say hi: \n"</span>)</span><br><span class="line">    bufrw.Flush()</span><br><span class="line"></span><br><span class="line">    fmt.Fprintf(bufrw, <span class="string">"You said: %s Bye.\n"</span>, <span class="string">"Good"</span>)</span><br><span class="line">    bufrw.Flush()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/hijack"</span>, HiJack)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-ProtocolError"><a href="#type-ProtocolError" class="headerlink" title="type ProtocolError"></a><strong>type ProtocolError</strong></h3><p>type ProtocolError //http请求解析错误  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(err *ProtocolError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="type-Reques-struct"><a href="#type-Reques-struct" class="headerlink" title="type Reques struct"></a><strong>type Reques struct</strong></h3><p>type Request//代表客户端给服务器端发送的一个请求.该字段在服务器端和客户端使用时区别很大.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Method指定HTTP方法(GET,POST,PUT等)默认使用GET方法。</span></span><br><span class="line">    Method <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// URL在服务端表示被请求的URI(uniform resource identifier,统一资源标识符)，在客户端表示要访问的URL。</span></span><br><span class="line">    <span class="comment">// 在服务端,URL字段是解析请求行的URI（保存在RequestURI字段）得到的,对大多数请求来说,除了Path和RawQuery之外的字段都是空字符串。</span></span><br><span class="line">    <span class="comment">// 在客户端,URL的Host字段指定了要连接的服务器,而Request的Host字段指定要发送的HTTP请求的Host头的值。</span></span><br><span class="line">    URL *url.URL</span><br><span class="line">    <span class="comment">// 接收到的请求的协议版本。client的Request总是使用HTTP/1.1</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// "HTTP/1.0"</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// Header字段用来表示HTTP请求的头域。如果header（多行键值对格式）为：</span></span><br><span class="line">    <span class="comment">//    accept-encoding: gzip, deflate</span></span><br><span class="line">    <span class="comment">//    Accept-Language: en-us</span></span><br><span class="line">    <span class="comment">//    Connection: keep-alive</span></span><br><span class="line">    <span class="comment">// 则：</span></span><br><span class="line">    <span class="comment">//    Header = map[string][]string&#123;</span></span><br><span class="line">    <span class="comment">//        "Accept-Encoding": &#123;"gzip, deflate"&#125;,</span></span><br><span class="line">    <span class="comment">//        "Accept-Language": &#123;"en-us"&#125;,</span></span><br><span class="line">    <span class="comment">//        "Connection": &#123;"keep-alive"&#125;,</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// HTTP规定header的键名（头名）是区分大小写的，请求的解析器通过规范化头域的键名来实现这点,即首字母大写,其他字母小写,通过"-"进行分割。</span></span><br><span class="line">    <span class="comment">// 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// Body是请求的主体.对于客户端请求来说,一个nil body意味着没有body,http Client的Transport字段负责调用Body的Close方法。</span></span><br><span class="line">    <span class="comment">// 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF.Server会关闭请求主体，而ServeHTTP处理器不需要关闭Body字段。</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// ContentLength记录相关内容的长度.如果为-1,表示长度未知,如果values&gt;=0，表示可以从Body字段读取ContentLength字节数据。</span></span><br><span class="line">    <span class="comment">// 在客户端,如果Body非nil而该字段为0,表示不知道Body的长度。</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示"identity"编码。</span></span><br><span class="line">    <span class="comment">// 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除"chunked"传输编码。</span></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接。</span></span><br><span class="line">    Close <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 对于服务器端请求,Host指定URL指向的主机,可能的格式是host:port.对于客户请求,Host用来重写请求的Host头,如过该字段为""，Request.Write方法会使用URL.Host来进行赋值。</span></span><br><span class="line">    Host <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据.本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    Form url.Values</span><br><span class="line">    <span class="comment">// PostForm是解析好的POST或PUT的表单数据.本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    PostForm url.Values</span><br><span class="line">    <span class="comment">// MultipartForm是解析好的多部件表单，包括上传的文件.本字段只有在调用ParseMultipartForm后才有效。http客户端中会忽略MultipartForm并且使用Body替代</span></span><br><span class="line">    MultipartForm *multipart.Form</span><br><span class="line">    <span class="comment">// Trailer指定了在发送请求体之后额外的headers,在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。</span></span><br><span class="line">    <span class="comment">// （客户端会声明哪些trailer会发送）在处理器从Body读取时，不能使用本字段.在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。</span></span><br><span class="line">    <span class="comment">// （如果客户端发送了这些键值对），此时才可以访问本字段。</span></span><br><span class="line">    <span class="comment">// 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射.(值可以是nil或其终值),ContentLength字段必须是0或-1，以启用"chunked"传输编码发送请求。</span></span><br><span class="line">    <span class="comment">// 在开始发送请求后,Trailer可以在读取请求主体期间被修改，一旦请求主体返回EOF，调用者就不可再修改Trailer。</span></span><br><span class="line">    <span class="comment">// 几乎没有HTTP客户端、服务端或代理支持HTTP trailer。</span></span><br><span class="line">    Trailer Header</span><br><span class="line">    <span class="comment">// RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址,该字段经常用于日志.本字段不是ReadRequest函数填写的，也没有定义格式。</span></span><br><span class="line">    <span class="comment">// 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为"IP:port"格式的地址.客户端会忽略请求中的RemoteAddr字段。</span></span><br><span class="line">    RemoteAddr <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// RequestURI是客户端发送到服务端的请求中未修改的URI(参见RFC 2616,Section 5.1),如果在http请求中设置该字段便会报错.</span></span><br><span class="line">    RequestURI <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息,本字段不是ReadRequest函数填写的。</span></span><br><span class="line">    <span class="comment">// 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。</span></span><br><span class="line">    <span class="comment">// 客户端会忽略请求中的TLS字段。</span></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>func NewRequest(method, urlStr string, body io.Reader) (*Request, error) //利用指定的method,url以及可选的body返回一个新的请求.如果body参数实现了io.Closer接口，Request返回值的Body 字段会被设置为body，并会被Client类型的Do、Post和PostForm方法以及Transport.RoundTrip方法关闭。  </p>
<p>func ReadRequest(b *bufio.Reader) (req *Request, err error)//从b中读取和解析一个请求.  </p>
<p>func (r *Request) AddCookie(c *Cookie) //给request添加cookie,AddCookie向请求中添加一个cookie.按照RFC 6265 section 5.4的规则,AddCookie不会添加超过一个Cookie头字段.这表示所有的cookie都写在同一行,用分号分隔（cookie内部用逗号分隔属性）  </p>
<p>func (r <em>Request) Cookie(name string) (</em>Cookie, error)//返回request中指定名name的cookie，如果没有发现，返回ErrNoCookie  </p>
<p>func (r <em>Request) Cookies() []</em>Cookie//返回该请求的所有cookies  </p>
<p>func (r *Request) SetBasicAuth(username, password string)//利用提供的用户名和密码给http基本权限提供具有一定权限的header。当使用http基本授权时，用户名和密码是不加密的  </p>
<p>func (r *Request) UserAgent() string//如果在request中发送，该函数返回客户端的user-Agent</p>
<p>用法eg.  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://www.baidu.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.SetBasicAuth(<span class="string">"test"</span>, <span class="string">"123456"</span>)</span><br><span class="line">    fmt.Println(req.Proto)</span><br><span class="line">    cookie := &amp;http.Cookie&#123;</span><br><span class="line">        Name:  <span class="string">"test"</span>,</span><br><span class="line">        Value: <span class="string">"12"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    req.AddCookie(cookie)                     <span class="comment">//添加cookie</span></span><br><span class="line">    fmt.Println(req.Cookie(<span class="string">"test"</span>))           <span class="comment">//获取cookie</span></span><br><span class="line">    fmt.Println(req.Cookies())                <span class="comment">//获取cookies</span></span><br><span class="line">    req.Header.Set(<span class="string">"User-Agent"</span>, <span class="string">"useragent"</span>) <span class="comment">//设定ua</span></span><br><span class="line">    fmt.Println(req.UserAgent())</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">        content, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)//对于指定格式的key，FormFile返回符合条件的第一个文件，如果有必要的话，该函数会调用ParseMultipartForm和ParseForm。  </p>
<p>func (r *Request) FormValue(key string) string//返回key获取的队列中第一个值。在查询过程中post和put中的主题参数优先级高于url中的value。为了访问相同key的多个值，调用ParseForm然后直接检查RequestForm。  </p>
<p>func (r <em>Request) MultipartReader() (</em>multipart.Reader, error)//如果这是一个有多部分组成的post请求，该函数将会返回一个MIME 多部分reader，否则的话将会返回一个nil和error。使用本函数代替ParseMultipartForm可以将请求body当做流stream来处理。  </p>
<p>func (r *Request) ParseForm() error//解析URL中的查询字符串，并将解析结果更新到r.Form字段。对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。ParseMultipartForm会自动调用ParseForm。重复调用本方法是无意义的。  </p>
<p>func (r *Request) ParseMultipartForm(maxMemory int64) error //ParseMultipartForm将请求的主体作为multipart/form-data解析。请求的整个主体都会被解析，得到的文件记录最多 maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。如果必要，ParseMultipartForm会自行调用 ParseForm。重复调用本方法是无意义的。  </p>
<p>func (r *Request) PostFormValue(key string) string//返回post或者put请求body指定元素的第一个值，其中url中的参数被忽略。  </p>
<p>func (r *Request) ProtoAtLeast(major, minor int) bool//检测在request中使用的http协议是否至少是major.minor  </p>
<p>func (r *Request) Referer() string//如果request中有refer，那么refer返回相应的url。Referer在request中是拼错的，这个错误从http初期就已经存在了。该值也可以从Headermap中利用Header[“Referer”]获取；在使用过程中利用Referer这个方法而不是map的形式的好处是在编译过程中可以检查方法的错误，而无法检查map中key的错误。  </p>
<p> func (r *Request) Write(w io.Writer) error//Write方法以有线格式将HTTP/1.1请求写入w（用于将请求写入下层TCPConn等）。本方法会考虑请求的如下字段：Host URL Method (defaults to “GET”) Header ContentLength TransferEncoding Body<br>　如果存在Body，ContentLength字段&lt;= 0且TransferEncoding字段未显式设置为[“identity”]，Write方法会显式添加”Transfer-Encoding: chunked”到请求的头域。Body字段会在发送完请求后关闭。  </p>
<p> func (r *Request) WriteProxy(w io.Writer) error//该函数与Write方法类似，但是该方法写的request是按照http代理的格式去写。尤其是，按照RFC 2616 Section 5.1.2，WriteProxy会使用绝对URI（包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，WriteProxy都会使用r.Host或r.URL.Host设置Host头。</p>
<h3 id="type-Response-struct"><a href="#type-Response-struct" class="headerlink" title="type Response struct"></a><strong>type Response struct</strong></h3><p>type Response//指对于一个http请求的响应response  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status     <span class="keyword">string</span> <span class="comment">// 例如"200 OK"</span></span><br><span class="line">    StatusCode <span class="keyword">int</span>    <span class="comment">// 例如200</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// 例如"HTTP/1.0"</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 主协议号：例如1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 副协议号：例如0</span></span><br><span class="line">    <span class="comment">// Header保管header的key values，如果response中有多个header中具有相同的key，那么Header中保存为该键对应用逗号分隔串联起来的这些头的值// 被本结构体中的其他字段复制保管的头（如ContentLength）会从Header中删掉。Header中的键都是规范化的，参见CanonicalHeaderKey函数</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// Body代表response的主体。http的client和Transport确保这个body永远非nil，即使response没有body或body长度为0。调用者也需要关闭这个body// 如果服务端采用"chunked"传输编码发送的回复，Body字段会自动进行解码。</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// ContentLength记录相关内容的长度。</span></span><br><span class="line">    <span class="comment">// 其值为-1表示长度未知（采用chunked传输编码）</span></span><br><span class="line">    <span class="comment">// 除非对应的Request.Method是"HEAD"，其值&gt;=0表示可以从Body读取的字节数</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示"identity"编码。</span></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Close记录头域是否指定应在读取完主体后关闭连接。（即Connection头）</span></span><br><span class="line">    <span class="comment">// 该值是给客户端的建议，Response.Write方法的ReadResponse函数都不会关闭连接。</span></span><br><span class="line">    Close <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Trailer字段保存和头域相同格式的trailer键值对，和Header字段相同类型</span></span><br><span class="line">    Trailer Header</span><br><span class="line">    <span class="comment">// Request是用来获取此回复的请求，Request的Body字段是nil（因为已经被用掉了）这个字段是被Client类型发出请求并获得回复后填充的</span></span><br><span class="line">    Request *Request</span><br><span class="line">    <span class="comment">// TLS包含接收到该回复的TLS连接的信息。 对未加密的回复，本字段为nil。返回的指针是被（同一TLS连接接收到的）回复共享的，不应被修改。</span></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func Get(url string) (resp *Response, err error)//利用GET方法对一个指定的URL进行请求，如果response是如下重定向中的一个代码，则Get之后将会调用重定向内容，最多10次重定向。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">301</span> (永久重定向，告诉客户端以后应该从新地址访问)</span><br><span class="line"><span class="number">302</span> (暂时性重定向，作为HTTP1<span class="number">.0</span>的标准，以前叫做Moved Temporarily，现在叫做Found。现在使用只是为了兼容性处理，包括PHP的默认Location重定向用到也是<span class="number">302</span>)，注：<span class="number">303</span>和<span class="number">307</span>其实是对<span class="number">302</span>的细化。</span><br><span class="line"><span class="number">303</span> (对于Post请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URl)</span><br><span class="line"><span class="number">307</span> (临时重定向，对于Post请求，表示请求还没有被处理，客户端应该向Location里的URL重新发起Post请求)</span><br></pre></td></tr></table></figure>

<p>//如果有太多次重定向或者有一个http协议错误将会导致错误。当err为nil时，resp总是包含一个非nil的resp.body，Get是对DefaultClient.Get的一个包装。  </p>
<p>func Head(url string) (resp *Response, err error)//该函数功能见net中Head方法功能。该方法与默认的defaultClient中Head方法一致。  </p>
<p>func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)//该方法与默认的defaultClient中Post方法一致。  </p>
<p>func PostForm(url string, data url.Values) (resp *Response, err error)//该方法与默认的defaultClient中PostForm方法一致。</p>
<p>func ReadResponse(r <em>bufio.Reader, req *Request) (</em>Response, error)//ReadResponse从r读取并返回一个HTTP 回复。req参数是可选的，指定该回复对应的请求（即是对该请求的回复）。如果是nil，将假设请 求是GET请求。客户端必须在结束resp.Body的读取后关闭它。读取完毕并关闭后，客户端可以检查resp.Trailer字段获取回复的 trailer的键值对。（本函数主要用在客户端从下层获取回复）  </p>
<p>func (r <em>Response) Cookies() []</em>Cookie//解析cookie并返回在header中利用set-Cookie设定的cookie值。  </p>
<p>func (r <em>Response) Location() (</em>url.URL, error)//返回response中Location的header值的url。如果该值存在的话，则对于请求问题可以解决相对重定向的问题，如果该值为nil，则返回ErrNOLocation的错误。  </p>
<p>func (r *Response) ProtoAtLeast(major, minor int) bool//判定在response中使用的http协议是否至少是major.minor的形式。  </p>
<p>func (r *Response) Write(w io.Writer) error//将response中信息按照线性格式写入w中。</p>
<p><strong>type ResponseWriter 接口</strong>  </p>
<p>type ResponseWriter//该接口被http handler用来构建一个http response  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Header返回一个Header类型值，该值会被WriteHeader方法发送.在调用WriteHeader或Write方法后再改变header值是不起作用的。</span></span><br><span class="line">    Header() Header</span><br><span class="line">    <span class="comment">// WriteHeader该方法发送HTTP回复的头域和状态码。如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)</span></span><br><span class="line">    <span class="comment">// 因此，显示调用WriterHeader主要用于发送错误状态码。</span></span><br><span class="line">    WriteHeader(<span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// Write向连接中写入数据，该数据作为HTTP response的一部分。如果被调用时还没有调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)</span></span><br><span class="line">    <span class="comment">// 如果Header中没有"Content-Type"键，本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值。</span></span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-RoundTripper-接口"><a href="#type-RoundTripper-接口" class="headerlink" title="type RoundTripper 接口"></a><strong>type RoundTripper 接口</strong></h3><p>type RoundTripper//该函数是一个执行简单http事务的接口，该接口在被多协程并发使用时必须是安全的。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// RoundTrip执行单次HTTP事务，返回request的response，RoundTrip不应试图解析该回复。</span></span><br><span class="line">    <span class="comment">// 尤其要注意，只要RoundTrip获得了一个回复，不管该回复的HTTP状态码如何，它必须将返回值err设置为nil。</span></span><br><span class="line">    <span class="comment">// 非nil的返回值err应该留给获取回复失败的情况。类似的，RoundTrip不能试图管理高层协议，如重定向、认证或者cookie。</span></span><br><span class="line">    <span class="comment">// RoundTrip除了从请求的主体读取并关闭主体之外，不能够对请求做任何修改，包括（请求的）错误。</span></span><br><span class="line">    <span class="comment">// RoundTrip函数接收的请求的URL和Header字段必须保证是初始化了的。</span></span><br><span class="line">    RoundTrip(*Request) (*Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func NewFileTransport(fs FileSystem) RoundTripper //该函数返回一个RoundTripper接口，服务指定的文件系统。 返回的RoundTripper接口会忽略接收的请求中的URL主机及其他绝大多数属性。该函数的典型应用是给Transport类型的值注册”file”协议。如下所示：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := &amp;http.Transport&#123;&#125;</span><br><span class="line">t.RegisterProtocol(<span class="string">"file"</span>, http.NewFileTransport(http.Dir(<span class="string">"/"</span>)))</span><br><span class="line">c := &amp;http.Client&#123;Transport: t&#125;</span><br><span class="line">res, err := c.Get(<span class="string">"file:///etc/passwd"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="type-ServeMux"><a href="#type-ServeMux" class="headerlink" title="*type ServeMux *"></a>*<em>type ServeMux *</em></h3><p>type ServeMux //该函数是一个http请求多路复用器，它将每一个请求的URL和一个注册模式的列表进行匹配，然后调用和URL最匹配的模式的处理器进行后续操作。模式是固定的、由根开始的路径，如”/favicon.ico”，或由根开始的子树，如”/images/“ （注意结尾的斜杠）。较长的模式优先于较短的模式，因此如果模式”/images/“和”/images/thumbnails/“都注册了处理器，后一 个处理器会用于路径以”/images/thumbnails/“开始的请求，前一个处理器会接收到其余的路径在”/images/“子树下的请求。<br>注意，因为以斜杠结尾的模式代表一个由根开始的子树，模式”/“会匹配所有的未被其他注册的模式匹配的路径，而不仅仅是路径”/“。  </p>
<p>模式也能（可选地）以主机名开始，表示只匹配该主机上的路径。指定主机的模式优先于一般的模式，因此一个注册了两个模式”/codesearch”和”codesearch.google.com/“的处理器不会接管目标为”<a href="http://www.google.com/&quot;的请求。" target="_blank" rel="noopener">http://www.google.com/&quot;的请求。</a>  </p>
<p>ServeMux还会负责对URL路径的过滤，将任何路径中包含”.”或”..”元素的请求重定向到等价的没有这两种元素的URL。（参见path.Clean函数）  </p>
<p>func NewServeMux() *ServeMux //初始化一个新的ServeMux  </p>
<p>func (mux *ServeMux) Handle(pattern string, handler Handler) //将handler注册为指定的模式，如果该模式已经有了handler，则会出错panic。  </p>
<p>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))//将handler注册为指定的模式</p>
<p>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) //根据指定的r.Method,r.Host以及r.RUL.Path返回一个用来处理给定请求的handler。该函数总是返回一个非nil的 handler，如果path不是一个规范格式，则handler会重定向到其规范path。Handler总是返回匹配该请求的的已注册模式；在内建重 定向处理器的情况下，pattern会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，本方法将返回一个内建的”404 page not found”处理器和一个空字符串模式。</p>
<p>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)  //该函数用于将最接近请求url模式的handler分配给指定的请求。  </p>
<p>举例说明servemux的用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"just for test!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"/home"</span>)))</span><br><span class="line">    mux.HandleFunc(<span class="string">"/test"</span>, Test)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9999"</span>, mux)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Server-struct"><a href="#type-Server-struct" class="headerlink" title="type Server struct"></a><strong>type Server struct</strong></h3><p>type Server //该结构体定义一些用来运行HTTP Server的参数，如果Server默认为0的话，那么这也是一个有效的配置。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr           <span class="keyword">string</span>        <span class="comment">// 监听的TCP地址，如果为空字符串会使用":http"</span></span><br><span class="line">    Handler        Handler       <span class="comment">// 调用的处理器，如为nil会调用http.DefaultServeMux</span></span><br><span class="line">    ReadTimeout    time.Duration <span class="comment">// 请求的读取操作在超时前的最大持续时间</span></span><br><span class="line">    WriteTimeout   time.Duration <span class="comment">// 回复的写入操作在超时前的最大持续时间</span></span><br><span class="line">    MaxHeaderBytes <span class="keyword">int</span>           <span class="comment">// 请求的头域最大长度，如为0则用DefaultMaxHeaderBytes</span></span><br><span class="line">    TLSConfig      *tls.Config   <span class="comment">// 可选的TLS配置，用于ListenAndServeTLS方法</span></span><br><span class="line">    <span class="comment">// TLSNextProto（可选地）指定一个函数来在一个NPN型协议升级出现时接管TLS连接的所有权。</span></span><br><span class="line">    <span class="comment">// 映射的键为商谈的协议名；映射的值为函数，该函数的Handler参数应处理HTTP请求，</span></span><br><span class="line">    <span class="comment">// 并且初始化Handler.ServeHTTP的*Request参数的TLS和RemoteAddr字段（如果未设置）。</span></span><br><span class="line">    <span class="comment">// 连接在函数返回时会自动关闭。</span></span><br><span class="line">    TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span></span></span><br><span class="line">    <span class="comment">// ConnState字段指定一个可选的回调函数，该函数会在一个与客户端的连接改变状态时被调用。</span></span><br><span class="line">    <span class="comment">// 参见ConnState类型和相关常数获取细节。</span></span><br><span class="line">    ConnState <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span></span></span><br><span class="line">    <span class="comment">// ErrorLog指定一个可选的日志记录器，用于记录接收连接时的错误和处理器不正常的行为。</span></span><br><span class="line">    <span class="comment">// 如果本字段为nil，日志会通过log包的标准日志记录器写入os.Stderr。</span></span><br><span class="line">    ErrorLog *log.Logger</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func (srv *Server) ListenAndServe() error//监听TCP网络地址srv.Addr然后调用Serve来处理接下来连接的请求。如果srv.Addr是空的话，则使用“:http”。  </p>
<p>func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error//ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve方法处理接收到的连接。必须提供证书文件和对应的私钥文 件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使 用”:https”。  </p>
<p>func (srv *Server) Serve(l net.Listener) error//接受Listener l的连接，创建一个新的服务协程。该服务协程读取请求然后调用srv.Handler来应答。实际上就是实现了对某个端口进行监听，然后创建相应的连接。  </p>
<p>func (s *Server) SetKeepAlivesEnabled(v bool)//该函数控制是否http的keep-alives能够使用，默认情况下，keep-alives总是可用的。只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。  </p>
<p>举例说明Server的用法：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"just for test!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newserver := http.Server&#123;</span><br><span class="line">        Addr:         <span class="string">":9992"</span>,</span><br><span class="line">        ReadTimeout:  <span class="number">0</span>,</span><br><span class="line">        WriteTimeout: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"/home"</span>)))</span><br><span class="line">    mux.HandleFunc(<span class="string">"/test"</span>, Test)</span><br><span class="line"></span><br><span class="line">    newserver.Handler = mux</span><br><span class="line">    err := newserver.ListenAndServe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="comment">// err := http.ListenAndServe(":9999", mux)</span></span><br><span class="line">    <span class="comment">// if err != nil &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Println(err)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Transport-struct"><a href="#type-Transport-struct" class="headerlink" title="type Transport struct"></a><strong>type Transport struct</strong></h3><p>type Transport  //该结构体实现了RoundTripper接口，支持HTTP，HTTPS以及HTTP代理，TranSport也能缓存连接供将来使用。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Proxy指定一个对给定请求返回代理的函数。如果该函数返回了非nil的错误值，请求的执行就会中断并返回该错误。</span></span><br><span class="line">    <span class="comment">// 如果Proxy为nil或返回nil的*URL值，将不使用代理。</span></span><br><span class="line">    Proxy <span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="params">(*url.URL, error)</span></span></span><br><span class="line">    <span class="comment">// Dial指定创建未加密TCP连接的dial函数。如果Dial为nil，会使用net.Dial。</span></span><br><span class="line">    Dial <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line">　　<span class="comment">// DialTls利用一个可选的dial函数来为非代理的https请求创建一个TLS连接。如果DialTLS为nil的话，那么使用Dial和TLSClientConfig。</span></span><br><span class="line">　　<span class="comment">//如果DialTLS被设定，那么Dial钩子不被用于HTTPS请求和TLSClientConfig并且TLSHandshakeTimeout被忽略。返回的net.conn默认已经经过了TLS握手协议。</span></span><br><span class="line">　　DialTLS <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> </span><br><span class="line">    <span class="comment">// TLSClientConfig指定用于tls.Client的TLS配置信息。如果该字段为nil，会使用默认的配置信息。</span></span><br><span class="line">    TLSClientConfig *tls.Config</span><br><span class="line">    <span class="comment">// TLSHandshakeTimeout指定等待TLS握手完成的最长时间。零值表示不设置超时。</span></span><br><span class="line">    TLSHandshakeTimeout time.Duration</span><br><span class="line">    <span class="comment">// 如果DisableKeepAlives为真，不同HTTP请求之间TCP连接的重用将被阻止。</span></span><br><span class="line">    DisableKeepAlives <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 如果DisableCompression为真，会禁止Transport在请求中没有Accept-Encoding头时，</span></span><br><span class="line">    <span class="comment">// 主动添加"Accept-Encoding: gzip"头，以获取压缩数据。</span></span><br><span class="line">    <span class="comment">// 如果Transport自己请求gzip并得到了压缩后的回复，它会主动解压缩回复的主体。</span></span><br><span class="line">    <span class="comment">// 但如果用户显式的请求gzip压缩数据，Transport是不会主动解压缩的。</span></span><br><span class="line">    DisableCompression <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 如果MaxIdleConnsPerHost不为0，会控制每个主机下的最大闲置连接数目。</span></span><br><span class="line">    <span class="comment">// 如果MaxIdleConnsPerHost为0，会使用DefaultMaxIdleConnsPerHost。</span></span><br><span class="line">    MaxIdleConnsPerHost <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// ResponseHeaderTimeout指定在发送完请求（包括其可能的主体）之后，</span></span><br><span class="line">    <span class="comment">// 等待接收服务端的回复的头域的最大时间。零值表示不设置超时。</span></span><br><span class="line">    <span class="comment">// 该时间不包括读取回复主体的时间。</span></span><br><span class="line">    ResponseHeaderTimeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func (t *Transport) CancelRequest(req *Request)//通过关闭连接来取消传送中的请求。  </p>
<p>func (t *Transport) CloseIdleConnections()//关闭所有之前请求但目前处于空闲状态的连接。该方法并不中断任何正在使用的连接。  </p>
<p>func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)//RegisterProtocol注册一个新的名为scheme的协议。t会将使用scheme协议的请求转交给rt。rt有责任模拟HTTP请求的语义。RegisterProtocol可以被其他包用于提供”ftp”或”file”等协议的实现。  </p>
<p>func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)//该函数实现了RoundTripper接口，对于高层http客户端支持，例如处理cookies以及重定向，查看Get，Post以及Client类型。</p>
<hr>
<h1 id="io-ioutil-包"><a href="#io-ioutil-包" class="headerlink" title="io/ioutil 包"></a><code>io/ioutil</code> 包</h1><h2 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h2><h3 id="Discard-1"><a href="#Discard-1" class="headerlink" title="Discard"></a>Discard</h3><p>Discard 是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情并且始终成功返回。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Discard io.Writer = devNull(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="ReadAll"><a href="#ReadAll" class="headerlink" title="ReadAll"></a>ReadAll</h3><p>ReadAll 读取 r 中的所有数据，返回读取的数据和遇到的错误。<br>如果读取成功，则 err 返回 nil，而不是 EOF，因为 ReadAll 定义为读取所有数据，所以不会把 EOF 当做错误处理。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h3><p>ReadFile 读取文件中的所有数据，返回读取的数据和遇到的错误。  </p>
<p>如果读取成功，则 err 返回 nil，而不是 EOF。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h3><p>WriteFile 向文件中写入数据，写入前会清空文件。  </p>
<p>如果文件不存在，则会以指定的权限创建该文件。  </p>
<p>返回遇到的错误。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ReadDir"><a href="#ReadDir" class="headerlink" title="ReadDir"></a>ReadDir</h3><p>ReadDir 读取指定目录中的所有目录和文件（不包括子目录）。  </p>
<p>返回读取到的文件信息列表和遇到的错误，列表是经过排序的。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="keyword">string</span>)</span> <span class="params">([]os.FileInfo, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="NopCloser"><a href="#NopCloser" class="headerlink" title="NopCloser"></a>NopCloser</h3><p>NopCloser 将 r 包装为一个 ReadCloser 类型，但 Close 方法不做任何事情。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NopCloser</span><span class="params">(r io.Reader)</span> <span class="title">io</span>.<span class="title">ReadCloser</span></span></span><br></pre></td></tr></table></figure>

<h3 id="TempFile"><a href="#TempFile" class="headerlink" title="TempFile"></a>TempFile</h3><p>TempFile 在 dir 目录中创建一个以 prefix 为前缀的临时文件，并将其以读写模式打开。返回创建的文件对象和遇到的错误。  </p>
<p>如果 dir 为空，则在默认的临时目录中创建文件（参见 os.TempDir），多次调用会创建不同的临时文件，调用者可以通过 f.Name() 获取文件的完整路径。  </p>
<p>调用本函数所创建的临时文件，应该由调用者自己删除。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, prefix <span class="keyword">string</span>)</span> <span class="params">(f *os.File, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="TempDir"><a href="#TempDir" class="headerlink" title="TempDir"></a>TempDir</h3><p>TempDir 功能同 TempFile，只不过创建的是目录，返回目录的完整路径。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, prefix <span class="keyword">string</span>)</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>读取目录：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rd, err := ioutil.ReadDir(<span class="string">"/"</span>)</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">for</span> _, fi := <span class="keyword">range</span> rd &#123;</span><br><span class="line">        <span class="keyword">if</span> fi.IsDir() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"[%s]\n"</span>, fi.Name())</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(fi.Name())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>临时目录、临时文件：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建临时目录</span></span><br><span class="line">    dir, err := ioutil.TempDir(<span class="string">""</span>, <span class="string">"Test"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> os.Remove(dir) <span class="comment">// 用完删除</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时文件</span></span><br><span class="line">    f, err := ioutil.TempFile(dir, <span class="string">"Test"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> os.Remove(f.Name()) <span class="comment">// 用完删除</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, f.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="os-包"><a href="#os-包" class="headerlink" title="os 包"></a><code>os</code> 包</h1><h2 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h2><h3 id="获取当前目录、改变目录"><a href="#获取当前目录、改变目录" class="headerlink" title="获取当前目录、改变目录"></a>获取当前目录、改变目录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getwd</span><span class="params">()</span> <span class="params">(dir <span class="keyword">string</span>, err error)</span>    //获取当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chdir</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="title">error</span>            // 修改当前目录</span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(os.Getwd())</span><br><span class="line">  os.Chdir(<span class="string">"/Users/rtk"</span>)</span><br><span class="line">  fmt.Println(os.Getwd())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chmod</span><span class="params">(name <span class="keyword">string</span>, mode FileMode)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">eg. 将文件改为不可读：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(os.Getwd())</span><br><span class="line">  os.Chdir(<span class="string">"/Users/xujie/Desktop"</span>)</span><br><span class="line">  os.Chmod(<span class="string">"file.txt"</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取用户识别码uid-和-群组识别码gid"><a href="#获取用户识别码uid-和-群组识别码gid" class="headerlink" title="获取用户识别码uid 和 群组识别码gid"></a>获取用户识别码uid 和 群组识别码gid</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getuid</span><span class="params">()</span>  <span class="title">int</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getegid</span><span class="params">()</span>  <span class="title">int</span>  // 有效的用户识别码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Geteuid</span><span class="params">()</span> <span class="title">int</span>  // 有效的群组识别码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getgid</span><span class="params">()</span>  <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="查看用户所属组的列表"><a href="#查看用户所属组的列表" class="headerlink" title="查看用户所属组的列表"></a>查看用户所属组的列表</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getgroups</span><span class="params">()</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="返回底层系统的内存页面大小"><a href="#返回底层系统的内存页面大小" class="headerlink" title="返回底层系统的内存页面大小"></a>返回底层系统的内存页面大小</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getpagesize</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取主机名称"><a href="#获取主机名称" class="headerlink" title="获取主机名称"></a>获取主机名称</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hostname</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前进程id、父进程id"><a href="#获取当前进程id、父进程id" class="headerlink" title="获取当前进程id、父进程id"></a>获取当前进程id、父进程id</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getpid</span><span class="params">()</span>       // 获取当前进程<span class="title">id</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getppid</span><span class="params">()</span>      // 获取父进程<span class="title">id</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取文件的状态"><a href="#获取文件的状态" class="headerlink" title="获取文件的状态"></a>获取文件的状态</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  filename := <span class="string">"/Users/xujie/Desktop/file.txt"</span></span><br><span class="line">  file,_:=os.Stat(filename)</span><br><span class="line">  fmt.Println(file.Name())</span><br><span class="line">  fmt.Println(file.IsDir())</span><br><span class="line">  fmt.Println(file.Size())</span><br><span class="line">  fmt.Println(file.Mode())</span><br><span class="line">  fmt.Println(file.Sys())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err error)</span> <span class="title">bool</span>        // 文件存在,但是由系统产生错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err error)</span> <span class="title">bool</span>     // 目录或者文件不存在时返回<span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPermission</span><span class="params">(err error)</span><span class="title">bool</span>    // 检测是不是由于权限不足导致的错误</span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  filename := <span class="string">"file.txt"</span></span><br><span class="line">  _, err := os.Stat(filename);</span><br><span class="line">  fmt.Println(os.IsExist(err))</span><br><span class="line">  fmt.Println(os.IsNotExist(err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建文件夹、删除文件或文件夹"><a href="#创建文件夹、删除文件或文件夹" class="headerlink" title="创建文件夹、删除文件或文件夹"></a>创建文件夹、删除文件或文件夹</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span>   // 删除文件夹下所有文件</span></span><br></pre></td></tr></table></figure>

<h3 id="修改文件夹或文件的名称"><a href="#修改文件夹或文件的名称" class="headerlink" title="修改文件夹或文件的名称"></a>修改文件夹或文件的名称</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="移动文件夹或文件"><a href="#移动文件夹或文件" class="headerlink" title="移动文件夹或文件"></a>移动文件夹或文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法创建文件是默认的权限为0666,如果已经存在同名的文件,则调用此方法,会覆盖掉原来的文件  </p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span></span><br></pre></td></tr></table></figure>
<p>如果打开的文件不存在,则会返回错误 <code>open file1.txt: no such file or directory</code>  </p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>要注意的是，os.open() 打开的文件是只读的，写入不成功，需要：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span></span><br><span class="line"></span><br><span class="line">第二个参数</span><br><span class="line">O_RDONLY    打开只读文件</span><br><span class="line">O_WRONLY    打开只写文件</span><br><span class="line">O_RDWR  打开既可以读取又可以写入文件</span><br><span class="line">O_APPEND    写入文件时将数据追加到文件尾部</span><br><span class="line">O_CREATE    如果文件不存在，则创建一个新的文件</span><br><span class="line">O_EXCL  文件必须不存在，然后会创建一个新的文件</span><br><span class="line">O_SYNC  打开同步I/<span class="number">0</span></span><br><span class="line">O_TRUNC 文件打开时可以截断</span><br><span class="line"></span><br><span class="line">第三个参数就是权限模式</span><br></pre></td></tr></table></figure>
<p>例子：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 进入桌面目录</span></span><br><span class="line">  os.Chdir(<span class="string">"/Users/xujie/Desktop"</span>)</span><br><span class="line">  <span class="comment">// 创建一个文件夹</span></span><br><span class="line"> file,error:= os.OpenFile(<span class="string">"file.txt"</span>,os.O_RDWR,<span class="number">0666</span>)</span><br><span class="line"> <span class="comment">// 如果是要追加内容：</span></span><br><span class="line"> <span class="comment">// file,error:= os.OpenFile("file.txt",os.O_RDWR|os.O_APPEND,0666)</span></span><br><span class="line"> <span class="keyword">defer</span> file.Close()</span><br><span class="line"> <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line"> &#125;</span><br><span class="line"> _,error = file.WriteString(<span class="string">"你好"</span>)</span><br><span class="line">  _,error = file.WriteString(<span class="string">"从天有一个书"</span>)</span><br><span class="line">  fmt.Println(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 进入桌面目录</span></span><br><span class="line">  os.Chdir(<span class="string">"/Users/xujie/Desktop"</span>)</span><br><span class="line"> file,error:= os.Open(<span class="string">"file.txt"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">defer</span> file.Close()</span><br><span class="line"> <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line">  fileInfo,_ := file.Stat()</span><br><span class="line">  fmt.Println(fileInfo.Size())</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建缓冲区</span></span><br><span class="line"> data := <span class="built_in">make</span>([]<span class="keyword">byte</span>,fileInfo.Size())</span><br><span class="line"> <span class="comment">// 一次性读取所有内容到缓冲区中</span></span><br><span class="line"> _,error = file.Read(data)</span><br><span class="line"></span><br><span class="line"> fmt.Println(error)</span><br><span class="line"> fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure>

<h3 id="检测文件是否是同一个"><a href="#检测文件是否是同一个" class="headerlink" title="检测文件是否是同一个"></a>检测文件是否是同一个</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SameFile</span><span class="params">(fi1, fi2 FileInfo)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<p>就算是同一个文件,没在同一个路径下也会返回false，判断依据如下<br>这意味着两个基础结构的 inode 字段是相同的  </p>
<h3 id="获取文件模式相关信息"><a href="#获取文件模式相关信息" class="headerlink" title="获取文件模式相关信息"></a>获取文件模式相关信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m FileMode)</span> <span class="title">IsDir</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m FileMode)</span> <span class="title">IsRegular</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m FileMode)</span> <span class="title">Perm</span><span class="params">()</span> <span class="title">FileMode</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m FileMode)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fileInfo1,_:= os.Stat(<span class="string">"/Users/xujie/Desktop/DataParser.zip"</span>)</span><br><span class="line">  fmt.Println(fileInfo1.Mode().String())</span><br><span class="line">  fmt.Println(fileInfo1.Mode().IsRegular())</span><br><span class="line">  fmt.Println(fileInfo1.Mode().IsDir())</span><br><span class="line">  fmt.Println(fileInfo1.Mode().Perm())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="把文件所在的目录切换为当前目录"><a href="#把文件所在的目录切换为当前目录" class="headerlink" title="把文件所在的目录切换为当前目录"></a>把文件所在的目录切换为当前目录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chdir</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="查看文件名称"><a href="#查看文件名称" class="headerlink" title="查看文件名称"></a>查看文件名称</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="如何查看所有文件夹下的所有文件和文件数量"><a href="#如何查看所有文件夹下的所有文件和文件数量" class="headerlink" title="如何查看所有文件夹下的所有文件和文件数量"></a>如何查看所有文件夹下的所有文件和文件数量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Readdir</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]FileInfo, error)</span></span></span><br><span class="line"><span class="comment">// n 表示读取目录下文件的最大数量,n &lt; 0 表示全部 </span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file,_ := os.Open(<span class="string">"/Users/xujie/Desktop/未命名文件夹"</span>)</span><br><span class="line">  files,_ := file.Readdir(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">for</span> _,f := <span class="keyword">range</span>  files &#123;</span><br><span class="line">    fmt.Println(f.Name())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件夹的下面文件的名称"><a href="#读取文件夹的下面文件的名称" class="headerlink" title="读取文件夹的下面文件的名称"></a>读取文件夹的下面文件的名称</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Readdirnames</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(names []<span class="keyword">string</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file,_ := os.Open(<span class="string">"/Users/xujie/Desktop/未命名文件夹"</span>)</span><br><span class="line">  fileNames,_ := file.Readdirnames(<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">for</span> _,name := <span class="keyword">range</span>  fileNames &#123;</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取临时陌路的文件夹路径"><a href="#获取临时陌路的文件夹路径" class="headerlink" title="获取临时陌路的文件夹路径"></a>获取临时陌路的文件夹路径</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="判断字符是否是支持的路径分隔符"><a href="#判断字符是否是支持的路径分隔符" class="headerlink" title="判断字符是否是支持的路径分隔符"></a>判断字符是否是支持的路径分隔符</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPathSeparator</span><span class="params">(c <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(os.IsPathSeparator(<span class="string">'c'</span>))</span><br><span class="line">  fmt.Println(os.IsPathSeparator(<span class="string">'\\'</span>))</span><br><span class="line">  fmt.Println(os.IsPathSeparator(<span class="string">'/'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getenv</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LookupEnv</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">//key区分大小写</span></span><br></pre></td></tr></table></figure>

<h3 id="查找指定环境变量"><a href="#查找指定环境变量" class="headerlink" title="查找指定环境变量"></a>查找指定环境变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func</span> <span class="title">Expand</span><span class="params">(s <span class="keyword">string</span>, mapping <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">string</span>) <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExpandEnv</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取文件对应的unix文件描述符"><a href="#获取文件对应的unix文件描述符" class="headerlink" title="获取文件对应的unix文件描述符"></a>获取文件对应的unix文件描述符</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Fd</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Chown修改文件的用户ID和组ID"><a href="#Chown修改文件的用户ID和组ID" class="headerlink" title="Chown修改文件的用户ID和组ID"></a>Chown修改文件的用户ID和组ID</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chown</span><span class="params">(name <span class="keyword">string</span>, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="修改文件权限-1"><a href="#修改文件权限-1" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chmod</span><span class="params">(mode FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="强制改变文件大小"><a href="#强制改变文件大小" class="headerlink" title="强制改变文件大小"></a>强制改变文件大小</h3><p>两个方法：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Truncate</span><span class="params">(name <span class="keyword">string</span>, size <span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span><span class="title">Truncate</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>减小文件大小会造成内容丢失。  </p>
<h3 id="链接-硬链接"><a href="#链接-硬链接" class="headerlink" title="链接 硬链接"></a>链接 硬链接</h3><p>硬链接(hard link, 也称链接)就是一个文件的一个或多个文件名。再说白点，所谓链接无非是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Link</span><span class="params">(oldname, newname <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="同步保存当前文件的内容"><a href="#同步保存当前文件的内容" class="headerlink" title="同步保存当前文件的内容"></a>同步保存当前文件的内容</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Sync</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file,error := os.OpenFile(<span class="string">"/Users/xujie/Desktop/file.txt"</span>,os.O_RDWR,<span class="number">0777</span>)</span><br><span class="line">  <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line">  &#125;</span><br><span class="line">  file.WriteString(<span class="string">"新内容"</span>)</span><br><span class="line">  file.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewFile使用给出的Unix文件描述符和名称创建一个文件"><a href="#NewFile使用给出的Unix文件描述符和名称创建一个文件" class="headerlink" title="NewFile使用给出的Unix文件描述符和名称创建一个文件"></a>NewFile使用给出的Unix文件描述符和名称创建一个文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Lstat返回一个描述name指定的文件对象的FileInfo"><a href="#Lstat返回一个描述name指定的文件对象的FileInfo" class="headerlink" title="Lstat返回一个描述name指定的文件对象的FileInfo"></a>Lstat返回一个描述name指定的文件对象的FileInfo</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lstat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(fi FileInfo, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Lstat返回一个描述name指定的文件对象的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接的信息，本函数不会试图跳转该链接。如果出错，返回的错误值为*PathError类型   </p>
<h3 id="查看所有环境变量、清除环境变量"><a href="#查看所有环境变量、清除环境变量" class="headerlink" title="查看所有环境变量、清除环境变量"></a>查看所有环境变量、清除环境变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Environ</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Clearenv</span><span class="params">()</span> []<span class="title">string</span>  //慎用！！</span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前程序可执行的文件地址"><a href="#获取当前程序可执行的文件地址" class="headerlink" title="获取当前程序可执行的文件地址"></a>获取当前程序可执行的文件地址</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Executable</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="让程序已给定的状态码退出"><a href="#让程序已给定的状态码退出" class="headerlink" title="让程序已给定的状态码退出"></a>让程序已给定的状态码退出</h3><p>Exit让当前程序以给出的状态码code退出。一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exit</span><span class="params">(code <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="设置环和取消环境变量"><a href="#设置环和取消环境变量" class="headerlink" title="设置环和取消环境变量"></a>设置环和取消环境变量</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unsetenv</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setenv</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Setenv(<span class="string">"TMPDIR"</span>, <span class="string">"/my/tmp"</span>)</span><br><span class="line">    <span class="keyword">defer</span> os.Unsetenv(<span class="string">"TMPDIR"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建软链接"><a href="#创建软链接" class="headerlink" title="创建软链接"></a>创建软链接</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">软连接和硬链接的区别</a>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Symlink</span><span class="params">(oldname, newname <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取软链接文件对应的实际文件路径地址"><a href="#获取软链接文件对应的实际文件路径地址" class="headerlink" title="获取软链接文件对应的实际文件路径地址"></a>获取软链接文件对应的实际文件路径地址</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Readlink</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="更改指定文件的访问和修改时间"><a href="#更改指定文件的访问和修改时间" class="headerlink" title="更改指定文件的访问和修改时间"></a>更改指定文件的访问和修改时间</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chtimes</span><span class="params">(name <span class="keyword">string</span>, atime time.Time, mtime time.Time)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>第二个参数访问时间 第三个参数修改时间  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">os.Chtimes(<span class="string">"/Users/xujie/Desktop/file.txt"</span>,time.Now(),time.Now().Add(time.Hour * <span class="number">24</span>))</span><br></pre></td></tr></table></figure>

<h3 id="创建文件夹-并设置权限"><a href="#创建文件夹-并设置权限" class="headerlink" title="创建文件夹,并设置权限"></a>创建文件夹,并设置权限</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(path <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>规则：  </p>
<ul>
<li>如果已经存在同名文件夹,则此方法不做任何事情</li>
<li>文件夹里面所有文件都是同样的权限</li>
</ul>
<h3 id="设置文章的读写位置"><a href="#设置文章的读写位置" class="headerlink" title="设置文章的读写位置"></a>设置文章的读写位置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Seek设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> file,error := os.Open(<span class="string">"/Users/xujie/Desktop/file.txt"</span>)</span><br><span class="line"> <span class="keyword">defer</span>  file.Close()</span><br><span class="line"> <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> offset := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"> data := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10</span>)</span><br><span class="line"> totalData := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// 设置偏移量 </span></span><br><span class="line">  file.Seek(offset,<span class="number">0</span>)</span><br><span class="line">  offset += <span class="number">10</span></span><br><span class="line">  <span class="comment">// 读取数据</span></span><br><span class="line">  _,error = file.Read(data)</span><br><span class="line">   <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">     fmt.Println(error)</span><br><span class="line">     <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 拼接数据</span></span><br><span class="line">  totalData = <span class="built_in">append</span>(totalData,data...)</span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"> &#125;</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(totalData))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file.Seek(offset,0) offset = 0</code> 从文件中读取10个数据,之后偏移量设置为offset = 10,则从文件内容第11个字节开始读取，当Read方法读取文件到结尾时,会返回EOF标识,这个时候程序退出for循环  </p>
<h3 id="修改文件权限-2"><a href="#修改文件权限-2" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lchown</span><span class="params">(name <span class="keyword">string</span>, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="管道的用法"><a href="#管道的用法" class="headerlink" title="管道的用法"></a>管道的用法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span> <span class="params">(r *File, w *File, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法主要在协程之间进行数据传递，r.read 方法会等待接受w文件中写数据  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r,w,error := os.Pipe()</span><br><span class="line">  <span class="keyword">go</span> write(w)</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1000</span>)</span><br><span class="line">  <span class="comment">// 如果数据没有写入w中,则此方法一直在等待</span></span><br><span class="line">  n,_ := r.Read(data)</span><br><span class="line">  <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"读取数据："</span>)</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(data[:n]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(w *os.File)</span></span>&#123;</span><br><span class="line">  time.AfterFunc(time.Second* <span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     w.WriteString(<span class="string">"ABCD"</span>)</span><br><span class="line">     w.WriteString(<span class="string">"EFGH"</span>)</span><br><span class="line">     fmt.Println(<span class="string">"数据已写入w"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建系统错误"><a href="#创建系统错误" class="headerlink" title="创建系统错误"></a>创建系统错误</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSyscallError</span><span class="params">(syscall <span class="keyword">string</span>, err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="通过pid查找进行进程"><a href="#通过pid查找进行进程" class="headerlink" title="通过pid查找进行进程"></a>通过pid查找进行进程</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindProcess</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="params">(*Process, error)</span></span></span><br></pre></td></tr></table></figure>
<p>查找增加运行的进程,但是在 Unix 系统上，无论过程是否存在，FindProcess 都会成功并为给定的 PID 返回一个 Process  </p>
<h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Process)</span> <span class="title">Kill</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> pid := os.Getpid()</span><br><span class="line"> process,error := os.FindProcess(pid)</span><br><span class="line"> <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line"> &#125;</span><br><span class="line"> process.Kill()</span><br><span class="line"> <span class="comment">// 进行杀死 下面就不会执行了</span></span><br><span class="line"> fmt.Println(pid)</span><br><span class="line"> fmt.Println(process)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放与进程p关联的任何资源"><a href="#释放与进程p关联的任何资源" class="headerlink" title="释放与进程p关联的任何资源"></a>释放与进程p关联的任何资源</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Process)</span> <span class="title">Release</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Release释放进程p绑定的所有资源， 使它们（资源）不能再被（进程p）使用。只有没有调用Wait方法时才需要调用本方法  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Process)</span> <span class="title">Signal</span><span class="params">(sig Signal)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Process)</span> <span class="title">Wait</span><span class="params">()</span> <span class="params">(ProcessState, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">Exited</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">Pid</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">Success</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">Sys</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">SysUsage</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">SystemTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">UserTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyscallError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="runtime-包"><a href="#runtime-包" class="headerlink" title="runtime 包"></a><code>runtime</code> 包</h1><p>runtime 包 提供了运行时与系统的交互,比如控制协程函数，触发垃圾立即回收等等底层操作  </p>
<h2 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h2><h3 id="获取GO的信息"><a href="#获取GO的信息" class="headerlink" title="获取GO的信息"></a>获取GO的信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOROOT</span><span class="params">()</span> <span class="title">string</span>    // 获取<span class="title">GOROOT</span>环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Version</span><span class="params">()</span> <span class="title">string</span>   // 获取<span class="title">GO</span>的版本号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumCPU</span><span class="params">()</span> <span class="title">int</span>       // 获取本机逻辑<span class="title">CPU</span>个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span>  // 设置最大可同时执行的最大<span class="title">CPU</span>数</span></span><br><span class="line"><span class="comment">// 设置可同时执行的最大CPU数，并返回先前的设置。 </span></span><br><span class="line"><span class="comment">// 若 n &lt; 1，它就不会更改当前设置。</span></span><br></pre></td></tr></table></figure>

<h3 id="设置cpu-profile记录的速率"><a href="#设置cpu-profile记录的速率" class="headerlink" title="设置cpu profile记录的速率"></a>设置cpu profile记录的速率</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCPUProfileRate</span><span class="params">(hz <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>SetCPUProfileRate设置CPU profile记录的速率为平均每秒hz次。如果hz&lt;=0，SetCPUProfileRate会关闭profile的记录。如果记录器在执行，该速率必须在关闭之后才能修改。  </p>
<p>绝大多数使用者应使用runtime/pprof包或testing包的-test.cpuprofile选项而非直接使用SetCPUProfileRate  </p>
<h3 id="立即执行一次垃圾回收"><a href="#立即执行一次垃圾回收" class="headerlink" title="立即执行一次垃圾回收"></a>立即执行一次垃圾回收</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="给变量绑定方法，当垃圾回收的时候进行监听"><a href="#给变量绑定方法，当垃圾回收的时候进行监听" class="headerlink" title="给变量绑定方法，当垃圾回收的时候进行监听"></a>给变量绑定方法，当垃圾回收的时候进行监听</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFinalizer</span><span class="params">(x, f <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>注意x必须是指针类型,f 函数的参数一定要和x保持一致,或者写interface{},不然程序会报错  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i *Student = <span class="built_in">new</span>(Student)</span><br><span class="line">  runtime.SetFinalizer(i, <span class="function"><span class="keyword">func</span><span class="params">(i *Student)</span></span> &#123;</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"垃圾回收了"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  runtime.GC()</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看内存申请和分配统计信息"><a href="#查看内存申请和分配统计信息" class="headerlink" title="查看内存申请和分配统计信息"></a>查看内存申请和分配统计信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadMemStats</span><span class="params">(m *MemStats)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemStats <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 一般统计</span></span><br><span class="line">    Alloc      <span class="keyword">uint64</span> <span class="comment">// 已申请且仍在使用的字节数</span></span><br><span class="line">    TotalAlloc <span class="keyword">uint64</span> <span class="comment">// 已申请的总字节数（已释放的部分也算在内）</span></span><br><span class="line">    Sys        <span class="keyword">uint64</span> <span class="comment">// 从系统中获取的字节数（下面XxxSys之和）</span></span><br><span class="line">    Lookups    <span class="keyword">uint64</span> <span class="comment">// 指针查找的次数</span></span><br><span class="line">    Mallocs    <span class="keyword">uint64</span> <span class="comment">// 申请内存的次数</span></span><br><span class="line">    Frees      <span class="keyword">uint64</span> <span class="comment">// 释放内存的次数</span></span><br><span class="line">    <span class="comment">// 主分配堆统计</span></span><br><span class="line">    HeapAlloc    <span class="keyword">uint64</span> <span class="comment">// 已申请且仍在使用的字节数</span></span><br><span class="line">    HeapSys      <span class="keyword">uint64</span> <span class="comment">// 从系统中获取的字节数</span></span><br><span class="line">    HeapIdle     <span class="keyword">uint64</span> <span class="comment">// 闲置span中的字节数</span></span><br><span class="line">    HeapInuse    <span class="keyword">uint64</span> <span class="comment">// 非闲置span中的字节数</span></span><br><span class="line">    HeapReleased <span class="keyword">uint64</span> <span class="comment">// 释放到系统的字节数</span></span><br><span class="line">    HeapObjects  <span class="keyword">uint64</span> <span class="comment">// 已分配对象的总个数</span></span><br><span class="line">    <span class="comment">// L低层次、大小固定的结构体分配器统计，Inuse为正在使用的字节数，Sys为从系统获取的字节数</span></span><br><span class="line">    StackInuse  <span class="keyword">uint64</span> <span class="comment">// 引导程序的堆栈</span></span><br><span class="line">    StackSys    <span class="keyword">uint64</span></span><br><span class="line">    MSpanInuse  <span class="keyword">uint64</span> <span class="comment">// mspan结构体</span></span><br><span class="line">    MSpanSys    <span class="keyword">uint64</span></span><br><span class="line">    MCacheInuse <span class="keyword">uint64</span> <span class="comment">// mcache结构体</span></span><br><span class="line">    MCacheSys   <span class="keyword">uint64</span></span><br><span class="line">    BuckHashSys <span class="keyword">uint64</span> <span class="comment">// profile桶散列表</span></span><br><span class="line">    GCSys       <span class="keyword">uint64</span> <span class="comment">// GC元数据</span></span><br><span class="line">    OtherSys    <span class="keyword">uint64</span> <span class="comment">// 其他系统申请</span></span><br><span class="line">    <span class="comment">// 垃圾收集器统计</span></span><br><span class="line">    NextGC       <span class="keyword">uint64</span> <span class="comment">// 会在HeapAlloc字段到达该值（字节数）时运行下次GC</span></span><br><span class="line">    LastGC       <span class="keyword">uint64</span> <span class="comment">// 上次运行的绝对时间（纳秒）</span></span><br><span class="line">    PauseTotalNs <span class="keyword">uint64</span></span><br><span class="line">    PauseNs      [<span class="number">256</span>]<span class="keyword">uint64</span> <span class="comment">// 近期GC暂停时间的循环缓冲，最近一次在[(NumGC+255)%256]</span></span><br><span class="line">    NumGC        <span class="keyword">uint32</span></span><br><span class="line">    EnableGC     <span class="keyword">bool</span></span><br><span class="line">    DebugGC      <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 每次申请的字节数的统计，61是C代码中的尺寸分级数</span></span><br><span class="line">    BySize [<span class="number">61</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        Size    <span class="keyword">uint32</span></span><br><span class="line">        Mallocs <span class="keyword">uint64</span></span><br><span class="line">        Frees   <span class="keyword">uint64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看程序"><a href="#查看程序" class="headerlink" title="查看程序"></a>查看程序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MemProfileRecord)</span> <span class="title">InUseBytes</span><span class="params">()</span> <span class="title">int64</span>   // <span class="title">InUseBytes</span>返回正在使用的字节数（<span class="title">AllocBytes</span> – <span class="title">FreeBytes</span>）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MemProfileRecord)</span> <span class="title">InUseObjects</span><span class="params">()</span> <span class="title">int64</span> //<span class="title">InUseObjects</span>返回正在使用的对象数（<span class="title">AllocObjects</span> - <span class="title">FreeObjects</span>）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MemProfileRecord)</span> <span class="title">Stack</span><span class="params">()</span> []<span class="title">uintptr</span>    // <span class="title">Stack</span>返回关联至此记录的调用栈踪迹，即<span class="title">r</span>.<span class="title">Stack0</span>的前缀。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MemProfile</span><span class="params">(p []MemProfileRecord, inuseZero <span class="keyword">bool</span>)</span> <span class="params">(n <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 获取内存profile记录历史</span></span><br></pre></td></tr></table></figure>
<p>MemProfile返回当前内存profile中的记录数n。若len(p)&gt;=n，MemProfile会将此分析报告复制到p中并返回(n, true)；如果len(p)&lt; n，MemProfile则不会更改p，而只返回(n, false)。  </p>
<p>如果inuseZero为真，该profile就会包含无效分配记录（其中r.AllocBytes&gt;0，而r.AllocBytes==r.FreeBytes。这些内存都是被申请后又释放回运行时环境的）。  </p>
<p>大多数调用者应当使用runtime/pprof包或testing包的-test.memprofile标记，而非直接调用MemProfile  </p>
<h3 id="执行一个断点"><a href="#执行一个断点" class="headerlink" title="执行一个断点"></a>执行一个断点</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Breakpoint</span><span class="params">()</span></span></span><br><span class="line">runtime.Breakpoint()</span><br></pre></td></tr></table></figure>

<h3 id="获取程序调用go协程的栈踪迹历史"><a href="#获取程序调用go协程的栈踪迹历史" class="headerlink" title="获取程序调用go协程的栈踪迹历史"></a>获取程序调用go协程的栈踪迹历史</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stack</span><span class="params">(buf []<span class="keyword">byte</span>, all <span class="keyword">bool</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>Stack将调用其的go程的调用栈踪迹格式化后写入到buf中并返回写入的字节数。若all为true，函数会在写入当前go程的踪迹信息后，将其它所有go程的调用栈踪迹都格式化写入到buf中。  </p>
<h3 id="获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号"><a href="#获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号" class="headerlink" title="获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号"></a>获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Caller</span><span class="params">(skip <span class="keyword">int</span>)</span> <span class="params">(pc <span class="keyword">uintptr</span>, file <span class="keyword">string</span>, line <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pc,file,line,ok := runtime.Caller(<span class="number">0</span>)</span><br><span class="line">  fmt.Println(pc)</span><br><span class="line">  fmt.Println(file)</span><br><span class="line">  fmt.Println(line)</span><br><span class="line">  fmt.Println(ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取与当前堆栈记录相关链的调用栈踪迹"><a href="#获取与当前堆栈记录相关链的调用栈踪迹" class="headerlink" title="获取与当前堆栈记录相关链的调用栈踪迹"></a>获取与当前堆栈记录相关链的调用栈踪迹</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Callers</span><span class="params">(skip <span class="keyword">int</span>, pc []<span class="keyword">uintptr</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>函数把当前go程调用栈上的调用栈标识符填入切片pc中，返回写入到pc中的项数。实参skip为开始在pc中记录之前所要跳过的栈帧数，0表示Callers自身的调用栈，1表示Callers所在的调用栈。返回写入p的项数。  </p>
<h3 id="获取一个标识调用栈标识符pc对应的调用栈"><a href="#获取一个标识调用栈标识符pc对应的调用栈" class="headerlink" title="获取一个标识调用栈标识符pc对应的调用栈"></a>获取一个标识调用栈标识符pc对应的调用栈</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> *<span class="title">Func</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span>    // 获取调用栈所调用的函数的名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">FileLine</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> <span class="params">(file <span class="keyword">string</span>, line <span class="keyword">int</span>)</span></span>     </span><br><span class="line"><span class="comment">// 获取调用栈所调用的函数的所在的源文件名和行号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">Entry</span><span class="params">()</span> <span class="title">uintptr</span>  // 获取该调用栈的调用栈标识符</span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前进程执行的cgo调用次数"><a href="#获取当前进程执行的cgo调用次数" class="headerlink" title="获取当前进程执行的cgo调用次数"></a>获取当前进程执行的cgo调用次数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumCgoCall</span><span class="params">()</span> <span class="title">int64</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前存在的go协程数"><a href="#获取当前存在的go协程数" class="headerlink" title="获取当前存在的go协程数"></a>获取当前存在的go协程数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumGoroutine</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="终止掉当前的go协程"><a href="#终止掉当前的go协程" class="headerlink" title="终止掉当前的go协程"></a>终止掉当前的go协程</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>Goexit终止调用它的go协程,其他协程不受影响,Goexit会在终止该go协程前执行所有的defer函数，前提是defer必须在它前面定义,如果在main go协程调用本方法,会终止该go协程,但不会让main返回,因为main函数没有返回,程序会继续执行其他go协程,当其他go协程执行完毕后,程序就会崩溃.  </p>
<h3 id="让其他go协程优先执行-等其他协程执行完后-在执行当前的协程"><a href="#让其他go协程优先执行-等其他协程执行完后-在执行当前的协程" class="headerlink" title="让其他go协程优先执行,等其他协程执行完后,在执行当前的协程"></a>让其他go协程优先执行,等其他协程执行完后,在执行当前的协程</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取活跃的go协程的堆栈profile以及记录个数"><a href="#获取活跃的go协程的堆栈profile以及记录个数" class="headerlink" title="获取活跃的go协程的堆栈profile以及记录个数"></a>获取活跃的go协程的堆栈profile以及记录个数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoroutineProfile</span><span class="params">(p []StackRecord)</span> <span class="params">(n <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程"><a href="#将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程" class="headerlink" title="将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程"></a>将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LockOSThread</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>将调用的go程绑定到它当前所在的操作系统线程。除非调用的go程退出或调用UnlockOSThread，否则它将总是在该线程中执行，而其它go程则不能进入该线程  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnlockOSThread</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 解除go协程与操作系统线程的绑定关系</span></span><br></pre></td></tr></table></figure>
<p>将调用的go程解除和它绑定的操作系统线程。若调用的go程未调用LockOSThread，UnlockOSThread不做操作  </p>
<h3 id="获取线程创建profile中的记录个数"><a href="#获取线程创建profile中的记录个数" class="headerlink" title="获取线程创建profile中的记录个数"></a>获取线程创建profile中的记录个数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ThreadCreateProfile</span><span class="params">(p []StackRecord)</span> <span class="params">(n <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>返回线程创建profile中的记录个数。如果len(p)&gt;=n，本函数就会将profile中的记录复制到p中并返回(n, true)。若len(p)&lt; n，则不会更改p，而只返回(n, false)。  </p>
<p>绝大多数使用者应当使用runtime/pprof包，而非直接调用ThreadCreateProfile。  </p>
<h3 id="控制阻塞profile记录go协程阻塞事件的采样率"><a href="#控制阻塞profile记录go协程阻塞事件的采样率" class="headerlink" title="控制阻塞profile记录go协程阻塞事件的采样率"></a>控制阻塞profile记录go协程阻塞事件的采样率</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetBlockProfileRate</span><span class="params">(rate <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>SetBlockProfileRate控制阻塞profile记录go程阻塞事件的采样频率。对于一个阻塞事件，平均每阻塞rate纳秒，阻塞profile记录器就采集一份样本。  </p>
<p>要在profile中包括每一个阻塞事件，需传入rate=1；要完全关闭阻塞profile的记录，需传入rate&lt;=0。  </p>
<h3 id="返回当前阻塞profile中的记录个数"><a href="#返回当前阻塞profile中的记录个数" class="headerlink" title="返回当前阻塞profile中的记录个数"></a>返回当前阻塞profile中的记录个数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BlockProfile</span><span class="params">(p []BlockProfileRecord)</span> <span class="params">(n <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>BlockProfile返回当前阻塞profile中的记录个数。如果len(p)&gt;=n，本函数就会将此profile中的记录复制到p中并返回(n, true)。如果len(p)&lt; ，本函数则不会修改p，而只返回(n, false)。  </p>
<p>绝大多数使用者应当使用runtime/pprof包或testing包的-test.blockprofile标记， 而非直接调用 BlockProfile。  </p>
<hr>
<h1 id="sort-包"><a href="#sort-包" class="headerlink" title="sort 包"></a><code>sort</code> 包</h1><p>sort包中实现了３种基本的排序算法：插入排序．快排和堆排序．和其他语言中一样，这三种方式都是不公开的，他们只在sort包内部使用．所以用户在使用sort包进行排序时无需考虑使用那种排序方式，sort.Interface定义的三个方法：获取数据集合长度的Len()方法、比较两个元素大小的Less()方法和交换两个元素位置的Swap()方法，就可以顺利对数据集合进行排序。sort包会根据实际数据自动选择高效的排序算法。  </p>
<h2 id="type-Interface"><a href="#type-Interface" class="headerlink" title="type Interface"></a>type Interface</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">    Len() <span class="keyword">int</span>    <span class="comment">// Len 为集合内元素的总数</span></span><br><span class="line">  </span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span>　<span class="comment">//如果index为i的元素小于index为j的元素，则返回true，否则返回false</span></span><br><span class="line"></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)  <span class="comment">// Swap 交换索引为 i 和 j 的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何实现了 sort.Interface 的类型（一般为集合），均可使用该包中的方法进行排序。这些方法要求集合内列出元素的索引为整数。  </p>
<p>golang自身实现的interface有三种，Float64Slice，IntSlice，StringSlice  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义interface&#123;&#125;,并实现sort.Interface接口的三个方法</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c IntSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c[i], c[j] = c[j], c[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c[i] &lt; c[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := IntSlice&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>&#125;</span><br><span class="line">    b := []<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">5.3</span>, <span class="number">3.4</span>&#125;</span><br><span class="line">    c := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(sort.IsSorted(a)) <span class="comment">//false</span></span><br><span class="line">    <span class="keyword">if</span> !sort.IsSorted(a) &#123;</span><br><span class="line">        sort.Sort(a) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !sort.Float64sAreSorted(b) &#123;</span><br><span class="line">        sort.Float64s(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !sort.IntsAreSorted(c) &#123;</span><br><span class="line">        sort.Ints(c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a)<span class="comment">//[1 2 3 5 7]</span></span><br><span class="line">    fmt.Println(b)<span class="comment">//[1.1 2.3 3.4 5.3]</span></span><br><span class="line">    fmt.Println(c)<span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Search-二分法查找"><a href="#Search-二分法查找" class="headerlink" title="Search 二分法查找"></a>Search 二分法查找</h2><p><code>func Search(n int, f func(int) bool) int</code>  </p>
<p>使用二分法查找（常用于一个已排序、可索引的数据结构，如数组、切片），查找范围是[0:n],返回能使f(i)=true的最小i（0 &lt;= i &lt; n)，并且会假定，如果f(i)=true，则f(i+1)=true，即对于切片[0:n]，i之前的切片元素会使f()函数返回false，i及i之后的元素会使f()函数返回true。但是，当在切片中无法找到时f(i)=true的i时（此时切片元素都不能使f()函数返回true），Search()方法会返回n（而不是返回-1）。  </p>
<p>为了查找某个值，而不是某一范围的值时，如果slice以升序排序，则　f func中应该使用＞＝,如果slice以降序排序，则应该使用&lt;=。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    b := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= <span class="number">30</span> &#125;)</span><br><span class="line">    fmt.Println(b)　　　　　　　<span class="comment">//5，查找不到，返回a slice的长度５，而不是-1</span></span><br><span class="line">    c := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &lt;= <span class="number">3</span> &#125;)</span><br><span class="line">    fmt.Println(c)                             <span class="comment">//0，利用二分法进行查找，返回符合条件的最左边数值的index，即为０</span></span><br><span class="line">    d := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] == <span class="number">3</span> &#125;)</span><br><span class="line">    fmt.Println(d)                          <span class="comment">//2　　　</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></span>　　</span><br><span class="line"><span class="comment">//SearchFloat64s 在float64s切片中搜索x并返回索引如Search函数所述. 返回可以插入x值的索引位置，如果x不存在，返回数组a的长度切片必须以升序排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span>  </span><br><span class="line"><span class="comment">//SearchInts 在ints切片中搜索x并返回索引如Search函数所述. 返回可以插入x值的索引位置，如果x不存在，返回数组a的长度切片必须以升序排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">//SearchFloat64s 在strings切片中搜索x并返回索引如Search函数所述. 返回可以插入x值的索引位置，如果x不存在，返回数组a的长度切片必须以升序排列</span></span><br></pre></td></tr></table></figure>
<p>其中需要注意的是，以上三种search查找方法，其对应的slice必须按照<strong>升序</strong>进行排序，否则会出现奇怪的结果．</p>
<h2 id="Stable-排序"><a href="#Stable-排序" class="headerlink" title="Stable 排序"></a>Stable 排序</h2><p><code>func Stable(data Interface)</code> ：Stable对data进行排序，不过排序过程中，如果data中存在相等的元素，则他们原来的顺序不会改变，即如果有两个相等元素num,他们的初始index分别为i和j，并且i &lt; j，则利用Stable对data进行排序后，i依然小于ｊ．直接利用sort进行排序则不能够保证这一点．</p>
<h2 id="Reverse-逆序排序"><a href="#Reverse-逆序排序" class="headerlink" title="Reverse 逆序排序"></a>Reverse 逆序排序</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(a)        <span class="comment">// [1 2 5 3 4]</span></span><br><span class="line">    sort.Sort(sort.Reverse(sort.IntSlice(a)))</span><br><span class="line">    fmt.Println(a)        <span class="comment">// [5 4 3 2 1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="strconv-包"><a href="#strconv-包" class="headerlink" title="strconv 包"></a><code>strconv</code> 包</h1><p>与字符串相关的类型转换。<br>包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：<code>strconv.IntSize</code>。<br>任何类型 T 转换为字符串总是成功的。<br>数字 → 字符串：</p>
<ul>
<li><code>strconv.Itoa(i int) string</code> 返回数字 i 所表示的字符串类型的十进制数。  </li>
<li><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code> 将64位浮点型数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>b</code>、<code>e</code>、<code>f</code> 或 <code>g</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示 float32，用 64 表示 float64。  </li>
</ul>
<p>将字符串转换为其他类型 tp 并不总是可能的，可能会在运行时抛出错误 <code>parsing &quot;…&quot;: invalid argument</code>。<br>字符串 → 数字类型：  </p>
<ul>
<li><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 int 型。  </li>
<li><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 float64 型。  </li>
</ul>
<p>利用多个返回值的特性（第 1 个是转换后的结果（若成功），第 2 个是可能出现的错误），一般使用如下形式进行从字符串到其它类型的转换：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">val, err = strconv.Atoi(s)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="strings-包"><a href="#strings-包" class="headerlink" title="strings 包"></a><code>strings</code> 包</h1><p>Go 中使用 <code>strings</code> 包对字符串进行操作。<a href="http://docscn.studygolang.com/pkg/strings/" target="_blank" rel="noopener">中文文档</a>、 <a href="http://golang.org/pkg/strings/" target="_blank" rel="noopener">官方文档</a> 或 <a href="http://docs.studygolang.com/pkg/strings/" target="_blank" rel="noopener">国内访问文档</a>  </p>
<h2 id="前、后缀"><a href="#前、后缀" class="headerlink" title="前、后缀"></a>前、后缀</h2><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.HasSuffix(s, suffix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h2><p><code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code> :  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Contains(s, substr <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>

<p><code>func ContainsAny(s, chars string) bool</code> : 判断字符串s是否包含chars中任意一个字符，若chars为空，返回false  </p>
<p><code>func ContainsRune(s string, r rune) bool</code> : 是否包含r rune  </p>
<h2 id="索引字符串位置"><a href="#索引字符串位置" class="headerlink" title="索引字符串位置"></a>索引字符串位置</h2><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的第一次出现的索引（<code>str</code> 的第一个字符的索引），<br>返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Index(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p><code>LastIndex</code> 返回 <code>str</code> 在 <code>s</code> 中最后出现的所有（第一个字符），<br>返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.LastIndex(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>建议用 <code>IndexRune</code> 查询非 ASCII 编码的字符在字符串中的位置（返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：  ）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.IndexRune(s <span class="keyword">string</span>, r <span class="keyword">rune</span>) <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line">strings.IndexRune(<span class="string">"chicken"</span>, <span class="number">99</span>)</span><br><span class="line">strings.IndexRune(<span class="string">"chicken"</span>, <span class="keyword">rune</span>(<span class="string">'k'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并范围一个新的字符串，如果 <code>n = -1</code> 啧替换所有有 <code>old</code> 为 <code>new</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Replace(str, old, <span class="built_in">new</span>, n) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>返回的是str的副本  </p>
<h2 id="统计字符串出现的次数"><a href="#统计字符串出现的次数" class="headerlink" title="统计字符串出现的次数"></a>统计字符串出现的次数</h2><p><code>Count</code> 用于统计字符串 <code>str</code> 中字符串 <code>s</code> 出现的非重叠次数：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Count(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<h2 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h2><p><code>Repeat</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Repeat(s, count <span class="keyword">int</span>) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h2 id="修改字符串大小写"><a href="#修改字符串大小写" class="headerlink" title="修改字符串大小写"></a>修改字符串大小写</h2><p><code>ToLower</code> 将字符串中的 Unicode 字符全部转换为相应的小写字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Tolower(s) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p><code>ToUpper</code> 将字符串中的 Unicode 字符全部转换为相应的大写字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.ToUpper(s) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p><code>ToTitle</code> s 中的所有字符修改为其 Title 格式：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h2 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h2><p><code>strings.TrimSpace(s)</code> 用于剔除字符串开头和结尾的空白符号；<br><code>strings.Trim(s, &quot;cut&quot;)</code> 用于剔除字符串开头和结尾的 <code>cut</code>；<br><code>TrimLeft</code> 或者 <code>TrimRight</code> 用于只剔除开头或结尾的字符串。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>注：TrimSuffix只是去掉s字符串结尾的suffix字符串，只是去掉１次，而TrimRight是一直去掉s字符串右边的字符串，只要有响应的字符串就去掉，是一个多次的过程，这也是二者的本质区别．</p>
<h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><p><code>strings.Fields(s)</code> 会利用 1 个或多个空白符号(\t, \n, \v, \f, \r, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP))来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的空 slice。  </p>
<p><code>strings.Split(s, sep)</code> 用于自定义分割符号来对指定字符串进行分割，同样范围 slice。<br>因为这 2 个函数都会返回 slice，所以习惯使用 for - range 循环来对其进行处理。  </p>
<h2 id="拼接-slice-到字符串"><a href="#拼接-slice-到字符串" class="headerlink" title="拼接 slice 到字符串"></a>拼接 slice 到字符串</h2><p><code>Join</code> 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Join(sl [<span class="keyword">string</span>], sep <span class="keyword">string</span>) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h2 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h2><p><code>strings.NewReader(str)</code> 用于生成一个 ‘Reader’ 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其他类型读取内容的函数还有：<br><code>Read</code> 从 []byte 中读取内容；<br><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 byte 或者 rune。  </p>
<h2 id="比较两字符串字典顺序"><a href="#比较两字符串字典顺序" class="headerlink" title="比较两字符串字典顺序"></a>比较两字符串字典顺序</h2><p><code>func Compare(a, b string) int</code><br>return 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b.<br>但不常用，通常用 go 自身的 ==, &gt;, &lt; 来比较，更快更易懂。  </p>
<h2 id="忽略大小写判断s和t是否相等"><a href="#忽略大小写判断s和t是否相等" class="headerlink" title="忽略大小写判断s和t是否相等"></a>忽略大小写判断s和t是否相等</h2><p><code>func EqualFold(s, t string) bool</code></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>func Map(mapping func(rune) rune, s string) string</code> ：s 中满足 mapping(rune) 的字符替换为 mapping(rune) 的返回值。如果 mapping(rune) 返回负数，则相应的字符将被删除。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slash</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r == <span class="string">'\\'</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    s := <span class="string">"C:\\Windows\\System32\\FileName"</span></span><br><span class="line">    ms := strings.Map(Slash, s)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, ms) <span class="comment">// "C:/Windows/System32/FileName"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reader-go"><a href="#reader-go" class="headerlink" title="reader.go"></a>reader.go</h2><h3 id="Reader结构"><a href="#Reader结构" class="headerlink" title="Reader结构"></a>Reader结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reader 结构通过读取字符串，实现了 io.Reader，io.ReaderAt，</span></span><br><span class="line"><span class="comment">// io.Seeker，io.WriterTo，io.ByteScanner，io.RuneScanner 接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span> <span class="comment">// 要读取的字符串</span></span><br><span class="line">    i <span class="keyword">int</span> <span class="comment">// 当前读取的索引位置，从 i 处开始读取数据</span></span><br><span class="line">    prevRune <span class="keyword">int</span> <span class="comment">// 读取的前一个字符的索引位置，小于 0 表示之前未读取字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字符串 s 创建 strings.Reader 对象</span></span><br><span class="line"><span class="comment">// 这个函数类似于 bytes.NewBufferString</span></span><br><span class="line"><span class="comment">// 但比 bytes.NewBufferString 更有效率，而且只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span> &#123; <span class="keyword">return</span> &amp;Reader&#123;s, <span class="number">0</span>, <span class="number">-1</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Len-返回-r-i-之后的所有数据的字节长度"><a href="#Len-返回-r-i-之后的所有数据的字节长度" class="headerlink" title="Len 返回 r.i 之后的所有数据的字节长度"></a>Len 返回 r.i 之后的所有数据的字节长度</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Read-将-r-i-之后的所有数据写入到-b-中（如果-b-的容量足够大）"><a href="#Read-将-r-i-之后的所有数据写入到-b-中（如果-b-的容量足够大）" class="headerlink" title="Read 将 r.i 之后的所有数据写入到 b 中（如果 b 的容量足够大）"></a>Read 将 r.i 之后的所有数据写入到 b 中（如果 b 的容量足够大）</h3><p>返回读取的字节数和读取过程中遇到的错误<br>如果无可读数据，则返回 io.EOF  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 创建长度为 5 个字节的缓冲区</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 循环读取 r 中的字符串</span></span><br><span class="line">    <span class="keyword">for</span> n, _ := r.Read(b); n &gt; <span class="number">0</span>; n, _ = r.Read(b) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%q, "</span>, b[:n]) <span class="comment">// "Hello", " Worl", "d!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReadAt-将-off-之后的所有数据写入到-b-中（如果-b-的容量足够大）"><a href="#ReadAt-将-off-之后的所有数据写入到-b-中（如果-b-的容量足够大）" class="headerlink" title="ReadAt 将 off 之后的所有数据写入到 b 中（如果 b 的容量足够大）"></a>ReadAt 将 off 之后的所有数据写入到 b 中（如果 b 的容量足够大）</h3><p>返回读取的字节数和读取过程中遇到的错误<br>如果无可读数据，则返回 io.EOF<br>如果数据被一次性读取完毕，则返回 io.EOF  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 创建长度为 5 个字节的缓冲区</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 读取 r 中指定位置的字符串</span></span><br><span class="line">    n, _ := r.ReadAt(b, <span class="number">0</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, b[:n]) <span class="comment">// "Hello"</span></span><br><span class="line">    <span class="comment">// 读取 r 中指定位置的字符串</span></span><br><span class="line">    n, _ = r.ReadAt(b, <span class="number">6</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, b[:n]) <span class="comment">// "World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadByte-将-r-i-之后的一个字节写入到返回值-b-中"><a href="#ReadByte-将-r-i-之后的一个字节写入到返回值-b-中" class="headerlink" title="ReadByte 将 r.i 之后的一个字节写入到返回值 b 中"></a>ReadByte 将 r.i 之后的一个字节写入到返回值 b 中</h3><p>返回读取的字节和读取过程中遇到的错误<br>如果无可读数据，则返回 io.EOF  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(b <span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 读取 r 中的一个字节</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        b, _ := r.ReadByte()</span><br><span class="line">        fmt.Printf(<span class="string">"%q, "</span>, b) <span class="comment">// 'H', 'e', 'l',</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UnreadByte-撤消前一次的-ReadByte-操作，即-r-i–"><a href="#UnreadByte-撤消前一次的-ReadByte-操作，即-r-i–" class="headerlink" title="UnreadByte 撤消前一次的 ReadByte 操作，即 r.i–"></a>UnreadByte 撤消前一次的 ReadByte 操作，即 r.i–</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">UnreadByte</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 读取 r 中的一个字节</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        b, _ := r.ReadByte()</span><br><span class="line">        fmt.Printf(<span class="string">"%q, "</span>, b) <span class="comment">// 'H', 'H', 'H',</span></span><br><span class="line">        r.UnreadByte()        <span class="comment">// 撤消前一次的字节读取操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadRune-将-r-i-之后的一个字符写入到返回值-ch-中"><a href="#ReadRune-将-r-i-之后的一个字符写入到返回值-ch-中" class="headerlink" title="ReadRune 将 r.i 之后的一个字符写入到返回值 ch 中"></a>ReadRune 将 r.i 之后的一个字符写入到返回值 ch 中</h3><p>ch： 读取的字符<br>size：ch 的编码长度<br>err： 读取过程中遇到的错误<br>如果无可读数据，则返回 io.EOF<br>如果 r.i 之后不是一个合法的 UTF-8 字符编码，则返回 utf8.RuneError 字符  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadRune</span><span class="params">()</span> <span class="params">(ch <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"你好 世界！"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 读取 r 中的一个字符</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        b, n, _ := r.ReadRune()</span><br><span class="line">        fmt.Printf(<span class="string">`"%c:%v", `</span>, b, n)</span><br><span class="line">        <span class="comment">// "你:3", "好:3", " :1", "世:3", "界:3",</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="撤消前一次的-ReadRune-操作"><a href="#撤消前一次的-ReadRune-操作" class="headerlink" title="撤消前一次的 ReadRune 操作"></a>撤消前一次的 ReadRune 操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"你好 世界！"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 读取 r 中的一个字符</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        b, _, _ := r.ReadRune()</span><br><span class="line">        fmt.Printf(<span class="string">"%q, "</span>, b)</span><br><span class="line">        <span class="comment">// '你', '你', '你', '你', '你',</span></span><br><span class="line">        r.UnreadRune() <span class="comment">// 撤消前一次的字符读取操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Seek-用来移动-r-中的索引位置"><a href="#Seek-用来移动-r-中的索引位置" class="headerlink" title="Seek 用来移动 r 中的索引位置"></a>Seek 用来移动 r 中的索引位置</h3><p>offset：要移动的偏移量，负数表示反向移动<br>whence：从那里开始移动，0：起始位置，1：当前位置，2：结尾位置<br>如果 whence 不是 0、1、2，则返回错误信息<br>如果目标索引位置超出字符串范围，则返回错误信息<br>目标索引位置不能超出 1 &lt;&lt; 31，否则返回错误信息  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 创建读取缓冲区</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 读取 r 中指定位置的内容</span></span><br><span class="line">    r.Seek(<span class="number">6</span>, <span class="number">0</span>) <span class="comment">// 移动索引位置到第 7 个字节</span></span><br><span class="line">    r.Read(b)    <span class="comment">// 开始读取</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line">    r.Seek(<span class="number">-5</span>, <span class="number">1</span>) <span class="comment">// 将索引位置移回去</span></span><br><span class="line">    r.Read(b)     <span class="comment">// 继续读取</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WriteTo-将-r-i-之后的数据写入接口-w-中"><a href="#WriteTo-将-r-i-之后的数据写入接口-w-中" class="headerlink" title="WriteTo 将 r.i 之后的数据写入接口 w 中"></a>WriteTo 将 r.i 之后的数据写入接口 w 中</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 创建 bytes.Buffer 对象，它实现了 io.Writer 接口</span></span><br><span class="line">    buf := bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 将 r 中的数据写入 buf 中</span></span><br><span class="line">    r.WriteTo(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf) <span class="comment">// "Hello World!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="replace-go"><a href="#replace-go" class="headerlink" title="replace.go"></a>replace.go</h2><h3 id="Replacer-根据一个替换列表执行替换操作"><a href="#Replacer-根据一个替换列表执行替换操作" class="headerlink" title="Replacer 根据一个替换列表执行替换操作"></a>Replacer 根据一个替换列表执行替换操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Replacer <span class="keyword">struct</span> &#123;</span><br><span class="line">    Replace(s <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">    WriteString(w io.Writer, s <span class="keyword">string</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewReplacer-通过“替换列表”创建一个-Replacer-对象"><a href="#NewReplacer-通过“替换列表”创建一个-Replacer-对象" class="headerlink" title="NewReplacer 通过“替换列表”创建一个 Replacer 对象"></a>NewReplacer 通过“替换列表”创建一个 Replacer 对象</h3><p>按照“替换列表”中的顺序进行替换，只替换非重叠部分。<br>如果参数的个数不是偶数，则抛出异常。<br>如果在“替换列表”中有相同的“查找项”，则后面重复的“查找项”会被忽略  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReplacer</span><span class="params">(oldnew ...<span class="keyword">string</span>)</span> *<span class="title">Replacer</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Replace-返回对-s-进行“查找和替换”后的结果"><a href="#Replace-返回对-s-进行“查找和替换”后的结果" class="headerlink" title="Replace 返回对 s 进行“查找和替换”后的结果"></a>Replace 返回对 s 进行“查找和替换”后的结果</h3><p>Replace 使用的是 Boyer-Moore 算法，速度很快</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span> <span class="title">Replace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    srp := strings.NewReplacer(<span class="string">"Hello"</span>, <span class="string">"你好"</span>, <span class="string">"World"</span>, <span class="string">"世界"</span>, <span class="string">"!"</span>, <span class="string">"！"</span>)</span><br><span class="line">    s := <span class="string">"Hello World!Hello World!hello world!"</span></span><br><span class="line">    rst := srp.Replace(s)</span><br><span class="line">    fmt.Print(rst) <span class="comment">// 你好 世界！你好 世界！hello world！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：这两种写法均可．</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    wl := []<span class="keyword">string</span>&#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Hello"</span>, <span class="string">"你好"</span>&#125;</span><br><span class="line">    srp := strings.NewReplacer(wl...)</span><br><span class="line">    s := <span class="string">"Hello World! Hello World! hello world!"</span></span><br><span class="line">    rst := srp.Replace(s)</span><br><span class="line">    fmt.Print(rst) <span class="comment">// Hi World! Hi World! hello world!</span></span><br></pre></td></tr></table></figure>
<h3 id="WriteString-对-s-进行“查找和替换”，然后将结果写入-w-中"><a href="#WriteString-对-s-进行“查找和替换”，然后将结果写入-w-中" class="headerlink" title="WriteString 对 s 进行“查找和替换”，然后将结果写入 w 中"></a>WriteString 对 s 进行“查找和替换”，然后将结果写入 w 中</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span> <span class="title">WriteString</span><span class="params">(w io.Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wl := []<span class="keyword">string</span>&#123;<span class="string">"Hello"</span>, <span class="string">"你好"</span>, <span class="string">"World"</span>, <span class="string">"世界"</span>, <span class="string">"!"</span>, <span class="string">"！"</span>&#125;</span><br><span class="line">    srp := strings.NewReplacer(wl...)</span><br><span class="line">    s := <span class="string">"Hello World!Hello World!hello world!"</span></span><br><span class="line">    srp.WriteString(os.Stdout, s)</span><br><span class="line">    <span class="comment">// 你好 世界！你好 世界！hello world！</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a><code>sync</code> 包</h1><h2 id="临时对象池"><a href="#临时对象池" class="headerlink" title="临时对象池"></a>临时对象池</h2><p>Pool 用于存储临时对象，它将使用完毕的对象存入对象池中，在需要的时候取出来重复使用，目的是为了避免重复创建相同的对象造成 GC 负担过重。其中存放的临时对象随时可能被 GC 回收掉（如果该对象不再被其它变量引用）。  </p>
<p>从 Pool 中取出对象时，如果 Pool 中没有对象，将返回 nil，但是如果给 Pool.New 字段指定了一个函数的话，Pool 将使用该函数创建一个新对象返回。  </p>
<p>Pool 可以安全的在多个例程中并行使用，但 Pool 并不适用于所有空闲对象，Pool 应该用来管理并发的例程共享的临时对象，而不应该管理短寿命对象中的临时对象，因为这种情况下内存不能很好的分配，这些短寿命对象应该自己实现空闲列表。  </p>
<p>Pool 在开始使用之后，不能再被复制。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 创建临时对象的函数</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向临时对象池中存入对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从临时对象池中取出对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p>Once 的作用是多次调用但只执行一次，Once 只有一个方法，Once.Do()，向 Do 传入一个函数，这个函数在第一次执行 Once.Do() 的时候会被调用，以后再执行 Once.Do() 将没有任何动作，即使传入了其它的函数，也不会被执行，如果要执行其它函数，需要重新创建一个 Once 对象。  </p>
<p>Once 可以安全的在多个例程中并行使用。  </p>
<p>多次调用仅执行一次指定的函数 f：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>

<p>eg：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Only once"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            once.Do(onceBody) <span class="comment">// 多次调用只执行一次</span></span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// Only once</span></span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁用来保证在任一时刻，只能有一个例程访问某对象。Mutex 的初始值为解锁状态。Mutex 通常作为其它结构体的匿名字段使用，使该结构体具有 Lock 和 Unlock 方法。  </p>
<p>Mutex 可以安全的在多个例程中并行使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Locker 接口包装了基本的 Lock 和 UnLock 方法，用于加锁和解锁。</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock 用于锁住 m，如果 m 已经被加锁，则 Lock 将被阻塞，直到 m 被解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock 用于解锁 m，如果 m 未加锁，则该操作会引发 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>eg：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeInt <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    count := SafeInt&#123;&#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            count.Lock() <span class="comment">// 加锁，防止其它例程修改 count</span></span><br><span class="line">            count.Num += i</span><br><span class="line">            fmt.Print(count.Num, <span class="string">" "</span>)</span><br><span class="line">            count.Unlock() <span class="comment">// 修改完毕，解锁</span></span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果（不固定）：</span></span><br><span class="line"><span class="comment">// 2 11 14 18 23 29 36 44 45 45</span></span><br></pre></td></tr></table></figure>

<h2 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h2><p>RWMutex 比 Mutex 多了一个“读锁定”和“读解锁”，可以让多个例程同时读取某对象。RWMutex 的初始值为解锁状态。RWMutex 通常作为其它结构体的匿名字段使用。  </p>
<p>Mutex 可以安全的在多个例程中并行使用。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock 将 rw 设置为写锁定状态，禁止其他例程读取或写入。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock 解除 rw 的写锁定状态，如果 rw 未被写锁定，则该操作会引发 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RLock 将 rw 设置为读锁定状态，禁止其他例程写入，但可以读取。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Runlock 解除 rw 的读锁定状态，如果 rw 未被读锁顶，则该操作会引发 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RLocker 返回一个互斥锁，将 rw.RLock 和 rw.RUnlock 封装成了一个 Locker 接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLocker</span><span class="params">()</span> <span class="title">Locker</span></span></span><br></pre></td></tr></table></figure>

<h2 id="组等待"><a href="#组等待" class="headerlink" title="组等待"></a>组等待</h2><p>WaitGroup 用于等待一组例程的结束。主例程在创建每个子例程的时候先调用 Add 增加等待计数，每个子例程在结束时调用 Done 减少例程计数。之后，主例程通过 Wait 方法开始等待，直到计数器归零才继续执行。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数器增加 delta，delta 可以是负数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器减少 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待直到计数器归零。如果计数器小于 0，则该操作会引发 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>eg：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Print(i, <span class="string">" "</span>)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果（不固定）：</span></span><br><span class="line"><span class="comment">// 9 3 4 5 6 7 8 0 1 2</span></span><br></pre></td></tr></table></figure>

<h2 id="条件等待"><a href="#条件等待" class="headerlink" title="条件等待"></a>条件等待</h2><p>条件等待通过 Wait 让例程等待，通过 Signal 让一个等待的例程继续，通过 Broadcast 让所有等待的例程继续。  </p>
<p>在 Wait 之前应当手动为 c.L 上锁，Wait 结束后手动解锁。为避免虚假唤醒，需要将 Wait 放到一个条件判断循环中。官方要求的写法如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() &#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行条件满足之后的动作...</span></span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure>

<p>Cond 在开始使用之后，不能再被复制。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    L Locker <span class="comment">// 在“检查条件”或“更改条件”时 L 应该锁定。</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Broadcast 唤醒所有等待的 Wait，建议在“更改条件”时锁定 c.L，更改完毕再解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Signal 唤醒一个等待的 Wait，建议在“更改条件”时锁定 c.L，更改完毕再解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 会解锁 c.L 并进入等待状态，在被唤醒时，会重新锁定 c.L</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>eg：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    condition := <span class="literal">false</span> <span class="comment">// 条件不满足</span></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    cond := sync.NewCond(&amp;mu)</span><br><span class="line">    <span class="comment">// 让例程去创造条件</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        condition = <span class="literal">true</span> <span class="comment">// 更改条件</span></span><br><span class="line">        cond.Signal()    <span class="comment">// 发送通知：条件已经满足</span></span><br><span class="line">        mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">// 检查条件是否满足，避免虚假通知，同时避免 Signal 提前于 Wait 执行。</span></span><br><span class="line">    <span class="keyword">for</span> !condition &#123;</span><br><span class="line">        <span class="comment">// 等待条件满足的通知，如果收到虚假通知，则循环继续等待。</span></span><br><span class="line">        cond.Wait() <span class="comment">// 等待时 mu 处于解锁状态，唤醒时重新锁定。</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"条件满足，开始后续动作..."</span>)</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 条件满足，开始后续动作...</span></span><br></pre></td></tr></table></figure>


<hr>
<h1 id="time-包：时间和日期"><a href="#time-包：时间和日期" class="headerlink" title="time 包：时间和日期"></a><code>time</code> 包：时间和日期</h1><p>包中包括了两类时间：时间点（某一时刻）和时长（某一个时间段）<br><code>time</code> 包提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数。  </p>
<p>戳→<a href="http://docscn.studygolang.com/pkg/time/" target="_blank" rel="noopener">中文文档</a>、 <a href="http://golang.org/pkg/time/" target="_blank" rel="noopener">官方文档</a> 、 <a href="http://docs.studygolang.com/pkg/time/" target="_blank" rel="noopener">国内访问页面</a>   </p>
<p>获取当前时间：<code>time.Now()</code>；  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t time.Time = time.Now()</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">t := time.Now()</span><br></pre></td></tr></table></figure>
<p>获取时间的一部分： <code>t.Day</code>、<code>t.Minute()</code>…<br>自定义时间格式化字符串：eg.<code>fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>08.03.2019</code><br>Duration 类型表示两个连续时刻所相差的<strong>纳秒数</strong>，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。<br>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个t转换为相应格式的字符串，你可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println((t.Format(<span class="string">"02 Jan 2006 15:04"</span>)))</span><br></pre></td></tr></table></figure>
<p>如果需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 <code>time.After</code> 或者 <code>time.Ticker</code>。<br>另外，<code>time.Sleep(Duration d)</code> 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。  </p>
<h2 id="时间敞亮（时间格式化）"><a href="#时间敞亮（时间格式化）" class="headerlink" title="时间敞亮（时间格式化）"></a>时间敞亮（时间格式化）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ANSIC       = <span class="string">"Mon Jan _2 15:04:05 2006"</span></span><br><span class="line">    UnixDate    = <span class="string">"Mon Jan _2 15:04:05 MST 2006"</span></span><br><span class="line">    RubyDate    = <span class="string">"Mon Jan 02 15:04:05 -0700 2006"</span></span><br><span class="line">    RFC822      = <span class="string">"02 Jan 06 15:04 MST"</span></span><br><span class="line">    RFC822Z     = <span class="string">"02 Jan 06 15:04 -0700"</span> <span class="comment">// RFC822 with numeric zone</span></span><br><span class="line">    RFC850      = <span class="string">"Monday, 02-Jan-06 15:04:05 MST"</span></span><br><span class="line">    RFC1123     = <span class="string">"Mon, 02 Jan 2006 15:04:05 MST"</span></span><br><span class="line">    RFC1123Z    = <span class="string">"Mon, 02 Jan 2006 15:04:05 -0700"</span> <span class="comment">// RFC1123 with numeric zone</span></span><br><span class="line">    RFC3339     = <span class="string">"2006-01-02T15:04:05Z07:00"</span></span><br><span class="line">    RFC3339Nano = <span class="string">"2006-01-02T15:04:05.999999999Z07:00"</span></span><br><span class="line">    Kitchen     = <span class="string">"3:04PM"</span></span><br><span class="line">    <span class="comment">// Handy time stamps.</span></span><br><span class="line">    Stamp      = <span class="string">"Jan _2 15:04:05"</span></span><br><span class="line">    StampMilli = <span class="string">"Jan _2 15:04:05.000"</span></span><br><span class="line">    StampMicro = <span class="string">"Jan _2 15:04:05.000000"</span></span><br><span class="line">    StampNano  = <span class="string">"Jan _2 15:04:05.000000000"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这些常量是在time包中进行time 格式化 和time解析而预定义的一些常量，其实他们使用的都是一个特定的时间：<code>Mon Jan 2 15:04:05 MST 2006</code>  </p>
<h2 id="函数-5"><a href="#函数-5" class="headerlink" title="函数"></a>函数</h2><h3 id="time-组成"><a href="#time-组成" class="headerlink" title="time 组成"></a>time 组成</h3><p><code>time.Duration</code> 时间长度，消耗时间<br><code>time.Time</code> 时间点<br><code>time.C</code> 放时间的通道(tine.C := make(chan time.Time))</p>
<h3 id="After-函数"><a href="#After-函数" class="headerlink" title="After 函数"></a>After 函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure>
<p>表示多少时间之后，但是在去除channel内容之前不阻塞，后续程序可以继续执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sleep</span><span class="params">(d Duration)</span></span></span><br></pre></td></tr></table></figure>
<p>表示休眠多少时间，休眠时处于阻塞状态，后续程序无法执行。  </p>
<p>鉴于After特性，其通常用来处理程序超时问题，如下所示：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m := &lt;-c:</span><br><span class="line">    handle(m)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Minute):</span><br><span class="line">    fmt.Println(<span class="string">"timed out"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure>
<p>time.Tick(time.Duration)用法和time.After差不多，但是它是表示每隔多少时间之后，是一个重复的过程，其他与After一致。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span> </span><br><span class="line"><span class="comment">//时间长度，其对应的时间单位有Nanosecond，Microsecond,Millisecond,Second,Minute,Hour</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseDuration</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(Duration, error)</span></span></span><br><span class="line"><span class="comment">//传入字符串，返回响应的时间，其中传入的字符串中的有效时间单位如下：h,m,s,ms,us,ns，其他单位均无效，如果传入无效时间单位，则会返回０ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Since</span><span class="params">(t Time)</span> <span class="title">Duration</span></span> </span><br><span class="line"><span class="comment">//表示自从t时刻以后过了多长时间，是一个时间段，相当于time.Now().Sub(t)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">Hours</span><span class="params">()</span> <span class="title">float64</span></span> </span><br><span class="line"><span class="comment">//将制定时间段换算为float64类型的Hour为单位进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">Minutes</span><span class="params">()</span> <span class="title">float64</span></span> </span><br><span class="line"><span class="comment">//将制定时间段换算为float64类型的Minutes为单位进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">Nanoseconds</span><span class="params">()</span> <span class="title">int64</span></span> </span><br><span class="line"><span class="comment">//将制定时间段换算为int64类型的Nanoseconds为单位进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">Seconds</span><span class="params">()</span> <span class="title">float64</span></span> </span><br><span class="line"><span class="comment">//将制定时间段换算为float64类型的Seconds为单位进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d Duration)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>  </span><br><span class="line"><span class="comment">//与ParseDuration函数相反，该函数是将时间段转化为字符串输出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Location</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FixedZone</span><span class="params">(name <span class="keyword">string</span>, offset <span class="keyword">int</span>)</span> *<span class="title">Location</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadLocation</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Location, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Location)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Month <span class="comment">// 定义了1年的12个月</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Month)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>  //将时间月份以字符串形式打印出来．如<span class="title">fmt</span>.<span class="title">Println</span><span class="params">(time.June.String()</span>)则打印出<span class="title">June</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ParseError</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ParseError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Ticker  </span><br><span class="line"><span class="comment">//主要用来按照指定的时间周期来调用函数或者计算表达式，</span></span><br><span class="line"><span class="comment">//通常的使用方式是利用go新开一个协程使用，它是一个断续器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span> *<span class="title">Ticker</span></span></span><br><span class="line"><span class="comment">//新生成一个ticker,此Ticker包含一个channel，</span></span><br><span class="line"><span class="comment">//此channel以给定的duration发送时间。duration d必须大于0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">Stop</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">//用于关闭相应的Ticker，但并不关闭channel</span></span><br></pre></td></tr></table></figure>
<p>例子：<br>使用时间控制停止ticker：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">1500</span>)   </span><br><span class="line"><span class="comment">//阻塞，则执行次数为sleep的休眠时间/ticker的时间</span></span><br><span class="line">ticker.Stop()     </span><br><span class="line">fmt.Println(<span class="string">"Ticker stopped"</span>)</span><br></pre></td></tr></table></figure>
<p>使用channel控制停止ticker：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>，num) <span class="comment">//num为指定的执行次数</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">              c&lt;<span class="number">-1</span></span><br><span class="line">               fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">        </span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure>
<p>这种情况下，在执行num次以Ticker时间为单位的函数之后，c　channel中已满，以后便不会再执行对应的函数  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Time  <span class="comment">//包括日期和时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="keyword">int</span>, month Month, day, hour, min, sec, nsec <span class="keyword">int</span>, loc *Location)</span> <span class="title">Time</span></span>　</span><br><span class="line"><span class="comment">//按照指定格式输入数据后，便会按照如下格式输出对应的时间，输出格式为</span></span><br><span class="line"><span class="comment">//yyyy-mm-dd hh:mm:ss + nsec nanoseconds，　其中loc必须指定，否则便会panic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eg，</span></span><br><span class="line">t := time.Date(<span class="number">2009</span>, time.November, <span class="number">10</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">fmt.Printf(<span class="string">"Go launched at %s\n"</span>, t.Local())</span><br><span class="line"><span class="comment">//输出为：</span></span><br><span class="line">Go launched at <span class="number">2009</span><span class="number">-11</span><span class="number">-10</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">-0800</span> PST</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span> //返回当前时间，包括日期，时间和时区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="keyword">string</span>)</span> <span class="params">(Time, error)</span>　//输入格式化<span class="title">layout</span>和时间字符串，输出时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="keyword">string</span>, loc *Location)</span> <span class="params">(Time, error)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec <span class="keyword">int64</span>, nsec <span class="keyword">int64</span>)</span> <span class="title">Time</span>　//返回本地时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span>　　//增加时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">AddDate</span><span class="params">(years <span class="keyword">int</span>, months <span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">Time</span>//增加日期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span>　　//判断时间<span class="title">t</span>是否在时间ｕ的后面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span>　//判断时间<span class="title">t</span>是否在时间ｕ的前面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Clock</span><span class="params">()</span> <span class="params">(hour, min, sec <span class="keyword">int</span>)</span>　//获取时间ｔ的<span class="title">hour</span>,<span class="title">min</span>和<span class="title">second</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Date</span><span class="params">()</span> <span class="params">(year <span class="keyword">int</span>, month Month, day <span class="keyword">int</span>)</span>　//获取时间ｔ的<span class="title">year</span>,<span class="title">month</span>和<span class="title">day</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Day</span><span class="params">()</span> <span class="title">int</span>   //获取时间ｔ的<span class="title">day</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span>  //判断时间<span class="title">t</span>和时间<span class="title">u</span>是否相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Format</span><span class="params">(layout <span class="keyword">string</span>)</span> <span class="title">string</span>  //时间字符串格式化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">GobDecode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span> //编码为<span class="title">god</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">GobEncode</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span>//解码<span class="title">god</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Hour</span><span class="params">()</span> <span class="title">int</span>　//获取时间ｔ的小时</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">ISOWeek</span><span class="params">()</span> <span class="params">(year, week <span class="keyword">int</span>)</span>//获取时间ｔ的年份和星期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">In</span><span class="params">(loc *Location)</span> <span class="title">Time</span>//获取<span class="title">loc</span>时区的时间ｔ的对应时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">IsZero</span><span class="params">()</span> <span class="title">bool</span>　//判断是否为０时间实例<span class="title">January</span> 1, <span class="title">year</span> 1, 00:00:00 <span class="title">UTC</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Local</span><span class="params">()</span> <span class="title">Time</span>　//获取当地时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Location</span><span class="params">()</span> *<span class="title">Location</span>   //获取当地时区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">MarshalBinary</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span>　//<span class="title">marshal</span> <span class="title">binary</span>序列化，将时间<span class="title">t</span>序列化后存入[]<span class="title">byte</span>数组中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span>     //<span class="title">marshal</span> <span class="title">json</span>序列化，将时间<span class="title">t</span>序列化后存入[]<span class="title">byte</span>数组中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">MarshalText</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span>    //<span class="title">marshal</span> <span class="title">text</span>序列化，将时间<span class="title">t</span>序列化后存入[]<span class="title">byte</span>数组中</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.Date(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">918273645</span>, time.UTC)</span><br><span class="line">round := []time.Duration&#123;</span><br><span class="line">    time.Nanosecond,</span><br><span class="line">    time.Microsecond,</span><br><span class="line">    time.Millisecond,</span><br><span class="line">    time.Second,</span><br><span class="line">    <span class="number">2</span> * time.Second,</span><br><span class="line">    time.Minute,</span><br><span class="line">    <span class="number">10</span> * time.Minute,</span><br><span class="line">    time.Hour,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> round &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"t.Round(%6s) = %s\n"</span>, d, t.Round(d).Format(<span class="string">"15:04:05.999999999"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Second</span><span class="params">()</span> <span class="title">int</span>　//获取时间ｔ的秒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>　//获取时间ｔ的字符串表示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Sub</span><span class="params">(u Time)</span> <span class="title">Duration</span>　//与<span class="title">Add</span>相反，<span class="title">Sub</span>表示从时间ｔ中减去时间ｕ</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Truncate</span><span class="params">(d Duration)</span> <span class="title">Time</span>　//去尾法求近似值</span></span><br></pre></td></tr></table></figure>
<p>例子：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t, _ := time.Parse(<span class="string">"2006 Jan 02 15:04:05"</span>, <span class="string">"2012 Dec 07 12:15:30.918273645"</span>)</span><br><span class="line">trunc := []time.Duration&#123;</span><br><span class="line">    time.Nanosecond,</span><br><span class="line">    time.Microsecond,</span><br><span class="line">    time.Millisecond,</span><br><span class="line">    time.Second,</span><br><span class="line">    <span class="number">2</span> * time.Second,</span><br><span class="line">    time.Minute,</span><br><span class="line">    <span class="number">10</span> * time.Minute,</span><br><span class="line">    time.Hour,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> trunc &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"t.Truncate(%6s) = %s\n"</span>, d, t.Truncate(d).Format(<span class="string">"15:04:05.999999999"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">t.Truncate(   <span class="number">1</span>ns) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30.918273645</span></span><br><span class="line">t.Truncate(   <span class="number">1</span>µs) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30.918273</span></span><br><span class="line">t.Truncate(   <span class="number">1</span>ms) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30.918</span></span><br><span class="line">t.Truncate(    <span class="number">1</span>s) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30</span></span><br><span class="line">t.Truncate(    <span class="number">2</span>s) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30</span></span><br><span class="line">t.Truncate(  <span class="number">1</span>m0s) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">00</span></span><br><span class="line">t.Truncate( <span class="number">10</span>m0s) = <span class="number">12</span>:<span class="number">10</span>:<span class="number">00</span></span><br><span class="line">t.Truncate(<span class="number">1</span>h0m0s) = <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">UTC</span><span class="params">()</span> <span class="title">Time</span>　//将本地时间变换为<span class="title">UTC</span>时区的时间并返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Unix</span><span class="params">()</span> <span class="title">int64</span>　//返回<span class="title">Unix</span>时间，该时间是从<span class="title">January</span> 1, 1970 <span class="title">UTC</span>这个时间开始算起的．</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">UnixNano</span><span class="params">()</span> <span class="title">int64</span>　//以纳秒为单位返回<span class="title">Unix</span>时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">UnmarshalBinary</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span>　//将<span class="title">data</span>数据反序列化到时间ｔ中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span>　//将<span class="title">data</span>数据反序列化到时间ｔ中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">UnmarshalText</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span>　//将<span class="title">data</span>数据反序列化到时间ｔ中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Weekday</span><span class="params">()</span> <span class="title">Weekday</span>　//获取时间ｔ的<span class="title">Weekday</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Year</span><span class="params">()</span> <span class="title">int</span>　　　//获取时间ｔ的<span class="title">Year</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">YearDay</span><span class="params">()</span> <span class="title">int</span>     //获取时间ｔ的<span class="title">YearDay</span>，即１年中的第几天</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Zone</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, offset <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer　<span class="comment">//用于在指定的Duration类型时间后调用函数或计算表达式，它是一个计时器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span>) *<span class="title">Timer</span>　//和<span class="title">After</span>差不多，意思是多少时间之后执行函数<span class="title">f</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span>　//使用<span class="title">NewTimer</span><span class="params">()</span>,可以返回的<span class="title">Timer</span>类型在计时器到期之前,取消该计时器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Reset</span><span class="params">(d Duration)</span> <span class="title">bool</span>　//重新设定<span class="title">timer</span> <span class="title">t</span>的<span class="title">Duration</span> <span class="title">d</span>.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">bool</span>　//阻止<span class="title">timer</span>事件发生，当该函数执行后，<span class="title">timer</span>计时器停止，相应的事件不再执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Weekday)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>　//获取一周的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="一些例子："><a href="#一些例子：" class="headerlink" title="一些例子："></a>一些例子：</h3><p>获取年月日方法  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">y := t.Year() <span class="comment">// 年</span></span><br><span class="line">m := <span class="keyword">int</span>(t.Month()) <span class="comment">//月</span></span><br><span class="line">d := t.Day()<span class="comment">// 日</span></span><br><span class="line">h := t.Hour() <span class="comment">//小时</span></span><br><span class="line">min := t.Minute()<span class="comment">//分钟</span></span><br><span class="line">s := t.Second()<span class="comment">//秒</span></span><br><span class="line">fmt.Printf(<span class="string">"%d-%d-%d"</span>,y,m,d)<span class="comment">// 2017-12-26</span></span><br><span class="line">fmt.Printf(<span class="string">"%d%02d%02d"</span>,y,m,d) <span class="comment">// 20180101</span></span><br></pre></td></tr></table></figure>

<p>获取格式为:2017-12-29 16:58:39  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">fmt.Println(t.String()[:<span class="number">19</span>])</span><br><span class="line">layout := <span class="string">"2006-01-02 15:04:05"</span></span><br><span class="line">fmt.Println(t.Format(layout))</span><br></pre></td></tr></table></figure>

<p>获取三个小时之前的时间  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">du, _ := time.ParseDuration(<span class="string">"-3h"</span>)</span><br><span class="line">t := time.Now().Add(du)</span><br></pre></td></tr></table></figure>

<p>获取三天之前的时间</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">t.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-3</span>) </span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<p>t.AddDate(year,month,day) 正数向前，负数向后  </p>
<p>时间戳转time.Time 类型  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timestamp := <span class="number">1513580645</span></span><br><span class="line">t := time.Unix(timestamp,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>获取时间戳：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">timestamp := t.Unix()</span><br></pre></td></tr></table></figure>

<p>两个时间的间隔  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t1 := time.Now()</span><br><span class="line"><span class="comment">//do some function</span></span><br><span class="line">t2 := time.Now()</span><br><span class="line">sub := t2.Since(t1)</span><br></pre></td></tr></table></figure>

<p>字符串转时间  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">layout := <span class="string">"2006-01-02 15:04:05"</span> </span><br><span class="line"><span class="comment">// 这个格式，不能改，据说是Go诞生的时间，可能有特殊含义吧</span></span><br><span class="line">t , err := time.Parse(layout,<span class="string">"2017-12-26 17:20:21"</span>)</span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<p>标准时间字符串转化为时间<br>使用byte读取数据库当中的timestamp字段时，会出现标准的时间格式  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">layout := <span class="string">"2006-01-02T15:04:05Z07:00"</span></span><br><span class="line">timeStr := <span class="string">"2018-01-02T11:30:21Z"</span></span><br><span class="line">t , _ := time.Parse(layout,timeStr)</span><br><span class="line"><span class="comment">// t , _ := time.Parse(time.RFC3339,timeStr)</span></span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="unicode-包"><a href="#unicode-包" class="headerlink" title="unicode 包"></a><code>unicode</code> 包</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MaxRune         = <span class="string">'\U0010FFFF'</span> <span class="comment">// Unicode 码点的最大值</span></span><br><span class="line">    ReplacementChar = <span class="string">'\uFFFD'</span>     <span class="comment">// 表示无效的码点</span></span><br><span class="line">    MaxASCII        = <span class="string">'\u007F'</span>     <span class="comment">// 最大 ASCII 值</span></span><br><span class="line">    MaxLatin1       = <span class="string">'\u00FF'</span>     <span class="comment">// 最大 Latin-1 值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="RangeTable"><a href="#RangeTable" class="headerlink" title="RangeTable"></a>RangeTable</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符 r 是否在 rangtab 范围内。</span></span><br><span class="line"><span class="comment">// 可用的 RangeTable 参见 go/src/unicode/tables.go。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(rangeTab *RangeTable, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeTable 定义一个 Unicode 码点集合，包含 16 位和 32 位两个范围列表。</span></span><br><span class="line"><span class="comment">// 这两个列表必须经过排序而且不能重叠。R32 中只能包含大于 16 位的值。</span></span><br><span class="line"><span class="keyword">type</span> RangeTable <span class="keyword">struct</span> &#123;</span><br><span class="line">    R16         []Range16</span><br><span class="line">    R32         []Range32</span><br><span class="line">    LatinOffset <span class="keyword">int</span> <span class="comment">// R16 中 Hi &lt;= MaxLatin1 的条目数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range16 表示一个 16 位的 Unicode 码点范围。范围从 Lo 到 Hi，具有指定的步长。</span></span><br><span class="line"><span class="keyword">type</span> Range16 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lo     <span class="keyword">uint16</span></span><br><span class="line">    Hi     <span class="keyword">uint16</span></span><br><span class="line">    Stride <span class="keyword">uint16</span> <span class="comment">// 步长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range32 表示一个 32 位的 Unicode 码点范围。范围从 Lo 到 Hi，具有指定的步长。</span></span><br><span class="line"><span class="comment">// Lo 和 Hi 必须都大于 16 位。</span></span><br><span class="line"><span class="keyword">type</span> Range32 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lo     <span class="keyword">uint32</span></span><br><span class="line">    Hi     <span class="keyword">uint32</span></span><br><span class="line">    Stride <span class="keyword">uint32</span> <span class="comment">// 步长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断及转换字符大小写、Title"><a href="#判断及转换字符大小写、Title" class="headerlink" title="判断及转换字符大小写、Title"></a>判断及转换字符大小写、Title</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符 r 是否为大写格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符 r 是否为小写格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符 r 是否为 Unicode 规定的 Title 字符</span></span><br><span class="line"><span class="comment">// 大部分字符的 Title 格式就是其大写格式</span></span><br><span class="line"><span class="comment">// 只有少数字符的 Title 格式是特殊字符</span></span><br><span class="line"><span class="comment">// 这里判断的就是特殊字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToUpper 将字符 r 转换为大写格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToLower 将字符 r 转换为小写格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToTitle 将字符 r 转换为 Title 格式</span></span><br><span class="line"><span class="comment">// 大部分字符的 Title 格式就是其大写格式</span></span><br><span class="line"><span class="comment">// 只有少数字符的 Title 格式是特殊字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To 将字符 r 转换为指定的格式</span></span><br><span class="line"><span class="comment">// _case 取值：UpperCase、LowerCase、TitleCase</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">To</span><span class="params">(_case <span class="keyword">int</span>, r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br></pre></td></tr></table></figure>

<p>示例1：判断汉字：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 世界！"</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为汉字</span></span><br><span class="line">        <span class="keyword">if</span> unicode.Is(unicode.Scripts[<span class="string">"Han"</span>], r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r) <span class="comment">// 世界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更多 unicode.Scripts 取值请参考：http://www.cnblogs.com/golove/p/3269099.html</span></span><br></pre></td></tr></table></figure>

<p>示例2：判断大小写：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello ＡＢＣ！"</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为大写</span></span><br><span class="line">        <span class="keyword">if</span> unicode.IsUpper(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r) <span class="comment">// HＡＢＣ</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello ａｂｃ！"</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为小写</span></span><br><span class="line">        <span class="keyword">if</span> unicode.IsLower(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r) <span class="comment">// elloａｂｃ</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello ᾏᾟᾯ！"</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为标题</span></span><br><span class="line">        <span class="keyword">if</span> unicode.IsTitle(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r) <span class="comment">// ᾏᾟᾯ</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例3：输出 Unicode 规定的标题字符  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, cr := <span class="keyword">range</span> unicode.Lt.R16 &#123;</span><br><span class="line">        <span class="keyword">for</span> i := cr.Lo; i &lt;= cr.Hi; i += cr.Stride &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// ǅǈǋǲᾈᾉᾊᾋᾌᾍᾎᾏᾘᾙᾚᾛᾜᾝᾞᾟᾨᾩᾪᾫᾬᾭᾮᾯᾼῌῼ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例4：转换大小写  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello 世界！"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.ToUpper(r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.ToLower(r))</span><br><span class="line">    &#125; <span class="comment">// hello 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.ToTitle(r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.To(unicode.UpperCase, r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.To(unicode.LowerCase, r))</span><br><span class="line">    &#125; <span class="comment">// hello 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.To(unicode.TitleCase, r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rune操作"><a href="#rune操作" class="headerlink" title="rune操作"></a>rune操作</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ToUpper 将 r 转换为大写格式</span></span><br><span class="line"><span class="comment">// 优先使用指定的映射表 special</span></span><br><span class="line"><span class="comment">// 可用的 SpecialCase 参见 go/src/unicode/casetables.go。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(special SpecialCase)</span> <span class="title">ToUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToLower 将 r 转换为小写格式</span></span><br><span class="line"><span class="comment">// 优先使用指定的映射表 special</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(special SpecialCase)</span> <span class="title">ToLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToTitle 将 r 转换为 Title 格式</span></span><br><span class="line"><span class="comment">// 优先使用指定的映射表 special</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(special SpecialCase)</span> <span class="title">ToTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SpecialCase 表示特定语言的大小写映射，比如土耳其语。</span></span><br><span class="line"><span class="comment">// SpecialCase 的方法可以自定义标准映射（通过重写）。</span></span><br><span class="line"><span class="keyword">type</span> SpecialCase []CaseRange</span><br><span class="line"></span><br><span class="line"><span class="comment">// CaseRange 表示一个简单的 Unicode 码点范围，用于大小写转换。</span></span><br><span class="line"><span class="comment">// 在 Lo 和 Hi 范围内的码点，如果要转换成大写，只需要加上 d[0] 即可</span></span><br><span class="line"><span class="comment">// 如果要转换为小写，只需要加上 d[1] 即可，如果要转换为 Title 格式，</span></span><br><span class="line"><span class="comment">// 只需要加上 d[2] 即可。</span></span><br><span class="line"><span class="keyword">type</span> CaseRange <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lo    <span class="keyword">uint32</span></span><br><span class="line">    Hi    <span class="keyword">uint32</span></span><br><span class="line">    Delta d <span class="comment">// [3]rune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CaseRanges 中 Delta 数组的索引。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UpperCase = <span class="literal">iota</span></span><br><span class="line">    LowerCase</span><br><span class="line">    TitleCase</span><br><span class="line">    MaxCase</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个 CaseRange 中的 Delta 元素是 UpperLower，则表示这个 CaseRange 是</span></span><br><span class="line"><span class="comment">// 一个有着连续的大写小写大写小写的范围。也就是说，Lo 是大写，Lo+1 是小写，</span></span><br><span class="line"><span class="comment">// Lo+2 是大写，Lo+3 是小写 ... 一直到 Hi 为止。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UpperLower = MaxRune + <span class="number">1</span> <span class="comment">// 不是一个有效的 Delta 元素</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello 世界！"</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.SpecialCase(unicode.CaseRanges).ToUpper(r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.SpecialCase(unicode.CaseRanges).ToLower(r))</span><br><span class="line">    &#125; <span class="comment">// hello 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.SpecialCase(unicode.CaseRanges).ToTitle(r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SimpleFold-环绕查找"><a href="#SimpleFold-环绕查找" class="headerlink" title="SimpleFold 环绕查找"></a>SimpleFold 环绕查找</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SimpleFold 在 Unicode 字符表中从字符 r 开始环绕查找（到尾部后再从头开始）</span></span><br><span class="line"><span class="comment">// 下一个与 r 大小写相匹配的字符（一个字符的大写、小写、标题三者视为大小写相</span></span><br><span class="line"><span class="comment">// 匹配），这个函数遵循 Unicode 定义的大小写环绕匹配表。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// SimpleFold('A') = 'a'</span></span><br><span class="line"><span class="comment">// SimpleFold('a') = 'A'</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SimpleFold('K') = 'k'</span></span><br><span class="line"><span class="comment">// SimpleFold('k') = 'K' (开尔文符号)</span></span><br><span class="line"><span class="comment">// SimpleFold('K') = 'K'</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SimpleFold('1') = '1'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleFold</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"ΦφϕkKK"</span></span><br><span class="line">    <span class="comment">// 看看 s 里面是什么</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%x  "</span>, c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// 大写，小写，标题 | 当前字符 -&gt; 下一个匹配字符</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c, %c, %c | %c -&gt; %c\n"</span>,</span><br><span class="line">            unicode.ToUpper(v),</span><br><span class="line">            unicode.ToLower(v),</span><br><span class="line">            unicode.ToTitle(v),</span><br><span class="line">            v,</span><br><span class="line">            unicode.SimpleFold(v),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 3a6  3c6  3d5  6b  4b  212a</span></span><br><span class="line"><span class="comment">// Φ, φ, Φ | Φ -&gt; φ</span></span><br><span class="line"><span class="comment">// Φ, φ, Φ | φ -&gt; ϕ</span></span><br><span class="line"><span class="comment">// Φ, ϕ, Φ | ϕ -&gt; Φ</span></span><br><span class="line"><span class="comment">// K, k, K | k -&gt; K</span></span><br><span class="line"><span class="comment">// K, k, K | K -&gt; k</span></span><br><span class="line"><span class="comment">// K, k, K | K -&gt; K</span></span><br></pre></td></tr></table></figure>

<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IsDigit 判断 r 是否为一个十进制的数字字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsDigit</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsNumber 判断 r 是否为一个数字字符 (类别 N)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNumber</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsLetter 判断 r 是否为一个字母字符 (类别 L)</span></span><br><span class="line"><span class="comment">// 汉字也是一个字母字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsLetter</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsSpace 判断 r 是否为一个空白字符</span></span><br><span class="line"><span class="comment">// 在 Latin-1 字符集中，空白字符为：\t, \n, \v, \f, \r,</span></span><br><span class="line"><span class="comment">// 空格, U+0085 (NEL), U+00A0 (NBSP)</span></span><br><span class="line"><span class="comment">// 其它空白字符的定义有“类别 Z”和“Pattern_White_Space 属性”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSpace</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsControl 判断 r 是否为一个控制字符</span></span><br><span class="line"><span class="comment">// Unicode 类别 C 包含更多字符，比如代理字符</span></span><br><span class="line"><span class="comment">// 使用 Is(C, r) 来测试它们</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsControl</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsGraphic 判断字符 r 是否为一个“图形字符”</span></span><br><span class="line"><span class="comment">// “图形字符”包括字母、标记、数字、标点、符号、空格</span></span><br><span class="line"><span class="comment">// 他们分别对应于 L、M、N、P、S、Zs 类别</span></span><br><span class="line"><span class="comment">// 这些类别是 RangeTable 类型，存储了相应类别的字符范围</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsGraphic</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsPrint 判断字符 r 是否为 Go 所定义的“可打印字符”</span></span><br><span class="line"><span class="comment">// “可打印字符”包括字母、标记、数字、标点、符号和 ASCII 空格</span></span><br><span class="line"><span class="comment">// 他们分别对应于 L, M, N, P, S 类别和 ASCII 空格</span></span><br><span class="line"><span class="comment">// “可打印字符”和“图形字符”基本是相同的，不同之处在于</span></span><br><span class="line"><span class="comment">// “可打印字符”只包含 Zs 类别中的 ASCII 空格（U+0020）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsPunct 判断 r 是否为一个标点字符 (类别 P)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPunct</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsSymbol 判断 r 是否为一个符号字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSymbol</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsMark 判断 r 是否为一个 mark 字符 (类别 M)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsMark</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsOneOf 判断 r 是否在 set 范围内</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsOneOf</span><span class="params">(set []*RangeTable, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println() <span class="comment">// 数字</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 123１２３一二三！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsDigit(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 123１２３</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 数字</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 123１２３一二三！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsNumber(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 123１２３</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 字母</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello\n\t世界！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsLetter(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Hello世界</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 空白</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello \t世　界！\n"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsSpace(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%q"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// ' ''\t''\u3000''\n'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 控制字符</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello\n\t世界！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsControl(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%#q"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// '\n''\t'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 可打印</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello　世界！\t"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsPrint(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Hello世界！</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 图形</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello　世界！\t"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsGraphic(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Hello　世界！</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 掩码</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello ៉៊់៌៍！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsMark(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// ៉៊់៌៍</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 标点</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 世界！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsPunct(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// ！</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 符号</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello (&lt;世=界&gt;)"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsSymbol(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// &lt;=&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg.判断汉字和标点：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将 set 设置为“汉字、标点符号”</span></span><br><span class="line">    set := []*unicode.RangeTable&#123;unicode.Han, unicode.P&#125;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 世界！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsOneOf(set, r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 世界！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg.输出所有 mark 字符：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, cr := <span class="keyword">range</span> unicode.M.R16 &#123;</span><br><span class="line">        Lo, Hi, Stride := <span class="keyword">rune</span>(cr.Lo), <span class="keyword">rune</span>(cr.Hi), <span class="keyword">rune</span>(cr.Stride)</span><br><span class="line">        <span class="keyword">for</span> i := Lo; i &gt;= Lo &amp;&amp; i &lt;= Hi; i += Stride &#123;</span><br><span class="line">            <span class="keyword">if</span> unicode.IsMark(i) &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%c"</span>, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="unicode-utf16-包"><a href="#unicode-utf16-包" class="headerlink" title="unicode/utf16 包"></a><code>unicode/utf16</code> 包</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IsSurrogate 判断 r 是否为代理区字符</span></span><br><span class="line"><span class="comment">// 两个代理区字符可以用来组合成一个 utf16 编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSurrogate</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EncodeRune 将字符 r 编码成 UTF-16 代理对</span></span><br><span class="line"><span class="comment">// r：要编码的字符</span></span><br><span class="line"><span class="comment">// 如果 r &lt; 0x10000 ，则无需编码，其 UTF-16 序列就是其自身</span></span><br><span class="line"><span class="comment">// r1：编码后的 UTF-16 代理对的高位码元</span></span><br><span class="line"><span class="comment">// r2：编码后的 UTF-16 代理对的低位码元</span></span><br><span class="line"><span class="comment">// 如果 r 不是有效的 Unicode 字符，或者是代理区字符，或者无需编码</span></span><br><span class="line"><span class="comment">// 则返回 U+FFFD, U+FFFD</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(r1, r2 <span class="keyword">rune</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DecodeRune 将 UTF-16 代理对解码成一个 Unicode 字符</span></span><br><span class="line"><span class="comment">// r1：是 UTF-16 代理对的高位码元</span></span><br><span class="line"><span class="comment">// r2：是 UTF-16 代理对的低位码元</span></span><br><span class="line"><span class="comment">// 返回值为解码后的 Unicode 字符</span></span><br><span class="line"><span class="comment">// 如果 r1 或 r2 不是有效的 UTF-16 代理区字符，则返回 U+FFFD</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeRune</span><span class="params">(r1, r2 <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Decode 将 UTF-16 序列 s 解码成 Unicode 字符序列并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(s []<span class="keyword">uint16</span>)</span> []<span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode 将 s 编码成 UTF-16 序列并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(s []<span class="keyword">rune</span>)</span> []<span class="title">uint16</span></span></span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf16.IsSurrogate(<span class="number">0xD400</span>)) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf16.IsSurrogate(<span class="number">0xDC00</span>)) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf16.IsSurrogate(<span class="number">0xDFFF</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    r1, r2 := utf16.EncodeRune(<span class="string">'𠀾'</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%x, %x\n"</span>, r1, r2) <span class="comment">// d840, dc3e</span></span><br><span class="line"></span><br><span class="line">    r := utf16.DecodeRune(<span class="number">0xD840</span>, <span class="number">0xDC3E</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, r) <span class="comment">// d840, dc3e</span></span><br><span class="line"></span><br><span class="line">    u := []<span class="keyword">uint16</span>&#123;<span class="string">'不'</span>, <span class="string">'会'</span>, <span class="number">0xD840</span>, <span class="number">0xDC3E</span>&#125;</span><br><span class="line">    s := utf16.Decode(u)</span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>, s) <span class="comment">// [不 会 𠀾]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="unicode-utf8-包"><a href="#unicode-utf8-包" class="headerlink" title="unicode/utf8 包"></a><code>unicode/utf8</code> 包</h1><h2 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码所需的基本数字</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    RuneError = <span class="string">'\uFFFD'</span>     <span class="comment">// 错误的 Rune 或 Unicode 代理字符</span></span><br><span class="line">    RuneSelf  = <span class="number">0x80</span>         <span class="comment">// ASCII 字符范围</span></span><br><span class="line">    MaxRune   = <span class="string">'\U0010FFFF'</span> <span class="comment">// Unicode 码点的最大值</span></span><br><span class="line">    UTFMax    = <span class="number">4</span>            <span class="comment">// 一个字符编码的最大长度</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="函数-6"><a href="#函数-6" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 r 转换为 UTF-8 编码写入 p 中（p 必须足够长，通常为 4 个字节）</span></span><br><span class="line"><span class="comment">// 如果 r 是无效的 Unicode 字符，则写入 RuneError</span></span><br><span class="line"><span class="comment">// 返回写入的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRune</span><span class="params">(p []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码 p 中的第一个字符，返回解码后的字符和 p 中被解码的字节数</span></span><br><span class="line"><span class="comment">// 如果 p 为空，则返回（RuneError, 0）</span></span><br><span class="line"><span class="comment">// 如果 p 中的编码无效，则返回（RuneError, 1）</span></span><br><span class="line"><span class="comment">// 无效编码：UTF-8 编码不正确（比如长度不够）、结果超出 Unicode 范围、编码不是最短的。</span></span><br><span class="line"><span class="comment">// 关于最短编码：可以用四个字节编码一个单字节字符，但它不是最短的，比如：</span></span><br><span class="line"><span class="comment">// [111100000 10000000 10000000 10111000] 不是最短的，应该使用 [00111000]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeRuneInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码 p 中的最后一个字符，返回解码后的字符，和 p 中被解码的字节数</span></span><br><span class="line"><span class="comment">// 如果 p 为空，则返回（RuneError, 0）</span></span><br><span class="line"><span class="comment">// 如果 p 中的编码无效，则返回（RuneError, 1）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeLastRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeLastRuneInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FullRune 检测 p 中第一个字符的 UTF-8 编码是否完整（完整并不表示有效）。</span></span><br><span class="line"><span class="comment">// 一个无效的编码也被认为是完整字符，因为它将被转换为一个 RuneError 字符。</span></span><br><span class="line"><span class="comment">// 只有“编码有效但长度不够”的字符才被认为是不完整字符。</span></span><br><span class="line"><span class="comment">// 也就是说，只有截去一个有效字符的一个或多个尾部字节，该字符才算是不完整字符。</span></span><br><span class="line"><span class="comment">// 举例：</span></span><br><span class="line"><span class="comment">// "好"     是完整字符</span></span><br><span class="line"><span class="comment">// "好"[1:] 是完整字符（首字节无效，可转换为 RuneError 字符）</span></span><br><span class="line"><span class="comment">// "好"[2:] 是完整字符（首字节无效，可转换为 RuneError 字符）</span></span><br><span class="line"><span class="comment">// "好"[:2] 是不完整字符（编码有效但长度不够）</span></span><br><span class="line"><span class="comment">// "好"[:1] 是不完整字符（编码有效但长度不够）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FullRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FullRuneInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 p 中的字符个数</span></span><br><span class="line"><span class="comment">// 错误的 UTF8 编码和长度不足的 UTF8 编码将被当作单字节的 RuneError 处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneCount</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneCountInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RuneLen 返回需要多少字节来编码字符 r，如果 r 是无效的字符，则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneLen</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 b 是否为 UTF8 字符的首字节编码，最高位(bit)是不是 10 的字节就是首字节。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneStart</span><span class="params">(b <span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Valid 判断 p 是否为完整有效的 UTF8 编码序列。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Valid</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ValidRune 判断 r 能否被正确的转换为 UTF8 编码</span></span><br><span class="line"><span class="comment">// 超出 Unicode 范围的码点或 UTF-16 代理区中的码点是不能转换的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, utf8.UTFMax)</span><br><span class="line"></span><br><span class="line">    n := utf8.EncodeRune(b, <span class="string">'好'</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%v：%v\n"</span>, b, n) <span class="comment">// [229 165 189 0]：3</span></span><br><span class="line"></span><br><span class="line">    r, n := utf8.DecodeRune(b)</span><br><span class="line">    fmt.Printf(<span class="string">"%c：%v\n"</span>, r, n) <span class="comment">// 好：3</span></span><br><span class="line"></span><br><span class="line">    s := <span class="string">"大家好"</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">        r, n = utf8.DecodeRuneInString(s[i:])</span><br><span class="line">        fmt.Printf(<span class="string">"%c：%v   "</span>, r, n) <span class="comment">// 大：3   家：3   好：3</span></span><br><span class="line">        i += n</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s); i &gt; <span class="number">0</span>; &#123;</span><br><span class="line">        r, n = utf8.DecodeLastRuneInString(s[:i])</span><br><span class="line">        fmt.Printf(<span class="string">"%c：%v   "</span>, r, n) <span class="comment">// 好：3   家：3   大：3</span></span><br><span class="line">        i -= n</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    b = []<span class="keyword">byte</span>(<span class="string">"好"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.FullRune(b))     <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.FullRune(b[<span class="number">1</span>:])) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.FullRune(b[<span class="number">2</span>:])) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.FullRune(b[:<span class="number">2</span>])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf8.FullRune(b[:<span class="number">1</span>])) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    b = []<span class="keyword">byte</span>(<span class="string">"大家好"</span>)</span><br><span class="line">    fmt.Println(utf8.RuneCount(b)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%d, "</span>, utf8.RuneLen(<span class="string">'A'</span>))          <span class="comment">// 1</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d, "</span>, utf8.RuneLen(<span class="string">'\u03A6'</span>))     <span class="comment">// 2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d, "</span>, utf8.RuneLen(<span class="string">'好'</span>))          <span class="comment">// 3</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d, "</span>, utf8.RuneLen(<span class="string">'\U0010FFFF'</span>)) <span class="comment">// 4</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, utf8.RuneLen(<span class="number">0x1FFFFFFF</span>))   <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.RuneStart(<span class="string">"好"</span>[<span class="number">0</span>])) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.RuneStart(<span class="string">"好"</span>[<span class="number">1</span>])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf8.RuneStart(<span class="string">"好"</span>[<span class="number">2</span>])) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    b = []<span class="keyword">byte</span>(<span class="string">"你好"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b))     <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b[<span class="number">1</span>:])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b[<span class="number">2</span>:])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b[:<span class="number">2</span>])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b[:<span class="number">1</span>])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf8.Valid(b[<span class="number">3</span>:])) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.ValidRune(<span class="string">'好'</span>))        <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.ValidRune(<span class="number">0</span>))          <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.ValidRune(<span class="number">0xD800</span>))     <span class="comment">// false  代理区字符</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf8.ValidRune(<span class="number">0x10FFFFFF</span>)) <span class="comment">// false  超出范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p><em><code>to be continued...</code></em>  </p>
]]></content>
      <categories>
        <category>「语言」- Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 语言学习笔记</title>
    <url>/2019/03/07/Golang-Notes/</url>
    <content><![CDATA[<center> <font color="#bababa">

<p><strong><em>Go 语言学习笔记</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="单变量声明"><a href="#单变量声明" class="headerlink" title="单变量声明"></a>单变量声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明类型，另行赋值</span></span><br><span class="line"><span class="keyword">var</span> v_name v_type</span><br><span class="line">v_name = value</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明值，自动判定类型</span></span><br><span class="line"><span class="keyword">var</span> v_name = value</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略var，使用：=</span></span><br><span class="line">v_name := value</span><br></pre></td></tr></table></figure>
<h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明同个类型，非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 v_type</span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明值，自动判断类型</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用:=，只能在函数体中使用</span></span><br><span class="line">vname1, vmame2, vname3 := v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般用于全局变量声明</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>唯一类型，长度固定，已编号</code>的序列。<br>数组长度是数组type的一部分。<br>数组最大长度为 2Gb。<br>索引超出数组长度时，会 panic。  </p>
<h3 id="单维数组声明"><a href="#单维数组声明" class="headerlink" title="单维数组声明"></a>单维数组声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定元素类型及个数</span></span><br><span class="line"><span class="keyword">var</span> arr_name [SIZE] arr_type</span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>] <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组是值类型，用new()创建</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p><strong>初始化数组：</strong>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明时赋值，&#123;&#125;数据量不能大于[]</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.2</span>, <span class="number">4.0</span>, <span class="number">5.5</span>, <span class="number">6.0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">5</span>]<span class="keyword">string</span>&#123;<span class="number">3</span>: <span class="string">"abc"</span>, <span class="number">4</span>: <span class="string">"xyz"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[]不设大小，自动判断数组大小</span></span><br><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.2</span>, <span class="number">4.0</span>, <span class="number">5.5</span>, <span class="number">6.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明后单独赋值</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr_name [SIZE1][SIZE2]...[SIZEN] arr_type</span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">var</span> arr3[<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果要用变量来代表构成二维数组的长度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是不对的！</span></span><br><span class="line">s := [val1][val2]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要用make：</span></span><br><span class="line">s := <span class="built_in">make</span>([][]<span class="keyword">int</span>, val1)</span><br><span class="line"><span class="keyword">for</span> _, row := s&#123;</span><br><span class="line">    row := <span class="built_in">make</span>([]<span class="keyword">int</span>, val2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二维数组初始化：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,    <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,    <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,   <span class="comment">/*  第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须有逗号</span></span><br></pre></td></tr></table></figure>

<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><ul>
<li>用 for 遍历：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++｛</span><br><span class="line">    arr1[i] = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用 for-range：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i,_:= <span class="keyword">range</span> arr1 &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li>new() 的区别：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">new</span>([<span class="number">5</span>]<span class="keyword">int</span>)  <span class="comment">// arr1 的类型是 *[5]int</span></span><br><span class="line"><span class="keyword">var</span> arr2 [<span class="number">5</span>]<span class="keyword">int</span>         <span class="comment">// arr2 的类型是 [5]int</span></span><br></pre></td></tr></table></figure>
故传参时，<code>func1(arr2)</code> 是数组拷贝，不能修改原数组。要修改，要 <code>func(&amp;arr2)</code></li>
<li>把大数组传给函数会消耗很多内存，避免方法：（1）传递数组的指针；（2）使用数组的切片。  </li>
</ul>
<hr>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>是对数组一个连续片段的引用（该数组称为相关数组，通常是匿名的）。  </p>
<h3 id="切片声明"><a href="#切片声明" class="headerlink" title="切片声明"></a>切片声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明类型，省略大小</span></span><br><span class="line"><span class="keyword">var</span> slice_name []<span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用make()创建切片</span></span><br><span class="line"><span class="keyword">var</span> slice_name [] = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">//也可简写成</span></span><br><span class="line">slice_name := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, capacity)  <span class="comment">//capacity为可选参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 new() 创建，与用 make 相同</span></span><br><span class="line"><span class="built_in">new</span>([<span class="number">100</span>]<span class="keyword">int</span>)[<span class="number">0</span>:<span class="number">50</span>]</span><br><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">50</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>new() 和 make() 的区别：  </p>
<ul>
<li>new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为<em>T的内存地址：这种方法*</em>返回一个指向类型为 T，值为 0 的地址的指针**，它适用于值类型如数组和结构体。 </li>
<li>make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel。<br>即 new 函数分配内存，make 函数初始化。  </li>
<li><em>切片初始化：*</em>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接:=声明+初始化</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;   <span class="comment">// cap = len = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组初始化切片</span></span><br><span class="line">s := arr[:]     <span class="comment">// s := arr[startIndex:endIndex]</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">type</span> arr[:]</span><br></pre></td></tr></table></figure></li>
<li><em>空(nil)切片：*</em><br>一个切片在未初始化之前默认为 nil，长度为 0。  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span>(s == <span class="literal">nil</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片的操作"><a href="#切片的操作" class="headerlink" title="切片的操作"></a>切片的操作</h3></li>
<li>切片重组（reslice）：切片达到cao上限后可扩容，改变切片长度的过程称为重组reslicing。做法：<code>slice1 = slice1[0:end]</code><br>切片扩展 1 位： <code>sl = sl[0:len(sl)+1]</code>  </li>
<li>切片后移 1 位：<code>s = s[1:]</code>,不可前移。</li>
<li>注意：不要用指针指向 slice，因为切片本身已经是一个引用类型，所以它本身就是一个指针！  </li>
<li>for-range 用于切片时，第一个返回值 ix 是索引，第二个返回值 val 是该索引位置的值，val 是值拷贝。</li>
<li><code>copy(sl_to, sl_form)</code> 切片复制  </li>
<li><code>apend(sl, elem1...)</code> 切片追加  </li>
<li>s 是个字符串（本质是字节数组），那可通过 <code>c := []byte(s)</code> 来获得字节切片 c。或者 <code>copy(dst []byte, src string)</code>    </li>
<li>字符串是不可被赋值修改的，要修改可以将字符串转化成字节数字，然后修改数组元素，最后把字节数组转换回字符串：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">"hello"</span></span><br><span class="line">c := []<span class="keyword">byte</span>(s)</span><br><span class="line">c[<span class="number">0</span>] = <span class="string">'c'</span></span><br><span class="line">s2 := <span class="keyword">string</span>(c) <span class="comment">// s2 == "cello"</span></span><br></pre></td></tr></table></figure></li>
<li><code>sort</code> 包实现搜索和排序。搜索元素前必须先排序（因为搜索是二分法）。<a href="http://golang.org/pkg/sort/" target="_blank" rel="noopener">sort 官方文档</a>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Ints(arri)     <span class="comment">// 升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stirings</span><span class="params">(a []<span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line">IntsAreSorted(a []<span class="keyword">int</span>) <span class="keyword">bool</span>     <span class="comment">// 检查是否已被排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span>     // 搜索</span></span><br></pre></td></tr></table></figure></li>
<li>append 函数常见操作<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切片 b 追加到切片 a 之后：</span></span><br><span class="line">a = <span class="built_in">append</span>(a, b...)</span><br><span class="line"><span class="comment">// 复制切片 a 的元素到新的切片 b 上：</span></span><br><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line"><span class="comment">// 删除位于索引 i 的元素：</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br><span class="line"><span class="comment">// 切除切片 a 中从索引 i 至 j 位置的元素：</span></span><br><span class="line">a = apend(a[:i], a[j:]...)</span><br><span class="line"><span class="comment">// 为切片 a 拓展 j 个元素长度：</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="built_in">make</span>([]T, j)...)</span><br><span class="line"><span class="comment">// 在索引 i 的位置插入元素 x：</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]T&#123;x&#125;, a[i:]...)...)</span><br><span class="line"><span class="comment">// 在索引 i 的位置插入切片 b 的所有元素：</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(b, a[i:]...)...)</span><br><span class="line"><span class="comment">// 取出位于切片 a 最末尾的元素 x：</span></span><br><span class="line">x, a = a[<span class="built_in">len</span>(a)<span class="number">-1</span>], a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="切片和垃圾回收"><a href="#切片和垃圾回收" class="headerlink" title="切片和垃圾回收"></a>切片和垃圾回收</h3><p>切片的底层是数组，数组实际容量可能大于切片容量，只有没有任何切片指向数组时，底层数组的内存才会被释放，因此可能对导致过多内存被占用。  </p>
<hr>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p_name *p_type</span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="keyword">float32</span></span><br></pre></td></tr></table></figure>
<p><strong>指针使用：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span></span><br><span class="line">ip = &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"a 变量的地址是: %x\n"</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">"ip 变量储存的指针地址: %x\n"</span>, ip )   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">fmt.Printf(<span class="string">"*ip 变量的值: %d\n"</span>, *ip )          <span class="comment">/* 使用指针访问值 */</span></span><br></pre></td></tr></table></figure>
<p><strong>空指针：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"ptr的值为 ： %x\n"</span>), ptr)   <span class="comment">/* 空指针的值为零 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//控指针的判断：</span></span><br><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nil</span>)     <span class="comment">/* ptr 不是空指针 */</span></span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">nil</span>)    <span class="comment">/* ptr 是空指针 */</span></span><br></pre></td></tr></table></figure>
<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := []<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">200</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> ptr [MAX]*<span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>  i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">      ptr[i] = &amp;a[i] <span class="comment">/* 整数地址赋值给指针数组 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>  i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"a[%d] = %d\n"</span>, i,*ptr[i] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>一系列相同或不同类型的数据结构构成的集合。</p>
<p>组成结构体类型的数据称为<strong>字段（field）</strong>。    </p>
<h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span>&#123;</span><br><span class="line">    filed1 <span class="keyword">type</span>;</span><br><span class="line">    filed2 <span class="keyword">type</span>;</span><br><span class="line">    ...</span><br><span class="line">    filedN <span class="keyword">type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 new，会分配内存</span></span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用的初始化结构体方式：</span></span><br><span class="line">ms := &amp;struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">"Chris"</span>&#125;   <span class="comment">//是一种简写，底层仍会调用 new()，必须按顺序赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用结构体声明变量</span></span><br><span class="line">struct_name := struct_variable_type &#123;value1, value2...,valueN&#125;</span><br><span class="line">struct_name_name2 := struct_variable_type&#123;filed1: value1, filed2: value2..., filedN: valueN&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结构体成员，选择器（selector</span></span><br><span class="line">结构体.成员名</span><br><span class="line">structname.fieldname</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体名struct_name可以作为函数参数</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义指向结构体的指针</span></span><br><span class="line"><span class="keyword">var</span> struct_pointer *struct_variable_type</span><br><span class="line">struct_pointer = &amp;struct_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指针访问成员</span></span><br><span class="line">struct_pointer.keyN</span><br></pre></td></tr></table></figure>

<h3 id="使用工厂方法创建结构体实例"><a href="#使用工厂方法创建结构体实例" class="headerlink" title="使用工厂方法创建结构体实例"></a>使用工厂方法创建结构体实例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;                              <span class="comment">//定义了如下的 File 结构体类型</span></span><br><span class="line">    fd      <span class="keyword">int</span>     <span class="comment">// 文件描述符</span></span><br><span class="line">    name    <span class="keyword">string</span>  <span class="comment">// 文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;       <span class="comment">// 返回一个指向结构体实例的指针</span></span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;File&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := NewFile(<span class="number">10</span>, <span class="string">"./test.txt"</span>)                   <span class="comment">// 调用工厂方法</span></span><br></pre></td></tr></table></figure>
<p>如果想知道结构体类型T的一个实例占用了多少内存，可以使用：<code>size := unsafe.Sizeof(T{})</code>。  </p>
<p>试图 <code>make()</code> 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 <code>new()</code> 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 <code>new(Foo)</code> 返回的是一个指向 <code>nil</code> 的指针，它尚未被分配内存。所以在使用 <code>map</code> 时要特别谨慎。：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span> &#123;</span><br><span class="line">    thingOne <span class="keyword">string</span></span><br><span class="line">    thingTwo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    y := <span class="built_in">new</span>(Bar)</span><br><span class="line">    (*y).thingOne = <span class="string">"hello"</span></span><br><span class="line">    (*y).thingTwo = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NOT OK</span></span><br><span class="line">    z := <span class="built_in">make</span>(Bar) <span class="comment">// 编译错误：cannot make type Bar</span></span><br><span class="line">    (*z).thingOne = <span class="string">"hello"</span></span><br><span class="line">    (*z).thingTwo = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    x := <span class="built_in">make</span>(Foo)</span><br><span class="line">    x[<span class="string">"x"</span>] = <span class="string">"goodbye"</span></span><br><span class="line">    x[<span class="string">"y"</span>] = <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NOT OK</span></span><br><span class="line">    u := <span class="built_in">new</span>(Foo)</span><br><span class="line">    (*u)[<span class="string">"x"</span>] = <span class="string">"goodbye"</span> <span class="comment">// 运行时错误!! panic: assignment to entry in nil map</span></span><br><span class="line">    (*u)[<span class="string">"y"</span>] = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带标签的结构体"><a href="#带标签的结构体" class="headerlink" title="带标签的结构体"></a>带标签的结构体</h3><p>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 <code>reflect</code> 能获取它。 <code>reflect</code>包可以在运行时自省类型、属性和方法，比如：在一个变量上调用 <code>reflect.TypeOf()</code> 可以获取变量的正确类型，如果变量是一个结构体类型，就可以通过 Field 来索引结构体的字段，然后就可以使用 Tag 属性。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TagType <span class="keyword">struct</span> &#123; <span class="comment">// tags</span></span><br><span class="line">    field1 <span class="keyword">bool</span>   <span class="string">"An important answer"</span></span><br><span class="line">    field2 <span class="keyword">string</span> <span class="string">"The name of the thing"</span></span><br><span class="line">    field3 <span class="keyword">int</span>    <span class="string">"How much there are"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tt := TagType&#123;<span class="literal">true</span>, <span class="string">"Barak Obama"</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        refTag(tt, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refTag</span><span class="params">(tt TagType, ix <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ttType := reflect.TypeOf(tt)</span><br><span class="line">    ixField := ttType.Field(ix)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, ixField.Tag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">An important answer</span><br><span class="line">The name of the thing</span><br><span class="line">How much there are</span><br></pre></td></tr></table></figure>

<h3 id="匿名字段和内嵌结构体"><a href="#匿名字段和内嵌结构体" class="headerlink" title="匿名字段和内嵌结构体"></a>匿名字段和内嵌结构体</h3><p>结构体可以包含一个或多个 <strong>匿名（或内嵌）字段</strong>，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 <strong>结构体可以包含内嵌结构体</strong>。  </p>
<ul>
<li>当两个字段命名冲突时候：<ul>
<li>外场名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；  </li>
<li>如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。  </li>
</ul>
</li>
</ul>
<hr>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。  </p>
<p>接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：invalid receiver type…。  </p>
<p>最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。  </p>
<p>一个类型加上它的方法等价于面向对象中的一个<strong>类</strong>。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。  </p>
<p>类型 T（或 <em>T）上的所有方法的集合叫做类型 T（或 <em>T）的</em></em>方法集**。  </p>
<p>定义方法的一般格式：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果方法不需要使用 recv 的值，可以用 _ 替换它：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在方法名之前，func 关键字之后的括号中指定 receiver。  </p>
<p>如果 <code>recv</code> 是 receiver 的实例，Method1 是它的方法名，那么方法调用遵循传统的 <code>object.name</code> 选择器符号：<strong>recv.Method1()</strong>。  </p>
<p>如果 <code>recv</code> 是一个指针，Go 会自动解引用。  </p>
<h3 id="函数和方法的区别"><a href="#函数和方法的区别" class="headerlink" title="函数和方法的区别"></a>函数和方法的区别</h3><p>函数将变量作为参数：<strong>Function1(recv)</strong>  </p>
<p>方法在变量上被调用：<strong>recv.Method1()</strong>  </p>
<p><strong>receiver_type</strong> 叫做 <strong>（接收者）基本类型</strong>，这个类型必须在和方法同样的包中被声明。  </p>
<p><strong>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</strong>  </p>
<h3 id="方法和未导出字段"><a href="#方法和未导出字段" class="headerlink" title="方法和未导出字段"></a>方法和未导出字段</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md#1064-%E6%96%B9%E6%B3%95%E5%92%8C%E6%9C%AA%E5%AF%BC%E5%87%BA%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">可以建立Set方法来修改未导出的字段</a>  </p>
<h3 id="内嵌类型的方法和继承"><a href="#内嵌类型的方法和继承" class="headerlink" title="内嵌类型的方法和继承"></a>内嵌类型的方法和继承</h3><p>将父类型放在子类型中来实现亚型。<br><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md#1065-%E5%86%85%E5%B5%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="在类型中嵌入功能"><a href="#在类型中嵌入功能" class="headerlink" title="在类型中嵌入功能"></a>在类型中嵌入功能</h3><p>主要有两种方法来实现在类型中嵌入功能：  </p>
<p>A：聚合（或组合）：包含一个所需功能类型的具名字段。  </p>
<p>B：内嵌：内嵌（匿名地）所需功能类型。  </p>
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md#1066-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md#1067-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="和其他面向对象语言比较-Go-的类型和方法"><a href="#和其他面向对象语言比较-Go-的类型和方法" class="headerlink" title="和其他面向对象语言比较 Go 的类型和方法"></a>和其他面向对象语言比较 Go 的类型和方法</h3><p>在如 C++、Java、C# 和 Ruby 这样的面向对象语言中，方法在类的上下文中被定义和继承：在一个对象上调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，如果没有会导致异常发生。  </p>
<p>在 Go 语言中，这样的继承层次是完全没必要的：如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系。在这个意义上，Go 具有更大的灵活性。  </p>
<p>Go 不需要一个显式的类定义，如同 Java、C++、C# 等那样，相反地，“类”是通过提供一组作用于一个共同类型的方法集来隐式定义的。类型可以是结构体或者任何用户自定义类型。  </p>
<p><strong>总结</strong></p>
<p>在 Go 中，类型就是类（数据和关联的方法）。Go 不知道类似面向对象语言的类继承的概念。继承有两个好处：代码复用和多态。  </p>
<p>在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 <strong>组件编程（Component Programming）</strong>。  </p>
<p>许多开发者说相比于类继承，Go 的接口提供了更强大、却更简单的多态行为。  </p>
<p><strong>备注</strong></p>
<p>如果真的需要更多面向对象的能力，看一下 <a href="https://github.com/losalamos/goop" target="_blank" rel="noopener"><code>goop</code></a> 包（Go Object-Oriented Programming），它由 Scott Pakin 编写: 它给 Go 提供了 JavaScript 风格的对象（基于原型的对象），并且支持多重继承和类型独立分派，通过它可以实现你喜欢的其他编程语言里的一些结构。  </p>
<h3 id="类型的-String-方法和格式化描述符"><a href="#类型的-String-方法和格式化描述符" class="headerlink" title="类型的 String() 方法和格式化描述符"></a>类型的 String() 方法和格式化描述符</h3><p>如果类型定义了 <code>String()</code> 方法，它会被用在 <code>fmt.Printf()</code> 中生成默认的输出：等同于使用格式化描述符 <code>%v</code> 产生的输出。还有 <code>fmt.Print()</code> 和 <code>fmt.Println()</code> 也会自动使用 <code>String()</code> 方法。  </p>
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.7.md" target="_blank" rel="noopener">example</a>  </p>
<p>格式化描述符 <code>%T</code> 会给出类型的完全规格，<code>%#v</code> 会给出实例的完整输出，包括它的字段（在程序自动生成 <code>Go</code> 代码时也很有用）。  </p>
<p><strong>备注</strong></p>
<p>不要在 <code>String()</code> 方法里面调用涉及 <code>String()</code> 方法的方法，它会导致意料之外的错误，比如下面的例子，它导致了一个无限递归调用（<code>TT.String()</code> 调用 <code>fmt.Sprintf</code>，而 <code>fmt.Sprintf</code> 又会反过来调用 <code>TT.String()</code>…），很快就会导致内存溢出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TT <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t TT)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v"</span>, t)</span><br><span class="line">&#125;</span><br><span class="line">t.String()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map(集合)"></a>Map(集合)</h2><p>一种无序的键值的集合。可以迭代，不返回顺序。<br>通过key来快速检索。<br>声明时不需要知道 map 长度，map 可以动态增长。不存在固定长度或最大限制，但可以选择表明map的初始容量 <code>capacity</code>：<code>make(map[keytype]valuetype, cap)</code><br>未初始化的 map 的值是 nil。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量声明，不初始化的话，默认map是nil，nil map不能用来存放键值</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"><span class="comment">//或使用make</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//创建</span></span><br><span class="line">countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">countryCapitalMap[<span class="string">"France"</span>] = <span class="string">"Paris"</span> <span class="comment">//map插入key - value对</span></span><br><span class="line">countryCapitalMap[<span class="string">"Italy"</span>] = <span class="string">"罗马"</span></span><br><span class="line">countryCapitalMap[<span class="string">"Japan"</span>] = <span class="string">"东京"</span></span><br><span class="line">countryCapitalMap[<span class="string">"India "</span>] = <span class="string">"新德里"</span></span><br><span class="line"><span class="comment">/* 遍历输出 */</span></span><br><span class="line"><span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">    fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap[country])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 查看元素在map中是否存在 */</span></span><br><span class="line">capital, ok := countryCapitalMap[<span class="string">"美国"</span>] <span class="comment">//存在ok=true，不存在ok=false</span></span><br><span class="line">fmt.Println(capital)</span><br><span class="line">fmt.Println(ok)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"美国的首都是"</span>, capital)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"美国的首都不存在"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h3><ul>
<li><p>测试键值对  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, ok := map1[key1] <span class="comment">// 如果key1存在则ok == true，否则ok为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := map1[key1]; ok &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete()函数<br>删除Map的元素，参数为key。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(map1, key1)      <span class="comment">// 如果 key1 不存在，该操作不会产生错误。</span></span><br><span class="line"><span class="built_in">delete</span>(countryCapitalMap, <span class="string">"France"</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>for-range 用法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="用切片作为-map-的值"><a href="#用切片作为-map-的值" class="headerlink" title="用切片作为 map 的值"></a>用切片作为 map 的值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>)</span><br><span class="line">mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*[]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="map-类型的切片"><a href="#map-类型的切片" class="headerlink" title="map 类型的切片"></a>map 类型的切片</h3><p>必须用两次 <code>make()</code>，第一次分配切片，第二次分配切片中每个 map 元素：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Version A:</span></span><br><span class="line">    items := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> items &#123;</span><br><span class="line">        items[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">        items[i][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Version A: Value of items: %v\n"</span>, items)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Version B: NOT GOOD!</span></span><br><span class="line">    items2 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items2 &#123;</span><br><span class="line">        item = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// item is only a copy of the slice element.</span></span><br><span class="line">        item[<span class="number">1</span>] = <span class="number">2</span> <span class="comment">// This 'item' will be lost on the next iteration.</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Version B: Value of items: %v\n"</span>, items2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Version A: Value of items: [<span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>]]</span><br><span class="line">Version B: Value of items: [<span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[]]</span><br></pre></td></tr></table></figure>
<p>注意，应当像 A 版本那样通过索引使用切片的 map 元素。在 B 版本中获得的项只是 map 值的一个拷贝而已，所以真正的 map 元素没有得到初始化。  </p>
<h3 id="map-的排序"><a href="#map-的排序" class="headerlink" title="map 的排序"></a>map 的排序</h3><p>map 默认是无序的。<br>如要排序，要将 key（或 value）拷贝到一个切片，在对切片排序（<code>sort</code> 包），然后用切片的 for-range 方法打印 key 和 value。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    barVal = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"alpha"</span>: <span class="number">34</span>, <span class="string">"bravo"</span>: <span class="number">56</span>, <span class="string">"charlie"</span>: <span class="number">23</span>,</span><br><span class="line">                            <span class="string">"delta"</span>: <span class="number">87</span>, <span class="string">"echo"</span>: <span class="number">56</span>, <span class="string">"foxtrot"</span>: <span class="number">12</span>,</span><br><span class="line">                            <span class="string">"golf"</span>: <span class="number">34</span>, <span class="string">"hotel"</span>: <span class="number">16</span>, <span class="string">"indio"</span>: <span class="number">87</span>,</span><br><span class="line">                            <span class="string">"juliet"</span>: <span class="number">65</span>, <span class="string">"kili"</span>: <span class="number">43</span>, <span class="string">"lima"</span>: <span class="number">98</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"unsorted:"</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Key: %v, Value: %v / "</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    keys := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(barVal))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, _ := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">        keys[i] = k</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(keys)</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(<span class="string">"sorted:"</span>)</span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Key: %v, Value: %v / "</span>, k, barVal[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要一个排序的列表，最好使用结构体切片，这样更有效：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span> &#123;</span><br><span class="line">    key <span class="keyword">string</span></span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a>指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">"Hello World!"</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">string</span> = &amp;s</span><br></pre></td></tr></table></figure>
<p>为了防止内存溢出，Go 语言不允许指针算法（如： <code>pointer+2</code>），因此 <code>c = *p++</code> 是非法的。  </p>
<hr>
<h2 id="接口（Interfaces）与反射（reflection）"><a href="#接口（Interfaces）与反射（reflection）" class="headerlink" title="接口（Interfaces）与反射（reflection）"></a>接口（Interfaces）与反射（reflection）</h2><p>接口提供了一种方式来 <strong>说明</strong> 对象的行为：如果谁能搞定这件事，它就可以用在这儿。<br>接口定义了一组方法（方法集），但不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。  </p>
<p>定义接口的格式：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span>&#123;   <span class="comment">// namer 是一个接口类型</span></span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按约定，只包含一个方法的接口的名字由方法名加 <code>[e]r</code> 后缀组成，如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code>、<code>Logger</code>、<code>Converter</code> 等。  </p>
<p>类型（如结构体）实现接口方法集中的方法，每个方法的实现说明了次方法是如何作用于该类型的： <strong>即实现接口</strong>，同时方法集也构成了该类型的接口。  </p>
<p><strong>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口</strong>。  </p>
<p><strong>实现某个接口的类型（除了实现接口方法外）可以有其他的方法</strong>。  </p>
<p><strong>一个类型可以实现多个接口</strong>。  </p>
<p><strong>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）</strong>。  </p>
<p>即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。  </p>
<p>所有这些特性使得接口具有很大的灵活性。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    areaIntf = sq1      <span class="comment">// 赋值给接口类型变量</span></span><br><span class="line">    <span class="comment">// or:</span></span><br><span class="line">    <span class="comment">// areaIntf := Shaper(sq1)</span></span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    <span class="comment">// areaIntf := sq1</span></span><br><span class="line">    fmt.Printf(<span class="string">"The square has area: %f\n"</span>, areaIntf.Area())</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">float32</span> = sq1.Area()</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 <strong>多态</strong> 的 Go 版本，多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    length, width <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.length * r.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    r := Rectangle&#123;<span class="number">5</span>, <span class="number">3</span>&#125; <span class="comment">// Area() of Rectangle needs a value</span></span><br><span class="line">    q := &amp;Square&#123;<span class="number">5</span>&#125;      <span class="comment">// Area() of Square needs a pointer</span></span><br><span class="line">    <span class="comment">// shapes := []Shaper&#123;Shaper(r), Shaper(q)&#125;</span></span><br><span class="line">    <span class="comment">// or shorter</span></span><br><span class="line">    shapes := []Shaper&#123;r, q&#125;</span><br><span class="line">    fmt.Println(<span class="string">"Looping through shapes for area ..."</span>)</span><br><span class="line">    <span class="keyword">for</span> n, _ := <span class="keyword">range</span> shapes &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Shape details: "</span>, shapes[n])</span><br><span class="line">        fmt.Println(<span class="string">"Area of this shape is: "</span>, shapes[n].Area())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h3><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="keyword">bool</span></span><br><span class="line">    Write(b Buffer) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型断言：如何检测和转换接口变量的类型"><a href="#类型断言：如何检测和转换接口变量的类型" class="headerlink" title="类型断言：如何检测和转换接口变量的类型"></a>类型断言：如何检测和转换接口变量的类型</h3><p>一个接口类型的变量 <code>varI</code> 中可以包含任何类型的值，必须有一种方式来检测它的 <strong>动态</strong> 类型，即运行时在变量中存储的值的实际类型。通常我们可以使用 <strong>类型断言</strong> 来测试在某个时刻 <code>varI</code> 是否包含类型 <code>T</code> 的值：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := varI.(T)       <span class="comment">// unchecked type assertion</span></span><br></pre></td></tr></table></figure>
<p><strong>varI 必须是一个接口变量</strong>，否则编译器会报错：<code>invalid type assertion: varI.(T) (non-interface type (type of varI) on left)</code> 。  </p>
<p>类型断言可能是无效的，更安全的方式是使用以下形式来进行类型断言：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// checked type assertion</span></span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// varI is not of type T</span></span><br></pre></td></tr></table></figure>
<p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；  </p>
<p>否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误(panic)发生。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">hello</span><br><span class="line">hello <span class="literal">true</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="built_in">panic</span>: <span class="keyword">interface</span> conversion: <span class="keyword">interface</span> &#123;&#125; is <span class="keyword">string</span>, not <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">    /tmp/sandbox319904390/main.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0x220</span></span><br></pre></td></tr></table></figure>


<p><strong>应该总是使用上面的方式来进行类型断言</strong>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// Is Square the type of areaIntf?</span></span><br><span class="line">    <span class="keyword">if</span> t, ok := areaIntf.(*Square); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"The type of areaIntf is: %T\n"</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u, ok := areaIntf.(*Circle); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"The type of areaIntf is: %T\n"</span>, u)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"areaIntf does not contain a variable of type Circle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ci.radius * ci.radius * math.Pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型判断（选择）：type-switch"><a href="#类型判断（选择）：type-switch" class="headerlink" title="类型判断（选择）：type-switch"></a>类型判断（选择）：type-switch</h3><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type。</code>  </p>
<p>接口变量的类型也可以使用一种特殊形式的 <code>switch</code> 来检测：<strong>type-switch</strong> ：<br>eg1：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := areaIntf.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Square:</span><br><span class="line">    fmt.Printf(<span class="string">"Type Square %T with value %v\n"</span>, t, t)</span><br><span class="line"><span class="keyword">case</span> *Circle:</span><br><span class="line">    fmt.Printf(<span class="string">"Type Circle %T with value %v\n"</span>, t, t)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"nil value: nothing to check?\n"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"Unexpected type %T\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Type Square *main.Square with value &amp;&#123;<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>eg2：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">"hello"</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Twice <span class="number">21</span> is <span class="number">42</span></span><br><span class="line"><span class="string">"hello"</span> is <span class="number">5</span> bytes long</span><br><span class="line">I don<span class="string">'t know about type bool!</span></span><br></pre></td></tr></table></figure>
<p>变量 <code>t</code> 得到了 <code>areaIntf</code> 的值和类型， 所有 <code>case</code> 语句中列举的类型（<code>nil</code> 除外）都必须实现对应的接口（在上例中即 <code>Shaper</code>），如果被检测类型没有在 <code>case</code> 语句列举的类型中，就会执行 <code>default</code> 语句。  </p>
<p>可以用 <code>type-switch</code> 进行运行时类型分析，但是在 <code>type-switch</code> 不允许有 <code>fallthrough</code> 。  </p>
<p>如果仅仅是测试变量的类型，不用它的值，那么就可以不需要赋值语句，比如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> areaIntf.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Square:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line"><span class="keyword">case</span> *Circle:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码片段展示了一个类型分类函数，它有一个可变长度参数，可以是任意类型的数组，它会根据数组元素的实际类型执行不同的动作：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a bool\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a float64\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a int\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a nil\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a string\n"</span>, i)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is unknown\n"</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样调用此方法：<code>classifier(13, -14.3, &quot;BELGIUM&quot;, complex(1, 2), nil, false)</code> 。  </p>
<p>在处理来自于外部的、类型未知的数据时，比如解析诸如 JSON 或 XML 编码的数据，类型测试和转换会非常有用。  </p>
<h3 id="测试一个值是否实现了某个接口"><a href="#测试一个值是否实现了某个接口" class="headerlink" title="测试一个值是否实现了某个接口"></a>测试一个值是否实现了某个接口</h3><p>假定 <code>v</code> 是一个值，然后我们想测试它是否实现了 <code>Stringer</code> 接口，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sv, ok := v.(Stringer); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"v implements String(): %s\n"</span>, sv.String()) <span class="comment">// note: sv, not v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是<strong>多态的本质</strong>。  </p>
<p>编写参数是接口变量的函数，这使得它们更具有一般性。  </p>
<p><strong>使用接口使代码更具有普适性。</strong>  </p>
<h3 id="使用方法集与接口"><a href="#使用方法集与接口" class="headerlink" title="使用方法集与接口"></a>使用方法集与接口</h3><p>作用于变量上的方法实际上是不区分变量到底是指针还是值的。当碰到接口类型值时，这会变得有点复杂，原因是接口变量中存储的具体值是不可寻址的，幸运的是，如果使用不当编译器会给出错误。  </p>
<p><strong>总结</strong>  </p>
<p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 <code>P</code> 直接可以辨识的：  </p>
<ul>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ul>
<p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。  </p>
<p><strong>译注</strong>  </p>
<p>Go 语言规范定义了接口方法集的调用规则：  </p>
<ul>
<li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li>
<li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li>
<li>类型 T 的可调用方法集不包含接受者为 *T 的方法  </li>
</ul>
<h3 id="第一个例子：使用-Sorter-接口排序"><a href="#第一个例子：使用-Sorter-接口排序" class="headerlink" title="第一个例子：使用 Sorter 接口排序"></a>第一个例子：使用 Sorter 接口排序</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.7.md" target="_blank" rel="noopener">The way to go 参考内容</a>  </p>
<h3 id="第二个例子：读和写"><a href="#第二个例子：读和写" class="headerlink" title="第二个例子：读和写"></a>第二个例子：读和写</h3><p><code>io</code> 包提供了用于读和写的接口 <code>io.Reader</code> 和 <code>io.Writer</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个对象要是可读的，它必须实现 <code>io.Reader</code> 接口，这个接口只有一个签名是 <code>Read(p []byte) (n int, err error)</code> 的方法，它从调用它的对象上读取数据，并把读到的数据放入参数中的字节切片中，然后返回读取的字节数和一个 <code>error</code> 对象，如果没有错误发生返回 <code>nil</code>，如果已经到达输入的尾端，会返回 <code>io.EOF(&quot;EOF&quot;)</code>，如果读取的过程中发生了错误，就会返回具体的错误信息。类似地，一个对象要是可写的，它必须实现 <code>io.Writer</code> 接口，这个接口也只有一个签名是 <code>Write(p []byte) (n int, err error)</code> 的方法，它将指定字节切片中的数据写入调用它的对象里，然后返回实际写入的字节数和一个 <code>error</code> 对象（如果没有错误发生就是 <code>nil</code>）。  </p>
<p><code>io</code> 包里的 <code>Readers</code> 和 <code>Writers</code> 都是不带缓冲的，<code>bufio</code> 包里提供了对应的带缓冲的操作，在读写 <code>UTF-8</code> 编码的文本文件时它们尤其有用。  </p>
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.8.md" target="_blank" rel="noopener">The way to go 参考内容</a>  </p>
<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p><strong>空接口或者最小接口</strong> 不包含任何方法，它对实现不做任何要求：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>任何其他类型都实现了空接口，<code>any</code> 或 <code>Any</code> 是空接口一个很好的别名或缩写。  </p>
<p>可以给一个空接口类型的变量 <code>var val interface {}</code> 赋任何类型的值。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val Any</span><br><span class="line">    val = <span class="number">5</span></span><br><span class="line">    fmt.Printf(<span class="string">"val has the value: %v\n"</span>, val)</span><br><span class="line">    val = str</span><br><span class="line">    fmt.Printf(<span class="string">"val has the value: %v\n"</span>, val)</span><br><span class="line">    pers1 := <span class="built_in">new</span>(Person)</span><br><span class="line">    pers1.name = <span class="string">"Rob Pike"</span></span><br><span class="line">    pers1.age = <span class="number">55</span></span><br><span class="line">    val = pers1</span><br><span class="line">    fmt.Printf(<span class="string">"val has the value: %v\n"</span>, val)</span><br><span class="line">    <span class="keyword">switch</span> t := val.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Type int %T\n"</span>, t)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Type string %T\n"</span>, t)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Type boolean %T\n"</span>, t)</span><br><span class="line">    <span class="keyword">case</span> *Person:</span><br><span class="line">        fmt.Printf(<span class="string">"Type pointer to Person %T\n"</span>, t)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Unexpected type %T"</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">val has the value: <span class="number">5</span></span><br><span class="line">val has the value: ABC</span><br><span class="line">val has the value: &amp;&#123;Rob Pike <span class="number">55</span>&#125;</span><br><span class="line">Type pointer to Person *main.Person</span><br></pre></td></tr></table></figure>
<p>空接口在 <code>type-switch</code> 中联合 <code>lambda</code> 函数的用法：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> specialString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> whatIsThis specialString = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeSwitch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testFunc := <span class="function"><span class="keyword">func</span><span class="params">(any <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> v := any.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is a bool type"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is an int type"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is a float32 type"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is a string type"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> specialString:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is a special String!"</span>, v)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"unknown type!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    testFunc(whatIsThis)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    TypeSwitch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">any hello is a special String!</span><br></pre></td></tr></table></figure>
<h3 id="构建通用类型或包含不同类型变量的数组"><a href="#构建通用类型或包含不同类型变量的数组" class="headerlink" title="构建通用类型或包含不同类型变量的数组"></a>构建通用类型或包含不同类型变量的数组</h3><p>通过使用空接口。让我们给空接口定一个别名类型 <code>Element</code>：<code>type Element interface{}</code><br>然后定义一个容器类型的结构体 <code>Vector</code>，它包含一个 <code>Element</code> 类型元素的切片：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector <span class="keyword">struct</span> &#123;</span><br><span class="line">    a []Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vector</code> 里能放任何类型的变量，因为任何类型都实现了空接口，实际上 <code>Vector</code> 里放的每个元素可以是不同类型的变量。我们为它定义一个 <code>At()</code> 方法用于返回第 <code>i</code> 个元素：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span> <span class="title">At</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Element</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定一个 <code>Set()</code> 方法用于设置第 <code>i</code> 个元素的值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span> <span class="title">Set</span><span class="params">(i <span class="keyword">int</span>, e Element)</span></span> &#123;</span><br><span class="line">    p.a[i] = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vector</code> 中存储的所有元素都是 <code>Element</code> 类型，要得到它们的原始类型（unboxing：拆箱）需要用到类型断言。  </p>
<h3 id="复制数据切片至空接口切片"><a href="#复制数据切片至空接口切片" class="headerlink" title="复制数据切片至空接口切片"></a>复制数据切片至空接口切片</h3><p>假设你有一个 <code>myType</code> 类型的数据切片，你想将切片中的数据复制到一个空接口切片中，必须使用 <code>for-range</code> 语句来一个一个显式地复制：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通用类型的节点数据结构"><a href="#通用类型的节点数据结构" class="headerlink" title="通用类型的节点数据结构"></a>通用类型的节点数据结构</h3><p>[The way to Go 参考内容]（<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.9.md#1194-%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84）" target="_blank" rel="noopener">https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.9.md#1194-%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84）</a>  </p>
<h3 id="接口到接口"><a href="#接口到接口" class="headerlink" title="接口到接口"></a>接口到接口</h3><p>[The way to Go 参考内容]（<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.9.md#1195-%E6%8E%A5%E5%8F%A3%E5%88%B0%E6%8E%A5%E5%8F%A3）" target="_blank" rel="noopener">https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.9.md#1195-%E6%8E%A5%E5%8F%A3%E5%88%B0%E6%8E%A5%E5%8F%A3）</a>  </p>
<h3 id="反射包"><a href="#反射包" class="headerlink" title="反射包"></a>反射包</h3><p>反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。反射可以在运行时检查类型和变量，例如它的大小、方法和 <code>动态</code><br>的调用这些方法。这对于没有源代码的包尤其有用。这是一个强大的工具，除非真得有必要，否则应当避免使用或小心使用。  </p>
<p>变量的最基本信息就是类型和值：反射包的 <code>Type</code> 用来表示一个 Go 类型，反射包的 <code>Value</code> 为 Go 值提供了反射接口。 </p>
<p>实际上，反射是通过检查一个接口的值，变量首先被转换成空接口:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure>

<p>reflect.Type 和 reflect.Value 都有许多方法用于检查和操作它们。一个重要的例子是 Value 有一个 Type 方法返回 reflect.Value 的 Type。另一个是 Type 和 Value 都有 Kind 方法返回一个常量来表示类型：Uint、Float64、Slice 等等。同样 Value 有叫做 Int 和 Float 的方法可以获取存储在内部的值（跟 int64 和 float64 一样）  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span></span><br><span class="line">    Bool</span><br><span class="line">    Int</span><br><span class="line">    Int8</span><br><span class="line">    Int16</span><br><span class="line">    Int32</span><br><span class="line">    Int64</span><br><span class="line">    Uint</span><br><span class="line">    Uint8</span><br><span class="line">    Uint16</span><br><span class="line">    Uint32</span><br><span class="line">    Uint64</span><br><span class="line">    Uintptr</span><br><span class="line">    Float32</span><br><span class="line">    Float64</span><br><span class="line">    Complex64</span><br><span class="line">    Complex128</span><br><span class="line">    Array</span><br><span class="line">    Chan</span><br><span class="line">    Func</span><br><span class="line">    Interface</span><br><span class="line">    Map</span><br><span class="line">    Ptr</span><br><span class="line">    Slice</span><br><span class="line">    String</span><br><span class="line">    Struct</span><br><span class="line">    UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于 float64 类型的变量 x，如果 <code>v:=reflect.ValueOf(x)</code>，那么 <code>v.Kind()</code> 返回 <code>reflect.Float64</code> ，所以下面的表达式是 <code>true</code><br><code>v.Kind() == reflect.Float64</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kind 总是返回底层类型：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> m MyInt = <span class="number">5</span></span><br><span class="line">v := reflect.ValueOf(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法 `v.Kind()` 返回 `reflect.Int`。</span></span><br></pre></td></tr></table></figure>
<p>变量 v 的 <code>Interface()</code> 方法可以得到还原（接口）值，所以可以这样打印 v 的值：<code>fmt.Println(v.Interface())</code>  </p>
<p>eg.  </p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var x float64 = <span class="number">3.4</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"type:"</span>, reflect.TypeOf(x))     <span class="comment">// type: float64</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"value:"</span>, v)                    <span class="comment">// value: 3.4</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"type:"</span>, v.Type())              <span class="comment">// type: float64</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"kind:"</span>, v.Kind())              <span class="comment">// kind: float64</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"value:"</span>, v.<span class="keyword">Float</span>())            <span class="comment">// value: 3.4</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(v.<span class="keyword">Interface</span>())                  <span class="comment">// 3.4</span></span><br><span class="line">    fmt.Printf(<span class="string">"value is %5.2e\n"</span>, v.<span class="keyword">Interface</span>())   <span class="comment">// value is 3.40e+00</span></span><br><span class="line">    y := v.<span class="keyword">Interface</span>().(float64)</span><br><span class="line">    fmt.<span class="keyword">Println</span>(y)                              <span class="comment">// 3.4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过反射修改（设置）值：</strong>  </p>
<p>假设我们要把 x 的值改为 3.1415。Value 有一些方法可以完成这个任务，但是必须小心使用：<code>v.SetFloat(3.1415)</code>。</p>
<p>这将产生一个错误：<code>reflect.Value.SetFloat using unaddressable value</code>。</p>
<p>问题的原因是 v 不是可设置的（这里并不是说值不可寻址）。是否可设置是 Value 的一个属性，并且不是所有的反射值都有这个属性：可以使用 <code>CanSet()</code> 方法测试是否可设置。</p>
<p>在例子中我们看到 <code>v.CanSet()</code> 返回 false： <code>settability of v: false</code></p>
<p>当 <code>v := reflect.ValueOf(x)</code> 函数通过传递一个 x 拷贝创建了 v，那么 v 的改变并不能更改原始的 x。要想 v 的更改能作用到 x，那就必须传递 x 的地址 <code>v = reflect.ValueOf(&amp;x)</code>。</p>
<p>通过 Type() 我们看到 v 现在的类型是 <code>*float64</code> 并且仍然是不可设置的。</p>
<p>要想让其可设置我们需要使用 <code>Elem()</code> 函数，这间接的使用指针：<code>v = v.Elem()</code></p>
<p>现在 <code>v.CanSet()</code> 返回 true 并且 <code>v.SetFloat(3.1415)</code> 设置成功了！</p>
<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    <span class="comment">// setting a value:</span></span><br><span class="line">    <span class="comment">// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())        <span class="comment">// settability of v: false</span></span><br><span class="line">    v = reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">    fmt.Println(<span class="string">"type of v:"</span>, v.Type())             <span class="comment">// type of v: *float64</span></span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())    <span class="comment">// settability of v: false</span></span><br><span class="line">    v = v.Elem()</span><br><span class="line">    fmt.Println(<span class="string">"The Elem of v is: "</span>, v)        <span class="comment">// The Elem of v is:  &lt;float64 Value&gt;</span></span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())    <span class="comment">// settability of v: true</span></span><br><span class="line">    v.SetFloat(<span class="number">3.1415</span>) <span class="comment">// this works!</span></span><br><span class="line">    fmt.Println(v.Interface())      <span class="comment">// 3.1415</span></span><br><span class="line">    fmt.Println(v)      <span class="comment">// &lt;float64 Value&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射中有些内容是需要用地址去改变它的状态的。  </p>
<p><strong>反射结构：</strong>  </p>
<p>有些时候需要反射一个结构类型。<code>NumField()</code> 方法返回结构内的字段数量；通过一个 for 循环用索引取得每个字段的值 <code>Field(i)</code>。  </p>
<p>我们同样能够调用签名在结构上的方法，例如，使用索引 n 来调用：<code>Method(n).Call(nil)</code>。  </p>
<p>eg.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NotknownType <span class="keyword">struct</span> &#123;</span><br><span class="line">    s1, s2, s3 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NotknownType)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n.s1 + <span class="string">" - "</span> + n.s2 + <span class="string">" - "</span> + n.s3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// variable to investigate:</span></span><br><span class="line"><span class="keyword">var</span> secret <span class="keyword">interface</span>&#123;&#125; = NotknownType&#123;<span class="string">"Ada"</span>, <span class="string">"Go"</span>, <span class="string">"Oberon"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    value := reflect.ValueOf(secret) <span class="comment">// &lt;main.NotknownType Value&gt;</span></span><br><span class="line">    typ := reflect.TypeOf(secret)    <span class="comment">// main.NotknownType</span></span><br><span class="line">    <span class="comment">// alternative:</span></span><br><span class="line">    <span class="comment">//typ := value.Type()  // main.NotknownType</span></span><br><span class="line">    fmt.Println(typ)</span><br><span class="line">    knd := value.Kind() <span class="comment">// struct</span></span><br><span class="line">    fmt.Println(knd)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate through the fields of the struct:</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; value.NumField(); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Field %d: %v\n"</span>, i, value.Field(i))</span><br><span class="line">        <span class="comment">// error: panic: reflect.Value.SetString using value obtained using unexported field</span></span><br><span class="line">        <span class="comment">//value.Field(i).SetString("C#")</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the first method, which is String():</span></span><br><span class="line">    results := value.Method(<span class="number">0</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(results) <span class="comment">// [Ada - Go - Oberon]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果尝试更改一个值，会得到一个错误：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>: reflect.Value.SetString using value obtained using unexported field</span><br></pre></td></tr></table></figure>

<p>这是因为结构中只有被导出字段（首字母大写）才是可设置的  </p>
<p>eg2.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">    s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    typeOfT := s.Type()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">        f := s.Field(i)</span><br><span class="line">        fmt.Printf(<span class="string">"%d: %s %s = %v\n"</span>, i,</span><br><span class="line">            typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">    &#125;</span><br><span class="line">    s.Field(<span class="number">0</span>).SetInt(<span class="number">77</span>)</span><br><span class="line">    s.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"t is now"</span>, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">0</span>: A <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line"><span class="number">1</span>: B <span class="keyword">string</span> = skidoo</span><br><span class="line">t is now &#123;<span class="number">77</span> Sunset Strip&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Printf-和反射"><a href="#Printf-和反射" class="headerlink" title="Printf 和反射"></a>Printf 和反射</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.11.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="接口与动态类型"><a href="#接口与动态类型" class="headerlink" title="接口与动态类型"></a>接口与动态类型</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.12.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="总结：Go-中的面向对象"><a href="#总结：Go-中的面向对象" class="headerlink" title="总结：Go 中的面向对象"></a>总结：Go 中的面向对象</h3><p>Go 没有类，而是松耦合的类型、方法对接口的实现。  </p>
<p>OO 语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？  </p>
<ul>
<li><p>封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层（参见 4.2 节的可见性规则）:  </p>
<p>  1）包范围内的：通过标识符首字母小写，<code>对象</code> 只在它所在的包内可见  </p>
<p>  2）可导出的：通过标识符首字母大写，<code>对象</code> 对所在包以外也可见  </p>
</li>
</ul>
<p>类型只拥有自己所在包中定义的方法。  </p>
<ul>
<li>继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现  </li>
<li>多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。  </li>
</ul>
<hr>
<h1 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h1><h2 id="strings-包"><a href="#strings-包" class="headerlink" title="strings 包"></a><code>strings</code> 包</h2><p>Go 中使用 <code>strings</code> 包对字符串进行操作。  </p>
<h3 id="前、后缀"><a href="#前、后缀" class="headerlink" title="前、后缀"></a>前、后缀</h3><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.HasSuffix(s, suffix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h3><p><code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code> :  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Contains(s, substr <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<h3 id="索引字符串位置"><a href="#索引字符串位置" class="headerlink" title="索引字符串位置"></a>索引字符串位置</h3><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的第一次出现的索引（<code>str</code> 的第一个字符的索引），<br>返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Index(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p><code>LastIndex</code> 返回 <code>str</code> 在 <code>s</code> 中最后出现的所有（第一个字符），<br>返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.LastIndex(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>建议用 <code>IndexRune</code> 查询非 ASCII 编码的字符在字符串中的位置（返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：  ）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.IndexRune(s <span class="keyword">string</span>, r <span class="keyword">rune</span>) <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line">strings.IndexRune(<span class="string">"chicken"</span>, <span class="number">99</span>)</span><br><span class="line">strings.IndexRune(<span class="string">"chicken"</span>, <span class="keyword">rune</span>(<span class="string">'k'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并范围一个新的字符串，如果 <code>n = -1</code> 啧替换所有有 <code>old</code> 为 <code>new</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Replace(str, old, <span class="built_in">new</span>, n) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h3 id="统计字符串出现的次数"><a href="#统计字符串出现的次数" class="headerlink" title="统计字符串出现的次数"></a>统计字符串出现的次数</h3><p><code>Count</code> 用于统计字符串 <code>str</code> 中字符串 <code>s</code> 出现的非重叠次数：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Count(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<h3 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h3><p><code>Repeat</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Repeat(s, count <span class="keyword">int</span>) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h3 id="修改字符串大小写"><a href="#修改字符串大小写" class="headerlink" title="修改字符串大小写"></a>修改字符串大小写</h3><p><code>ToLower</code> 讲字符串中的 Unicode 字符全部转换为相应的小写字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Tolower(s) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p><code>ToUpper</code> 讲字符串中的 Unicode 字符全部转换为相应的大写字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.ToUpper(s) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h3 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h3><p><code>strings.TrimSpace(s)</code> 用于剔除字符串开头和结尾的空白符号；<br><code>strings.Trim(s, &quot;cut&quot;)</code> 用于剔除字符串开头和结尾的 <code>cut</code>；<br><code>TrimLeft</code> 或者 <code>TrimRight</code> 用于只剔除开头或结尾的字符串。  </p>
<h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p><code>strings.Fields(s)</code> 会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice。<br><code>strings.Split(s, sep)</code> 用于自定义分割符号来对指定字符串进行分割，同样范围 slice。<br>因为这 2 个函数都会返回 slice，所以习惯使用 for - range 循环来对其进行处理。  </p>
<h3 id="拼接-slice-到字符串"><a href="#拼接-slice-到字符串" class="headerlink" title="拼接 slice 到字符串"></a>拼接 slice 到字符串</h3><p><code>Join</code> 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Join(sl [<span class="keyword">string</span>], sep <span class="keyword">string</span>) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h3 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h3><p><code>strings.NewReader(str)</code> 用于生成一个 ‘Reader’ 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其他类型读取内容的函数还有：<br><code>Read</code> 从 []byte 中读取内容；<br><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 byte 或者 rune。  </p>
<p>其他有关字符串操作的文档参考 <a href="http://golang.org/pkg/strings/" target="_blank" rel="noopener">官方文档</a> 或 <a href="http://docs.studygolang.com/pkg/strings/" target="_blank" rel="noopener">国内访问文档</a>。</p>
<hr>
<h2 id="Strconv-包"><a href="#Strconv-包" class="headerlink" title="Strconv 包"></a><code>Strconv</code> 包</h2><p>与字符串相关的类型转换。<br>包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：<code>strconv.IntSize</code>。<br>任何类型 T 转换为字符串总是成功的。<br>数字 → 字符串：</p>
<ul>
<li><code>strconv.Itoa(i int) string</code> 返回数字 i 所表示的字符串类型的十进制数。  </li>
<li><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code> 将64位浮点型数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>b</code>、<code>e</code>、<code>f</code> 或 <code>g</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示 float32，用 64 表示 float64。  </li>
</ul>
<p>将字符串转换为其他类型 tp 并不总是可能的，可能会在运行时抛出错误 <code>parsing &quot;…&quot;: invalid argument</code>。<br>字符串 → 数字类型：  </p>
<ul>
<li><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 int 型。  </li>
<li><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 float64 型。  </li>
</ul>
<p>利用多个返回值的特性（第 1 个是转换后的结果（若成功），第 2 个是可能出现的错误），一般使用如下形式进行从字符串到其它类型的转换：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">val, err = strconv.Atoi(s)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="time-包：时间和日期"><a href="#time-包：时间和日期" class="headerlink" title="time 包：时间和日期"></a><code>time</code> 包：时间和日期</h2><p><code>time</code> 包提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数。<br>获取当前时间：<code>time.Now()</code>；  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t time.Time = time.Now()</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">t := time.Now()</span><br></pre></td></tr></table></figure>
<p>获取时间的一部分： <code>t.Day</code>、<code>t.Minute()</code>…<br>自定义时间格式化字符串：eg.<code>fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>08.03.2019</code><br>Duration 类型表示两个连续时刻所相差的<strong>纳秒数</strong>，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。<br>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个t转换为相应格式的字符串，你可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println((t.Format(<span class="string">"02 Jan 2006 15:04"</span>)))</span><br></pre></td></tr></table></figure>
<p>如果需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 <code>time.After</code> 或者 <code>time.Ticker</code>。<br>另外，<code>time.Sleep(Duration d)</code> 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。<br>其他关于时间操作的文档参考 <a href="http://golang.org/pkg/time/" target="_blank" rel="noopener">官方文档</a> 或 <a href="http://docs.studygolang.com/pkg/time/" target="_blank" rel="noopener">国内访问页面</a>。  </p>
<hr>
<h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><h2 id="if-else-结构"><a href="#if-else-结构" class="headerlink" title="if-else 结构"></a>if-else 结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if</span></span><br><span class="line"><span class="keyword">if</span> condition&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else...</span></span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些例子：  </p>
<ol>
<li>判断一个字符串是否为空：</li>
</ol>
<ul>
<li><code>if str == &quot;&quot; {...}</code></li>
<li><code>if len(str) == 0 {...}</code></li>
</ul>
<ol start="2">
<li>判断运行 Go 程序的操作系统类型，这可以通过常量 <code>runtime.GOOS</code> 来判断。  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码一般被放在 init() 函数中执行。 如以下示例演示如何根据操作系统来决定输入结束时的提示：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prompt = <span class="string">"Enter a digit, e.g. 3 "</span>+ <span class="string">"or %s to quit."</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> runtime.GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">        prompt = fmt.Sprintf(prompt, <span class="string">"Ctrl+Z, Enter"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// Unix-like</span></span><br><span class="line">        prompt = fmt.Sprintf(prompt, <span class="string">"Ctrl+D"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数 <code>Abs()</code> 用于返回一个整型数字的绝对值：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>isGrater</code> 用来比较两个整型数字的大小：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isGreater</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
if 可以包含一个初始化语句（如：给变量赋值），初始化语句后方必须加分号：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> val := <span class="number">10</span>; val &gt; max &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意 <code>:=</code> 声明的变量作用于仅在 if 结构中。如果变量在 if 结构之前就已经存在，那么在 if 结构中该变量原来的值会被隐藏。  <h3 id="comma-ok模式（pattern）"><a href="#comma-ok模式（pattern）" class="headerlink" title="comma,ok模式（pattern）"></a>comma,ok模式（pattern）</h3>Go 语言中函数经常用两个返回值来表示是否执行成功：返回某个值以及 true 表示成功；返回零值（或 nil）和 false 表示失败。也可以使用 error 类型的变量来代替第二个返回值：成功执行的话，error 的值为 nil，否则就会包含相应的错误信息。  </li>
</ol>
<p><strong>习惯用法</strong>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, err := pack1.Function1(param1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"An error occured in pack1.Function1 with parameter %v"</span>, param1)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未发生错误，继续执行：</span></span><br><span class="line"><span class="comment">// 由于本例的函数调用者属于 main 函数，所以程序会直接停止运行。</span></span><br></pre></td></tr></table></figure>
<p>如果要在错误发生的同时终止程序的运行，可以使用 <code>os</code> 包的 <code>Exit</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Program stopping with error %v"</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// （此处的退出代码 1 可以使用外部脚本获取到）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有错误发生时，代码继续运行就是唯一要做的事情，所以 if 语句块后面不需要使用 else 分支。  </p>
<h2 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line"><span class="keyword">case</span> val1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> val2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试多个可能符合条件的值，使用逗号分隔，例如： <code>case val1, val2, val3</code>。  </li>
<li>每个 <code>case</code> 分支都是唯一的，从上至下逐一测试，直到匹配为止。  </li>
<li>一旦成功匹配某个分支，在执行完相应代码后就会退出整个 switch 代码块，所以不用 <code>break</code>。  </li>
<li>如果执行完 <code>case</code> 后还需要继续执行后续分支的代码，要使用 <code>fallthrough</code>。  </li>
<li>可以用 <code>return</code> 语句来提前结束代码块的执行。（还要时刻确保函数始终有返回值，switch 后再添加相应 <code>return</code>）  </li>
<li><code>switch</code> 后也可不跟变量，<code>case</code> 后跟 condition，用起来像链式 if-else。  </li>
<li><code>switch</code> 后也可跟一个初始化语句，需要加分号 <code>;</code>。 </li>
</ul>
<h2 id="for-结构"><a href="#for-结构" class="headerlink" title="for 结构"></a>for 结构</h2><h3 id="计数器形式"><a href="#计数器形式" class="headerlink" title="计数器形式"></a>计数器形式</h3><p>基本形式：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始化语句; 条件语句; 修饰语句 &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特别注意，永远不要在循环体内修改计数器！  </li>
</ul>
<p>同时使用多个计数器：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, N; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件判断的迭代形式"><a href="#条件判断的迭代形式" class="headerlink" title="条件判断的迭代形式"></a>条件判断的迭代形式</h3><p>基本形式：<code>for 条件语句 {}</code>  </p>
<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>基本形式：<code>for {}</code>  </p>
<ul>
<li>需要循环内用 <code>break</code> 或 <code>return</code> 退出循环体。（<code>break</code> 只是退出循环体，<code>return</code> 是提前对函数进行返回，不会执行后续代码）  </li>
<li>无限循环的经典应用是服务器，用于<strong>不断等待</strong>和<strong>接受新的请求</strong>：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t, err = p.Token(); err == <span class="literal">nil</span>; t, err = p.Token() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-range-结构"><a href="#for-range-结构" class="headerlink" title="for-range 结构"></a>for-range 结构</h3>用于迭代任何一个集合（数组、map）。<br>一般形式：<code>for ix, val := range coll {...}</code>  </li>
<li>需要注意，val始终是集合中索引的值的拷贝，对它修改不会影响集合内原值（除非 <code>val</code> 为指针）。  </li>
<li>一个字符串是 Unicode 编码的字符（或称之为 <code>rune</code>）集合，因此可可以用它迭代字符串：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Break-与-continue"><a href="#Break-与-continue" class="headerlink" title="Break 与 continue"></a>Break 与 continue</h2></li>
<li>一个 break 的作用范围是该语句出现后的最内部的结构。（只会跳出最内层循环）  </li>
<li>关键词 continue 忽略剩余循环体直接进入下一次循环过程，执行下次循环前需要判断循环条件。  </li>
<li>continue 只能用于 for 循环中。  </li>
</ul>
<h2 id="标签与-goto"><a href="#标签与-goto" class="headerlink" title="标签与 goto"></a>标签与 goto</h2><ul>
<li>标签名称是大小写敏感的，一般建议全用大写字母。  </li>
<li>配合 goto 跳出多层循环或模拟循环。  </li>
<li>不鼓励使用标签和 goto，会导致糟糕的程序设计，可被更可读的方案替代。 </li>
<li>一定要用的话，只使用正序的标签（先 goto，后标签），且两者间不能出现新的定义变量语句！  </li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>Go 中不允许函数重载（function overloading，指可以编写多个同名函数）。  </li>
<li>如果需要声明一个在外部定义的函数，只要给出函数名与函数签名，不用给出函数体：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flushICache</span><span class="params">(begin, end <span class="keyword">uintptr</span>)</span>    // <span class="title">implemented</span> <span class="title">externally</span></span></span><br></pre></td></tr></table></figure></li>
<li>函数可以被作为类型来声明使用：  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> binOp <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="传参和返回"><a href="#传参和返回" class="headerlink" title="传参和返回"></a>传参和返回</h2><ul>
<li>分按值传递（call by value） 按引用传递（call by reference）。  </li>
<li>几乎在任何情况下，传递指针的消耗比传递副本来的少。  </li>
<li>在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。</li>
<li>如果函数要返回四到五个值，可以传递一个切片给函数（如果返回值具有相同类型）或者是传递一个结构体（如果返回值具有不同的类型）。因为传递一个指针允许直接修改变量的值，消耗也更少。</li>
</ul>
<h2 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h2><ul>
<li>变参函数：函数最有一个参数采用 <code>...type</code> 的形式。函数接受某个类型的 slice 的参数。  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(a, b, arg ...<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>解决边长参数不是相同类型的方法：（1）使用结构；（2）使用空接口。  </li>
</ul>
<h2 id="defer-和追踪"><a href="#defer-和追踪" class="headerlink" title="defer 和追踪"></a>defer 和追踪</h2><ul>
<li>关键词 defer 让我们推迟到函数返回之前（或任意位置执行 <code>return</code> 语句之后）一刻才执行某个语句或函数。  </li>
<li>defer 一般用于释放某些已分配的资源。</li>
<li>多个 defer 行为被注册，会逆序执行（类似栈），  </li>
<li>defer 允许我们进行一些函数执行完成后的收尾工作：（1）关闭文件流；（2）解锁一个加锁的资源；（3）打印最终报告；（4）关闭数据库连接。  </li>
<li>用 defer 实现代码追踪。</li>
<li>用 defer 记录函数的参数与返回值。</li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>不需要导入就可使用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>close</td>
<td>用于管道通信</td>
</tr>
<tr>
<td>len、cap len</td>
<td>用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td>
</tr>
<tr>
<td>new、make</td>
<td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作,new() 是一个函数，不要忘记它的括号</td>
</tr>
<tr>
<td>copy、append</td>
<td>用于复制和连接切片</td>
</tr>
<tr>
<td>panic、recover</td>
<td>两者均用于错误处理机制</td>
</tr>
<tr>
<td>print、println</td>
<td>底层打印函数，在部署环境中建议使用 fmt 包</td>
</tr>
<tr>
<td>complex、real imag</td>
<td>用于创建和操作复数</td>
</tr>
</tbody></table>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>经常遇到的问题是栈溢出：大量递归调用导致程序栈内存分配耗尽。可通过一个名为懒惰求值的技术解决，Go 中可以使用管道（channel）和 goroutine来实现。</p>
<h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>eg. 函数 <code>strings.IndexFunc()</code><br>其函数签名是 <code>func IndexFunc(s string, f func(c int) bool) int</code>，它的返回值是在函数 <code>f(c)</code> 返回 true、-1 或从未返回时的索引值。  </p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>不想给函数起名字时，可以用匿名函数，例如： <code>func(x, y int) int { return x + y }</code>。<br>匿名函数不能独立存在，要赋值给变量（即保存函数的地址到变量中）：<code>fplus := func(x, y int) int { return x + y }</code>,然后用变量名来调用：<code>fplus(3,4)</code>，或直接对匿名函数进行调用：<code>func(x, y int) int { return x + y }(3, 4)</code>。  </p>
<h3 id="defer语句和匿名函数"><a href="#defer语句和匿名函数" class="headerlink" title="defer语句和匿名函数"></a>defer语句和匿名函数</h3><p>两者经常搭配，可用于改变函数的命名返回值。<br>匿名函数还可以配合 <code>go</code> 关键字来作为 goroutine 使用。<br>匿名函数被称之为闭包：被允许调用定义在起环境下的变量。闭包可使得某个函数捕捉到一些外部状态，如：函数被创建时的状态。或者说：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。<br>闭包经常被用作包装函数：会预先定义好 1 个或多个参数以用于包装。<br>另一个应用是用闭包来完成更加简洁的错误检查。  </p>
<h2 id="应用闭包：将函数作为返回值"><a href="#应用闭包：将函数作为返回值" class="headerlink" title="应用闭包：将函数作为返回值"></a>应用闭包：将函数作为返回值</h2><ul>
<li>闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。  </li>
<li>闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的。  </li>
</ul>
<h2 id="使用闭包调试"><a href="#使用闭包调试" class="headerlink" title="使用闭包调试"></a>使用闭包调试</h2><p>调试时需要准确知道哪个文件中的具体哪个函数正在执行。可以使用 <code>runtime</code> 或 <code>log</code> 包中的特殊函数来实现这样的功能。包 runtime 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">where := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">log.Printf(<span class="string">"%s:%d"</span>, file, line)</span><br><span class="line">&#125;</span><br><span class="line">where()</span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line">where()</span><br><span class="line"><span class="comment">// some more code</span></span><br><span class="line">where()</span><br></pre></td></tr></table></figure>
<p>也可以设置 <code>log</code> 包中的 flag 参数来实现：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.SetFlags(log.Llongfile)</span><br><span class="line">log.Print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>或使用一个更加简短版本的 <code>where</code> 函数：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> where = log.Print</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    where()</span><br><span class="line">    ... some code</span><br><span class="line">    where()</span><br><span class="line">    ... some code</span><br><span class="line">    where()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算函数执行时间"><a href="#计算函数执行时间" class="headerlink" title="计算函数执行时间"></a>计算函数执行时间</h2><p>在计算开始签设置一个起始时候，在计算结束时的结束时间，求差值。<br>可用 <code>time</code> 包中的 <code>Now()</code> 和 <code>Sub</code> 函数：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">start := time.Now()</span><br><span class="line">longCalculation()</span><br><span class="line">end := time.Now()</span><br><span class="line">delta := end.Sub(start)</span><br><span class="line">fmt.Printf(<span class="string">"longCalculation took this amount of time: %s\n"</span>, delta)</span><br></pre></td></tr></table></figure>

<h2 id="通过内存缓存来提升性能"><a href="#通过内存缓存来提升性能" class="headerlink" title="通过内存缓存来提升性能"></a>通过内存缓存来提升性能</h2><p>大量计算式，提升性能最有效的一种方式是<strong>避免重复计算</strong>。通过在内存中缓存和重复利用相同计算的结果，成为内存缓存。<br>eg. 求斐波那契数列：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LIM = <span class="number">41</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fibs [LIM]<span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">        start := time.Now()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; LIM; i++ &#123;</span><br><span class="line">            result = fibonacci(i)</span><br><span class="line">            fmt.Printf(<span class="string">"fibonacci(%d) is: %d\n"</span>, i, result)</span><br><span class="line">        &#125;</span><br><span class="line">        end := time.Now()</span><br><span class="line">        delta := end.Sub(start)</span><br><span class="line">        fmt.Printf(<span class="string">"longCalculation took this amount of time: %s\n"</span>, delta)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// memoization: check if fibonacci(n) is already known in array:</span></span><br><span class="line">        <span class="keyword">if</span> fibs[n] != <span class="number">0</span> &#123;</span><br><span class="line">            res = fibs[n]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fibs[n] = res</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h1><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>内置在 Go 语言中的，150 个以上。  </p>
<ul>
<li><code>unsafe</code>: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中。</li>
<li><code>syscall</code>-<code>os</code>-<code>os/exec</code>:  <ul>
<li><code>os</code>: 提供给我们一个平台无关性的操作系统功能接口，采用类Unix设计，隐藏了不同操作系统间差异，让不同的文件系统和操作系统对象表现一致。  </li>
<li><code>os/exec</code>: 提供我们运行外部操作系统命令和程序的方式。  </li>
<li><code>syscall</code>: 底层的外部包，提供了操作系统底层调用的基本接口。</li>
</ul>
</li>
<li><code>archive/tar</code> 和 <code>/zip-compress</code>：压缩(解压缩)文件功能。</li>
<li><code>fmt</code>-<code>io</code>-<code>bufio</code>-<code>path/filepath</code>-<code>flag</code>:  <ul>
<li><code>fmt</code>: 提供了格式化输入输出功能。  </li>
<li><code>io</code>: 提供了基本输入输出功能，大多数是围绕系统功能的封装。  </li>
<li><code>bufio</code>: 缓冲输入输出功能的封装。  </li>
<li><code>path/filepath</code>: 用来操作在当前系统中的目标文件名路径。  </li>
<li><code>flag</code>: 对命令行参数的操作。　　</li>
</ul>
</li>
<li><code>strings</code>-<code>strconv</code>-<code>unicode</code>-<code>regexp</code>-<code>bytes</code>:  <ul>
<li><code>strings</code>: 提供对字符串的操作。  </li>
<li><code>strconv</code>: 提供将字符串转换为基础类型的功能。</li>
<li><code>unicode</code>: 为 unicode 型的字符串提供特殊的功能。</li>
<li><code>regexp</code>: 正则表达式功能。  </li>
<li><code>bytes</code>: 提供对字符型分片的操作。  </li>
<li><code>index/suffixarray</code>: 子字符串快速查询。</li>
</ul>
</li>
<li><code>math</code>-<code>math/cmath</code>-<code>math/big</code>-<code>math/rand</code>-<code>sort</code>:  <ul>
<li><code>math</code>: 基本的数学函数。  </li>
<li><code>math/cmath</code>: 对复数的操作。  </li>
<li><code>math/rand</code>: 伪随机数生成。  </li>
<li><code>sort</code>: 为数组排序和自定义集合。  </li>
<li><code>math/big</code>: 大数的实现和计算。  　　</li>
</ul>
</li>
<li><code>container</code>-<code>/list-ring-heap</code>: 实现对集合的操作。  <ul>
<li><code>list</code>: 双链表。</li>
<li><code>ring</code>: 环形链表。</li>
</ul>
</li>
<li><code>time</code>-<code>log</code>:  <ul>
<li><code>time</code>: 日期和时间的基本操作。  </li>
<li><code>log</code>: 记录程序运行时产生的日志,我们将在后面的章节使用它。</li>
</ul>
</li>
<li><code>encoding/json</code>-<code>encoding/xml</code>-<code>text/template</code>:<ul>
<li><code>encoding/json</code>: 读取并解码和写入并编码 JSON 数据。  </li>
<li><code>encoding/xml</code>:简单的 XML1.0 解析器。  </li>
<li><code>text/template</code>:生成像 HTML 一样的数据与文本混合的数据驱动模板。  </li>
</ul>
</li>
<li><code>net</code>-<code>net/http</code>-<code>html</code><ul>
<li><code>net</code>: 网络数据的基本操作。  </li>
<li><code>http</code>: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。  </li>
<li><code>html</code>: HTML5 解析器。  </li>
</ul>
</li>
<li><code>runtime</code>: Go 程序运行时的交互操作，例如垃圾回收和协程创建。  </li>
<li><code>reflect</code>: 实现通过程序运行时反射，让程序操作任意类型的变量。  </li>
</ul>
<p><code>exp</code> 包中有许多将被编译为新包的实验性的包。它们将成为独立的包在下次稳定版本发布的时候。如果前一个版本已经存在了，它们将被作为过时的包被回收。然而 Go1.0 发布的时候并不包含过时或者实验性的包。</p>
<h2 id="regexp-包"><a href="#regexp-包" class="headerlink" title="regexp 包"></a>regexp 包</h2><p>正则表达式语法和使用见 <a href="http://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="noopener">维基百科</a><br>简单模式，用 <code>Match</code> 方法即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ok, _ := regexp.Match(pat, []<span class="keyword">byte</span>(searchIn))        <span class="comment">// ok 将返回 true 或 false</span></span><br></pre></td></tr></table></figure>
<p>也可以用 <code>MatchString</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ok, _ := regexp.MatchString(pat, searchIn)</span><br></pre></td></tr></table></figure>
<p>更多方法中，必须先将正则通过 <code>Compile</code> 方法返回一个 Regexp 对象。<br><code>Compile</code> 函数也可能返回一个错误，我们在使用时忽略对错误的判断是因为我们确信自己正则表达式是有效的。当用户输入或从数据中获取正则表达式的时候，我们有必要去检验它的正确性。另外我们也可以使用 <code>MustCompile</code> 方法，它可以像 <code>Compile</code> 方法一样检验正则的有效性，但是当正则不合法时程序将 panic。  </p>
<h2 id="锁和-sync-包"><a href="#锁和-sync-包" class="headerlink" title="锁和 sync 包"></a>锁和 sync 包</h2><p>多个线程同时操作一个变量时，可能会出错，需要锁。 这种锁的机制是通过 sync 包中 Mutex 来实现的。sync 来源于 “synchronized” 一词，这意味着线程将有序的对同一变量进行访问。<br><code>sync.Mutex</code> 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;      <span class="comment">// 假设 info 是一个需要上锁的放在共享内存中的变量</span></span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    <span class="comment">// ... other fields, e.g.: Str string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个函数要改变这个变量：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Update</span><span class="params">(info *Info)</span></span> &#123;</span><br><span class="line">    info.mu.Lock()</span><br><span class="line">    <span class="comment">// critical section:</span></span><br><span class="line">    info.Str = <span class="comment">// new value</span></span><br><span class="line">    <span class="comment">// end critical section</span></span><br><span class="line">    info.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg. 实现一个可以上锁的共享缓冲器:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 sync 包中还有一个 <code>RWMutex</code> 锁：他能通过 <code>RLock()</code> 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 <code>Lock()</code> 将和普通的 <code>Mutex</code> 作用相同。包中还有一个方便的 <code>Once</code> 类型变量的方法 <code>once.Do(call)</code>，这个方法确保被调用函数只能被调用一次。  </p>
<p>相对简单的情况下，通过使用 sync 包可以解决同一时间只能一个线程访问变量或 map 类型数据的问题。如果这种方式导致程序明显变慢或者引起其他问题，我们要重新思考来通过 goroutines 和 channels 来解决问题，这是在 Go 语言中所提倡用来实现并发的技术。我们将在第 14 章对其深入了解，并在第 14.7 节中对这两种方式进行比较。</p>
<h2 id="精密计算和-big-包"><a href="#精密计算和-big-包" class="headerlink" title="精密计算和 big 包"></a>精密计算和 big 包</h2><p>对于整数的高精度计算 Go 语言中提供了 big 包。其中包含了 math 包：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型（可以表示为 2/5 或 3.1416 这样的分数，而不是无理数或 π）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存和处理开销使它们使用起来要比内置的数字类型慢很多。</p>
<p>大的整型数字是通过 big.NewInt(n) 来构造的，其中 n 为 int64 类型整数。而大有理数是用过 big.NewRat(N,D) 方法构造。N（分子）和 D（分母）都是 int64 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 Add() 和 Mul() 这样的方法。它们作用于作为 receiver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 big.Int 类型的临时变量来存放中间结果，所以这样的运算可通过内存链式存储。</p>
<h2 id="自定义包和可见性"><a href="#自定义包和可见性" class="headerlink" title="自定义包和可见性"></a>自定义包和可见性</h2><p>当写自己包的时候，要使用短小的不含有 <code>_</code>(下划线)的小写单词来为文件命名。  </p>
<p>import 的一般格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包的路径或 URL 地址"</span>   <span class="comment">// 路径指当前目录的相对路径</span></span><br><span class="line"><span class="comment">// eg.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./pack1/pack1"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/org1/pack1”</span></span><br></pre></td></tr></table></figure>

<p>Import with _ :pack1包只导入其副作用，也就是说，只执行它的init函数并初始化其中的全局变量。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"./pack1/pack1"</span></span><br></pre></td></tr></table></figure>

<p>导入外部安装包：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> install codesite.ext/author/goExample/goex   <span class="comment">// ←网址</span></span><br></pre></td></tr></table></figure>
<p>将一个名为 <code>codesite.ext/author/goExample/goex</code> 的 map 安装在 <code>$GOROOT/src/</code> 目录下。  </p>
<p>在 <code>http://golang.org/cmd/goinstall/</code> 的 <code>go install</code> 文档中列出了一些广泛被使用的托管在网络代码仓库的包的导入路径  </p>
<p><strong>包的初始化:</strong></p>
<p>程序的执行开始于导入包，初始化 main 包然后调用 main 函数。  </p>
<p>一个没有导入的包将通过分配初始值给所有的包级变量和调用源码中定义的包级 init 函数来初始化。一个包可能有多个 init 函数甚至在一个源码文件中。它们的执行是无序的。这是最好的例子来测定包的值是否只依赖于相同包下的其他值或者函数。  </p>
<p>init 函数是不能被调用的。  </p>
<p>导入的包在包自身初始化前被初始化，而一个包在程序执行中只能初始化一次。  </p>
<h2 id="为自定义包使用-godoc"><a href="#为自定义包使用-godoc" class="headerlink" title="为自定义包使用 godoc"></a>为自定义包使用 godoc</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.6.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="使用-go-install-安装自定义包"><a href="#使用-go-install-安装自定义包" class="headerlink" title="使用 go install 安装自定义包"></a>使用 go install 安装自定义包</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.7.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="自定义包的目录结构、go-install-和-go-test"><a href="#自定义包的目录结构、go-install-和-go-test" class="headerlink" title="自定义包的目录结构、go install 和 go test"></a>自定义包的目录结构、go install 和 go test</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.8.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="通过-Git-打包和安装"><a href="#通过-Git-打包和安装" class="headerlink" title="通过 Git 打包和安装"></a>通过 Git 打包和安装</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.9.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="Go-的外部包和项目"><a href="#Go-的外部包和项目" class="headerlink" title="Go 的外部包和项目"></a>Go 的外部包和项目</h2><p>着手自己 Go 项目前，最好查下是否有存在的第三方包或项目可使用。大多可通过 go install 安装。  </p>
<p><a href="https://gowalker.org" target="_blank" rel="noopener">Go Walker</a> 支持查询。  </p>
<p>目前已经有许多非常好的外部库，如：</p>
<ul>
<li>MySQL(GoMySQL), PostgreSQL(go-pgsql), MongoDB (mgo, gomongo), CouchDB (couch-go), ODBC (godbcl), Redis (redis.go) and SQLite3 (gosqlite) database drivers</li>
<li>SDL bindings</li>
<li>Google’s Protocal Buffers(goprotobuf)</li>
<li>XML-RPC(go-xmlrpc)</li>
<li>Twitter(twitterstream)</li>
<li>OAuth libraries(GoAuth)</li>
</ul>
<h2 id="在-Go-程序中使用外部库"><a href="#在-Go-程序中使用外部库" class="headerlink" title="在 Go 程序中使用外部库"></a>在 Go 程序中使用外部库</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.11.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<hr>
<h1 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h1><h2 id="读取用户的输入"><a href="#读取用户的输入" class="headerlink" title="读取用户的输入"></a>读取用户的输入</h2><p>读取用户的键盘（控制台）输入，从键盘和标准输入 <code>os.Stdin</code> 读取输入，最简单的办法是用 <code>fmt</code> 包提供的 Scan 和 Sscan 开头的函数：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    firstName, lastName, s <span class="keyword">string</span></span><br><span class="line">    i                      <span class="keyword">int</span></span><br><span class="line">    f                      <span class="keyword">float32</span></span><br><span class="line">    input                  = <span class="string">"56.12 / 5212 / Go"</span></span><br><span class="line">    format                 = <span class="string">"%f / %d / %s"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Please enter your full name:"</span>)</span><br><span class="line">    fmt.Scanln(&amp;firstName, &amp;lastName)</span><br><span class="line">    <span class="comment">// fmt.Scanf("%s %s", &amp;firstName, &amp;lastName)</span></span><br><span class="line">    fmt.Printf(<span class="string">"Hi %s %s\n"</span>, firstName, lastName)</span><br><span class="line">    fmt.Sscanf(input, format, &amp;f, &amp;i, &amp;s)</span><br><span class="line">    fmt.Println(<span class="string">"Frome the string we read:"</span>, f, i, s)</span><br><span class="line">    <span class="comment">// 输出结果: From the string we read: 56.12 5212 Go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Scanln</code> 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。<code>Scanf</code> 与其类似，除了 <code>Scanf</code> 的第一个参数用作格式字符串，用来决定如何读取。<code>Sscan</code> 和以 <code>Sscan</code> 开头的函数则是从字符串读取，除此之外，与 <code>Scanf</code> 相同。如果这些函数读取到的结果与您预想的不同，您可以检查成功读入数据的个数和返回的错误。  </p>
<p>也可以用 <code>bufio</code> 包提供的缓冲读取（buffered reader）来读取数据：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inputReader *bufio.Reader</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputReader = bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println(<span class="string">"Please enter some input:"</span>)</span><br><span class="line">    input, err = inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"The input was: %s\n"</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inputReader</code> 是一个指向 <code>bufio.Reader</code> 的指针。<code>inputReader := bufio.NewReader(os.Stdin)</code> 这行代码，将会创建一个读取器，并将其与标准输入绑定。  </p>
<p><code>bufio.NewReader()</code> 构造函数的签名为：<code>func NewReader(rd io.Reader) *Reader</code>  </p>
<p>该函数的实参可以是满足 <code>io.Reader</code> 接口的任意对象（任意包含有适当的 <code>Read()</code> 方法的对象，请参考<a href="11.8.md">章节11.8</a>），函数返回一个新的带缓冲的 <code>io.Reader</code> 对象，它将从指定读取器（例如 <code>os.Stdin</code>）读取内容。  </p>
<p>返回的读取器对象提供一个方法 <code>ReadString(delim byte)</code>，该方法从输入中读取内容，直到碰到 <code>delim</code> 指定的字符，然后将读取到的内容连同 <code>delim</code> 字符一起放到缓冲区。  </p>
<p><code>ReadString</code> 返回读取到的字符串，如果碰到错误则返回 <code>nil</code>。如果它一直读到文件结束，则返回读取到的字符串和 <code>io.EOF</code>。如果读取过程中没有碰到 <code>delim</code> 字符，将返回错误 <code>err != nil</code>。  </p>
<p>在上面的例子中，我们会读取键盘输入，直到回车键（\n）被按下。  </p>
<p>屏幕是标准输出 <code>os.Stdout</code>；<code>os.Stderr</code> 用于显示错误信息，大多数情况下等同于 <code>os.Stdout</code>。  </p>
<p>一般情况下，我们会省略变量声明，而使用 <code>:=</code>，例如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>第二个例子从键盘读取输入，使用了 <code>switch</code> 语句：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println(<span class="string">"Please enter your name:"</span>)</span><br><span class="line">    input, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"There were errors reading, exiting program."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Your name is %s"</span>, input)</span><br><span class="line">    <span class="comment">// For Unix: test with delimiter "\n", for Windows: test with "\r\n"</span></span><br><span class="line">    <span class="keyword">switch</span> input &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Philip\r\n"</span>:  fmt.Println(<span class="string">"Welcome Philip!"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Chris\r\n"</span>:   fmt.Println(<span class="string">"Welcome Chris!"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Ivo\r\n"</span>:     fmt.Println(<span class="string">"Welcome Ivo!"</span>)</span><br><span class="line">    <span class="keyword">default</span>: fmt.Printf(<span class="string">"You are not welcome here! Goodbye!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// version 2:   </span></span><br><span class="line">    <span class="keyword">switch</span> input &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Philip\r\n"</span>:  <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Ivo\r\n"</span>:     <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Chris\r\n"</span>:   fmt.Printf(<span class="string">"Welcome %s\n"</span>, input)</span><br><span class="line">    <span class="keyword">default</span>: fmt.Printf(<span class="string">"You are not welcome here! Goodbye!\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// version 3:</span></span><br><span class="line">    <span class="keyword">switch</span> input &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Philip\r\n"</span>, <span class="string">"Ivo\r\n"</span>:   fmt.Printf(<span class="string">"Welcome %s\n"</span>, input)</span><br><span class="line">    <span class="keyword">default</span>: fmt.Printf(<span class="string">"You are not welcome here! Goodbye!\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>在 Go 语言中，文件使用指向 <code>os.File</code> 类型的指针来表示的，也叫做文件句柄。我们在前面章节使用到过标准输入 <code>os.Stdin</code> 和标准输出 <code>os.Stdout</code>，他们的类型都是 <code>*os.File</code>：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputFile, inputError := os.Open(<span class="string">"input.dat"</span>)</span><br><span class="line">    <span class="keyword">if</span> inputError != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred on opening the inputfile\n"</span> +</span><br><span class="line">            <span class="string">"Does the file exist?\n"</span> +</span><br><span class="line">            <span class="string">"Have you got acces to it?\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// exit the function on error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, readerError := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"The input was: %s"</span>, inputString)</span><br><span class="line">        <span class="keyword">if</span> readerError == io.EOF &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量 <code>inputFile</code> 是 <code>*os.File</code> 类型的。该类型是一个结构，表示一个打开文件的描述符（文件句柄）。然后，使用 <code>os</code> 包里的 <code>Open</code> 函数来打开一个文件。该函数的参数是文件名，类型为 <code>string</code>。在上面的程序中，我们以只读模式打开 <code>input.dat</code> 文件。  </p>
<p>如果文件不存在或者程序没有足够的权限打开这个文件，Open函数会返回一个错误：<code>inputFile, inputError = os.Open(&quot;input.dat&quot;)</code>。如果文件打开正常，我们就使用 <code>defer inputFile.Close()</code> 语句确保在程序退出前关闭该文件。然后，我们使用 <code>bufio.NewReader</code> 来获得一个读取器变量。  </p>
<p>通过使用 <code>bufio</code> 包提供的读取器（写入器也类似），如上面程序所示，我们可以很方便的操作相对高层的 string 对象，而避免了去操作比较底层的字节。  </p>
<p>接着，我们在一个无限循环中使用 <code>ReadString(&#39;\n&#39;)</code> 或 <code>ReadBytes(&#39;\n&#39;)</code> 将文件的内容逐行（行结束符 ‘\n’）读取出来。  </p>
<p><strong>注意：</strong> 在之前的例子中，我们看到，Unix和Linux的行结束符是 \n，而Windows的行结束符是 \r\n。在使用 <code>ReadString</code> 和 <code>ReadBytes</code> 方法的时候，我们不需要关心操作系统的类型，直接使用 \n 就可以了。另外，我们也可以使用 <code>ReadLine()</code> 方法来实现相同的功能。  </p>
<p>一旦读取到文件末尾，变量 <code>readerError</code> 的值将变成非空（事实上，常量 <code>io.EOF</code> 的值是 true），我们就会执行 <code>return</code> 语句从而退出循环。  </p>
<p><strong>其他类似函数：</strong>  </p>
<p><strong>1) 将整个文件的内容读到一个字符串里：</strong>  </p>
<p>如果您想这么做，可以使用 <code>io/ioutil</code> 包里的 <code>ioutil.ReadFile()</code> 方法，该方法第一个返回值的类型是 <code>[]byte</code>，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 nil。请看示例 12.5。类似的，函数 <code>WriteFile()</code> 可以将 <code>[]byte</code> 的值写入文件。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputFile := <span class="string">"products.txt"</span></span><br><span class="line">    outputFile := <span class="string">"products_copy.txt"</span></span><br><span class="line">    buf, err := ioutil.ReadFile(inputFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"File Error: %s\n"</span>, err)</span><br><span class="line">        <span class="comment">// panic(err.Error())</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(buf))</span><br><span class="line">    err = ioutil.WriteFile(outputFile, buf, <span class="number">0644</span>) <span class="comment">// oct, not hex</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2) 带缓冲的读取</strong>  </p>
<p>在很多情况下，文件的内容是不按行划分的，或者干脆就是一个二进制文件。在这种情况下，<code>ReadString()</code>就无法使用了，我们可以使用 <code>bufio.Reader</code> 的 <code>Read()</code>，它只接收一个参数：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">...</span><br><span class="line">n, err := inputReader.Read(buf)</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">break</span>&#125;</span><br></pre></td></tr></table></figure>

<p>变量 n 的值表示读取到的字节数.  </p>
<p><strong>3) 按列读取文件中的数据</strong>  </p>
<p>如果数据是按列排列并用空格分隔的，你可以使用 <code>fmt</code> 包提供的以 FScan 开头的一系列函数来读取他们。请看以下程序，我们将 3 列的数据分别读入变量 v1、v2 和 v3 内，然后分别把他们添加到切片的尾部。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"products2.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> col1, col2, col3 []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> v1, v2, v3 <span class="keyword">string</span></span><br><span class="line">        _, err := fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)</span><br><span class="line">        <span class="comment">// scans until newline</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        col1 = <span class="built_in">append</span>(col1, v1)</span><br><span class="line">        col2 = <span class="built_in">append</span>(col2, v2)</span><br><span class="line">        col3 = <span class="built_in">append</span>(col3, v3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(col1)</span><br><span class="line">    fmt.Println(col2)</span><br><span class="line">    fmt.Println(col3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：  </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[ABC FUNC GO]</span><br><span class="line">[<span class="number">40</span> <span class="number">56</span> <span class="number">45</span>]</span><br><span class="line">[<span class="number">150</span> <span class="number">280</span> <span class="number">356</span>]</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>path</code> 包里包含一个子包叫 <code>filepath</code>，这个子包提供了跨平台的函数，用于处理文件名和路径。例如 Base() 函数用于获得路径中的最后一个元素（不包含后面的分隔符）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"path/filepath"</span></span><br><span class="line">filename := filepath.Base(path)</span><br></pre></td></tr></table></figure>

<h3 id="compress-包：读取压缩文件"><a href="#compress-包：读取压缩文件" class="headerlink" title="compress 包：读取压缩文件"></a><code>compress</code> 包：读取压缩文件</h3><p><code>compress</code>包提供了读取压缩文件的功能，支持的压缩文件格式为：bzip2、flate、gzip、lzw 和 zlib。  </p>
<p>下面的程序展示了如何读取一个 gzip 文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fName := <span class="string">"MyFile.gz"</span></span><br><span class="line">    <span class="keyword">var</span> r *bufio.Reader</span><br><span class="line">    fi, err := os.Open(fName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"%v, Can't open %s: error: %s\n"</span>, os.Args[<span class="number">0</span>], fName,</span><br><span class="line">            err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fi.Close()</span><br><span class="line">    fz, err := gzip.NewReader(fi)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        r = bufio.NewReader(fi)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = bufio.NewReader(fz)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, err := r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Done reading file"</span>)</span><br><span class="line">            os.Exit(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// var outputWriter *bufio.Writer</span></span><br><span class="line">    <span class="comment">// var outputFile *os.File</span></span><br><span class="line">    <span class="comment">// var outputError os.Error</span></span><br><span class="line">    <span class="comment">// var outputString string</span></span><br><span class="line">    outputFile, outputError := os.OpenFile(<span class="string">"output.dat"</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> outputError != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred with file opening or creation\n"</span>)</span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outputFile.Close()</span><br><span class="line"></span><br><span class="line">    outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line">    outputString := <span class="string">"hello world!\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">        outputWriter.WriteString(outputString)</span><br><span class="line">    &#125;</span><br><span class="line">    outputWriter.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了文件句柄，我们还需要 <code>bufio</code> 的 <code>Writer</code>。我们以只写模式打开文件 <code>output.dat</code>，如果文件不存在则自动创建：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">outputFile, outputError := os.OpenFile(<span class="string">"output.dat"</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>OpenFile</code> 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符“|”连接），使用的文件权限。  </p>
<p>我们通常会用到以下标志：  </p>
<ul>
<li><code>os.O_RDONLY</code>：只读  </li>
<li><code>os.O_WRONLY</code>：只写  </li>
<li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。  </li>
<li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为0。</li>
</ul>
<p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。  </p>
<p>然后，我们创建一个写入器（缓冲区）对象：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">outputWriter := bufio.NewWriter(outputFile)</span><br></pre></td></tr></table></figure>

<p>接着，使用一个 for 循环，将字符串写入缓冲区，写 10 次：<code>outputWriter.WriteString(outputString)</code>  </p>
<p>缓冲区的内容紧接着被完全写入文件：<code>outputWriter.Flush()</code>  </p>
<p>如果写入的东西很简单，我们可以使用 <code>fmt.Fprintf(outputFile, &quot;Some test data.\n&quot;)</code> 直接将内容写入文件。<code>fmt</code> 包里的 F 开头的 Print 函数可以直接写入任何 <code>io.Writer</code>，包括文件。  </p>
<p>程序 <code>filewrite.go</code> 展示了不使用 <code>fmt.FPrintf</code> 函数，使用其他函数如何写文件：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Stdout.WriteString(<span class="string">"hello, world\n"</span>)</span><br><span class="line">    f, _ := os.OpenFile(<span class="string">"test"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    f.WriteString(<span class="string">"hello, world in a file\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>os.Stdout.WriteString(&quot;hello, world\n&quot;)</code>，我们可以输出到屏幕。  </p>
<p>我们以只写模式创建或打开文件”test”，并且忽略了可能发生的错误：<code>f, _ := os.OpenFile(&quot;test&quot;, os.O_CREATE|os.O_WRONLY, 0666)</code>  </p>
<p>我们不使用缓冲区，直接将内容写入文件：<code>f.WriteString( )</code>  </p>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>用 <code>io</code> 包：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// filecopy.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CopyFile(<span class="string">"target.txt"</span>, <span class="string">"source.txt"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Copy done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>defer</code> 的使用：当打开目标文件时发生了错误，那么 <code>defer</code> 仍然能够确保 <code>src.Close()</code> 执行。如果不这么做，文件会一直保持打开状态并占用资源。</p>
<h2 id="从命令行读参数"><a href="#从命令行读参数" class="headerlink" title="从命令行读参数"></a>从命令行读参数</h2><h3 id="os-包"><a href="#os-包" class="headerlink" title="os 包"></a>os 包</h3><p>os 包中有一个 string 类型的切片变量 <code>os.Args</code>，用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数。来看下面的打招呼程序：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os_args.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    who := <span class="string">"Alice "</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        who += strings.Join(os.Args[<span class="number">1</span>:], <span class="string">" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Good Morning"</span>, who)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 IDE 或编辑器中直接运行这个程序输出：<code>Good Morning Alice</code>  </p>
<p>我们在命令行运行 <code>os_args or ./os_args</code> 会得到同样的结果。  </p>
<p>但是我们在命令行加入参数，像这样：<code>os_args John Bill Marc Luke</code>，将得到这样的输出：<code>Good Morning Alice John Bill Marc Luke</code>  </p>
<p>这个命令行参数会放置在切片 <code>os.Args[]</code> 中（以空格分隔），从索引1开始（<code>os.Args[0]</code> 放的是程序本身的名字，在本例中是 <code>os_args</code>）。函数 <code>strings.Join</code> 以空格为间隔连接这些参数。  </p>
<h3 id="flag-包"><a href="#flag-包" class="headerlink" title="flag 包"></a>flag 包</h3><p>flag 包有一个扩展功能用来解析命令行选项。但是通常被用来替换基本常量，例如，在某些情况下我们希望在命令行给常量一些不一样的值。  </p>
<p>在 flag 包中有一个 Flag 被定义成一个含有如下字段的结构体：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Flag <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name     <span class="keyword">string</span> <span class="comment">// name as it appears on command line</span></span><br><span class="line">    Usage    <span class="keyword">string</span> <span class="comment">// help message</span></span><br><span class="line">    Value    Value  <span class="comment">// value as set</span></span><br><span class="line">    DefValue <span class="keyword">string</span> <span class="comment">// default value (as text); for usage message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟 Unix 的 echo 功能：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span> <span class="comment">// command line option parser</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewLine = flag.Bool(<span class="string">"n"</span>, <span class="literal">false</span>, <span class="string">"print newline"</span>) <span class="comment">// echo -n flag, of type *bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Space   = <span class="string">" "</span></span><br><span class="line">    Newline = <span class="string">"\n"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.PrintDefaults()</span><br><span class="line">    flag.Parse() <span class="comment">// Scans the arg list and sets up flags</span></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            s += <span class="string">" "</span></span><br><span class="line">            <span class="keyword">if</span> *NewLine &#123; <span class="comment">// -n is parsed, flag becomes true</span></span><br><span class="line">                s += Newline</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s += flag.Arg(i)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.WriteString(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flag.Parse()</code> 扫描参数列表（或者常量列表）并设置 flag, <code>flag.Arg(i)</code> 表示第i个参数。<code>Parse()</code> 之后 <code>flag.Arg(i)</code> 全部可用，<code>flag.Arg(0)</code> 就是第一个真实的 flag，而不是像 <code>os.Args(0)</code> 放置程序的名字。  </p>
<p><code>flag.Narg()</code> 返回参数的数量。解析后 flag 或常量就可用了。<br><code>flag.Bool()</code> 定义了一个默认值是 <code>false</code> 的 flag：当在命令行出现了第一个参数（这里是 “n”），flag 被设置成 <code>true</code>（NewLine 是 <code>*bool</code> 类型）。flag 被解引用到 <code>*NewLine</code>，所以当值是 <code>true</code> 时将添加一个 Newline（”\n”）。  </p>
<p><code>flag.PrintDefaults()</code> 打印 flag 的使用帮助信息，本例中打印的是：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">-n=<span class="literal">false</span>: <span class="built_in">print</span> newline</span><br></pre></td></tr></table></figure>

<p><code>flag.VisitAll(fn func(*Flag))</code> 是另一个有用的功能：按照字典顺序遍历 flag，并且对每个标签调用 fn   </p>
<p>当在命令行（Windows）中执行：<code>echo.exe A B C</code>，将输出：<code>A B C</code>；执行 <code>echo.exe -n A B C</code>，将输出：  </p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br></pre></td></tr></table></figure>

<p>每个字符的输出都新起一行，每次都在输出的数据前面打印使用帮助信息：<code>-n=false: print newline</code>。  </p>
<p>对于 <code>flag.Bool</code> 你可以设置布尔型 flag 来测试你的代码，例如定义一个 flag <code>processedFlag</code>:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> processedFlag = flag.Bool(<span class="string">"proc"</span>, <span class="literal">false</span>, <span class="string">"nothing processed yet"</span>)</span><br></pre></td></tr></table></figure>

<p>在后面用如下代码来测试：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> *processedFlag &#123; <span class="comment">// found flag -proc</span></span><br><span class="line">    r = process()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要给 flag 定义其它类型，可以使用 <code>flag.Int()</code>，<code>flag.Float64()</code>，<code>flag.String()</code>。  </p>
<h2 id="用-buffer-读取文件"><a href="#用-buffer-读取文件" class="headerlink" title="用 buffer 读取文件"></a>用 buffer 读取文件</h2><p>使用了缓冲读取文件和命令行 flag 解析这两项技术。如果不加参数，那么你输入什么屏幕就打印什么。  </p>
<p>参数被认为是文件名，如果文件存在的话就打印文件内容到屏幕。命令行执行 <code>cat test</code> 测试输出。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(r *bufio.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf, err := r.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(os.Stdout, <span class="string">"%s"</span>, buf)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line">        cat(bufio.NewReader(os.Stdin))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err := os.Open(flag.Arg(i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"%s:error reading from %s: %s\n"</span>, os.Args[<span class="number">0</span>], flag.Arg(i), err.Error())</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        cat(bufio.NewReader(f))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用切片读写文件"><a href="#用切片读写文件" class="headerlink" title="用切片读写文件"></a>用切片读写文件</h2><p>切片提供了 Go 中处理 I/O 缓冲的标准方式，下面 <code>cat</code> 函数的第二版中，在一个切片缓冲内使用无限 for 循环（直到文件尾部 EOF）读取文件，并写入到标准输出（<code>os.Stdout</code>）。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> NBUF = <span class="number">512</span></span><br><span class="line">    <span class="keyword">var</span> buf [NBUF]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> nr, err := f.Read(buf[:]); <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nr &lt; <span class="number">0</span>:</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"cat: error reading: %s\n"</span>, err.Error())</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">case</span> nr == <span class="number">0</span>: <span class="comment">// EOF</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> nr &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nw, ew := os.Stdout.Write(buf[<span class="number">0</span>:nr]); nw != nr &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">"cat: error writing: %s\n"</span>, ew.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码来自于 <code>cat2.go</code>，使用了 os 包中的 <code>os.File</code> 和 <code>Read</code> 方法；<code>cat2.go</code> 与 <code>cat.go</code> 具有同样的功能。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> NBUF = <span class="number">512</span></span><br><span class="line">    <span class="keyword">var</span> buf [NBUF]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> nr, err := f.Read(buf[:]); <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nr &lt; <span class="number">0</span>:</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"cat: error reading: %s\n"</span>, err.Error())</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">case</span> nr == <span class="number">0</span>: <span class="comment">// EOF</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> nr &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nw, ew := os.Stdout.Write(buf[<span class="number">0</span>:nr]); nw != nr &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">"cat: error writing: %s\n"</span>, ew.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse() <span class="comment">// Scans the arg list and sets up flags</span></span><br><span class="line">    <span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line">        cat(os.Stdin)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err := os.Open(flag.Arg(i))</span><br><span class="line">        <span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"cat: can't open %s: error %s\n"</span>, flag.Arg(i), err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        cat(f)</span><br><span class="line">        f.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用-defer-关闭文件"><a href="#用-defer-关闭文件" class="headerlink" title="用 defer 关闭文件"></a>用 defer 关闭文件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">data</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    f, _ := os.OpenFile(name, os.O_RDONLY, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// idiomatic Go code!</span></span><br><span class="line">    contents, _ := ioutil.ReadAll(f)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 return 后执行了 <code>f.Close()</code>  </p>
<h2 id="使用接口的实际例子：fmt-Fprintf"><a href="#使用接口的实际例子：fmt-Fprintf" class="headerlink" title="使用接口的实际例子：fmt.Fprintf"></a>使用接口的实际例子：fmt.Fprintf</h2><p>例子程序 <code>io_interfaces.go</code> 很好的阐述了 io 包中的接口概念:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interfaces being used in the GO-package fmt</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// unbuffered</span></span><br><span class="line">    fmt.Fprintf(os.Stdout, <span class="string">"%s\n"</span>, <span class="string">"hello world! - unbuffered"</span>)</span><br><span class="line">    <span class="comment">// buffered: os.Stdout implements io.Writer</span></span><br><span class="line">    buf := bufio.NewWriter(os.Stdout)</span><br><span class="line">    <span class="comment">// and now so does buf.</span></span><br><span class="line">    fmt.Fprintf(buf, <span class="string">"%s\n"</span>, <span class="string">"hello world! - buffered"</span>)</span><br><span class="line">    buf.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hello world! - unbuffered</span><br><span class="line">hello world! - buffered</span><br></pre></td></tr></table></figure>

<p><code>fmt.Fprintf()</code> 函数的实际签名:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>其不是写入一个文件，而是写入一个 <code>io.Writer</code> 接口类型的变量，下面是 <code>Writer</code> 接口在 io 包中的定义：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fmt.Fprintf()</code> 依据指定的格式向第一个参数内写入字符串，第一个参数必须实现了 <code>io.Writer</code> 接口。<code>Fprintf()</code> 能够写入任何类型，只要其实现了 <code>Write</code> 方法，包括 <code>os.Stdout</code>,文件（例如 os.File），管道，网络连接，通道等等，同样的也可以使用 bufio 包中缓冲写入。bufio 包中定义了 <code>type Writer struct{...}</code>。  </p>
<p>bufio.Writer 实现了 Write 方法：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>它还有一个工厂函数：传给它一个 <code>io.Writer</code> 类型的参数，它会返回一个带缓冲的 <code>bufio.Writer</code> 类型的 <code>io.Writer</code>:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span> <span class="params">(b *Writer)</span></span></span><br></pre></td></tr></table></figure>

<p>其适合任何形式的缓冲写入。  </p>
<p>在缓冲写入的最后千万不要忘了使用 <code>Flush()</code>，否则最后的输出不会被写入。  </p>
<h2 id="JSON-数据格式"><a href="#JSON-数据格式" class="headerlink" title="JSON 数据格式"></a>JSON 数据格式</h2><p>数据结构要在网络中传输或保存到文件，就必须对其编码和解码；目前存在很多编码格式：JSON，XML，gob，Google 缓冲协议等等。Go 语言支持所有这些编码格式。  </p>
<p>术语说明：  </p>
<ul>
<li>数据结构 –&gt; 指定格式 = <code>序列化</code> 或 <code>编码</code>（传输之前）</li>
<li>指定格式 –&gt; 数据格式 = <code>反序列化</code> 或 <code>解码</code>（传输之后）</li>
</ul>
<p>序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure）  </p>
<p>编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。  </p>
<p>JSON 有时候是首选，由于其格式上非常简洁。通常 JSON 被用于 web 后端和浏览器之间的通讯，但是在其它场景也同样的有用。  </p>
<p>一个简短的 JSON 片段：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"Person"</span>: &#123;</span><br><span class="line">        <span class="string">"FirstName"</span>: <span class="string">"Laura"</span>,</span><br><span class="line">        <span class="string">"LastName"</span>: <span class="string">"Lynn"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// json.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="keyword">string</span></span><br><span class="line">    City    <span class="keyword">string</span></span><br><span class="line">    Country <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VCard <span class="keyword">struct</span> &#123;</span><br><span class="line">    FirstName <span class="keyword">string</span></span><br><span class="line">    LastName  <span class="keyword">string</span></span><br><span class="line">    Addresses []*Address</span><br><span class="line">    Remark    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pa := &amp;Address&#123;<span class="string">"private"</span>, <span class="string">"Aartselaar"</span>, <span class="string">"Belgium"</span>&#125;</span><br><span class="line">    wa := &amp;Address&#123;<span class="string">"work"</span>, <span class="string">"Boom"</span>, <span class="string">"Belgium"</span>&#125;</span><br><span class="line">    vc := VCard&#123;<span class="string">"Jan"</span>, <span class="string">"Kersschot"</span>, []*Address&#123;pa, wa&#125;, <span class="string">"none"</span>&#125;</span><br><span class="line">    <span class="comment">// fmt.Printf("%v: \n", vc) // &#123;Jan Kersschot [0x126d2b80 0x126d2be0] none&#125;:</span></span><br><span class="line">    <span class="comment">// JSON format:</span></span><br><span class="line">    js, _ := json.Marshal(vc)</span><br><span class="line">    fmt.Printf(<span class="string">"JSON format: %s"</span>, js)</span><br><span class="line">    <span class="comment">// using an encoder:</span></span><br><span class="line">    file, _ := os.OpenFile(<span class="string">"vcard.json"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    enc := json.NewEncoder(file)</span><br><span class="line">    err := enc.Encode(vc)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"Error in encoding json"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>json.Marshal()</code> 的函数签名是 <code>func Marshal(v interface{}) ([]byte, error)</code>，下面是数据编码后的 JSON 文本（实际上是一个 []byte）：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"FirstName"</span>: <span class="string">"Jan"</span>,</span><br><span class="line">    <span class="string">"LastName"</span>: <span class="string">"Kersschot"</span>,</span><br><span class="line">    <span class="string">"Addresses"</span>: [&#123;</span><br><span class="line">        <span class="string">"Type"</span>: <span class="string">"private"</span>,</span><br><span class="line">        <span class="string">"City"</span>: <span class="string">"Aartselaar"</span>,</span><br><span class="line">        <span class="string">"Country"</span>: <span class="string">"Belgium"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">"Type"</span>: <span class="string">"work"</span>,</span><br><span class="line">        <span class="string">"City"</span>: <span class="string">"Boom"</span>,</span><br><span class="line">        <span class="string">"Country"</span>: <span class="string">"Belgium"</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">"Remark"</span>: <span class="string">"none"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出于安全考虑，在 web 应用中最好使用 <code>json.MarshalforHTML()</code> 函数，其对数据执行HTML转码，所以文本可以被安全地嵌在 HTML <code>&lt;script&gt;</code> 标签中。  </p>
<p><code>json.NewEncoder()</code> 的函数签名是 <code>func NewEncoder(w io.Writer) *Encoder</code>，返回的Encoder类型的指针可调用方法 <code>Encode(v interface{})</code>，将数据对象 v 的json编码写入 <code>io.Writer</code> w 中。  </p>
<p>JSON 与 Go 类型对应如下：  </p>
<ul>
<li>bool 对应 JSON 的 booleans</li>
<li>float64 对应 JSON 的 numbers</li>
<li>string 对应 JSON 的 strings</li>
<li>nil 对应 JSON 的 null</li>
</ul>
<p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：  </p>
<ul>
<li><p>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map[string]T（T是 <code>json</code> 包中支持的任何类型）</p>
</li>
<li><p>Channel，复杂类型和函数类型不能被编码</p>
</li>
<li><p>不支持循环数据结构；它将引起序列化进入一个无限循环</p>
</li>
<li><p>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</p>
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.9.md" target="_blank" rel="noopener">反序列化、解码任意的数据、解码数据到结构、编码和解码流 参见</a>  </p>
</li>
</ul>
<h2 id="XML-数据格式"><a href="#XML-数据格式" class="headerlink" title="XML 数据格式"></a>XML 数据格式</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.10.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="用-Gob-传输数据"><a href="#用-Gob-传输数据" class="headerlink" title="用 Gob 传输数据"></a>用 Gob 传输数据</h2><p>Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；可以在 <code>encoding</code> 包中找到。这种格式的数据简称为 Gob （即 Go binary 的缩写）。类似于 Python 的 “pickle” 和 Java 的 “Serialization”。<br><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.11.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="Go-中的密码学"><a href="#Go-中的密码学" class="headerlink" title="Go 中的密码学"></a>Go 中的密码学</h2><p>Go 为加密提供了超过 30 个包：  </p>
<ul>
<li><code>hash</code> 包：实现了 <code>adler32</code>、<code>crc32</code>、<code>crc64</code> 和 <code>fnv</code> 校验；</li>
<li><code>crypto</code> 包：实现了其它的 hash 算法，比如 <code>md4</code>、<code>md5</code>、<code>sha1</code> 等。以及完整地实现了 <code>aes</code>、<code>blowfish</code>、<code>rc4</code>、<code>rsa</code>、<code>xtea</code> 等加密算法。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hash_sha1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hasher := sha1.New()</span><br><span class="line">    io.WriteString(hasher, <span class="string">"test"</span>)</span><br><span class="line">    b := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Result: %x\n"</span>, hasher.Sum(b))</span><br><span class="line">    fmt.Printf(<span class="string">"Result: %d\n"</span>, hasher.Sum(b))</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    hasher.Reset()</span><br><span class="line">    data := []<span class="keyword">byte</span>(<span class="string">"We shall overcome!"</span>)</span><br><span class="line">    n, err := hasher.Write(data)</span><br><span class="line">    <span class="keyword">if</span> n!=<span class="built_in">len</span>(data) || err!=<span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"Hash write error: %v / %v"</span>, n, err)</span><br><span class="line">    &#125;</span><br><span class="line">    checksum := hasher.Sum(b)</span><br><span class="line">    fmt.Printf(<span class="string">"Result: %x\n"</span>, checksum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Result: a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</span><br><span class="line">Result: [<span class="number">169</span> <span class="number">74</span> <span class="number">143</span> <span class="number">229</span> <span class="number">204</span> <span class="number">177</span> <span class="number">155</span> <span class="number">166</span> <span class="number">28</span> <span class="number">76</span> <span class="number">8</span> <span class="number">115</span> <span class="number">211</span> <span class="number">145</span> <span class="number">233</span> <span class="number">135</span> <span class="number">152</span> <span class="number">47</span> <span class="number">187</span> <span class="number">211</span>]</span><br><span class="line">Result: e2222bfc59850bbb00a722e764a555603bb59b2a</span><br></pre></td></tr></table></figure>
<p>通过调用 <code>sha1.New()</code> 创建了一个新的 <code>hash.Hash</code> 对象，用来计算 SHA1 校验值。<code>Hash</code> 类型实际上是一个接口，它实现了 <code>io.Writer</code> 接口：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Write (via the embedded io.Writer interface) adds more data to the running hash.</span></span><br><span class="line">    <span class="comment">// It never returns an error.</span></span><br><span class="line">    io.Writer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum appends the current hash to b and returns the resulting slice.</span></span><br><span class="line">    <span class="comment">// It does not change the underlying hash state.</span></span><br><span class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset resets the Hash to its initial state.</span></span><br><span class="line">    Reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Size returns the number of bytes Sum will return.</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlockSize returns the hash's underlying block size.</span></span><br><span class="line">    <span class="comment">// The Write method must be able to accept any amount</span></span><br><span class="line">    <span class="comment">// of data, but it may operate more efficiently if all writes</span></span><br><span class="line">    <span class="comment">// are a multiple of the block size.</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 io.WriteString 或 hasher.Write 将给定的 []byte 附加到当前的 <code>hash.Hash</code> 对象中。</p>
<h1 id="错误处理与测试"><a href="#错误处理与测试" class="headerlink" title="错误处理与测试"></a>错误处理与测试</h1><p><strong>永远不要忽略错误，否则可能会导致程序崩溃！！</strong>  </p>
<p><code>panic and recover</code> 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> value, err := pack1.Func1(param1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Error %s in pack1.Func1 with parameter %v"</span>, err.Error(), param1)</span><br><span class="line">    <span class="keyword">return</span>    <span class="comment">// or: return err</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Process(value)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 <code>fmt.Printf</code> 还可以使用 log 中对应的方法，如果程序中止也没关系的话甚至可以使用 <code>panic</code>  </p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go 有一个预先定义的 error 接口类型  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序处于错误状态时可以用 <code>os.Exit(1)</code> 来中止运行。  </p>
<h3 id="定义错误"><a href="#定义错误" class="headerlink" title="定义错误"></a>定义错误</h3><p>用 <code>errors</code>（必须先 import）包的 <code>errors.New</code> 函数接收合适的错误信息来创建：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := errors.New(<span class="string">"math - square root of negative number"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errNotFound error = errors.New(<span class="string">"Not found error"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"error: %v"</span>, errNotFound)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error: Not found error</span></span><br></pre></td></tr></table></figure>
<p>用于计算平方根函数的参数测试：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New (<span class="string">"math - square root of negative number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// implementation of Sqrt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := Sqrt(<span class="number">-1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Error: %s\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 fmt.Printf 会自动调用 String() 方法 （参见 10.7 节），所以错误信息 “Error: math - square root of negative number” 会打印出来。通常（错误信息）都会有像 “Error:” 这样的前缀，所以你的错误信息不要以大写字母开头。  </p>
<p>有不同错误条件可能发生，那么对实际的错误使用类型断言或类型判断（type-switch）是很有用的，并且可以根据错误场景做一些补救和恢复操作。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op <span class="keyword">string</span>    <span class="comment">// "open", "unlink", etc.</span></span><br><span class="line">    Path <span class="keyword">string</span>  <span class="comment">// The associated file.</span></span><br><span class="line">    Err error  <span class="comment">// Returned by the system call.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">" "</span> + e.Path + <span class="string">": "</span>+ e.Err.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  err != nil</span></span><br><span class="line"><span class="keyword">if</span> e, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">    <span class="comment">// remedy situation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> ParseError:</span><br><span class="line">        PrintParseError(err)</span><br><span class="line">    <span class="keyword">case</span> PathError:</span><br><span class="line">        PrintPathError(err)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Not a special error, just %s\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：当 json.Decode 在解析 JSON 文档发生语法错误时，指定返回一个 SyntaxError 类型的错误：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="keyword">string</span> <span class="comment">// description of error</span></span><br><span class="line"><span class="comment">// error occurred after reading Offset bytes, from which line and columnnr can be obtained</span></span><br><span class="line">    Offset <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure>
<p>在调用代码中你可以像这样用类型断言测试错误是不是上面的类型：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> serr, ok := err.(*json.SyntaxError); ok &#123;</span><br><span class="line">    line, col := findLine(f, serr.Offset)</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s:%d:%d: %v"</span>, f.Name(), line, col, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包也可以用额外的方法（methods）定义特定的错误，比如 net.Error：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net</span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Timeout() <span class="keyword">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="keyword">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遵循同一种命名规范：错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。  </p>
<h3 id="用-fmt-创建错误对象"><a href="#用-fmt-创建错误对象" class="headerlink" title="用 fmt 创建错误对象"></a>用 fmt 创建错误对象</h3><p>可以用 <code>fmt.Errorf()</code> 来实现：它和 <code>fmt.Printf()</code> 完全一样，接收一个或多个格式占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"math: square root of negative number %g"</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子2：从命令行读取输入时，如果加了 help 标志，我们可以用有用的信息产生一个错误：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; (os.Args[<span class="number">1</span>] == <span class="string">"-h"</span> || os.Args[<span class="number">1</span>] == <span class="string">"--help"</span>) &#123;</span><br><span class="line">    err = fmt.Errorf(<span class="string">"usage: %s infile.txt outfile.txt"</span>, filepath.Base(os.Args[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行时异常和-panic"><a href="#运行时异常和-panic" class="headerlink" title="运行时异常和 panic"></a>运行时异常和 panic</h2><p>当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发<em>运行时 panic</em>，伴随着程序的崩溃抛出一个 <code>runtime.Error</code> 接口类型的值。这个错误值有个 <code>RuntimeError()</code> 方法用于区别普通错误。  </p>
<p><code>panic</code> 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 <code>panic</code> 函数产生一个中止程序的运行时错误。<code>panic</code> 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Starting the program"</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"A severe error occurred: stopping the program!"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Ending the program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Starting the program</span><br><span class="line"><span class="string">panic:</span> A severe error <span class="string">occurred:</span> stopping the program!</span><br><span class="line">panic PC=<span class="number">0x4f3038</span></span><br><span class="line">runtime.panic+<span class="number">0x99</span> <span class="regexp">/go/</span>src<span class="regexp">/pkg/</span>runtime/proc.<span class="string">c:</span><span class="number">1032</span></span><br><span class="line">       runtime.panic(<span class="number">0x442938</span>, <span class="number">0x4f08e8</span>)</span><br><span class="line">main.main+<span class="number">0xa5</span> <span class="string">E:</span><span class="regexp">/Go/</span>GoBoek<span class="regexp">/code examples/</span>chapter <span class="number">13</span>/panic.<span class="string">go:</span><span class="number">8</span></span><br><span class="line">       main.main()</span><br><span class="line">runtime.mainstart+<span class="number">0xf</span> <span class="number">386</span>/asm.<span class="string">s:</span><span class="number">84</span></span><br><span class="line">       runtime.mainstart()</span><br><span class="line">runtime.goexit <span class="regexp">/go/</span>src<span class="regexp">/pkg/</span>runtime/proc.<span class="string">c:</span><span class="number">148</span></span><br><span class="line">       runtime.goexit()</span><br><span class="line">---- Error run <span class="string">E:</span><span class="regexp">/Go/</span>GoBoek<span class="regexp">/code examples/</span>chapter <span class="number">13</span>/panic.exe with code Crashed</span><br><span class="line">---- Program exited with code <span class="number">-1073741783</span></span><br></pre></td></tr></table></figure>
<p>一个检查程序是否被已知用户启动的具体例子：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"Unknown user: no value for $USER"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在导入包的 init() 函数中检查这些。  </p>
<p>当发生错误必须中止程序时，<code>panic</code> 可以用于错误处理模式：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"ERROR occurred:"</span> + err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Go panicking</strong>：  </p>
<p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 <em>panicking</em>。  </p>
<p>标准库中有许多包含 <code>Must</code> 前缀的函数，像 <code>regexp.MustComplie</code> 和 <code>template.Must</code>；当正则表达式或模板中转入的转换字符串导致错误时，这些函数会 panic。  </p>
<p>不能随意地用 panic 中止程序，必须尽力补救错误让程序能继续执行。  </p>
<h2 id="从-panic-中恢复（Recover）"><a href="#从-panic-中恢复（Recover）" class="headerlink" title="从 panic 中恢复（Recover）"></a>从 panic 中恢复（Recover）</h2><p>这个（recover）内建函数被用于从 panic 或 错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。  </p>
<p><code>recover</code> 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 <code>recover</code> 会返回 nil，且没有其它效果。  </p>
<p>总结：panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(g <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">"done"</span>)</span><br><span class="line">        <span class="comment">// Println executes normally even if there is a panic</span></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"run time panic: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    log.Println(<span class="string">"start"</span>)</span><br><span class="line">    g() <span class="comment">//   possible runtime-error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>log 包实现了简单的日志功能：默认的 log 对象向标准错误输出中写入并打印每条日志信息的日期和时间。除了 <code>Println</code> 和 <code>Printf</code> 函数，其它的致命性函数都会在写完日志信息后调用 os.Exit(1)，那些退出函数也是如此。而 Panic 效果的函数会在写完日志信息后调用 panic；可以在程序必须中止或发生了临界错误时使用它们，就像当 web 服务器不能启动时那样。  </p>
<p>一个展示 panic，defer 和 recover 怎么结合使用的完整例子：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// panic_recover.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">badCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"bad end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Panicing %s\r\n"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    badCall()</span><br><span class="line">    fmt.Printf(<span class="string">"After bad call\r\n"</span>) <span class="comment">// &lt;-- wordt niet bereikt</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Calling test\r\n"</span>)</span><br><span class="line">    test()</span><br><span class="line">    fmt.Printf(<span class="string">"Test completed\r\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">Calling test</span><br><span class="line">Panicing bad end</span><br><span class="line"><span class="keyword">Test </span>completed</span><br></pre></td></tr></table></figure>

<h2 id="自定义包中的错误处理和-panicking"><a href="#自定义包中的错误处理和-panicking" class="headerlink" title="自定义包中的错误处理和 panicking"></a>自定义包中的错误处理和 panicking</h2><p>这是所有自定义包实现者应该遵守的最佳实践：  </p>
<p>1）<em>在包内部，总是应该从 panic 中 recover</em>：不允许显式的超出包范围的 panic()  </p>
<p>2）<em>向包的调用者返回错误值（而不是 panic）。</em>  </p>
<h2 id="一种用闭包处理错误的模式"><a href="#一种用闭包处理错误的模式" class="headerlink" title="一种用闭包处理错误的模式"></a>一种用闭包处理错误的模式</h2><p>模式中使用了两个帮助函数：<br>1）check：这是用来检查是否有错误和 panic 发生的函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(err error)</span></span> &#123; <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="built_in">panic</span>(err) &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>2）errorhandler：这是一个包装函数。接收一个 fType1 类型的函数 fn 并返回一个调用 fn 的函数。里面就包含有 defer/recover 机制，这在 <a href="13.3.md">13.3 节</a>中有相应描述。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorHandler</span><span class="params">(fn fType1)</span> <span class="title">fType1</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a type1, b type2)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err, ok := <span class="built_in">recover</span>().(error); ok &#123;</span><br><span class="line">                log.Printf(<span class="string">"run time panic: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        fn(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动外部命令和程序"><a href="#启动外部命令和程序" class="headerlink" title="启动外部命令和程序"></a>启动外部命令和程序</h2><p>os 包有一个 <code>StartProcess</code> 函数可以调用或启动外部系统命令和二进制可执行文件；它的第一个参数是要运行的进程，第二个参数用来传递选项或参数，第三个参数是含有系统环境基本信息的结构体。  </p>
<p>这个函数返回被启动进程的 id（pid），或者启动失败返回错误。  </p>
<p>exec 包中也有同样功能的更简单的结构体和函数；主要是 <code>exec.Command(name string, arg ...string)</code> 和 <code>Run()</code>。首先需要用系统命令或可执行文件的名字创建一个 <code>Command</code> 对象，然后用这个对象作为接收者调用 <code>Run()</code>。  </p>
<h2 id="Go-中的单元测试和基准测试"><a href="#Go-中的单元测试和基准测试" class="headerlink" title="Go 中的单元测试和基准测试"></a>Go 中的单元测试和基准测试</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.7.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<p>测试的具体例子：<br><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.8.md" target="_blank" rel="noopener">The way to Go 参考内容</a>   </p>
<p>用（测试数据）表驱动测试：<br> <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.9.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="性能调试：分析并优化-Go-程序"><a href="#性能调试：分析并优化-Go-程序" class="headerlink" title="性能调试：分析并优化 Go 程序"></a>性能调试：分析并优化 Go 程序</h2><p> 时间和内存消耗、用 go test 调试、用 pprof 调试： <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.10.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<hr>
<h1 id="协程（goroutine）与通道（channel）"><a href="#协程（goroutine）与通道（channel）" class="headerlink" title="协程（goroutine）与通道（channel）"></a>协程（goroutine）与通道（channel）</h1><p> <strong>不要通过共享内存来通信，而通过通信来共享内存。</strong>  </p>
<h2 id="并发、并行和协程"><a href="#并发、并行和协程" class="headerlink" title="并发、并行和协程"></a>并发、并行和协程</h2><p> 在 Go 中，应用程序并发处理的部分被称作 <code>goroutines（协程）</code>。  </p>
<p> Go 使用 <code>channels</code> 来同步协程。  </p>
<p> 协程是通过使用关键字 go 调用（执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：<code>go sum(bigArray)</code>，在后台计算总和。  </p>
<p>协程的栈会根据需要进行伸缩，不出现栈溢出；开发者不需要关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数不会得到任何的返回值。  </p>
<p>在一个协程中，比如它需要进行非常密集的运算，你可以在运算循环中周期的使用 runtime.Gosched()：这会让出处理器，允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。使用 Gosched() 可以使计算均匀分布，使通信不至于迟迟得不到响应。  </p>
<h3 id="并发和并行的差异"><a href="#并发和并行的差异" class="headerlink" title="并发和并行的差异"></a>并发和并行的差异</h3><p>Go 的并发原语提供了良好的并发设计基础：表达程序结构以便表示独立地执行的动作。  </p>
<p>在当前的运行时（2012 年一月）实现中，Go 默认没有并行指令，只有一个独立的核心或处理器被专门用于 Go 程序，不论它启动了多少个协程；所以这些协程是并发运行的，但他们不是并行运行的：同一时间只有一个协程会处在运行状态。  </p>
<h3 id="使用-GOMAXPROCS"><a href="#使用-GOMAXPROCS" class="headerlink" title="使用 GOMAXPROCS"></a>使用 GOMAXPROCS</h3><p>在 gc 编译器下（6g 或者 8g）你必须设置 GOMAXPROCS 为一个大于默认值 1 的数值来允许运行时支持使用多于 1 个的操作系统线程，所有的协程都会共享同一个线程除非将 GOMAXPROCS 设置为一个大于 1 的数。当 GOMAXPROCS 大于 1 时，会有一个线程池管理许多的线程。通过 gccgo 编译器 GOMAXPROCS 有效的与运行中的协程数量相等。假设 n 是机器上处理器或者核心的数量。如果你设置环境变量 GOMAXPROCS&gt;=n，或者执行 runtime.GOMAXPROCS(n)，接下来协程会被分割（分散）到 n 个处理器上。更多的处理器并不意味着性能的线性提升。有这样一个经验法则，对于 n 个核心的情况设置 GOMAXPROCS 为 n-1 以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1 + GOMAXPROCS &gt; 1。</p>
<p>所以如果在某一时间只有一个协程在执行，不要设置 GOMAXPROCS！  </p>
<p>总结：GOMAXPROCS 等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行。  </p>
<h3 id="如何用命令行指定使用的核心数量"><a href="#如何用命令行指定使用的核心数量" class="headerlink" title="如何用命令行指定使用的核心数量"></a>如何用命令行指定使用的核心数量</h3><p>使用 <code>flags</code> 包，如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numCores = flag.Int(<span class="string">"n"</span>, <span class="number">2</span>, <span class="string">"number of CPU cores to use"</span>)</span><br><span class="line"></span><br><span class="line">in main()</span><br><span class="line">flag.Parse()</span><br><span class="line">runtime.GOMAXPROCS(*numCores)</span><br></pre></td></tr></table></figure>

<p>协程可以通过调用<code>runtime.Goexit()</code>来停止，尽管这样做几乎没有必要。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"In main()"</span>)</span><br><span class="line">    <span class="keyword">go</span> longWait()</span><br><span class="line">    <span class="keyword">go</span> shortWait()</span><br><span class="line">    fmt.Println(<span class="string">"About to sleep in main()"</span>)</span><br><span class="line">    <span class="comment">// sleep works with a Duration in nanoseconds (ns) !</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * <span class="number">1e9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"At the end of main()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longWait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Beginning longWait()"</span>)</span><br><span class="line">    time.Sleep(<span class="number">5</span> * <span class="number">1e9</span>) <span class="comment">// sleep for 5 seconds</span></span><br><span class="line">    fmt.Println(<span class="string">"End of longWait()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortWait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Beginning shortWait()"</span>)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>) <span class="comment">// sleep for 2 seconds</span></span><br><span class="line">    fmt.Println(<span class="string">"End of shortWait()"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：  </p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">In</span></span> <span class="function"><span class="title">main</span>()</span></span><br><span class="line"><span class="variable">About</span> <span class="variable">to</span> <span class="variable">sleep</span> <span class="variable"><span class="keyword">in</span></span> <span class="function"><span class="title">main</span>()</span></span><br><span class="line"><span class="variable">Beginning</span> <span class="function"><span class="title">longWait</span>()</span></span><br><span class="line"><span class="variable">Beginning</span> <span class="function"><span class="title">shortWait</span>()</span></span><br><span class="line"><span class="variable">End</span> <span class="variable">of</span> <span class="function"><span class="title">shortWait</span>()</span></span><br><span class="line"><span class="variable">End</span> <span class="variable">of</span> <span class="function"><span class="title">longWait</span>()</span></span><br><span class="line"><span class="variable">At</span> <span class="variable">the</span> <span class="variable">end</span> <span class="variable">of</span> <span class="function"><span class="title">main</span>() <span class="comment">// after 10s</span></span></span><br></pre></td></tr></table></figure>

<p>当 <code>main()</code> 函数返回的时候，程序退出：它不会等待任何其他非 main 协程的结束。这就是为什么在服务器程序中，每一个请求都会启动一个协程来处理，<code>server()</code> 函数必须保持运行状态。通常使用一个无限循环来达到这样的目的。  </p>
<h3 id="Go-协程（goroutines）和协程（coroutines）"><a href="#Go-协程（goroutines）和协程（coroutines）" class="headerlink" title="Go 协程（goroutines）和协程（coroutines）"></a>Go 协程（goroutines）和协程（coroutines）</h3><p>在其他语言中，比如 C#，Lua 或者 Python 都有协程的概念。这个名字表明它和 Go协程有些相似，但有两点不同：  </p>
<ul>
<li>Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的  </li>
<li>Go 协程通过通道来通信；协程通过让出和恢复操作来通信  </li>
</ul>
<p>Go 协程比协程更强大，也很容易从协程的逻辑复用到 Go 协程。  </p>
<h2 id="协程间的信道"><a href="#协程间的信道" class="headerlink" title="协程间的信道"></a>协程间的信道</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Go 有一种特殊的类型，<em>通道（channel）<em>，就像一个可以用于发送类型化数据的管道，由其负责协程之间的通信，从而避开所有由共享内存导致的陷阱；这种通过通道进行通信的方式保证了同步性。数据在通道中进行传递：</em>在任何给定时间，一个数据被设计为只有一个协程可以对其访问，所以不会发生数据竞争。</em> 数据的所有权（可以读写数据的能力）也因此被传递。  </p>
<p>声明通道：<code>var identifier chan datatype</code>  </p>
<p>未初始化的通道的值是nil。  </p>
<p>所以通道只能传输一种类型的数据，比如 <code>chan int</code> 或者 <code>chan string</code>，所有的类型都可以用于通道，空接口 <code>interface{}</code> 也可以。甚至可以（有时非常有用）创建通道的通道。  </p>
<p>通道实际上是类型化消息的队列：使数据得以传输。它是先进先出（FIFO）的结构所以可以保证发送给他们的元素的顺序（有些人知道，通道可以比作 Unix shells 中的双向管道（two-way pipe））。通道也是引用类型，所以我们使用 <code>make()</code> 函数来给它分配内存。这里先声明了一个字符串通道 ch1，然后创建了它（实例化）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>

<p>可以更短： <code>ch1 := make(chan string)</code>  </p>
<p>构建一个int通道的通道： <code>chanOfChans := make(chan int)</code>  </p>
<p>或者函数通道：<code>funcChan := make(chan func())</code>  </p>
<p>所以通道是对象的第一类型：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。另外它们是类型化的，允许类型检查，比如尝试使用整数通道发送一个指针。  </p>
<h3 id="通信操作符-lt"><a href="#通信操作符-lt" class="headerlink" title="通信操作符 &lt;-"></a>通信操作符 &lt;-</h3><p>这个操作符直观的标示了数据的传输：信息按照箭头的方向流动。</p>
<p>流向通道（发送）</p>
<p><code>ch &lt;- int1</code> 表示：用通道 ch 发送变量 int1（双目运算符，中缀 = 发送）  </p>
<p>从通道流出（接收），三种方式：  </p>
<p><code>int2 = &lt;- ch</code> 表示：变量 int2 从通道 ch（一元运算的前缀操作符，前缀 = 接收）接收数据（获取新值）；假设 int2 已经声明过了，如果没有的话可以写成：<code>int2 := &lt;- ch</code>。  </p>
<p><code>&lt;- ch</code> 可以单独调用获取通道的（下一个）值，当前值会被丢弃，但是可以用来验证，所以以下代码是合法的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;- ch != <span class="number">1000</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作符 &lt;- 也被用来发送和接收，Go 尽管不必要，为了可读性，通道的命名通常以 <code>ch</code> 开头或者包含 <code>chan</code>。通道的发送和接收操作都是自动的：它们通常一气呵成。例子：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> sendData(ch)</span><br><span class="line">    <span class="keyword">go</span> getData(ch)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Washington"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tripoli"</span></span><br><span class="line">    ch &lt;- <span class="string">"London"</span></span><br><span class="line">    ch &lt;- <span class="string">"Beijing"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tokyo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// time.Sleep(2e9)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        input = &lt;-ch</span><br><span class="line">        fmt.Printf(<span class="string">"%s "</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Washington</span> Tripoli London <span class="keyword">Beijing </span>tokyo</span><br></pre></td></tr></table></figure>

<p><code>main()</code> 函数中启动了两个协程：<code>sendData()</code> 通过通道 ch 发送了 5 个字符串，<code>getData()</code> 按顺序接收它们并打印出来。  </p>
<p>如果 2 个协程需要通信，你必须给他们同一个通道作为参数才行。  </p>
<p>协程之间的同步非常重要：  </p>
<ul>
<li>main() 等待了 1 秒让两个协程完成，如果不这样，sendData() 就没有机会输出。</li>
<li>getData() 使用了无限循环：它随着 sendData() 的发送完成和 ch 变空也结束了。</li>
<li>如果我们移除一个或所有 <code>go</code> 关键字，程序无法运行，Go 运行时会抛出 panic：</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">---- Error run E:/Go/Goboek/<span class="keyword">code</span> examples/chapter <span class="number">14</span>/goroutine2.exe <span class="keyword">with</span> <span class="keyword">code</span> Crashed ---- Program exited <span class="keyword">with</span> <span class="keyword">code</span> <span class="number">-2147483645</span>: panic: all goroutines are asleep-deadlock!</span><br></pre></td></tr></table></figure>

<p>为什么会这样？运行时会检查所有的协程（也许只有一个是这种情况）是否在等待（可以读取或者写入某个通道），意味着程序无法处理。这是死锁（deadlock）形式，运行时可以检测到这种情况。  </p>
<p>注意：不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。  </p>
<h3 id="通道阻塞"><a href="#通道阻塞" class="headerlink" title="通道阻塞"></a>通道阻塞</h3><p>1）对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。  </p>
<p>2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。  </p>
<h3 id="通过一个（或多个）通道交换数据进行协程同步"><a href="#通过一个（或多个）通道交换数据进行协程同步" class="headerlink" title="通过一个（或多个）通道交换数据进行协程同步"></a>通过一个（或多个）通道交换数据进行协程同步</h3><p>通信是一种同步形式：通过通道，两个协程在通信（协程会和）中某刻同步交换数据。无缓冲通道成为了多个协程同步的完美工具。  </p>
<p>甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态。Go 运行时会检查并 panic，停止程序。死锁几乎完全是由糟糕的设计导致的。  </p>
<p>无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道。  </p>
<h3 id="同步通道-使用带缓冲的通道"><a href="#同步通道-使用带缓冲的通道" class="headerlink" title="同步通道-使用带缓冲的通道"></a>同步通道-使用带缓冲的通道</h3><p>一个无缓冲通道只能包含 1 个元素，有时显得很局限。我们给通道提供了一个缓存，可以在扩展的 <code>make</code> 命令中设置它的容量，如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">buf := <span class="number">100</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, buf)</span><br></pre></td></tr></table></figure>

<p>buf 是通道可以同时容纳的元素（这里是 string）个数  </p>
<p>在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。  </p>
<p>缓冲容量和类型无关，所以可以（尽管可能导致危险）给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 <code>cap</code> 函数可以返回缓冲区的容量。  </p>
<p>如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是0或者未设置，通信仅在收发双方准备好的情况下才可以成功。  </p>
<p>同步：<code>ch :=make(chan type, value)</code>  </p>
<ul>
<li>value == 0 -&gt; synchronous, unbuffered (阻塞）</li>
<li>value &gt; 0 -&gt; asynchronous, buffered（非阻塞）取决于value元素</li>
</ul>
<p>若使用通道的缓冲，你的程序会在“请求”激增的时候表现更好：更具弹性，专业术语叫：更具有伸缩性（scalable）。要在首要位置使用无缓冲通道来设计算法，只在不确定的情况下使用缓冲。  </p>
<h3 id="协程中用通道输出结果"><a href="#协程中用通道输出结果" class="headerlink" title="协程中用通道输出结果"></a>协程中用通道输出结果</h3><p>为了知道计算何时完成，可以通过信道回报。在例子 <code>go sum(bigArray)</code> 中，要这样写：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(bigArray, ch) <span class="comment">// bigArray puts the calculated sum on ch</span></span><br><span class="line"><span class="comment">// .. do something else for a while</span></span><br><span class="line">sum := &lt;- ch <span class="comment">// wait for, and retrieve the sum</span></span><br></pre></td></tr></table></figure>

<p>也可以使用通道来达到同步的目的，这个很有效的用法在传统计算机中称为信号量（semaphore）。或者换个方式：通过通道发送信号告知处理已经完成（在协程中）。  </p>
<p>在其他协程运行时让 main 程序无限阻塞的通常做法是在 <code>main</code> 函数的最后放置一个{}。 </p>
<p>也可以使用通道让 <code>main</code> 程序等待协程完成，就是所谓的信号量模式：  </p>
<h3 id="信号量模式"><a href="#信号量模式" class="headerlink" title="信号量模式"></a>信号量模式</h3><p>协程通过在通道 <code>ch</code> 中放置一个值来处理结束的信号。<code>main</code> 协程等待 <code>&lt;-ch</code> 直到从中获取到值。  </p>
<p>我们期望从这个通道中获取返回的结果，像这样：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    ch &lt;- someComputation() <span class="comment">// when it completes, signal on the channel.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// allocate a channel.</span></span><br><span class="line">    <span class="keyword">go</span> compute(ch)      <span class="comment">// stat something in a goroutines</span></span><br><span class="line">    doSomethingElseForAWhile()</span><br><span class="line">    result := &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个信号也可以是其他的，不返回结果，比如下面这个协程中的匿名函数（lambda）协程：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">    ch &lt;- <span class="number">1</span> <span class="comment">// Send a signal; value does not matter</span></span><br><span class="line">&#125;()</span><br><span class="line">doSomethingElseForAWhile()</span><br><span class="line">&lt;- ch   <span class="comment">// Wait for goroutine to finish; discard sent value.</span></span><br></pre></td></tr></table></figure>

<p>或者等待两个协程完成，每一个都会对切片s的一部分进行排序，片段如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">// doSort is a lambda function, so a closure which knows the channel done:</span></span><br><span class="line">doSort := <span class="function"><span class="keyword">func</span><span class="params">(s []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    sort(s)</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">i := pivot(s)</span><br><span class="line"><span class="keyword">go</span> doSort(s[:i])</span><br><span class="line"><span class="keyword">go</span> doSort(s[i:])</span><br><span class="line">&lt;-done</span><br><span class="line">&lt;-done</span><br></pre></td></tr></table></figure>

<p>下边的代码，用完整的信号量模式对长度为N的 float64 切片进行了 N 个<code>doSomething()</code> 计算并同时完成，通道 sem 分配了相同的长度（切包含空接口类型的元素），待所有的计算都完成后，发送信号（通过放入值）。在循环中从通道 sem 不停的接收数据来等待所有的协程完成。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> empty Empty</span><br><span class="line">...</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">float64</span>, N)</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">float64</span>, N)</span><br><span class="line">sem := <span class="built_in">make</span>(<span class="keyword">chan</span> Empty, N)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> i, xi := <span class="keyword">range</span> data &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>, xi <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">        res[i] = doSomething(i, xi)</span><br><span class="line">        sem &lt;- empty</span><br><span class="line">    &#125; (i, xi)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait for goroutines to finish</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123; &lt;-sem &#125;</span><br></pre></td></tr></table></figure>

<p>注意闭合：<code>i</code>、<code>xi</code> 都是作为参数传入闭合函数的，从外层循环中隐藏了变量 <code>i</code> 和 <code>xi</code>。让每个协程有一份 <code>i</code> 和 <code>xi</code> 的拷贝；另外，for 循环的下一次迭代会更新所有协程中 <code>i</code> 和 <code>xi</code> 的值。切片 <code>res</code> 没有传入闭合函数，因为协程不需要单独拷贝一份。切片 <code>res</code> 也在闭合函数中但并不是参数。  </p>
<h3 id="实现并行的-for-循环"><a href="#实现并行的-for-循环" class="headerlink" title="实现并行的 for 循环"></a>实现并行的 for 循环</h3><p>在 for 循环中并行计算迭代可能带来很好的性能提升。不过所有的迭代都必须是独立完成的。for 循环的每一个迭代是并行完成的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>, v <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">        doSomething(i, v)</span><br><span class="line">        ...</span><br><span class="line">    &#125; (i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用带缓冲通道实现一个信号量"><a href="#用带缓冲通道实现一个信号量" class="headerlink" title="用带缓冲通道实现一个信号量"></a>用带缓冲通道实现一个信号量</h3><p>信号量是实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题，比如没有实现信号量的 <code>sync</code> 的 Go 包，使用带缓冲的通道可以轻松实现：  </p>
<ul>
<li>带缓冲通道的容量和要同步的资源容量相同</li>
<li>通道的长度（当前存放的元素个数）与当前资源被使用的数量相同</li>
<li>容量减去通道的长度就是未处理的资源个数（标准信号量的整数值）</li>
</ul>
<p>不用管通道中存放的是什么，只关注长度；因此我们创建了一个长度可变但容量为0（字节）的通道：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> semaphore <span class="keyword">chan</span> Empty</span><br></pre></td></tr></table></figure>

<p>将可用资源的数量N来初始化信号量 <code>semaphore</code>：<code>sem = make(semaphore, N)</code>  </p>
<p>然后直接对信号量进行操作：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// acquire n resources</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">P</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    e := <span class="built_in">new</span>(Empty)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        s &lt;- e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release n resouces</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">V</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; n; i++&#123;</span><br><span class="line">        &lt;- s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用来实现一个互斥的例子：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* mutexes */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.P(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">Unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s.V(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* signal-wait */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">Wait</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.P(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.V(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给通道使用-for-循环"><a href="#给通道使用-for-循环" class="headerlink" title="给通道使用 for 循环"></a>给通道使用 for 循环</h3><p><code>for</code> 循环的 <code>range</code> 语句可以用在通道 <code>ch</code> 上，便可以从通道中获取值，像这样：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"The value is %v\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习惯用法：通道迭代模式<br>这个模式用到了后边14.6章示例 producer_consumer.go 的生产者-消费者模式，通常，需要从包含了地址索引字段 items 的容器给通道填入元素。为容器的类型定义一个方法 <code>Iter()</code>，返回一个只读的通道（参见第 14.2.8 节）items，如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span> <span class="title">Iter</span> <span class="params">()</span> &lt;- <span class="title">chan</span> <span class="title">item</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> item)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; c.Len(); i++&#123;    <span class="comment">// or use a for-range loop</span></span><br><span class="line">            ch &lt;- c.items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在协程里，一个 for 循环迭代容器 c 中的元素（对于树或图的算法，这种简单的 for 循环可以替换为深度优先搜索）。  </p>
<p>调用这个方法的代码可以这样迭代容器：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> container.Iter() &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>可以运行在自己的协程中，所以上边的迭代用到了一个通道和两个协程（可能运行在两个线程上）。就有了一个特殊的生产者-消费者模式。如果程序在协程给通道写完值之前结束，协程不会被回收；设计如此。这种行为看起来是错误的，但是通道是一种线程安全的通信。在这种情况下，协程尝试写入一个通道，而这个通道永远不会被读取，这可能是个 bug 而并非期望它被静默的回收。  </p>
<p>习惯用法：生产者消费者模式  </p>
<p>假设你有 <code>Produce()</code> 函数来产生 <code>Consume</code> 函数需要的值。它们都可以运行在独立的协程中，生产者在通道中放入给消费者读取的值。整个处理过程可以替换为无限循环：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    Consume(Produce())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通道的方向"><a href="#通道的方向" class="headerlink" title="通道的方向"></a>通道的方向</h3><p>通道类型可以用注解来表示它只发送或者只接收：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> send_only <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>        <span class="comment">// channel can only receive data</span></span><br><span class="line"><span class="keyword">var</span> recv_only &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>        <span class="comment">// channel can only send data</span></span><br></pre></td></tr></table></figure>
<p>只接收的通道（&lt;-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。通道创建的时候都是双向的，但也可以分配有方向的通道变量，就像以下代码：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// bidirectional</span></span><br><span class="line"><span class="keyword">go</span> source(c)</span><br><span class="line"><span class="keyword">go</span> sink(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">source</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123; ch &lt;- <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sink</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123; &lt;-ch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习惯用法：管道和选择器模式  </p>
<p>更具体的例子还有协程处理它从通道接收的数据并发送给输出通道：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sendChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">receiveChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> processChannel(sendChan, receiveChan)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processChannel</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> inValue := <span class="keyword">range</span> in &#123;</span><br><span class="line">        result := ... <span class="comment">/// processing inValue</span></span><br><span class="line">        out &lt;- result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用方向注解来限制协程对通道的操作。  </p>
<p>这里有一个来自 Go 指导的很赞的例子，打印了输出的素数，使用选择器（‘筛’）作为它的算法。每个 prime 都有一个选择器，如下图：  </p>
<p><img src="/images/the_way_to_go_14.2_fig14.2.png" alt="">  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.package main</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Send the sequence 2, 3, 4, ... to channel 'ch'.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">        ch &lt;- i <span class="comment">// Send 'i' to channel 'ch'.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy the values from channel 'in' to channel 'out',</span></span><br><span class="line"><span class="comment">// removing those divisible by 'prime'.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(in, out <span class="keyword">chan</span> <span class="keyword">int</span>, prime <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i := &lt;-in <span class="comment">// Receive value of new variable 'i' from 'in'.</span></span><br><span class="line">        <span class="keyword">if</span> i%prime != <span class="number">0</span> &#123;</span><br><span class="line">            out &lt;- i <span class="comment">// Send 'i' to channel 'out'.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The prime sieve: Daisy-chain filter processes together.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// Create a new channel.</span></span><br><span class="line">    <span class="keyword">go</span> generate(ch)      <span class="comment">// Start generate() as a goroutine.</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        prime := &lt;-ch</span><br><span class="line">        fmt.Print(prime, <span class="string">" "</span>)</span><br><span class="line">        ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> filter(ch, ch1, prime)</span><br><span class="line">        ch = ch1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协程 <code>filter(in, out chan int, prime int)</code> 拷贝整数到输出通道，丢弃掉可以被 prime 整除的数字。然后每个 prime 又开启了一个新的协程，生成器和选择器并发请求。  </p>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span> <span class="number">17</span> <span class="number">19</span> <span class="number">23</span> <span class="number">29</span> <span class="number">31</span> <span class="number">37</span> <span class="number">41</span> <span class="number">43</span> <span class="number">47</span> <span class="number">53</span> <span class="number">59</span> <span class="number">61</span> <span class="number">67</span> <span class="number">71</span> <span class="number">73</span> <span class="number">79</span> <span class="number">83</span> <span class="number">89</span> <span class="number">97</span> <span class="number">101</span></span><br><span class="line"><span class="number">103</span> <span class="number">107</span> <span class="number">109</span> <span class="number">113</span> <span class="number">127</span> <span class="number">131</span> <span class="number">137</span> <span class="number">139</span> <span class="number">149</span> <span class="number">151</span> <span class="number">157</span> <span class="number">163</span> <span class="number">167</span> <span class="number">173</span> <span class="number">179</span> <span class="number">181</span> <span class="number">191</span> <span class="number">193</span> <span class="number">197</span> <span class="number">199</span> <span class="number">211</span> <span class="number">223</span></span><br><span class="line"><span class="number">227</span> <span class="number">229</span> <span class="number">233</span> <span class="number">239</span> <span class="number">241</span> <span class="number">251</span> <span class="number">257</span> <span class="number">263</span> <span class="number">269</span> <span class="number">271</span> <span class="number">277</span> <span class="number">281</span> <span class="number">283</span> <span class="number">293</span> <span class="number">307</span> <span class="number">311</span> <span class="number">313</span> <span class="number">317</span> <span class="number">331</span> <span class="number">337</span> <span class="number">347</span> <span class="number">349</span></span><br><span class="line"><span class="number">353</span> <span class="number">359</span> <span class="number">367</span> <span class="number">373</span> <span class="number">379</span> <span class="number">383</span> <span class="number">389</span> <span class="number">397</span> <span class="number">401</span> <span class="number">409</span> <span class="number">419</span> <span class="number">421</span> <span class="number">431</span> <span class="number">433</span> <span class="number">439</span> <span class="number">443</span> <span class="number">449</span> <span class="number">457</span> <span class="number">461</span> <span class="number">463</span> <span class="number">467</span> <span class="number">479</span></span><br><span class="line"><span class="number">487</span> <span class="number">491</span> <span class="number">499</span> <span class="number">503</span> <span class="number">509</span> <span class="number">521</span> <span class="number">523</span> <span class="number">541</span> <span class="number">547</span> <span class="number">557</span> <span class="number">563</span> <span class="number">569</span> <span class="number">571</span> <span class="number">577</span> <span class="number">587</span> <span class="number">593</span> <span class="number">599</span> <span class="number">601</span> <span class="number">607</span> <span class="number">613</span> <span class="number">617</span> <span class="number">619</span></span><br><span class="line"><span class="number">631</span> <span class="number">641</span> <span class="number">643</span> <span class="number">647</span> <span class="number">653</span> <span class="number">659</span> <span class="number">661</span> <span class="number">673</span> <span class="number">677</span> <span class="number">683</span> <span class="number">691</span> <span class="number">701</span> <span class="number">709</span> <span class="number">719</span> <span class="number">727</span> <span class="number">733</span> <span class="number">739</span> <span class="number">743</span> <span class="number">751</span> <span class="number">757</span> <span class="number">761</span> <span class="number">769</span></span><br><span class="line"><span class="number">773</span> <span class="number">787</span> <span class="number">797</span> <span class="number">809</span> <span class="number">811</span> <span class="number">821</span> <span class="number">823</span> <span class="number">827</span> <span class="number">829</span> <span class="number">839</span> <span class="number">853</span> <span class="number">857</span> <span class="number">859</span> <span class="number">863</span> <span class="number">877</span> <span class="number">881</span> <span class="number">883</span> <span class="number">887</span> <span class="number">907</span> <span class="number">911</span> <span class="number">919</span> <span class="number">929</span></span><br><span class="line"><span class="number">937</span> <span class="number">941</span> <span class="number">947</span> <span class="number">953</span> <span class="number">967</span> <span class="number">971</span> <span class="number">977</span> <span class="number">983</span> <span class="number">991</span> <span class="number">997</span> <span class="number">1009</span> <span class="number">1013.</span>..</span><br></pre></td></tr></table></figure>

<p>第二个版本引入了上边的习惯用法：函数 <code>sieve</code>、<code>generate</code> 和 <code>filter</code> 都是工厂；它们创建通道并返回，而且使用了协程的 lambda 函数。<code>main</code> 函数现在短小清晰：它调用 <code>sieve()</code> 返回了包含素数的通道，然后通过 <code>fmt.Println(&lt;-primes)</code> 打印出来。  </p>
<p>版本2：示例 14.8-sieve2.go:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send the sequence 2, 3, 4, ... to returned channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter out input values divisible by 'prime', send rest to returned channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(in <span class="keyword">chan</span> <span class="keyword">int</span>, prime <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i := &lt;-in; i%prime != <span class="number">0</span> &#123;</span><br><span class="line">                out &lt;- i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sieve</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch := generate()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            prime := &lt;-ch</span><br><span class="line">            ch = filter(ch, prime)</span><br><span class="line">            out &lt;- prime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := sieve()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(&lt;-primes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协程的同步：关闭通道-测试阻塞的通道"><a href="#协程的同步：关闭通道-测试阻塞的通道" class="headerlink" title="协程的同步：关闭通道-测试阻塞的通道"></a>协程的同步：关闭通道-测试阻塞的通道</h2><p>通道可以被显式的关闭；尽管它们和文件不同：不必每次都关闭。只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道。只有发送者需要关闭通道，接收者永远不会需要。  </p>
<p>继续看示例 goroutine2.go：我们如何在通道的 <code>sendData()</code> 完成的时候发送一个信号，<code>getData()</code> 又如何检测到通道是否关闭或阻塞？  </p>
<p>第一个可以通过函数 <code>close(ch)</code> 来完成：这个将通道标记为无法通过发送操作 <code>&lt;-</code> 接受更多的值；给已经关闭的通道发送或者再次关闭都会导致运行时的 panic。在创建一个通道后使用 defer 语句是个不错的办法（类似这种情况）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">float64</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>第二个问题可以使用逗号，ok 操作符：用来检测通道是否被关闭。  </p>
<p>如何来检测可以收到没有被阻塞（或者通道没有被关闭）？  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch   <span class="comment">// ok is true if v received value</span></span><br></pre></td></tr></table></figure>

<p>通常和 if 语句一起使用：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := &lt;-ch; ok &#123;</span><br><span class="line">  process(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在 for 循环中接收的时候，当关闭或者阻塞的时候使用 break：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">process(v)</span><br></pre></td></tr></table></figure>

<p>在示例程序 14.2 中使用这些可以改进为版本 goroutine3.go，输出相同。</p>
<p>实现非阻塞通道的读取，需要使用 select。</p>
<p>示例 14.9-goroutine3.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> sendData(ch)</span><br><span class="line">    getData(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Washington"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tripoli"</span></span><br><span class="line">    ch &lt;- <span class="string">"London"</span></span><br><span class="line">    ch &lt;- <span class="string">"Beijing"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tokio"</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        input, open := &lt;-ch</span><br><span class="line">        <span class="keyword">if</span> !open &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"%s "</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改变了以下代码：  </p>
<ul>
<li>现在只有 <code>sendData()</code> 是协程，<code>getData()</code> 和 <code>main()</code> 在同一个线程中：  </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> sendData(ch)</span><br><span class="line">getData(ch)</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>sendData()</code> 函数的最后，关闭了通道：  </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Washington"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tripoli"</span></span><br><span class="line">    ch &lt;- <span class="string">"London"</span></span><br><span class="line">    ch &lt;- <span class="string">"Beijing"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tokio"</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 for 循环的 <code>getData()</code> 中，在每次接收通道的数据之前都使用 <code>if !open</code> 来检测：  </li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        input, open := &lt;-ch</span><br><span class="line">        <span class="keyword">if</span> !open &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"%s "</span>, input)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 for-range 语句来读取通道是更好的办法，因为这会自动检测通道是否关闭：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> input := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    process(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阻塞和生产者-消费者模式：  </p>
<p>在第 14.2.10 节的通道迭代器中，两个协程经常是一个阻塞另外一个。如果程序工作在多核心的机器上，大部分时间只用到了一个处理器。可以通过使用带缓冲（缓冲空间大于 0）的通道来改善。比如，缓冲大小为 100，迭代器在阻塞之前，至少可以从容器获得 100 个元素。如果消费者协程在独立的内核运行，就有可能让协程不会出现阻塞。  </p>
<p>由于容器中元素的数量通常是已知的，需要让通道有足够的容量放置所有的元素。这样，迭代器就不会阻塞（尽管消费者协程仍然可能阻塞）。然后，这样有效的加倍了迭代容器所需要的内存使用量，所以通道的容量需要限制一下最大值。记录运行时间和性能测试可以帮助你找到最小的缓存容量带来最好的性能。  </p>
<h2 id="使用-select-切换协程"><a href="#使用-select-切换协程" class="headerlink" title="使用 select 切换协程"></a>使用 select 切换协程</h2><p>从不同的并发执行的协程中获取值可以通过关键字<code>select</code>来完成，它和<code>switch</code>控制语句非常相似（章节5.3）也被称作通信开关；它的行为像是“你准备好了吗”的轮询机制；<code>select</code>监听进入通道的数据，也可以是用通道发送值的时候。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> u:= &lt;- ch1:</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// no value ready to be received</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>default</code> 语句是可选的；fallthrough 行为，和普通的 switch 相似，是不允许的。在任何一个 case 中执行 <code>break</code> 或者 <code>return</code>，select 就结束了。  </p>
<p><code>select</code> 做的就是：选择处理列出的多个通信情况中的一个。  </p>
<ul>
<li>如果都阻塞了，会等待直到其中一个可以处理</li>
<li>如果多个可以处理，随机选择一个</li>
<li>如果没有通道操作可以处理并且写了 <code>default</code> 语句，它就会执行：<code>default</code> 永远是可运行的（这就是准备好了，可以执行）。</li>
</ul>
<p>在 <code>select</code> 中使用发送操作并且有 <code>default</code> 可以确保发送不被阻塞！如果没有 <code>default</code>，select 就会一直阻塞。  </p>
<p><code>select</code> 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 <code>break</code> 语句使循环退出。  </p>
<p>在程序 goroutine_select.go中有 2 个通道 <code>ch1</code> 和 <code>ch2</code>，三个协程 <code>pump1()</code>、<code>pump2()</code> 和 <code>suck()</code>。这是一个典型的生产者消费者模式。在无限循环中，<code>ch1</code> 和 <code>ch2</code> 通过 <code>pump1()</code> 和 <code>pump2()</code> 填充整数；<code>suck()</code> 也是在无限循环中轮询输入的，通过 <code>select</code> 语句获取 <code>ch1</code> 和 <code>ch2</code> 的整数并输出。选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。  </p>
<p>示例 14.10-goroutine_select.go：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> pump1(ch1)</span><br><span class="line">    <span class="keyword">go</span> pump2(ch2)</span><br><span class="line">    <span class="keyword">go</span> suck(ch1, ch2)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        ch &lt;- i * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        ch &lt;- i + <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suck</span><span class="params">(ch1, ch2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-ch1:</span><br><span class="line">            fmt.Printf(<span class="string">"Received on channel 1: %d\n"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-ch2:</span><br><span class="line">            fmt.Printf(<span class="string">"Received on channel 2: %d\n"</span>, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：  </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Received on channel <span class="number">2</span>: <span class="number">5</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">6</span></span><br><span class="line">Received on channel <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">7</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">8</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">9</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">10</span></span><br><span class="line">Received on channel <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">11</span></span><br><span class="line">...</span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">47404</span></span><br><span class="line">Received on channel <span class="number">1</span>: <span class="number">94346</span></span><br><span class="line">Received on channel <span class="number">1</span>: <span class="number">94348</span></span><br></pre></td></tr></table></figure>

<h2 id="通道、超时和计时器（Ticker）"><a href="#通道、超时和计时器（Ticker）" class="headerlink" title="通道、超时和计时器（Ticker）"></a>通道、超时和计时器（Ticker）</h2><p><code>time</code> 包中包含了 <code>time.Ticker</code> 结构体，这个对象以指定的时间间隔重复的向通道 C 发送时间值：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time <span class="comment">// the channel on which the ticks are delivered.</span></span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间间隔的单位是 ns（纳秒，int64），在工厂函数 <code>time.NewTicker</code> 中以 <code>Duration</code> 类型的参数传入：<code>func Newticker(dur) *Ticker</code>。  </p>
<p>在协程周期性的执行一些事情（打印状态日志，输出，计算等等）的时候非常有用。  </p>
<p>调用 <code>Stop()</code> 使计时器停止，在 <code>defer</code> 语句中使用。这些都很好的适应 <code>select</code> 语句:  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ticker := time.NewTicker(updateInterval)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> u:= &lt;-ch1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;-ch2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">    logState(status) <span class="comment">// call some logging function logState</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// no value ready to be received</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>time.Tick()</code> 函数声明为 <code>Tick(d Duration) &lt;-chan Time</code>，当你想返回一个通道而不必关闭它的时候这个函数非常有用：它以 d 为周期给返回的通道发送时间，d是纳秒数。如果需要像下边的代码一样，限制处理频率（函数 <code>client.Call()</code> 是一个 RPC 调用，这里暂不赘述：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">rate_per_sec := <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> dur Duration = <span class="number">1e9</span> / rate_per_sec</span><br><span class="line">chRate := time.Tick(dur) <span class="comment">// a tick every 1/10th of a second</span></span><br><span class="line"><span class="keyword">for</span> req := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    &lt;- chRate <span class="comment">// rate limit our Service.Method RPC calls</span></span><br><span class="line">    <span class="keyword">go</span> client.Call(<span class="string">"Service.Method"</span>, req, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只会按照指定频率处理请求：<code>chRate</code> 阻塞了更高的频率。每秒处理的频率可以根据机器负载（和/或）资源的情况而增加或减少。  </p>
<p>定时器（Timer）结构体看上去和计时器（Ticker）结构体的确很像（构造为 <code>NewTimer(d Duration)</code>），但是它只发送一次时间，在 <code>Dration d</code> 之后。  </p>
<p>还有 <code>time.After(d)</code> 函数，声明如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure>

<p>在 <code>Duration d</code> 之后，当前时间被发到返回的通道；所以它和 <code>NewTimer(d).C</code> 是等价的；它类似 <code>Tick()</code>，但是 <code>After()</code> 只发送一次时间。下边有个很具体的示例，很好的阐明了 <code>select</code> 中 <code>default</code> 的作用：  </p>
<p>示例 14.11：timer_goroutine.go)：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(<span class="number">1e8</span>)</span><br><span class="line">    boom := time.After(<span class="number">5e8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            fmt.Println(<span class="string">"tick."</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-boom:</span><br><span class="line">            fmt.Println(<span class="string">"BOOM!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"    ."</span>)</span><br><span class="line">            time.Sleep(<span class="number">5e7</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：  </p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">BOOM!</span><br></pre></td></tr></table></figure>

<p>习惯用法：简单超时模式  </p>
<p>要从通道 <code>ch</code> 中接收数据，但是最多等待1秒。先创建一个信号通道，然后启动一个 <code>lambda</code> 协程，协程在给通道发送数据之前是休眠的：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1e9</span>) <span class="comment">// one second</span></span><br><span class="line">        timeout &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>select</code> 语句接收 <code>ch</code> 或者 <code>timeout</code> 的数据：如果 <code>ch</code> 在 1 秒内没有收到数据，就选择到了 <code>time</code> 分支并放弃了 <code>ch</code> 的读取。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="comment">// a read from ch has occured</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">        <span class="comment">// the read from ch has timed out</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种形式：取消耗时很长的同步调用  </p>
<p>也可以使用 <code>time.After()</code> 函数替换 <code>timeout-channel</code>。可以在 <code>select</code> 中通过 <code>time.After()</code> 发送的超时信号来停止协程的执行。以下代码，在 <code>timeoutNs</code> 纳秒后执行 <code>select</code> 的 <code>timeout</code> 分支后，执行<code>client.Call</code> 的协程也随之结束，不会给通道 <code>ch</code> 返回值：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- client.Call(<span class="string">"Service.Method"</span>, args, &amp;reply) &#125; ()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> resp := &lt;-ch</span><br><span class="line">    <span class="comment">// use resp and reply</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeoutNs):</span><br><span class="line">    <span class="comment">// call timed out</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意缓冲大小设置为 1 是必要的，可以避免协程死锁以及确保超时的通道可以被垃圾回收。此外，需要注意在有多个 <code>case</code> 符合条件时， <code>select</code> 对 <code>case</code> 的选择是伪随机的，如果上面的代码稍作修改如下，则 <code>select</code> 语句可能不会在定时器超时信号到来时立刻选中 <code>time.After(timeoutNs)</code> 对应的 <code>case</code>，因此协程可能不会严格按照定时器设置的时间结束。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; ch &lt;- <span class="number">1</span> &#125; &#125; ()</span><br><span class="line">L:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(timeoutNs):</span><br><span class="line">        <span class="comment">// call timed out</span></span><br><span class="line">        <span class="keyword">break</span> L</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种形式：假设程序从多个复制的数据库同时读取。只需要一个答案，需要接收首先到达的答案，<code>Query</code> 函数获取数据库的连接切片并请求。并行请求每一个数据库并返回收到的第一个响应：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(conns []conn, query <span class="keyword">string</span>)</span> <span class="title">Result</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, conn := <span class="keyword">range</span> conns &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c Conn)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- c.DoQuery(query):</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(conn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次声明，结果通道 <code>ch</code> 必须是带缓冲的：以保证第一个发送进来的数据有地方可以存放，确保放入的首个数据总会成功，所以第一个到达的值会被获取而与执行的顺序无关。正在执行的协程可以总是可以使用 <code>runtime.Goexit()</code> 来停止。  </p>
<p>在应用中缓存数据：  </p>
<p>应用程序中用到了来自数据库（或者常见的数据存储）的数据时，经常会把数据缓存到内存中，因为从数据库中获取数据的操作代价很高；如果数据库中的值不发生变化就没有问题。但是如果值有变化，我们需要一个机制来周期性的从数据库重新读取这些值：缓存的值就不可用（过期）了，而且我们也不希望用户看到陈旧的数据。  </p>
<h2 id="协程和恢复（recover）"><a href="#协程和恢复（recover）" class="headerlink" title="协程和恢复（recover）"></a>协程和恢复（recover）</h2><p>一个用到 <code>recover</code> 的程序停掉了服务器内部一个失败的协程而不影响其他协程的工作。  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">        <span class="keyword">go</span> safelyDo(work)   <span class="comment">// start the goroutine for that work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"Work failed with %s in %v"</span>, err, work)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码，如果 <code>do(work)</code> 发生 panic，错误会被记录且协程会退出并释放，而其他协程不受影响。  </p>
<p>因为 <code>recover</code> 总是返回 <code>nil</code>，除非直接在 <code>defer</code> 修饰的函数中调用，<code>defer</code> 修饰的代码可以调用那些自身可以使用 <code>panic</code> 和 <code>recover</code> 避免失败的库例程（库函数）。举例，<code>safelyDo()</code> 中 <code>defer</code> 修饰的函数可能在调用 <code>recover</code> 之前就调用了一个 <code>logging</code> 函数，<code>panicking</code> 状态不会影响 <code>logging</code> 代码的运行。因为加入了恢复模式，函数 <code>do</code>（以及它调用的任何东西）可以通过调用 <code>panic</code> 来摆脱不好的情况。但是恢复是在 <code>panicking</code> 的协程内部的：不能被另外一个协程恢复。  </p>
<h2 id="新旧模型对比：任务和worker-（锁vs协程）"><a href="#新旧模型对比：任务和worker-（锁vs协程）" class="headerlink" title="新旧模型对比：任务和worker （锁vs协程）"></a>新旧模型对比：任务和worker （锁vs协程）</h2><p>假设我们需要处理很多任务；一个worker处理一项任务。任务可以被定义为一个结构体（具体的细节在这里并不重要）：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// some state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>旧模式：使用共享内存进行同步  </p>
<p>由各个任务组成的任务池共享内存；为了同步各个worker以及避免资源竞争，我们需要对任务池进行加锁保护：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    Mu      sync.Mutex</span><br><span class="line">    Tasks   []Task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sync.Mutex(是互斥锁：它用来在代码中保护临界区资源：同一时间只有一个go协程（goroutine）可以进入该临界区。如果出现了同一时间多个go协程都进入了该临界区，则会产生竞争：Pool结构就不能保证被正确更新。在传统的模式中（经典的面向对象的语言中应用得比较多，比如C++,JAVA,C#)，worker代码可能这样写：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(pool *Pool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        pool.Mu.lock()</span><br><span class="line">        <span class="comment">// begin critical section:</span></span><br><span class="line">        task := pool.Task[<span class="number">0</span>]        <span class="comment">// take the first task</span></span><br><span class="line">        pool.Tasks = pool.Task[<span class="number">1</span>:]  <span class="comment">// update the pool of tasks</span></span><br><span class="line">        <span class="comment">// end critical section</span></span><br><span class="line">        pool.Mu.Unlock()</span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些worker有许多都可以并发执行；他们可以在go协程中启动。一个worker先将pool锁定，从pool获取第一项任务，再解锁和处理任务。加锁保证了同一时间只有一个go协程可以进入到pool中：一项任务有且只能被赋予一个worker。如果不加锁，则工作协程可能会在<code>task:=pool.Task[0]</code>发生切换，导致<code>pool.Tasks=pool.Task[1:]</code>结果异常：一些worker获取不到任务，而一些任务可能被多个worker得到。加锁实现同步的方式在工作协程比较少时可以工作的很好，但是当工作协程数量很大，任务量也很多时，处理效率将会因为频繁的加锁/解锁开销而降低。当工作协程数增加到一个阈值时，程序效率会急剧下降，这就成为了瓶颈。  </p>
<p>新模式：使用通道  </p>
<p>使用通道进行同步：使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker在协程中启动，其数量N应该根据任务数量进行调整。  </p>
<p>主线程扮演着Master节点角色，可能写成如下形式：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pending, done := <span class="built_in">make</span>(<span class="keyword">chan</span> *Task), <span class="built_in">make</span>(<span class="keyword">chan</span> *Task)</span><br><span class="line">    <span class="keyword">go</span> sendWork(pending)       <span class="comment">// put tasks with work on the channel</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;   <span class="comment">// start N goroutines to do work</span></span><br><span class="line">        <span class="keyword">go</span> Worker(pending, done)</span><br><span class="line">    &#125;</span><br><span class="line">    consumeWork(done)          <span class="comment">// continue with the processed tasks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker的逻辑比较简单：从pending通道拿任务，处理后将其放到done通道中：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(in, out <span class="keyword">chan</span> *Task)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里并不使用锁：从通道得到新任务的过程没有任何竞争。随着任务数量增加，worker数量也应该相应增加，同时性能并不会像第一种方式那样下降明显。在pending通道中存在一份任务的拷贝，第一个worker从pending通道中获得第一个任务并进行处理，这里并不存在竞争（对一个通道读数据和写数据的整个过程是原子性的)。某一个任务会在哪一个worker中被执行是不可知的，反过来也是。worker数量的增多也会增加通信的开销，这会对性能有轻微的影响。  </p>
<p>从这个简单的例子中可能很难看出第二种模式的优势，但含有复杂锁运用的程序不仅在编写上显得困难，也不容易编写正确，使用第二种模式的话，就无需考虑这么复杂的东西了。  </p>
<p>因此，第二种模式对比第一种模式而言，不仅性能是一个主要优势，而且还有个更大的优势：代码显得更清晰、更优雅。一个更符合go语言习惯的worker写法：  </p>
<p><strong>IDIOM: Use an in- and out-channel instead of locking</strong>  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(in, out <span class="keyword">chan</span> *Task)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于任何可以建模为Master-Worker范例的问题，一个类似于worker使用通道进行通信和交互、Master进行整体协调的方案都能完美解决。如果系统部署在多台机器上，各个机器上执行Worker协程，Master和Worker之间使用netchan或者RPC进行通信（见下章）。  </p>
<p>怎么选择是该使用锁还是通道？  </p>
<p>通道是一个较新的概念，本节我们着重强调了在go协程里通道的使用，但这并不意味着经典的锁方法就不能使用。go语言让你可以根据实际问题进行选择：创建一个优雅、简单、可读性强、在大多数场景性能表现都能很好的方案。如果你的问题适合使用锁，也不要忌讳使用它。go语言注重实用，什么方式最能解决你的问题就用什么方式，而不是强迫你使用一种编码风格。下面列出一个普遍的经验法则：  </p>
<ul>
<li><p>使用锁的情景：</p>
<ul>
<li>访问共享数据结构中的缓存信息</li>
<li>保存应用程序上下文和状态信息数据</li>
</ul>
</li>
<li><p>使用通道的情景：</p>
<ul>
<li>与异步操作的结果进行交互</li>
<li>分发任务</li>
<li>传递数据所有权</li>
</ul>
</li>
</ul>
<p>当你发现你的锁使用规则变得很复杂时，可以反省使用通道会不会使问题变得简单些。  </p>
<h2 id="惰性生成器的实现"><a href="#惰性生成器的实现" class="headerlink" title="惰性生成器的实现"></a>惰性生成器的实现</h2><p>生成器是指当被调用时返回一个序列中下一个值的函数，例如：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">generateInteger() =&gt; <span class="number">0</span></span><br><span class="line">generateInteger() =&gt; <span class="number">1</span></span><br><span class="line">generateInteger() =&gt; <span class="number">2</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>生成器每次返回的是序列中下一个值而非整个序列；这种特性也称之为惰性求值：只在你需要时进行求值，同时保留相关变量资源（内存和cpu）：这是一项在需要时对表达式进行求值的技术。例如，生成一个无限数量的偶数序列：要产生这样一个序列并且在一个一个的使用可能会很困难，而且内存会溢出！但是一个含有通道和go协程的函数能轻易实现这个需求。  </p>
<p>在14.12的例子中，我们实现了一个使用 int 型通道来实现的生成器。通道被命名为<code>yield</code>和<code>resume</code>，这些词经常在协程代码中使用。  </p>
<p>示例 14.12 lazy_evaluation.go：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resume <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integers</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    yield := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            yield &lt;- count</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> yield</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateInteger</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;-resume</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resume = integers()</span><br><span class="line">    fmt.Println(generateInteger())  <span class="comment">//=&gt; 0</span></span><br><span class="line">    fmt.Println(generateInteger())  <span class="comment">//=&gt; 1</span></span><br><span class="line">    fmt.Println(generateInteger())  <span class="comment">//=&gt; 2    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个细微的区别是从通道读取的值可能会是稍早前产生的，并不是在程序被调用时生成的。如果确实需要这样的行为，就得实现一个请求响应机制。当生成器生成数据的过程是计算密集型且各个结果的顺序并不重要时，那么就可以将生成器放入到go协程实现并行化。但是得小心，使用大量的go协程的开销可能会超过带来的性能增益。  </p>
<p>这些原则可以概括为：通过巧妙地使用空接口、闭包和高阶函数，我们能实现一个通用的惰性生产器的工厂函数<code>BuildLazyEvaluator</code>（这个应该放在一个工具包中实现）。工厂函数需要一个函数和一个初始状态作为输入参数，返回一个无参、返回值是生成序列的函数。传入的函数需要计算出下一个返回值以及下一个状态参数。在工厂函数中，创建一个通道和无限循环的go协程。返回值被放到了该通道中，返回函数稍后被调用时从该通道中取得该返回值。每当取得一个值时，下一个值即被计算。在下面的例子中，定义了一个<code>evenFunc</code>函数，其是一个惰性生成函数：在main函数中，我们创建了前10个偶数，每个都是通过调用<code>even()</code>函数取得下一个值的。为此，我们需要在<code>BuildLazyIntEvaluator</code>函数中具体化我们的生成函数，然后我们能够基于此做出定义。  </p>
<p>示例 14.13 general_lazy_evalution1.go：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> EvalFunc <span class="function"><span class="keyword">func</span><span class="params">(Any)</span> <span class="params">(Any, Any)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    evenFunc := <span class="function"><span class="keyword">func</span><span class="params">(state Any)</span> <span class="params">(Any, Any)</span></span> &#123;</span><br><span class="line">        os := state.(<span class="keyword">int</span>)</span><br><span class="line">        ns := os + <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> os, ns</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    even := BuildLazyIntEvaluator(evenFunc, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%vth even: %v\n"</span>, i, even())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildLazyEvaluator</span><span class="params">(evalFunc EvalFunc, initState Any)</span> <span class="title">func</span><span class="params">()</span> <span class="title">Any</span></span> &#123;</span><br><span class="line">    retValChan := <span class="built_in">make</span>(<span class="keyword">chan</span> Any)</span><br><span class="line">    loopFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> actState Any = initState</span><br><span class="line">        <span class="keyword">var</span> retVal Any</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            retVal, actState = evalFunc(actState)</span><br><span class="line">            retValChan &lt;- retVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    retFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">Any</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;- retValChan</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> loopFunc()</span><br><span class="line">    <span class="keyword">return</span> retFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildLazyIntEvaluator</span><span class="params">(evalFunc EvalFunc, initState Any)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ef := BuildLazyEvaluator(evalFunc, initState)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ef().(<span class="keyword">int</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>th even: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>th even: <span class="number">2</span></span><br><span class="line"><span class="number">2</span>th even: <span class="number">4</span></span><br><span class="line"><span class="number">3</span>th even: <span class="number">6</span></span><br><span class="line"><span class="number">4</span>th even: <span class="number">8</span></span><br><span class="line"><span class="number">5</span>th even: <span class="number">10</span></span><br><span class="line"><span class="number">6</span>th even: <span class="number">12</span></span><br><span class="line"><span class="number">7</span>th even: <span class="number">14</span></span><br><span class="line"><span class="number">8</span>th even: <span class="number">16</span></span><br><span class="line"><span class="number">9</span>th even: <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h2 id="实现-Futures-模式"><a href="#实现-Futures-模式" class="headerlink" title="实现 Futures 模式"></a>实现 Futures 模式</h2><p>所谓Futures就是指：有时候在你使用某一个值之前需要先对其进行计算。这种情况下，你就可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕了。  </p>
<p>Futures模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于Futures需要返回一个值。  </p>
<p>参考条目文献给出了一个很精彩的例子：假设我们有一个矩阵类型，我们需要计算两个矩阵A和B乘积的逆，首先我们通过函数<code>Inverse(M)</code>分别对其进行求逆运算，在将结果相乘。如下函数<code>InverseProduct()</code>实现了如上过程：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InverseProduct</span><span class="params">(a Matrix, b Matrix)</span></span> &#123;</span><br><span class="line">    a_inv := Inverse(a)</span><br><span class="line">    b_inv := Inverse(b)</span><br><span class="line">    <span class="keyword">return</span> Product(a_inv, b_inv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，a和b的求逆矩阵需要先被计算。那么为什么在计算b的逆矩阵时，需要等待a的逆计算完成呢？显然不必要，这两个求逆运算其实可以并行执行的。换句话说，调用<code>Product</code>函数只需要等到<code>a_inv</code>和<code>b_inv</code>的计算完成。如下代码实现了并行计算方式：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InverseProduct</span><span class="params">(a Matrix, b Matrix)</span></span> &#123;</span><br><span class="line">    a_inv_future := InverseFuture(a)   <span class="comment">// start as a goroutine</span></span><br><span class="line">    b_inv_future := InverseFuture(b)   <span class="comment">// start as a goroutine</span></span><br><span class="line">    a_inv := &lt;-a_inv_future</span><br><span class="line">    b_inv := &lt;-b_inv_future</span><br><span class="line">    <span class="keyword">return</span> Product(a_inv, b_inv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InverseFuture</code>函数起了一个<code>goroutine</code>协程，在其执行闭包运算，该闭包会将矩阵求逆结果放入到future通道中：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InverseFuture</span><span class="params">(a Matrix)</span> <span class="title">chan</span> <span class="title">Matrix</span></span> &#123;</span><br><span class="line">    future := <span class="built_in">make</span>(<span class="keyword">chan</span> Matrix)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        future &lt;- Inverse(a)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当开发一个计算密集型库时，使用Futures模式设计API接口是很有意义的。在你的包使用Futures模式，且能保持友好的API接口。此外，Futures可以通过一个异步的API暴露出来。这样你可以以最小的成本将包中的并行计算移到用户代码中。（参见参考文件18：<a href="http://www.golangpatterns.info/concurrency/futures" target="_blank" rel="noopener">http://www.golangpatterns.info/concurrency/futures</a>）  </p>
<hr>
<h1 id="网络，模板和网页应用"><a href="#网络，模板和网页应用" class="headerlink" title="网络，模板和网页应用"></a>网络，模板和网页应用</h1><p>go在编写web应用方面非常得力。因为目前它还没有GUI（Graphic User Interface 即图形化用户界面）的框架，通过文本或者模板展现的html界面是目前go编写应用程序的唯一方式。（**译者注：实际上在翻译的时候，已经有了一些不太成熟的GUI库例如：go ui。）  </p>
<h2 id="tcp服务器"><a href="#tcp服务器" class="headerlink" title="tcp服务器"></a>tcp服务器</h2><p>这部分我们将使用TCP协议和在14章讲到的协程范式编写一个简单的客户端-服务器应用，一个（web）服务器应用需要响应众多客户端的并发请求：go会为每一个客户端产生一个协程用来处理请求。我们需要使用net包中网络通信的功能。它包含了用于TCP/IP以及UDP协议、域名解析等方法。  </p>
<p>服务器代码，单独的一个文件：  </p>
<p>示例 15.1 server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Starting the server ..."</span>)</span><br><span class="line">    <span class="comment">// 创建 listener</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:50000"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Error listening"</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听并接受来自客户端的连接</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Error accepting"</span>, err.Error())</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// 终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> doServerStuff(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doServerStuff</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</span><br><span class="line">        <span class="built_in">len</span>, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Error reading"</span>, err.Error())</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">//终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"Received data: %v"</span>, <span class="keyword">string</span>(buf[:<span class="built_in">len</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>main()</code>创建了一个<code>net.Listener</code>的变量，他是一个服务器的基本函数：用来监听和接收来自客户端的请求（来自localhost即IP地址为127.0.0.1端口为50000基于TCP协议）。这个<code>Listen()</code>函数可以返回一个<code>error</code>类型的错误变量。用一个无限for循环的<code>listener.Accept()</code>来等待客户端的请求。客户端的请求将产生一个<code>net.Conn</code>类型的连接变量。然后一个独立的协程使用这个连接执行<code>doServerStuff()</code>，开始使用一个512字节的缓冲<code>data</code>来读取客户端发送来的数据并且把它们打印到服务器的终端，<code>len</code>获取客户端发送的数据字节数；当客户端发送的所有数据都被读取完成时，协程就结束了。这段程序会为每一个客户端连接创建一个独立的协程。必须先运行服务器代码，再运行客户端代码。  </p>
<p>客户端代码写在另外一个文件client.go中：  </p>
<p>示例 15.2 client.go  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//打开连接:</span></span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:50000"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//由于目标计算机积极拒绝而无法创建连接</span></span><br><span class="line">        fmt.Println(<span class="string">"Error dialing"</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println(<span class="string">"First, what is your name?"</span>)</span><br><span class="line">    clientName, _ := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">// fmt.Printf("CLIENTNAME %s", clientName)</span></span><br><span class="line">    trimmedClient := strings.Trim(clientName, <span class="string">"\r\n"</span>) <span class="comment">// Windows 平台下用 "\r\n"，Linux平台下使用 "\n"</span></span><br><span class="line">    <span class="comment">// 给服务器发送信息直到程序退出：</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"What to send to the server? Type Q to quit."</span>)</span><br><span class="line">        input, _ := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        trimmedInput := strings.Trim(input, <span class="string">"\r\n"</span>)</span><br><span class="line">        <span class="comment">// fmt.Printf("input:--%s--", input)</span></span><br><span class="line">        <span class="comment">// fmt.Printf("trimmedInput:--%s--", trimmedInput)</span></span><br><span class="line">        <span class="keyword">if</span> trimmedInput == <span class="string">"Q"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(trimmedClient + <span class="string">" says: "</span> + trimmedInput))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端通过<code>net.Dial</code>创建了一个和服务器之间的连接  </p>
<p>它通过无限循环中的os.Stdin接收来自键盘的输入直到输入了“Q”。注意使用<code>\r</code>和<code>\n</code>换行符分割字符串（在windows平台下使用<code>\r\n</code>）。接下来分割后的输入通过<code>connection</code>的<code>Write</code>方法被发送到服务器。  </p>
<p>当然，服务器必须先启动好，如果服务器并未开始监听，客户端是无法成功连接的。  </p>
<p>如果在服务器没有开始监听的情况下运行客户端程序，客户端会停止并打印出以下错误信息：<code>对tcp 127.0.0.1:50000发起连接时产生错误：由于目标计算机的积极拒绝而无法创建连接</code>。  </p>
<p>打开控制台并转到服务器和客户端可执行程序所在的目录，Windows系统下输入server.exe（或者只输入server），Linux系统下输入./server。  </p>
<p>接下来控制台出现以下信息：<code>Starting the server ...</code>  </p>
<p>在Windows系统中，我们可以通过CTRL/C停止程序。  </p>
<p>然后开启2个或者3个独立的控制台窗口，然后分别输入client回车启动客户端程序  </p>
<p>以下是服务器的输出：  </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Starting the<span class="built_in"> Server </span><span class="built_in">..</span>.</span><br><span class="line">Received data: IVO says: Hi Server, what<span class="string">'s up ?</span></span><br><span class="line"><span class="string">Received data: CHRIS says: Are you busy server ?</span></span><br><span class="line"><span class="string">Received data: MARC says: Don'</span>t forget our appointment tomorrow !</span><br></pre></td></tr></table></figure>
<p>当客户端输入 Q 并结束程序时，服务器会输出以下信息：  </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">Error</span> reading WSARecv tcp 127.0.0.1:50000: The specified<span class="built_in"> network </span>name is <span class="literal">no</span> longer available.</span><br></pre></td></tr></table></figure>
<p>在网络编程中<code>net.Dial</code>函数是非常重要的，一旦你连接到远程系统，就会返回一个Conn类型接口，我们可以用它发送和接收数据。<code>Dial</code>函数巧妙的抽象了网络结构及传输。所以IPv4或者IPv6，TCP或者UDP都可以使用这个公用接口。  </p>
<p>下边这个示例先使用TCP协议连接远程80端口，然后使用UDP协议连接，最后使用TCP协议连接IPv6类型的地址：  </p>
<p>示例 15.3 dial.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// make a connection with www.example.org:</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"192.0.32.10:80"</span>) <span class="comment">// tcp ipv4</span></span><br><span class="line">    checkConnection(conn, err)</span><br><span class="line">    conn, err = net.Dial(<span class="string">"udp"</span>, <span class="string">"192.0.32.10:80"</span>) <span class="comment">// udp</span></span><br><span class="line">    checkConnection(conn, err)</span><br><span class="line">    conn, err = net.Dial(<span class="string">"tcp"</span>, <span class="string">"[2620:0:2d0:200::10]:80"</span>) <span class="comment">// tcp ipv6</span></span><br><span class="line">    checkConnection(conn, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkConnection</span><span class="params">(conn net.Conn, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"error %v connecting!"</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Connection is made with %v\n"</span>, conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下边也是一个使用net包从socket中打开，写入，读取数据的例子：  </p>
<p>示例 15.4 socket.go  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        host          = <span class="string">"www.apache.org"</span></span><br><span class="line">        port          = <span class="string">"80"</span></span><br><span class="line">        remote        = host + <span class="string">":"</span> + port</span><br><span class="line">        msg    <span class="keyword">string</span> = <span class="string">"GET / \n"</span></span><br><span class="line">        data          = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, <span class="number">4096</span>)</span><br><span class="line">        read          = <span class="literal">true</span></span><br><span class="line">        count         = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 创建一个socket</span></span><br><span class="line">    con, err := net.Dial(<span class="string">"tcp"</span>, remote)</span><br><span class="line">    <span class="comment">// 发送我们的消息，一个http GET请求</span></span><br><span class="line">    io.WriteString(con, msg)</span><br><span class="line">    <span class="comment">// 读取服务器的响应</span></span><br><span class="line">    <span class="keyword">for</span> read &#123;</span><br><span class="line">        count, err = con.Read(data)</span><br><span class="line">        read = (err == <span class="literal">nil</span>)</span><br><span class="line">        fmt.Printf(<span class="keyword">string</span>(data[<span class="number">0</span>:count]))</span><br><span class="line">    &#125;</span><br><span class="line">    con.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个简单的网页服务器"><a href="#一个简单的网页服务器" class="headerlink" title="一个简单的网页服务器"></a>一个简单的网页服务器</h2><p>Http是一个比tcp更高级的协议，它描述了客户端浏览器如何与网页服务器进行通信。Go有自己的<code>net/http</code>包，我们来看看它。我们从一些简单的示例开始，<br>首先编写一个“Hello world!”：查看示例15.6  </p>
<p>我们引入了<code>http</code>包并启动了网页服务器，和15.1的<code>net.Listen(&quot;tcp&quot;, &quot;localhost:50000&quot;)</code>函数的tcp服务器是类似的，使用<code>http.ListenAndServe(&quot;localhost:8080&quot;, nil)</code>函数，如果成功会返回空，否则会返回一个错误（可以指定localhost为其他地址，8080是指定的端口号）  </p>
<p><code>http.URL</code>描述了web服务器的地址，内含存放了url字符串的<code>Path</code>属性；<code>http.Request</code>描述了客户端请求，内含一个<code>URL</code>属性  </p>
<p>如果<code>req</code>请求是一个POST类型的html表单，“var1”就是html表单中一个输入属性的名称，然后用户输入的值就可以通过GO代码：<code>req.FormValue(&quot;var1&quot;)</code>获取到（请看<a href="15.4.md">章节15.4</a>）。还有一种方法就是先执行<code>request.ParseForm()</code>然后再获取<code>request.Form[&quot;var1&quot;]</code>的第一个返回参数，就像这样：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">var1, found := request.Form[<span class="string">"var1"</span>]</span><br></pre></td></tr></table></figure>
<p>第二个参数<code>found</code>就是<code>true</code>，如果<code>var1</code>并未出现在表单中，<code>found</code>就是<code>false</code>  </p>
<p>表单属性实际上是一个<code>map[string][]string</code>类型。网页服务器返回了一个<code>http.Response</code>，它是通过<code>http.ResponseWriter</code>对象输出的，这个对象整合了HTTP服务器的返回结果；通过对它写入内容，我们就将数据发送给了HTTP客户端。  </p>
<p>现在我们还需要编写网页服务器必须执行的程序，它是如何处理请求的呢。这是在<code>http.HandleFunc</code>函数中完成的，就是在这个例子中当根路径“/”（url地址是<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ）被请求的时候（或者这个服务器上的其他地址），<code>HelloServer</code>函数就被执行了。这个函数是<code>http.HandlerFunc</code>类型的，它们通常用使用Prehandler来命名，在前边加了一个Pref前缀。  </p>
<p><code>http.HandleFunc</code>注册了一个处理函数(这里是<code>HelloServer</code>)来处理对应<code>/</code>的请求。  </p>
<p><code>/</code>可以被替换为其他特定的url比如<code>/create</code>，<code>/edit</code>等等；你可以为每一个特定的url定义一个单独的处理函数。这个函数需要两个参数：第一个是<code>ReponseWriter</code>类型的<code>w</code>；第二个是请求<code>req</code>。程序向<code>w</code>写入了<code>Hello</code>和<code>r.URL.Path[1:]</code>组成的字符串后边的<code>[1:]</code>表示“创建一个从第一个字符到结尾的子切片”，用来丢弃掉路径开头的“/”，<code>fmt.Fprintf()</code>函数完成了本次写入（请看章节12.8）；另外一种写法是<code>io.WriteString(w, &quot;hello, world!\n&quot;)</code>  </p>
<p>总结：第一个参数是请求的路径，第二个参数是处理这个路径请求的函数的引用。  </p>
<p>示例 15.6 hello_world_webserver.go  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Inside HelloServer handler"</span>)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello,"</span>+req.URL.Path[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, HelloServer)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">"localhost:8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令行启动程序，会打开一个命令窗口显示如下文字：  </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Starting Process <span class="string">E:</span><span class="regexp">/Go/</span>GoBoek<span class="regexp">/code_examples/</span>chapter_14/hello_world_webserver.exe</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后打开你的浏览器并输入url地址：<code>http://localhost:8080/world</code>，浏览器就会出现文字：<code>Hello, world</code>，网页服务器会响应你在<code>:8080/</code>后边输入的内容  </p>
<p>使用<code>fmt.Println</code>在控制台打印状态，在每个handler被请求的时候，在他们内部打印日志会很有帮助  </p>
<p>注：<br>1）前两行（没有错误处理代码）可以替换成以下写法：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, http.HandlerFunc(HelloServer))</span><br></pre></td></tr></table></figure>
<p>2）<code>fmt.Fprint</code>和<code>fmt.Fprintf</code>都是用来写入<code>http.ResponseWriter</code>的不错的函数（他们实现了<code>io.Writer</code>）。<br>比如我们可以使用  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Fprintf(w, <span class="string">"&lt;h1&gt;%s&lt;h1&gt;&lt;div&gt;%s&lt;/div&gt;"</span>, title, body)</span><br></pre></td></tr></table></figure>
<p>来构建一个非常简单的网页并插入<code>title</code>和<code>body</code>的值  </p>
<p>如果你需要更多复杂的替换，使用模板包（请看章节15.7）<br>3）如果你需要使用安全的https连接，使用<code>http.ListenAndServeTLS()</code>代替<code>http.ListenAndServe()</code><br>4）<code>http.HandleFunc(&quot;/&quot;, Hfunc)</code>中的<code>HFunc</code>是一个处理函数，如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HFunc</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用这种方式：<code>http.Handle(&quot;/&quot;, http.HandlerFunc(HFunc))</code>  </p>
<p>上边的<code>HandlerFunc</code>只是一个类型名称，它定义如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure>
<p>它是一个可以把普通的函数当做HTTP处理器的适配器。如果<code>f</code>函数声明的合适，<code>HandlerFunc(f)</code>就是一个执行了<code>f</code>函数的处理器对象。  </p>
<p><code>http.Handle</code>的第二个参数也可以是<code>T</code>的一个obj对象：<code>http.Handle(&quot;/&quot;, obj)</code>给T提供了<code>ServeHTTP</code>方法，实现了http的<code>Handler</code>接口：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(obj *Typ)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个用法在章节15.8类型<code>Counter</code>和<code>Chan</code>上使用过。只要实现了<code>http.Handler</code>，<code>http</code>包就可以处理任何HTTP请求。  </p>
<h2 id="访问并读取页面"><a href="#访问并读取页面" class="headerlink" title="访问并读取页面"></a>访问并读取页面</h2><p>在下边这个程序中，数组中的url都将被访问：会发送一个简单的<code>http.Head()</code>请求查看返回值；它的声明如下：<code>func Head(url string) (r *Response, err error)</code>  </p>
<p>返回状态码会被打印出来。  </p>
<p>示例 15.7 poll_url.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">    <span class="string">"http://golang.org/"</span>,</span><br><span class="line">    <span class="string">"http://blog.golang.org/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Execute an HTTP HEAD request for all url's</span></span><br><span class="line">    <span class="comment">// and returns the HTTP status string or an error string.</span></span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        resp, err := http.Head(url)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Error:"</span>, url, err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(url, <span class="string">": "</span>, resp.Status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：  </p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//www.google.com/ : 302 Found</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//golang.org/ : 200 OK</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//blog.golang.org/ : 200 OK</span></span><br></pre></td></tr></table></figure>
<p><strong><em>译者注</em></strong> 由于国内的网络环境现状，很有可能见到如下超时错误提示：  </p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Error: </span>http://www.google.com/ Head http://www.google.com/: dial tcp 216.58.221.100:80: connectex: A connection attempt failed because the connected pa</span><br><span class="line">rty did not properly respond after a period of time, or established connection failed because connected host has failed to respond.</span><br></pre></td></tr></table></figure>
<p>在下边的程序中我们使用<code>http.Get()</code>获取网页内容； <code>Get</code>的返回值<code>res</code>中的<code>Body</code>属性包含了网页内容，然后我们用<code>ioutil.ReadAll</code>把它读出来：  </p>
<p>示例 15.8 http_fetch.go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res, err := http.Get(<span class="string">"http://www.google.com"</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line">    data, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line">    fmt.Printf(<span class="string">"Got: %q"</span>, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Get : %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问不存在的网站时，这里有一个<code>CheckError</code>输出错误的例子：  </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">2011</span>/<span class="number">09</span>/<span class="number">30</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">15</span> Get: Get http:<span class="comment">//www.google.bex: dial tcp www.google.bex:80:GetHostByName: No such host is known.</span></span><br></pre></td></tr></table></figure>
<p><strong><em>译者注</em></strong> 和上一个例子相似，你可以把google.com更换为一个国内可以顺畅访问的网址进行测试  </p>
<p>在下边的程序中，我们获取一个twitter用户的状态，通过<code>xml</code>包将这个状态解析成为一个结构：  </p>
<p>示例 15.9 twitter_status.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/xml"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这个结构会保存解析后的返回数据。</span></span><br><span class="line"><span class="comment">他们会形成有层级的XML，可以忽略一些无用的数据*/</span></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">    Text <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    XMLName xml.Name</span><br><span class="line">    Status  Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 发起请求查询推特Goodland用户的状态</span></span><br><span class="line">    response, _ := http.Get(<span class="string">"http://twitter.com/users/Googland.xml"</span>)</span><br><span class="line">    <span class="comment">// 初始化XML返回值的结构</span></span><br><span class="line">    user := User&#123;xml.Name&#123;<span class="string">""</span>, <span class="string">"user"</span>&#125;, Status&#123;<span class="string">""</span>&#125;&#125;</span><br><span class="line">    <span class="comment">// 将XML解析为我们的结构</span></span><br><span class="line">    xml.Unmarshal(response.Body, &amp;user)</span><br><span class="line">    fmt.Printf(<span class="string">"status: %s"</span>, user.Status.Text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">status: Robot cars invade California, on orders from Google: Google has been testing self-driving cars ... http:<span class="regexp">//</span>bit.ly<span class="regexp">/cbtpUN http:/</span><span class="regexp">/retwt.me/</span><span class="number">97</span>p&lt;<span class="keyword">exit</span> code=<span class="string">"0"</span> msg=<span class="string">"process exited normally"</span><span class="regexp">/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>译者注</strong> 和上边的示例相似，你可能无法获取到xml数据，另外由于go版本的更新，<code>xml.Unmarshal</code>函数的第一个参数需是[]byte类型，而无法传入<code>Body</code>。  </p>
<p>我们会在章节15.4中用到<code>http</code>包中的其他重要的函数：  </p>
<ul>
<li><code>http.Redirect(w ResponseWriter, r *Request, url string, code int)</code>：这个函数会让浏览器重定向到url（是请求的url的相对路径）以及状态码。</li>
<li><code>http.NotFound(w ResponseWriter, r *Request)</code>：这个函数将返回网页没有找到，HTTP 404错误。</li>
<li><code>http.Error(w ResponseWriter, error string, code int)</code>：这个函数返回特定的错误信息和HTTP代码。</li>
<li>另<code>http.Request</code>对象的一个重要属性<code>req</code>：<code>req.Method</code>，这是一个包含<code>GET</code>或<code>POST</code>字符串，用来描述网页是以何种方式被请求的。</li>
</ul>
<p>go为所有的HTTP状态码定义了常量，比如：  </p>
<pre><code>http.StatusContinue     = 100
http.StatusOK           = 200
http.StatusFound        = 302
http.StatusBadRequest       = 400
http.StatusUnauthorized     = 401
http.StatusForbidden        = 403
http.StatusNotFound     = 404
http.StatusInternalServerError  = 500</code></pre><p>你可以使用<code>w.header().Set(&quot;Content-Type&quot;, &quot;../..&quot;)</code>设置头信息  </p>
<p>比如在网页应用发送html字符串的时候，在输出之前执行<code>w.Header().Set(&quot;Content-Type&quot;, &quot;text/html&quot;)</code>。  </p>
<h2 id="写一个简单的网页应用"><a href="#写一个简单的网页应用" class="headerlink" title="写一个简单的网页应用"></a>写一个简单的网页应用</h2><p>下边的程序在端口8088上启动了一个网页服务器；<code>SimpleServer</code>会处理<code>/test1</code>url使它在浏览器输出<code>hello world</code>。<code>FormServer</code>会处理<code>/test2</code>url：如果url最初由浏览器请求，那么它就是一个<code>GET</code>请求，并且返回一个<code>form</code>常量，包含了简单的<code>input</code>表单，这个表单里有一个文本框和一个提交按钮。当在文本框输入一些东西并点击提交按钮的时候，会发起一个<code>POST</code>请求。<code>FormServer</code>中的代码用到了<code>switch</code>来区分两种情况。在<code>POST</code>情况下，使用<code>request.FormValue(&quot;inp&quot;)</code>通过文本框的<code>name</code>属性<code>inp</code>来获取内容，并写回浏览器页面。在控制台启动程序并在浏览器中打开url<code>http://localhost:8088/test2</code>来测试这个程序：</p>
<p>示例 15.10 simple_webserver.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> form = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;form action="#" method="post" name="bar"&gt;</span></span><br><span class="line"><span class="string">            &lt;input type="text" name="in" /&gt;</span></span><br><span class="line"><span class="string">            &lt;input type="submit" value="submit"/&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* handle a simple get request */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleServer</span><span class="params">(w http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    io.WriteString(w, <span class="string">"&lt;h1&gt;hello, world&lt;/h1&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormServer</span><span class="params">(w http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">    <span class="keyword">switch</span> request.Method &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"GET"</span>:</span><br><span class="line">        <span class="comment">/* display the form to the user */</span></span><br><span class="line">        io.WriteString(w, form)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"POST"</span>:</span><br><span class="line">        <span class="comment">/* handle the form data, note that ParseForm must</span></span><br><span class="line"><span class="comment">           be called before we can extract form data */</span></span><br><span class="line">        <span class="comment">//request.ParseForm();</span></span><br><span class="line">        <span class="comment">//io.WriteString(w, request.Form["in"][0])</span></span><br><span class="line">        io.WriteString(w, request.FormValue(<span class="string">"in"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/test1"</span>, SimpleServer)</span><br><span class="line">    http.HandleFunc(<span class="string">"/test2"</span>, FormServer)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8088"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：当使用字符串常量表示html文本的时候，包含<code>&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code>对于让浏览器识别它收到了一个html非常重要。  </p>
<p>更安全的做法是在处理器中使用<code>w.Header().Set(&quot;Content-Type&quot;, &quot;text/html&quot;)</code>在写入返回之前将<code>header</code>的<code>content-type</code>设置为<code>text/html</code>  </p>
<p><code>content-type</code>会让浏览器认为它可以使用函数<code>http.DetectContentType([]byte(form))</code>来处理收到的数据  </p>
<hr>
<h1 id="常用资料"><a href="#常用资料" class="headerlink" title="常用资料"></a>常用资料</h1><h2 id="Go-关键字"><a href="#Go-关键字" class="headerlink" title="Go 关键字"></a>Go 关键字</h2><ul>
<li><p>25 个关键字  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>      <span class="keyword">default</span>       <span class="function"><span class="keyword">func</span>     <span class="title">interface</span>   <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>       <span class="keyword">defer</span>         <span class="keyword">go</span>       <span class="keyword">map</span>         <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>       <span class="keyword">else</span>          <span class="keyword">goto</span>     <span class="keyword">package</span>     <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>      <span class="keyword">fallthrough</span>   <span class="keyword">if</span>       <span class="keyword">range</span>       <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>   <span class="keyword">for</span>           <span class="keyword">import</span>   <span class="keyword">return</span>      <span class="keyword">var</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>36 个预定义标识符  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">内建常量: <span class="literal">true</span> <span class="literal">false</span> <span class="literal">iota</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">内建类型: <span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span></span><br><span class="line">          <span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line">          <span class="keyword">float32</span> <span class="keyword">float64</span> <span class="keyword">complex128</span> <span class="keyword">complex64</span></span><br><span class="line">          <span class="keyword">bool</span> <span class="keyword">byte</span> <span class="keyword">rune</span> <span class="keyword">string</span> error</span><br><span class="line"></span><br><span class="line">内建函数: <span class="built_in">make</span> <span class="built_in">len</span> <span class="built_in">cap</span> <span class="built_in">new</span> <span class="built_in">append</span> <span class="built_in">copy</span> <span class="built_in">close</span> <span class="built_in">delete</span></span><br><span class="line">          <span class="built_in">complex</span> <span class="built_in">real</span> <span class="built_in">imag</span></span><br><span class="line">          <span class="built_in">panic</span> <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="文件读写参数"><a href="#文件读写参数" class="headerlink" title="文件读写参数"></a>文件读写参数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span></span><br><span class="line"></span><br><span class="line">第二个参数</span><br><span class="line">O_RDONLY    打开只读文件</span><br><span class="line">O_WRONLY    打开只写文件</span><br><span class="line">O_RDWR  打开既可以读取又可以写入文件</span><br><span class="line">O_APPEND    写入文件时将数据追加到文件尾部</span><br><span class="line">O_CREATE    如果文件不存在，则创建一个新的文件</span><br><span class="line">O_EXCL  文件必须不存在，然后会创建一个新的文件</span><br><span class="line">O_SYNC  打开同步I/<span class="number">0</span></span><br><span class="line">O_TRUNC 文件打开时可以截断</span><br><span class="line"></span><br><span class="line">第三个参数就是权限模式</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>「语言」- Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
</search>
