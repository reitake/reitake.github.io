<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="AoeMgN9r3ZTJhZZgqjfb4tkZf3qRjujP-1gjzMb-x80">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reitake.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go 语言中的常见错误笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 中常见错误">
<meta property="og:url" content="https://reitake.github.io/2019/03/11/Go-Common-Mistakes/index.html">
<meta property="og:site_name" content="My Notes Blog">
<meta property="og:description" content="Go 语言中的常见错误笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-03-11T13:15:27.000Z">
<meta property="article:modified_time" content="2020-12-07T13:34:32.923Z">
<meta property="article:author" content="rtk">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="Note">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://reitake.github.io/2019/03/11/Go-Common-Mistakes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Go 中常见错误 | My Notes Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Notes Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">生活不易 喵声叹气</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-fw fa-gears"></i>工具</a>

  </li>
        <li class="menu-item menu-item-others">

    <a href="/others/" rel="section"><i class="fa fa-fw fa-spinner"></i>不务正业</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://reitake.github.io/2019/03/11/Go-Common-Mistakes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rtk">
      <meta itemprop="description" content="冷萃少冰不加糖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Notes Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Go 中常见错误
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-11 21:15:27" itemprop="dateCreated datePublished" datetime="2019-03-11T21:15:27+08:00">2019-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 21:34:32" itemprop="dateModified" datetime="2020-12-07T21:34:32+08:00">2020-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8C%E8%AF%AD%E8%A8%80%E3%80%8D-Go/" itemprop="url" rel="index"><span itemprop="name">「语言」- Go</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/11/Go-Common-Mistakes/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/11/Go-Common-Mistakes/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <center> <font color="#bababa">

<p><strong><em>Go 语言中的常见错误笔记</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li>永远不要使用形如 <code>var p*a</code> 声明变量，这会混淆指针声明和乘法运算（参考<a href="04.9.md">4.9小节</a>）</li>
<li>永远不要在<code>for</code>循环自身中改变计数器变量（参考<a href="05.4.md">5.4小节</a>）</li>
<li>永远不要在<code>for-range</code>循环中使用一个值去改变自身的值（参考<a href="05.4.md">5.4.4小节</a>）</li>
<li>永远不要将<code>goto</code>和前置标签一起使用（参考<a href="05.6.md">5.6小节</a>）</li>
<li>永远不要忘记在函数名（参考<a href="06.0.md">第6章</a>）后加括号()，尤其调用一个对象的方法或者使用匿名函数启动一个协程时</li>
<li>永远不要使用<code>new()</code>一个map，一直使用make（参考<a href="08.0.md">第8章</a>）</li>
<li>当为一个类型定义一个String()方法时，不要使用<code>fmt.Print</code>或者类似的代码（参考<a href="10.7.md">10.7小节</a>）</li>
<li>永远不要忘记当终止缓存写入时，使用<code>Flush</code>函数（参考<a href="12.2.md">12.2.3小节</a>）</li>
<li>永远不要忽略错误提示，忽略错误会导致程序奔溃（参考<a href="13.1.md">13.1小节</a>）</li>
<li>不要使用全局变量或者共享内存，这会使并发执行的代码变得不安全（参考<a href="14.1.md">14.1小节</a>）</li>
<li><code>println</code>函数仅仅是用于调试的目的</li>
</ul>
<p>最佳实践：对比以下使用方式：  </p>
<ul>
<li>使用正确的方式初始化一个元素是切片的映射，例如<code>map[type]slice</code>（参考<a href="08.1.md">8.1.3小节</a>）</li>
<li>一直使用逗号，ok或者checked形式作为类型断言（参考<a href="11.3.md">11.3小节</a>）</li>
<li>使用一个工厂函数创建并初始化自己定义类型（参考<a href="10.2.md">10.2小节</a>-<a href="18.4.md">18.4小节</a>）</li>
<li>仅当一个结构体的方法想改变结构体时，使用结构体指针作为方法的接受者，否则使用一个结构体值类型<a href="10.6.md">10.6.3小节</a></li>
</ul>
<h1 id="误用字符串"><a href="#误用字符串" class="headerlink" title="误用字符串"></a>误用字符串</h1><p>当需要对一个字符串进行频繁的操作时，谨记在go语言中字符串是不可变的（类似java和c#）。使用诸如<code>a += b</code>形式连接字符串效率低下，尤其在一个循环内部使用这种形式。这会导致大量的内存开销和拷贝。<strong>应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中。</strong> 例如以下的代码示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">    b.WriteString(str) <span class="comment">// 将字符串str写入缓存buffer</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> b.String()</span><br></pre></td></tr></table></figure>

<p>注意：由于编译优化和依赖于使用缓存操作的字符串大小，当循环次数大于15时，效率才会更佳。  </p>
<h1 id="发生错误时使用defer关闭一个文件"><a href="#发生错误时使用defer关闭一个文件" class="headerlink" title="发生错误时使用defer关闭一个文件"></a>发生错误时使用defer关闭一个文件</h1><p>如果你在一个for循环内部处理一系列文件，你需要使用defer确保文件在处理完毕后被关闭，例如：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    <span class="keyword">if</span> f, err = os.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这是错误的方式，当循环结束时文件没有关闭</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="comment">// 对文件进行操作</span></span><br><span class="line">    f.Process(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在循环结尾处的defer没有执行，所以文件一直没有关闭！垃圾回收机制可能会自动关闭文件，但是这会产生一个错误，更好的做法是：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">    <span class="keyword">if</span> f, err = os.Open(file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对文件进行操作</span></span><br><span class="line">    f.Process(data)</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    f.Close()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>defer仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。</strong>  </p>
<h1 id="何时使用new-和make"><a href="#何时使用new-和make" class="headerlink" title="何时使用new()和make()"></a>何时使用new()和make()</h1><ul>
<li>切片、映射和通道，使用make</li>
<li>数组、结构体和所有的值类型，使用new </li>
</ul>
<h1 id="不需要将一个指向切片的指针传递给函数"><a href="#不需要将一个指向切片的指针传递给函数" class="headerlink" title="不需要将一个指向切片的指针传递给函数"></a>不需要将一个指向切片的指针传递给函数</h1><p>切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。<br>因此应该这样做：</p>
<pre><code>func findBiggest( listOfNumbers []int ) int {}</code></pre><p>而不是：  </p>
<pre><code>func findBiggest( listOfNumbers *[]int ) int {}</code></pre><p><strong>当切片作为参数传递时，切记不要解引用切片。</strong>  </p>
<h1 id="使用指针指向接口类型"><a href="#使用指针指向接口类型" class="headerlink" title="使用指针指向接口类型"></a>使用指针指向接口类型</h1><p>查看如下程序：<code>nexter</code>是一个接口类型，并且定义了一个<code>next()</code>方法读取下一字节。函数<code>nextFew</code>将<code>nexter</code>接口作为参数并读取接下来的<code>num</code>个字节，并返回一个切片：这是正确做法。但是<code>nextFew2</code>使用一个指向<code>nexter</code>接口类型的指针作为参数传递给函数：当使用<code>next()</code>函数时，系统会给出一个编译错误：<strong>n.next undefined (type *nexter has no<br>field or method next)</strong> （译者注：n.next未定义（*nexter类型没有next成员或next方法））  </p>
<p>例 pointer_interface.go (不能通过编译):  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    “fmt”</span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> nexter <span class="keyword">interface</span> &#123;</span><br><span class="line">    next() <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFew1</span><span class="params">(n nexter, num <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        b[i] = n.next()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFew2</span><span class="params">(n *nexter, num <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">        b[i] = n.next() <span class="comment">// 编译错误:n.next未定义（*nexter类型没有next成员或next方法）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(“Hello World!”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。</strong>  </p>
<h1 id="使用值类型时误用指针"><a href="#使用值类型时误用指针" class="headerlink" title="使用值类型时误用指针"></a>使用值类型时误用指针</h1><p>将一个值类型作为一个参数传递给函数或者作为一个方法的接收者，似乎是对内存的滥用，因为值类型一直是传递拷贝。但是另一方面，值类型的内存是在栈上分配，内存分配快速且开销不大。如果你传递一个指针，而不是一个值类型，go编译器大多数情况下会认为需要创建一个对象，并将对象移动到堆上，所以会导致额外的内存分配：因此当使用指针代替值类型作为参数传递时，我们没有任何收获。  </p>
<h1 id="误用协程和通道"><a href="#误用协程和通道" class="headerlink" title="误用协程和通道"></a>误用协程和通道</h1><p>在实际应用中，你不需要并发执行，或者你不需要关注协程和通道的开销，在大多数情况下，通过栈传递参数会更有效率。  </p>
<p>但是，如果你使用<code>break</code>、<code>return</code>或者<code>panic</code>去跳出一个循环，很有可能会导致内存溢出，因为协程正处理某些事情而被阻塞。在实际代码中，通常仅需写一个简单的过程式循环即可。<strong>当且仅当代码中并发执行非常重要，才使用协程和通道。</strong></p>
<h1 id="闭包和协程的使用"><a href="#闭包和协程的使用" class="headerlink" title="闭包和协程的使用"></a>闭包和协程的使用</h1><p>看下面代码：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 版本A:</span></span><br><span class="line">    <span class="keyword">for</span> ix := <span class="keyword">range</span> values &#123; <span class="comment">// ix是索引值</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(ix, <span class="string">" "</span>)</span><br><span class="line">        &#125;() <span class="comment">// 调用闭包打印每个索引值</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// 版本B: 和A版本类似，但是通过调用闭包作为一个协程</span></span><br><span class="line">    <span class="keyword">for</span> ix := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(ix, <span class="string">" "</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    time.Sleep(<span class="number">5e9</span>)</span><br><span class="line">    <span class="comment">// 版本C: 正确的处理方式</span></span><br><span class="line">    <span class="keyword">for</span> ix := <span class="keyword">range</span> values &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ix <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            fmt.Print(ix, <span class="string">" "</span>)</span><br><span class="line">        &#125;(ix)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    time.Sleep(<span class="number">5e9</span>)</span><br><span class="line">    <span class="comment">// 版本D: 输出值:</span></span><br><span class="line">    <span class="keyword">for</span> ix := <span class="keyword">range</span> values &#123;</span><br><span class="line">        val := values[ix]</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Print(val, <span class="string">" "</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">10 </span><span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>版本A调用闭包5次打印每个索引值，版本B也做相同的事，但是通过协程调用每个闭包。按理说这将执行得更快，因为闭包是并发执行的。如果我们阻塞足够多的时间，让所有协程执行完毕，版本B的输出是：<code>4 4 4 4 4</code>。为什么会这样？在版本B的循环中，<code>ix</code>变量实际是一个单变量，表示每个数组元素的索引值。因为这些闭包都只绑定到一个变量，这是一个比较好的方式，当你运行这段代码时，你将看见每次循环都打印最后一个索引值<code>4</code>，而不是每个元素的索引值。因为协程可能在循环结束后还没有开始执行，而此时<code>ix</code>值是<code>4</code>。  </p>
<p>版本C的循环写法才是正确的：调用每个闭包时将<code>ix</code>作为参数传递给闭包。<code>ix</code>在每次循环时都被重新赋值，并将每个协程的<code>ix</code>放置在栈中，所以当协程最终被执行时，每个索引值对协程都是可用的。注意这里的输出可能是<code>0 2 1 3 4</code>或者<code>0 3 1 2 4</code>或者其他类似的序列，这主要取决于每个协程何时开始被执行。  </p>
<p>在版本D中，我们输出这个数组的值，为什么版本B不能而版本D可以呢？  </p>
<p>因为版本D中的变量声明是在循环体内部，所以在每次循环时，这些变量相互之间是不共享的，所以这些变量可以单独的被每个闭包使用。  </p>
<h1 id="糟糕的错误处理"><a href="#糟糕的错误处理" class="headerlink" title="糟糕的错误处理"></a>糟糕的错误处理</h1><h2 id="不要使用布尔值"><a href="#不要使用布尔值" class="headerlink" title="不要使用布尔值"></a>不要使用布尔值</h2><p>像下面代码一样，创建一个布尔型变量用于测试错误条件是多余的：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> good <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 测试一个错误，`good`被赋为`true`或者`false`</span></span><br><span class="line">    <span class="keyword">if</span> !good &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"things aren’t good"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>立即检测一个错误：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... err1 := api.Func1()</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123; … &#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免错误检测使代码变得混乱："><a href="#避免错误检测使代码变得混乱：" class="headerlink" title="避免错误检测使代码变得混乱："></a>避免错误检测使代码变得混乱：</h2><p>避免写出这样的代码：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">... err1 := api.Func1()</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"err: "</span> + err.Error())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">err2 := api.Func2()</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，包括在一个初始化的<code>if</code>语句中对函数的调用。但即使代码中到处都是以<code>if</code>语句的形式通知错误（通过打印错误信息）。通过这种方式，很难分辨什么是正常的程序逻辑，什么是错误检测或错误通知。还需注意的是，大部分代码都是致力于错误的检测。通常解决此问题的好办法是尽可能以闭包的形式封装你的错误检测，例如下面的代码：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequestHandler</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    err := <span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> req.Method != <span class="string">"GET"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">"expected GET"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> input := parseInput(req); input != <span class="string">"command"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> errors.New(<span class="string">"malformed command"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以在此进行其他的错误检测</span></span><br><span class="line">    &#125; ()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            w.WriteHeader(<span class="number">400</span>)</span><br><span class="line">            io.WriteString(w, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        doSomething() ...</span><br></pre></td></tr></table></figure>

<p>这种方法可以很容易分辨出错误检测、错误通知和正常的程序逻辑<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.5.md" target="_blank" rel="noopener">更详细…</a>。  </p>
<h1 id="不能使用简短声明来设置字段的值"><a href="#不能使用简短声明来设置字段的值" class="headerlink" title="不能使用简短声明来设置字段的值"></a>不能使用简短声明来设置字段的值</h1><p>struct 的变量字段不能使用 := 来赋值以使用预定义的变量来避免解决：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    data.result, err := work()  <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">"info: %+v\n"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    <span class="keyword">var</span> err error   <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    data.result, err = work()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"info: %+v\n"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="显式类型的变量无法使用-nil-来初始化"><a href="#显式类型的变量无法使用-nil-来初始化" class="headerlink" title="显式类型的变量无法使用 nil 来初始化"></a>显式类型的变量无法使用 nil 来初始化</h1><p><code>nil</code> 是 interface、function、pointer、map、slice 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span> <span class="comment">// error: use of untyped nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="直接使用值为-nil-的-slice、map"><a href="#直接使用值为-nil-的-slice、map" class="headerlink" title="直接使用值为 nil 的 slice、map"></a>直接使用值为 nil 的 slice、map</h1><p>允许对值为 nil 的 slice 添加元素，但对值为 nil 的 map 添加元素则会造成运行时 panic  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    m[<span class="string">"one"</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int)// map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h1><p>在创建 map 类型的变量时可以指定容量，但不能像 slice 一样使用 cap() 来检测分配空间的大小：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="string-类型的变量值不能为-nil"><a href="#string-类型的变量值不能为-nil" class="headerlink" title="string 类型的变量值不能为 nil"></a>string 类型的变量值不能为 nil</h1><p>不用 <code>nil</code> 初始化字符串  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="literal">nil</span>  <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;   <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span>    <span class="comment">// 字符串类型的零值是空串 ""</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &#123;</span><br><span class="line">        s = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="range-遍历-slice-和-array-时混淆了返回值"><a href="#range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="range 遍历 slice 和 array 时混淆了返回值"></a>range 遍历 slice 和 array 时混淆了返回值</h1><p>Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值。  </p>
<h1 id="slice-和-array-其实是一维数据"><a href="#slice-和-array-其实是一维数据" class="headerlink" title="slice 和 array 其实是一维数据"></a>slice 和 array 其实是一维数据</h1><ul>
<li>使用原始的一维数组：要做好索引检查、溢出检测、以及当数组满时再添加值时要重新做内存分配。  </li>
<li>使用“独立”的切片分两步：  <ul>
<li>创建外部 slice</li>
<li>对每个内部 slice 进行内存分配。注意内部的 slice 相互独立，使得任一内部 slice 增缩都不会影响到其他的 slice  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用各自独立的 6 个 slice 来创建 [2][3] 的动态多维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">2</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    table := <span class="built_in">make</span>([][]<span class="keyword">int</span>, x)</span><br><span class="line">    <span class="keyword">for</span> i  := <span class="keyword">range</span> table &#123;</span><br><span class="line">        table[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用“共享底层数组”的切片:  <ul>
<li>创建一个存放原始数据的容器 slice</li>
<li>创建其他的 slice</li>
<li>切割原始 slice 来初始化其他的 slice</li>
</ul>
</li>
</ul>
<h1 id="访问-map-中不存在的-key"><a href="#访问-map-中不存在的-key" class="headerlink" title="访问 map 中不存在的 key"></a>访问 map 中不存在的 key</h1><p>不能通过取出来的值来判断 key 是不是在 map 中。<br>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"2"</span>, <span class="string">"two"</span>: <span class="string">""</span>, <span class="string">"three"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">"two"</span>]; v == <span class="string">""</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key two is no entry"</span>)  <span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"2"</span>, <span class="string">"two"</span>: <span class="string">""</span>, <span class="string">"three"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := x[<span class="string">"two"</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key two is no entry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="string-类型的值是常量，不可更改"><a href="#string-类型的值是常量，不可更改" class="headerlink" title="string 类型的值是常量，不可更改"></a>string 类型的值是常量，不可更改</h1><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。<br>string 类型的值是只读的二进制 byte slice，如果真要修改字符串中的字符，将 string 转为 []byte 修改后，再转为 string 即可：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">"T"</span>      <span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    xBytes := []<span class="keyword">byte</span>(x)</span><br><span class="line">    xBytes[<span class="number">0</span>] = <span class="string">'T'</span> <span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">    x = <span class="keyword">string</span>(xBytes)</span><br><span class="line">    fmt.Println(x)  <span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： 上边的示例并不是更新字符串的正确姿势，因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的。  </p>
<p>更新字串的正确姿势：将 string 转为 rune slice（此时 1 个 rune 可能占多个 byte），直接更新 rune 中的字符  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    xRunes := []<span class="keyword">rune</span>(x)</span><br><span class="line">    xRunes[<span class="number">0</span>] = <span class="string">'我'</span></span><br><span class="line">    x = <span class="keyword">string</span>(xRunes)</span><br><span class="line">    fmt.Println(x)  <span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 的内建函数 <code>len()</code> 返回的是字符串的 byte 数量，而不是像 Python 中那样是计算 Unicode 字符数。  </p>
<p>如果要得到字符串的字符数，可使用 “unicode/utf8” 包中的 <code>RuneCountInString(str string) (n int)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))   <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： RuneCountInString 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 rune：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"é"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))  <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))   <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(<span class="string">"cafe\u0301"</span>)   <span class="comment">// café // 法文的 cafe，实际上是两个 rune 的组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="在多行-array、slice、map-语句中缺少-号"><a href="#在多行-array、slice、map-语句中缺少-号" class="headerlink" title="在多行 array、slice、map 语句中缺少 , 号"></a>在多行 array、slice、map 语句中缺少 , 号</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>   <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;    </span><br><span class="line">    z := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="log-Fatal-和-log-Panic-不只是-log"><a href="#log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="log.Fatal 和 log.Panic 不只是 log"></a><code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h1><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 Fatal<em>()、Panic</em>() 时能做更多日志外的事，如中断程序的执行等：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"Fatal level log: log entry"</span>)     <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">"Nomal level log: log entry"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对内建数据结构的操作并不是同步的"><a href="#对内建数据结构的操作并不是同步的" class="headerlink" title="对内建数据结构的操作并不是同步的"></a>对内建数据结构的操作并不是同步的</h1><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。  </p>
<p>goroutine 和 channel 是进行原子操作的好方法，或使用 “sync” 包中的锁。  </p>
<h1 id="range-迭代-string-得到的值"><a href="#range-迭代-string-得到的值" class="headerlink" title="range 迭代 string 得到的值"></a>range 迭代 string 得到的值</h1><p>range 得到的索引是字符值（Unicode point / rune）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。  </p>
<p>for range 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 0XFFFD rune（�）UNicode 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">"A\xfe\x02\xff\x04"</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>, v)   <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4   // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>, v)   <span class="comment">// 0x41 0xfe 0x2 0xff 0x4   // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="range-迭代-map"><a href="#range-迭代-map" class="headerlink" title="range 迭代 map"></a>range 迭代 map</h1><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。  </p>
<p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>, <span class="string">"four"</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="switch-中的-fallthrough-语句"><a href="#switch-中的-fallthrough-语句" class="headerlink" title="switch 中的 fallthrough 语句"></a>switch 中的 fallthrough 语句</h1><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 break，不过你可以在 case 代码块末尾使用 fallthrough，强制执行下一个 case 代码块。也可以改写 case 为多条件判断。  </p>
<h1 id="自增和自减运算"><a href="#自增和自减运算" class="headerlink" title="自增和自减运算"></a>自增和自减运算</h1><p>多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>--</code> 只作为运算符而非表达式。  </p>
<h1 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h1><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 中用 <code>^</code> XOR 操作符来按位取反。<br>同时 <code>^</code> 也是按位异或（XOR）操作符。  </p>
<p>Go 也有特殊的操作符 AND NOT <code>&amp;^</code> 操作符，不同位才取1。</p>
<h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>优先级列表：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure>

<h1 id="不导出的-struct-字段无法被-encode"><a href="#不导出的-struct-字段无法被-encode" class="headerlink" title="不导出的 struct 字段无法被 encode"></a>不导出的 struct 字段无法被 encode</h1><p>以小写字母开头的字段成员是无法被外部直接访问的，所以 <code>struct</code> 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := MyData&#123;<span class="number">1</span>, <span class="string">"two"</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, in) <span class="comment">// main.MyData&#123;One:1, two:"two"&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded, _ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(encoded))    <span class="comment">// &#123;"One":1&#125;    // 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded, &amp;out)</span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, out)    <span class="comment">// main.MyData&#123;One:1, two:""&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="程序退出时还有-goroutine-在执行"><a href="#程序退出时还有-goroutine-在执行" class="headerlink" title="程序退出时还有 goroutine 在执行"></a>程序退出时还有 goroutine 在执行</h1><p>程序默认不等所有 goroutine 都执行完才退出，这点需要特别注意。  </p>
<p>常用解决办法：使用 “WaitGroup” 变量，它会让主程序等待所有 goroutine 执行完毕再退出。  </p>
<p>如果你的 goroutine 要做消息的循环处理等耗时操作，可以向它们发送一条 kill 消息来关闭它们。或直接关闭一个它们都等待接收数据的 channel：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)   <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;  <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="keyword">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] m =&gt; %v\n"</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] is done\n"</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>若函数 receiver 传参是传值方式，则无法修改参数的原有值</h1><p>方法 receiver 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。  </p>
<p>除非 receiver 参数是 map 或 slice 类型的变量，并且是以指针方式更新 map 中的字段、slice 中的元素的，才会更新原有值:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num   <span class="keyword">int</span></span><br><span class="line">    key   *<span class="keyword">string</span></span><br><span class="line">    items <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *data)</span> <span class="title">pointerFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.num = <span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this data)</span> <span class="title">valueFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    this.num = <span class="number">8</span></span><br><span class="line">    *this.key = <span class="string">"valueFunc.key"</span></span><br><span class="line">    this.items[<span class="string">"valueFunc"</span>] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    key := <span class="string">"key1"</span></span><br><span class="line"></span><br><span class="line">    d := data&#123;<span class="number">1</span>, &amp;key, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"num=%v  key=%v  items=%v\n"</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.pointerFunc() <span class="comment">// 修改 num 的值为 7</span></span><br><span class="line">    fmt.Printf(<span class="string">"num=%v  key=%v  items=%v\n"</span>, d.num, *d.key, d.items)</span><br><span class="line"></span><br><span class="line">    d.valueFunc()   <span class="comment">// 修改 key 和 items 的值，num 未修改成功</span></span><br><span class="line">    fmt.Printf(<span class="string">"num=%v  key=%v  items=%v\n"</span>, d.num, *d.key, d.items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="struct、array、slice-和-map-的值比较"><a href="#struct、array、slice-和-map-的值比较" class="headerlink" title="struct、array、slice 和 map 的值比较"></a>struct、array、slice 和 map 的值比较</h1><p>可以使用相等运算符 == 来比较结构体变量，前提是两个结构体的成员都是可比较的类型。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num     <span class="keyword">int</span></span><br><span class="line">    fp      <span class="keyword">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">complex64</span></span><br><span class="line">    str     <span class="keyword">string</span></span><br><span class="line">    char    <span class="keyword">rune</span></span><br><span class="line">    yes     <span class="keyword">bool</span></span><br><span class="line">    events  &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref     *<span class="keyword">byte</span></span><br><span class="line">    raw     [<span class="number">10</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, v1 == v2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num    <span class="keyword">int</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span>      // 无法比较</span></span><br><span class="line">    doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span>      // 无法比较</span></span><br><span class="line">    m      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>    <span class="comment">// 无法比较</span></span><br><span class="line">    bytes  []<span class="keyword">byte</span>           <span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 “reflect” 包的 <code>DeepEqual()</code> ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"a"</span>, <span class="string">"two"</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"two"</span>: <span class="string">"b"</span>, <span class="string">"one"</span>: <span class="string">"a"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(m1, m2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(s1, s2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种比较方式可能比较慢，根据你的程序需求来使用。<code>DeepEqual()</code> 还有其他用法：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="keyword">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"b1 == b2: "</span>, reflect.DeepEqual(b1, b2))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> <code>DeepEqual()</code> 并不总适合于比较 slice</p>
<p>如果要大小写不敏感来比较 byte 或 string 中的英文文本，可以使用 “bytes” 或 “strings” 包的 <code>ToUpper()</code> 和 <code>ToLower()</code> 函数。比较其他语言的 byte 或 string，应使用 <code>bytes.EqualFold()</code> 和 <code>strings.EqualFold()</code>  </p>
<p>如果 byte slice 中含有验证用户身份的数据（密文哈希、token 等），不应再使用 <code>reflect.DeepEqual()</code>、<code>bytes.Equal()</code>、 <code>bytes.Compare()</code>。这三个函数容易对程序造成 timing attacks，此时应使用 “crypto/subtle” 包中的 <code>subtle.ConstantTimeCompare()</code> 等函数  </p>
<h1 id="在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>在 range 迭代 slice、array、map 时通过更新引用来更新元素</h1><p>在 range 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址。  </p>
<p>如果要修改原有元素的值，应该使用索引直接访问。  </p>
<p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123; num <span class="keyword">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span> <span class="comment">// 直接使用指针更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])  <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="slice-中隐藏的数据"><a href="#slice-中隐藏的数据" class="headerlink" title="slice 中隐藏的数据"></a>slice 中隐藏的数据</h1><p>从 slice 中重新切出新 slice 时，新 slice 会引用原 slice 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 slice 来指向原底层数组的部分数据，将导致难以预料的内存使用。  </p>
<p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> <span class="params">(res []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>]) <span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="旧-slice"><a href="#旧-slice" class="headerlink" title="旧 slice"></a>旧 slice</h1><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。  </p>
<p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)   <span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)   <span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">    fmt.Println(s1)     <span class="comment">// [1 22 23]</span></span><br><span class="line">    fmt.Println(s2)     <span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)  <span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s1)     <span class="comment">// [1 22 23]    // 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">    fmt.Println(s2)     <span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="跳出-for-switch-和-for-select-代码块"><a href="#跳出-for-switch-和-for-select-代码块" class="headerlink" title="跳出 for-switch 和 for-select 代码块"></a>跳出 for-switch 和 for-select 代码块</h1><p>没有指定标签的 break 只会跳出 switch/select 语句，若不能使用 return 语句跳出的话，可为 break 跳出标签指定的代码块然后 <code>goto</code>。  </p>
<h1 id="defer-函数的参数值"><a href="#defer-函数的参数值" class="headerlink" title="defer 函数的参数值"></a>defer 函数的参数值</h1><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"result: "</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: 2</span></span><br></pre></td></tr></table></figure>

<h1 id="defer-函数的执行时机"><a href="#defer-函数的执行时机" class="headerlink" title="defer 函数的执行时机"></a>defer 函数的执行时机</h1><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。  </p>
<p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir := os.Args[<span class="number">1</span>]</span><br><span class="line">    start, err := os.Stat(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">        os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="keyword">string</span></span><br><span class="line">    filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="keyword">string</span>, fInfo os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"bad target:"</span>, target, <span class="string">"error:"</span>, err)   <span class="comment">//error:too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 f 资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法：defer延迟执行的函数写入匿名函数  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"bad target:"</span>, target, <span class="string">"error:"</span>, err)</span><br><span class="line">                <span class="keyword">return</span>  <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close() <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以去掉 defer，在文件资源使用完毕后，直接调用 f.Close() 来关闭。  </p>
<h1 id="失败的类型断言"><a href="#失败的类型断言" class="headerlink" title="失败的类型断言"></a>失败的类型断言</h1><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int], data: "</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int], data: "</span>, data)   <span class="comment">// [isn't a int], data:  0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int], data: "</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int], data: "</span>, data)   <span class="comment">// [not an int], data:  great</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用指针作为方法的-receiver"><a href="#使用指针作为方法的-receiver" class="headerlink" title="使用指针作为方法的 receiver"></a>使用指针作为方法的 receiver</h1><p>只要值是可寻址的，就可以在值上直接调用指针方法。即是对一个方法，它的 receiver 是指针就足矣。  </p>
<p>但不是所有值都是可寻址的，比如 map 类型的元素、通过 interface 引用的变量：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> printer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *data)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"name: "</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := data&#123;<span class="string">"one"</span>&#125;</span><br><span class="line">    d1.<span class="built_in">print</span>()  <span class="comment">// d1 变量可寻址，可直接调用指针 receiver 的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> in printer = data&#123;<span class="string">"two"</span>&#125;</span><br><span class="line">    in.<span class="built_in">print</span>()  <span class="comment">// 类型不匹配</span></span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data&#123;</span><br><span class="line">        <span class="string">"x"</span>: data&#123;<span class="string">"three"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">"x"</span>].<span class="built_in">print</span>()  <span class="comment">// m["x"] 是不可寻址的    // 变动频繁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cannot use data literal (type data) as type printer in assignment:<br>data does not implement printer (print method has pointer receiver)<br>cannot call pointer method on m[“x”]<br>cannot take the address of m[“x”]</p>
</blockquote>
<h1 id="更新-map-字段的值"><a href="#更新-map-字段的值" class="headerlink" title="更新 map 字段的值"></a>更新 map 字段的值</h1><p>如果 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法直接更新 struct 的字段值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data&#123;</span><br><span class="line">        <span class="string">"x"</span>: &#123;<span class="string">"Tom"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">"x"</span>].name = <span class="string">"Jerry"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"></span><br><span class="line">cannot assign to <span class="keyword">struct</span> field m[“x”].name in <span class="keyword">map</span></span><br></pre></td></tr></table></figure>

<p>因为 map 中的元素是不可寻址的。需区分开的是，slice 的元素可寻址：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []data&#123;&#123;<span class="string">"Tom"</span>&#125;&#125;</span><br><span class="line">    s[<span class="number">0</span>].name = <span class="string">"Jerry"</span></span><br><span class="line">    fmt.Println(s)  <span class="comment">// [&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新 map 中 struct 元素的字段值，有 2 个方法：  </p>
<ul>
<li>使用局部变量  </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取整个 struct 到局部变量中，修改字段值后再整个赋值</span></span><br><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]data&#123;</span><br><span class="line">        <span class="string">"x"</span>: &#123;<span class="string">"Tom"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    r := m[<span class="string">"x"</span>]</span><br><span class="line">    r.name = <span class="string">"Jerry"</span></span><br><span class="line">    m[<span class="string">"x"</span>] = r</span><br><span class="line">    fmt.Println(m)  <span class="comment">// map[x:&#123;Jerry&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用指向元素的 map 指针  </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]*data&#123;</span><br><span class="line">        <span class="string">"x"</span>: &#123;<span class="string">"Tom"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    m[<span class="string">"x"</span>].name = <span class="string">"Jerry"</span>   <span class="comment">// 直接修改 m["x"] 中的字段</span></span><br><span class="line">    fmt.Println(m[<span class="string">"x"</span>]) <span class="comment">// &amp;&#123;Jerry&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意下边这种误用：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]*data&#123;</span><br><span class="line">        <span class="string">"x"</span>: &#123;<span class="string">"Tom"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="string">"z"</span>].name = <span class="string">"what???"</span>  </span><br><span class="line">    fmt.Println(m[<span class="string">"x"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>panic: runtime error: invalid memory address or nil pointer dereference</p>
</blockquote>
<h1 id="nil-interface-和-nil-interface-值"><a href="#nil-interface-和-nil-interface-值" class="headerlink" title="nil interface 和 nil interface 值"></a>nil interface 和 nil interface 值</h1><p>虽然 interface 看起来像指针类型，但它不是。interface 类型的变量只有在类型和值均为 nil 时才为 nil  </p>
<p>如果你的 interface 变量的值是跟随其他变量变化的（雾），与 nil 比较相等时小心：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data *<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(data, data == <span class="literal">nil</span>)  <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)  <span class="comment">// &lt;nil&gt; true</span></span><br><span class="line"></span><br><span class="line">    in = data</span><br><span class="line">    fmt.Println(in, in == <span class="literal">nil</span>)  <span class="comment">// &lt;nil&gt; false  // data 值为 nil，但 in 值不为 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的函数返回值类型是 interface，更要小心这个坑：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Good result: "</span>, res)   <span class="comment">// Good result:  &lt;nil&gt;</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T\n"</span>, res)         <span class="comment">// *struct &#123;&#125;   // res 不是 nil，它的值为 nil</span></span><br><span class="line">        fmt.Printf(<span class="string">"%v\n"</span>, res)         <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doIt := <span class="function"><span class="keyword">func</span><span class="params">(arg <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">var</span> result *<span class="keyword">struct</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> arg &gt; <span class="number">0</span> &#123;</span><br><span class="line">            result = &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>  <span class="comment">// 明确指明返回 nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res := doIt(<span class="number">-1</span>); res != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Good result: "</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Bad result: "</span>, res)    <span class="comment">// Bad result:  &lt;nil&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆栈变量"><a href="#堆栈变量" class="headerlink" title="堆栈变量"></a>堆栈变量</h1><p>你并不总是清楚你的变量是分配到了堆还是栈。  </p>
<p>在 C++ 中使用 new 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 new()、make() 来创建变量，变量为内存分配位置依旧归 Go 编译器管。  </p>
<p>Go 编译器会根据变量的大小及其 “escape analysis” 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C/C++ 中是不行的。  </p>
<p>在 go build 或 go run 时，加入 -m 参数，能准确分析程序的变量分配位置。  </p>
<h1 id="GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><a href="#GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）" class="headerlink" title="GOMAXPROCS、Concurrency（并发）and Parallelism（并行）"></a>GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</h1><p>Go 1.4 及以下版本，程序只会使用 1 个执行上下文 / OS 线程，即任何时间都最多只有 1 个 goroutine 在执行。  </p>
<p>Go 1.5 版本将可执行上下文的数量设置为 runtime.NumCPU() 返回的逻辑 CPU 核心数，这个数与系统实际总的 CPU 逻辑核心数是否一致，取决于你的 CPU 分配给程序的核心数，可以使用 GOMAXPROCS 环境变量或者动态的使用 runtime.GOMAXPROCS() 来调整。  </p>
<p>误区： <code>GOMAXPROCS</code> 表示执行 goroutine 的 CPU 核心数，参考<a href="https://golang.org/pkg/runtime/" target="_blank" rel="noopener">文档</a>  </p>
<p><code>GOMAXPROCS</code> 的值是可以超过 CPU 的实际数量的，在 1.5 中最大为 256  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(runtime.NumCPU())   <span class="comment">// 4</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">// 20</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">300</span>)</span><br><span class="line">    fmt.Println(runtime.GOMAXPROCS(<span class="number">-1</span>)) <span class="comment">// Go 1.9.2 // 300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="读写操作的重新排序"><a href="#读写操作的重新排序" class="headerlink" title="读写操作的重新排序"></a>读写操作的重新排序</h1><p>Go 可能会重排一些操作的执行顺序，可以保证在一个 goroutine 中操作是顺序执行的，但不保证多 goroutine 的执行顺序。  </p>
<p>如果你想保持多 goroutine 像代码中的那样顺序执行，可以使用 channel 或 sync 包中的锁机制等。  </p>
<h1 id="优先调度"><a href="#优先调度" class="headerlink" title="优先调度"></a>优先调度</h1><p>你的程序可能出现一个 goroutine 在运行时阻止了其他 goroutine 的运行，比如程序中有一个不让调度器运行的 for 循环：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"done !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 的循环体不必为空，但如果代码不会触发调度器执行，将出现问题。  </p>
<p>调度器会在 GC、Go 声明、阻塞 channel、阻塞系统调用和锁操作后再执行，也会在非内联函数调用时执行：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"not done !"</span>)   <span class="comment">// 并不内联执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"done !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用 runtime 包中的 Gosched() 来 手动启动调度器：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done = <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> !done &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"done !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

            <div class="social-item">
              <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
                <span class="icon">
                  <i class="fa fa-wechat"></i>
                </span>

                <span class="label">WeChat</span>
              </a>
            </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
              <a href="/tags/Note/" rel="tag"><i class="fa fa-tag"></i> Note</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/07/Golang-Notes/" rel="prev" title="Go 语言学习笔记">
      <i class="fa fa-chevron-left"></i> Go 语言学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/14/Alg-Notes/" rel="next" title="Algorithm 笔记">
      Algorithm 笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Tips"><span class="nav-number">1.</span> <span class="nav-text">Tips</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#误用字符串"><span class="nav-number">2.</span> <span class="nav-text">误用字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#发生错误时使用defer关闭一个文件"><span class="nav-number">3.</span> <span class="nav-text">发生错误时使用defer关闭一个文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#何时使用new-和make"><span class="nav-number">4.</span> <span class="nav-text">何时使用new()和make()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不需要将一个指向切片的指针传递给函数"><span class="nav-number">5.</span> <span class="nav-text">不需要将一个指向切片的指针传递给函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用指针指向接口类型"><span class="nav-number">6.</span> <span class="nav-text">使用指针指向接口类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用值类型时误用指针"><span class="nav-number">7.</span> <span class="nav-text">使用值类型时误用指针</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#误用协程和通道"><span class="nav-number">8.</span> <span class="nav-text">误用协程和通道</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包和协程的使用"><span class="nav-number">9.</span> <span class="nav-text">闭包和协程的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#糟糕的错误处理"><span class="nav-number">10.</span> <span class="nav-text">糟糕的错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不要使用布尔值"><span class="nav-number">10.1.</span> <span class="nav-text">不要使用布尔值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免错误检测使代码变得混乱："><span class="nav-number">10.2.</span> <span class="nav-text">避免错误检测使代码变得混乱：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不能使用简短声明来设置字段的值"><span class="nav-number">11.</span> <span class="nav-text">不能使用简短声明来设置字段的值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#显式类型的变量无法使用-nil-来初始化"><span class="nav-number">12.</span> <span class="nav-text">显式类型的变量无法使用 nil 来初始化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#直接使用值为-nil-的-slice、map"><span class="nav-number">13.</span> <span class="nav-text">直接使用值为 nil 的 slice、map</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#map-容量"><span class="nav-number">14.</span> <span class="nav-text">map 容量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#string-类型的变量值不能为-nil"><span class="nav-number">15.</span> <span class="nav-text">string 类型的变量值不能为 nil</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#range-遍历-slice-和-array-时混淆了返回值"><span class="nav-number">16.</span> <span class="nav-text">range 遍历 slice 和 array 时混淆了返回值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slice-和-array-其实是一维数据"><span class="nav-number">17.</span> <span class="nav-text">slice 和 array 其实是一维数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#访问-map-中不存在的-key"><span class="nav-number">18.</span> <span class="nav-text">访问 map 中不存在的 key</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#string-类型的值是常量，不可更改"><span class="nav-number">19.</span> <span class="nav-text">string 类型的值是常量，不可更改</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串的长度"><span class="nav-number">20.</span> <span class="nav-text">字符串的长度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在多行-array、slice、map-语句中缺少-号"><span class="nav-number">21.</span> <span class="nav-text">在多行 array、slice、map 语句中缺少 , 号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#log-Fatal-和-log-Panic-不只是-log"><span class="nav-number">22.</span> <span class="nav-text">log.Fatal 和 log.Panic 不只是 log</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对内建数据结构的操作并不是同步的"><span class="nav-number">23.</span> <span class="nav-text">对内建数据结构的操作并不是同步的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#range-迭代-string-得到的值"><span class="nav-number">24.</span> <span class="nav-text">range 迭代 string 得到的值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#range-迭代-map"><span class="nav-number">25.</span> <span class="nav-text">range 迭代 map</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#switch-中的-fallthrough-语句"><span class="nav-number">26.</span> <span class="nav-text">switch 中的 fallthrough 语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自增和自减运算"><span class="nav-number">27.</span> <span class="nav-text">自增和自减运算</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#按位取反"><span class="nav-number">28.</span> <span class="nav-text">按位取反</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符的优先级"><span class="nav-number">29.</span> <span class="nav-text">运算符的优先级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不导出的-struct-字段无法被-encode"><span class="nav-number">30.</span> <span class="nav-text">不导出的 struct 字段无法被 encode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序退出时还有-goroutine-在执行"><span class="nav-number">31.</span> <span class="nav-text">程序退出时还有 goroutine 在执行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#若函数-receiver-传参是传值方式，则无法修改参数的原有值"><span class="nav-number">32.</span> <span class="nav-text">若函数 receiver 传参是传值方式，则无法修改参数的原有值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#struct、array、slice-和-map-的值比较"><span class="nav-number">33.</span> <span class="nav-text">struct、array、slice 和 map 的值比较</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在-range-迭代-slice、array、map-时通过更新引用来更新元素"><span class="nav-number">34.</span> <span class="nav-text">在 range 迭代 slice、array、map 时通过更新引用来更新元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slice-中隐藏的数据"><span class="nav-number">35.</span> <span class="nav-text">slice 中隐藏的数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#旧-slice"><span class="nav-number">36.</span> <span class="nav-text">旧 slice</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#跳出-for-switch-和-for-select-代码块"><span class="nav-number">37.</span> <span class="nav-text">跳出 for-switch 和 for-select 代码块</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defer-函数的参数值"><span class="nav-number">38.</span> <span class="nav-text">defer 函数的参数值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#defer-函数的执行时机"><span class="nav-number">39.</span> <span class="nav-text">defer 函数的执行时机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#失败的类型断言"><span class="nav-number">40.</span> <span class="nav-text">失败的类型断言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用指针作为方法的-receiver"><span class="nav-number">41.</span> <span class="nav-text">使用指针作为方法的 receiver</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#更新-map-字段的值"><span class="nav-number">42.</span> <span class="nav-text">更新 map 字段的值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#nil-interface-和-nil-interface-值"><span class="nav-number">43.</span> <span class="nav-text">nil interface 和 nil interface 值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#堆栈变量"><span class="nav-number">44.</span> <span class="nav-text">堆栈变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GOMAXPROCS、Concurrency（并发）and-Parallelism（并行）"><span class="nav-number">45.</span> <span class="nav-text">GOMAXPROCS、Concurrency（并发）and Parallelism（并行）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读写操作的重新排序"><span class="nav-number">46.</span> <span class="nav-text">读写操作的重新排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#优先调度"><span class="nav-number">47.</span> <span class="nav-text">优先调度</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rtk"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">rtk</p>
  <div class="site-description" itemprop="description">冷萃少冰不加糖</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/reitake" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;reitake" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/rrrrrtk" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;rrrrrtk" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rtk</span>
</div><span class="post-meta-item-icon">
    <i class="fa fa-clock-o"></i>
</span>
<span id="sitetime"></span>
<script language="javascript">
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
    year - 作为date对象的年份，为4位年份值
    month - 0-11之间的整数，做为date对象的月份
    day - 1-31之间的整数，做为date对象的天数
    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
    minutes - 0-59之间的整数，做为date对象的分钟数
    seconds - 0-59之间的整数，做为date对象的秒数
    microseconds - 0-999之间的整数，做为date对象的毫秒数 */
    var t1 = Date.UTC(2019,03,07,10,00,00); //建站时间
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒 ~喵~";
  }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
  siteTime();
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'FY0k4GNyVIFSqBrIxPq7yN7t-gzGzoHsz',
      appKey     : 'FqCFfTcVczkkBx9SyMlf7myz',
      placeholder: "喵w ヾﾉ≧w≦)o",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
