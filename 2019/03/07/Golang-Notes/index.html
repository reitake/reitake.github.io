<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="AoeMgN9r3ZTJhZZgqjfb4tkZf3qRjujP-1gjzMb-x80">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reitake.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go 语言学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 语言学习笔记">
<meta property="og:url" content="https://reitake.github.io/2019/03/07/Golang-Notes/index.html">
<meta property="og:site_name" content="My Notes Blog">
<meta property="og:description" content="Go 语言学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://reitake.github.io/images/the_way_to_go_14.2_fig14.2.png">
<meta property="article:published_time" content="2019-03-07T04:26:44.000Z">
<meta property="article:modified_time" content="2020-12-07T13:34:32.933Z">
<meta property="article:author" content="rtk">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://reitake.github.io/images/the_way_to_go_14.2_fig14.2.png">

<link rel="canonical" href="https://reitake.github.io/2019/03/07/Golang-Notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Go 语言学习笔记 | My Notes Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Notes Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">生活不易 喵声叹气</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-fw fa-gears"></i>工具</a>

  </li>
        <li class="menu-item menu-item-others">

    <a href="/others/" rel="section"><i class="fa fa-fw fa-spinner"></i>不务正业</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://reitake.github.io/2019/03/07/Golang-Notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rtk">
      <meta itemprop="description" content="冷萃少冰不加糖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Notes Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Go 语言学习笔记
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-07 12:26:44" itemprop="dateCreated datePublished" datetime="2019-03-07T12:26:44+08:00">2019-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 21:34:32" itemprop="dateModified" datetime="2020-12-07T21:34:32+08:00">2020-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8C%E8%AF%AD%E8%A8%80%E3%80%8D-Go/" itemprop="url" rel="index"><span itemprop="name">「语言」- Go</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/07/Golang-Notes/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/07/Golang-Notes/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <center> <font color="#bababa">

<p><strong><em>Go 语言学习笔记</em></strong></p>
<p></font> </center></p>
<a id="more"></a>

<hr>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="单变量声明"><a href="#单变量声明" class="headerlink" title="单变量声明"></a>单变量声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明类型，另行赋值</span></span><br><span class="line"><span class="keyword">var</span> v_name v_type</span><br><span class="line">v_name = value</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明值，自动判定类型</span></span><br><span class="line"><span class="keyword">var</span> v_name = value</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略var，使用：=</span></span><br><span class="line">v_name := value</span><br></pre></td></tr></table></figure>
<h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明同个类型，非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 v_type</span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明值，自动判断类型</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用:=，只能在函数体中使用</span></span><br><span class="line">vname1, vmame2, vname3 := v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般用于全局变量声明</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>唯一类型，长度固定，已编号</code>的序列。<br>数组长度是数组type的一部分。<br>数组最大长度为 2Gb。<br>索引超出数组长度时，会 panic。  </p>
<h3 id="单维数组声明"><a href="#单维数组声明" class="headerlink" title="单维数组声明"></a>单维数组声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定元素类型及个数</span></span><br><span class="line"><span class="keyword">var</span> arr_name [SIZE] arr_type</span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>] <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组是值类型，用new()创建</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">new</span>([]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p><strong>初始化数组：</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明时赋值，&#123;&#125;数据量不能大于[]</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.2</span>, <span class="number">4.0</span>, <span class="number">5.5</span>, <span class="number">6.0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">5</span>]<span class="keyword">string</span>&#123;<span class="number">3</span>: <span class="string">"abc"</span>, <span class="number">4</span>: <span class="string">"xyz"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[]不设大小，自动判断数组大小</span></span><br><span class="line"><span class="keyword">var</span> arr = [...]<span class="keyword">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.2</span>, <span class="number">4.0</span>, <span class="number">5.5</span>, <span class="number">6.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明后单独赋值</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">6.0</span></span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr_name [SIZE1][SIZE2]...[SIZEN] arr_type</span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">var</span> arr3[<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果要用变量来代表构成二维数组的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是不对的！</span></span><br><span class="line">s := [val1][val2]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要用make：</span></span><br><span class="line">s := <span class="built_in">make</span>([][]<span class="keyword">int</span>, val1)</span><br><span class="line"><span class="keyword">for</span> _, row := s&#123;</span><br><span class="line">    row := <span class="built_in">make</span>([]<span class="keyword">int</span>, val2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二维数组初始化：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,    <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,    <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,   <span class="comment">/*  第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须有逗号</span></span><br></pre></td></tr></table></figure>

<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><ul>
<li>用 for 遍历：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr1); i++｛</span><br><span class="line">    arr1[i] = ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用 for-range：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,_:= <span class="keyword">range</span> arr1 &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li>new() 的区别：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">new</span>([<span class="number">5</span>]<span class="keyword">int</span>)  <span class="comment">// arr1 的类型是 *[5]int</span></span><br><span class="line"><span class="keyword">var</span> arr2 [<span class="number">5</span>]<span class="keyword">int</span>         <span class="comment">// arr2 的类型是 [5]int</span></span><br></pre></td></tr></table></figure>
故传参时，<code>func1(arr2)</code> 是数组拷贝，不能修改原数组。要修改，要 <code>func(&amp;arr2)</code></li>
<li>把大数组传给函数会消耗很多内存，避免方法：（1）传递数组的指针；（2）使用数组的切片。  </li>
</ul>
<hr>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>是对数组一个连续片段的引用（该数组称为相关数组，通常是匿名的）。  </p>
<h3 id="切片声明"><a href="#切片声明" class="headerlink" title="切片声明"></a>切片声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明类型，省略大小</span></span><br><span class="line"><span class="keyword">var</span> slice_name []<span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用make()创建切片</span></span><br><span class="line"><span class="keyword">var</span> slice_name [] = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">//也可简写成</span></span><br><span class="line">slice_name := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, capacity)  <span class="comment">//capacity为可选参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 new() 创建，与用 make 相同</span></span><br><span class="line"><span class="built_in">new</span>([<span class="number">100</span>]<span class="keyword">int</span>)[<span class="number">0</span>:<span class="number">50</span>]</span><br><span class="line"><span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">50</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>new() 和 make() 的区别：  </p>
<ul>
<li>new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为<em>T的内存地址：这种方法*</em>返回一个指向类型为 T，值为 0 的地址的指针**，它适用于值类型如数组和结构体。 </li>
<li>make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel。<br>即 new 函数分配内存，make 函数初始化。  </li>
<li><em>切片初始化：*</em>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接:=声明+初始化</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;   <span class="comment">// cap = len = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组初始化切片</span></span><br><span class="line">s := arr[:]     <span class="comment">// s := arr[startIndex:endIndex]</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">type</span> arr[:]</span><br></pre></td></tr></table></figure></li>
<li><em>空(nil)切片：*</em><br>一个切片在未初始化之前默认为 nil，长度为 0。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span>(s == <span class="literal">nil</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片的操作"><a href="#切片的操作" class="headerlink" title="切片的操作"></a>切片的操作</h3></li>
<li>切片重组（reslice）：切片达到cao上限后可扩容，改变切片长度的过程称为重组reslicing。做法：<code>slice1 = slice1[0:end]</code><br>切片扩展 1 位： <code>sl = sl[0:len(sl)+1]</code>  </li>
<li>切片后移 1 位：<code>s = s[1:]</code>,不可前移。</li>
<li>注意：不要用指针指向 slice，因为切片本身已经是一个引用类型，所以它本身就是一个指针！  </li>
<li>for-range 用于切片时，第一个返回值 ix 是索引，第二个返回值 val 是该索引位置的值，val 是值拷贝。</li>
<li><code>copy(sl_to, sl_form)</code> 切片复制  </li>
<li><code>apend(sl, elem1...)</code> 切片追加  </li>
<li>s 是个字符串（本质是字节数组），那可通过 <code>c := []byte(s)</code> 来获得字节切片 c。或者 <code>copy(dst []byte, src string)</code>    </li>
<li>字符串是不可被赋值修改的，要修改可以将字符串转化成字节数字，然后修改数组元素，最后把字节数组转换回字符串：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello"</span></span><br><span class="line">c := []<span class="keyword">byte</span>(s)</span><br><span class="line">c[<span class="number">0</span>] = <span class="string">'c'</span></span><br><span class="line">s2 := <span class="keyword">string</span>(c) <span class="comment">// s2 == "cello"</span></span><br></pre></td></tr></table></figure></li>
<li><code>sort</code> 包实现搜索和排序。搜索元素前必须先排序（因为搜索是二分法）。<a href="http://golang.org/pkg/sort/" target="_blank" rel="noopener">sort 官方文档</a>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sort.Ints(arri)     <span class="comment">// 升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stirings</span><span class="params">(a []<span class="keyword">string</span>)</span></span></span><br><span class="line"></span><br><span class="line">IntsAreSorted(a []<span class="keyword">int</span>) <span class="keyword">bool</span>     <span class="comment">// 检查是否已被排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span>     // 搜索</span></span><br></pre></td></tr></table></figure></li>
<li>append 函数常见操作<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片 b 追加到切片 a 之后：</span></span><br><span class="line">a = <span class="built_in">append</span>(a, b...)</span><br><span class="line"><span class="comment">// 复制切片 a 的元素到新的切片 b 上：</span></span><br><span class="line">b = <span class="built_in">make</span>([]T, <span class="built_in">len</span>(a))</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br><span class="line"><span class="comment">// 删除位于索引 i 的元素：</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], a[i+<span class="number">1</span>:]...)</span><br><span class="line"><span class="comment">// 切除切片 a 中从索引 i 至 j 位置的元素：</span></span><br><span class="line">a = apend(a[:i], a[j:]...)</span><br><span class="line"><span class="comment">// 为切片 a 拓展 j 个元素长度：</span></span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="built_in">make</span>([]T, j)...)</span><br><span class="line"><span class="comment">// 在索引 i 的位置插入元素 x：</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>([]T&#123;x&#125;, a[i:]...)...)</span><br><span class="line"><span class="comment">// 在索引 i 的位置插入切片 b 的所有元素：</span></span><br><span class="line">a = <span class="built_in">append</span>(a[:i], <span class="built_in">append</span>(b, a[i:]...)...)</span><br><span class="line"><span class="comment">// 取出位于切片 a 最末尾的元素 x：</span></span><br><span class="line">x, a = a[<span class="built_in">len</span>(a)<span class="number">-1</span>], a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="切片和垃圾回收"><a href="#切片和垃圾回收" class="headerlink" title="切片和垃圾回收"></a>切片和垃圾回收</h3><p>切片的底层是数组，数组实际容量可能大于切片容量，只有没有任何切片指向数组时，底层数组的内存才会被释放，因此可能对导致过多内存被占用。  </p>
<hr>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p_name *p_type</span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="keyword">float32</span></span><br></pre></td></tr></table></figure>
<p><strong>指针使用：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span></span><br><span class="line">ip = &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"a 变量的地址是: %x\n"</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">"ip 变量储存的指针地址: %x\n"</span>, ip )   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">fmt.Printf(<span class="string">"*ip 变量的值: %d\n"</span>, *ip )          <span class="comment">/* 使用指针访问值 */</span></span><br></pre></td></tr></table></figure>
<p><strong>空指针：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"ptr的值为 ： %x\n"</span>), ptr)   <span class="comment">/* 空指针的值为零 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//控指针的判断：</span></span><br><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nil</span>)     <span class="comment">/* ptr 不是空指针 */</span></span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">nil</span>)    <span class="comment">/* ptr 是空指针 */</span></span><br></pre></td></tr></table></figure>
<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX <span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := []<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">200</span>&#125;</span><br><span class="line">   <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">var</span> ptr [MAX]*<span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>  i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">      ptr[i] = &amp;a[i] <span class="comment">/* 整数地址赋值给指针数组 */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>  i = <span class="number">0</span>; i &lt; MAX; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">"a[%d] = %d\n"</span>, i,*ptr[i] )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">200</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>一系列相同或不同类型的数据结构构成的集合。</p>
<p>组成结构体类型的数据称为<strong>字段（field）</strong>。    </p>
<h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span>&#123;</span><br><span class="line">    filed1 <span class="keyword">type</span>;</span><br><span class="line">    filed2 <span class="keyword">type</span>;</span><br><span class="line">    ...</span><br><span class="line">    filedN <span class="keyword">type</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 new，会分配内存</span></span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用的初始化结构体方式：</span></span><br><span class="line">ms := &amp;struct1&#123;<span class="number">10</span>, <span class="number">15.5</span>, <span class="string">"Chris"</span>&#125;   <span class="comment">//是一种简写，底层仍会调用 new()，必须按顺序赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用结构体声明变量</span></span><br><span class="line">struct_name := struct_variable_type &#123;value1, value2...,valueN&#125;</span><br><span class="line">struct_name_name2 := struct_variable_type&#123;filed1: value1, filed2: value2..., filedN: valueN&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结构体成员，选择器（selector</span></span><br><span class="line">结构体.成员名</span><br><span class="line">structname.fieldname</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体名struct_name可以作为函数参数</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义指向结构体的指针</span></span><br><span class="line"><span class="keyword">var</span> struct_pointer *struct_variable_type</span><br><span class="line">struct_pointer = &amp;struct_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指针访问成员</span></span><br><span class="line">struct_pointer.keyN</span><br></pre></td></tr></table></figure>

<h3 id="使用工厂方法创建结构体实例"><a href="#使用工厂方法创建结构体实例" class="headerlink" title="使用工厂方法创建结构体实例"></a>使用工厂方法创建结构体实例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;                              <span class="comment">//定义了如下的 File 结构体类型</span></span><br><span class="line">    fd      <span class="keyword">int</span>     <span class="comment">// 文件描述符</span></span><br><span class="line">    name    <span class="keyword">string</span>  <span class="comment">// 文件名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span> &#123;       <span class="comment">// 返回一个指向结构体实例的指针</span></span><br><span class="line">    <span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;File&#123;fd, name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := NewFile(<span class="number">10</span>, <span class="string">"./test.txt"</span>)                   <span class="comment">// 调用工厂方法</span></span><br></pre></td></tr></table></figure>
<p>如果想知道结构体类型T的一个实例占用了多少内存，可以使用：<code>size := unsafe.Sizeof(T{})</code>。  </p>
<p>试图 <code>make()</code> 一个结构体变量，会引发一个编译错误，这还不是太糟糕，但是 <code>new()</code> 一个映射并试图使用数据填充它，将会引发运行时错误！ 因为 <code>new(Foo)</code> 返回的是一个指向 <code>nil</code> 的指针，它尚未被分配内存。所以在使用 <code>map</code> 时要特别谨慎。：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span> &#123;</span><br><span class="line">    thingOne <span class="keyword">string</span></span><br><span class="line">    thingTwo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    y := <span class="built_in">new</span>(Bar)</span><br><span class="line">    (*y).thingOne = <span class="string">"hello"</span></span><br><span class="line">    (*y).thingTwo = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NOT OK</span></span><br><span class="line">    z := <span class="built_in">make</span>(Bar) <span class="comment">// 编译错误：cannot make type Bar</span></span><br><span class="line">    (*z).thingOne = <span class="string">"hello"</span></span><br><span class="line">    (*z).thingTwo = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">    x := <span class="built_in">make</span>(Foo)</span><br><span class="line">    x[<span class="string">"x"</span>] = <span class="string">"goodbye"</span></span><br><span class="line">    x[<span class="string">"y"</span>] = <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// NOT OK</span></span><br><span class="line">    u := <span class="built_in">new</span>(Foo)</span><br><span class="line">    (*u)[<span class="string">"x"</span>] = <span class="string">"goodbye"</span> <span class="comment">// 运行时错误!! panic: assignment to entry in nil map</span></span><br><span class="line">    (*u)[<span class="string">"y"</span>] = <span class="string">"world"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带标签的结构体"><a href="#带标签的结构体" class="headerlink" title="带标签的结构体"></a>带标签的结构体</h3><p>结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 <code>reflect</code> 能获取它。 <code>reflect</code>包可以在运行时自省类型、属性和方法，比如：在一个变量上调用 <code>reflect.TypeOf()</code> 可以获取变量的正确类型，如果变量是一个结构体类型，就可以通过 Field 来索引结构体的字段，然后就可以使用 Tag 属性。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TagType <span class="keyword">struct</span> &#123; <span class="comment">// tags</span></span><br><span class="line">    field1 <span class="keyword">bool</span>   <span class="string">"An important answer"</span></span><br><span class="line">    field2 <span class="keyword">string</span> <span class="string">"The name of the thing"</span></span><br><span class="line">    field3 <span class="keyword">int</span>    <span class="string">"How much there are"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tt := TagType&#123;<span class="literal">true</span>, <span class="string">"Barak Obama"</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        refTag(tt, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refTag</span><span class="params">(tt TagType, ix <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ttType := reflect.TypeOf(tt)</span><br><span class="line">    ixField := ttType.Field(ix)</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, ixField.Tag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">An important answer</span><br><span class="line">The name of the thing</span><br><span class="line">How much there are</span><br></pre></td></tr></table></figure>

<h3 id="匿名字段和内嵌结构体"><a href="#匿名字段和内嵌结构体" class="headerlink" title="匿名字段和内嵌结构体"></a>匿名字段和内嵌结构体</h3><p>结构体可以包含一个或多个 <strong>匿名（或内嵌）字段</strong>，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 <strong>结构体可以包含内嵌结构体</strong>。  </p>
<ul>
<li>当两个字段命名冲突时候：<ul>
<li>外场名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；  </li>
<li>如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。  </li>
</ul>
</li>
</ul>
<hr>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。  </p>
<p>接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：invalid receiver type…。  </p>
<p>最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。  </p>
<p>一个类型加上它的方法等价于面向对象中的一个<strong>类</strong>。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。  </p>
<p>类型 T（或 <em>T）上的所有方法的集合叫做类型 T（或 <em>T）的</em></em>方法集**。  </p>
<p>定义方法的一般格式：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果方法不需要使用 recv 的值，可以用 _ 替换它：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在方法名之前，func 关键字之后的括号中指定 receiver。  </p>
<p>如果 <code>recv</code> 是 receiver 的实例，Method1 是它的方法名，那么方法调用遵循传统的 <code>object.name</code> 选择器符号：<strong>recv.Method1()</strong>。  </p>
<p>如果 <code>recv</code> 是一个指针，Go 会自动解引用。  </p>
<h3 id="函数和方法的区别"><a href="#函数和方法的区别" class="headerlink" title="函数和方法的区别"></a>函数和方法的区别</h3><p>函数将变量作为参数：<strong>Function1(recv)</strong>  </p>
<p>方法在变量上被调用：<strong>recv.Method1()</strong>  </p>
<p><strong>receiver_type</strong> 叫做 <strong>（接收者）基本类型</strong>，这个类型必须在和方法同样的包中被声明。  </p>
<p><strong>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</strong>  </p>
<h3 id="方法和未导出字段"><a href="#方法和未导出字段" class="headerlink" title="方法和未导出字段"></a>方法和未导出字段</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md#1064-%E6%96%B9%E6%B3%95%E5%92%8C%E6%9C%AA%E5%AF%BC%E5%87%BA%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">可以建立Set方法来修改未导出的字段</a>  </p>
<h3 id="内嵌类型的方法和继承"><a href="#内嵌类型的方法和继承" class="headerlink" title="内嵌类型的方法和继承"></a>内嵌类型的方法和继承</h3><p>将父类型放在子类型中来实现亚型。<br><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md#1065-%E5%86%85%E5%B5%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="在类型中嵌入功能"><a href="#在类型中嵌入功能" class="headerlink" title="在类型中嵌入功能"></a>在类型中嵌入功能</h3><p>主要有两种方法来实现在类型中嵌入功能：  </p>
<p>A：聚合（或组合）：包含一个所需功能类型的具名字段。  </p>
<p>B：内嵌：内嵌（匿名地）所需功能类型。  </p>
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md#1066-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md#1067-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="和其他面向对象语言比较-Go-的类型和方法"><a href="#和其他面向对象语言比较-Go-的类型和方法" class="headerlink" title="和其他面向对象语言比较 Go 的类型和方法"></a>和其他面向对象语言比较 Go 的类型和方法</h3><p>在如 C++、Java、C# 和 Ruby 这样的面向对象语言中，方法在类的上下文中被定义和继承：在一个对象上调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，如果没有会导致异常发生。  </p>
<p>在 Go 语言中，这样的继承层次是完全没必要的：如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系。在这个意义上，Go 具有更大的灵活性。  </p>
<p>Go 不需要一个显式的类定义，如同 Java、C++、C# 等那样，相反地，“类”是通过提供一组作用于一个共同类型的方法集来隐式定义的。类型可以是结构体或者任何用户自定义类型。  </p>
<p><strong>总结</strong></p>
<p>在 Go 中，类型就是类（数据和关联的方法）。Go 不知道类似面向对象语言的类继承的概念。继承有两个好处：代码复用和多态。  </p>
<p>在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 <strong>组件编程（Component Programming）</strong>。  </p>
<p>许多开发者说相比于类继承，Go 的接口提供了更强大、却更简单的多态行为。  </p>
<p><strong>备注</strong></p>
<p>如果真的需要更多面向对象的能力，看一下 <a href="https://github.com/losalamos/goop" target="_blank" rel="noopener"><code>goop</code></a> 包（Go Object-Oriented Programming），它由 Scott Pakin 编写: 它给 Go 提供了 JavaScript 风格的对象（基于原型的对象），并且支持多重继承和类型独立分派，通过它可以实现你喜欢的其他编程语言里的一些结构。  </p>
<h3 id="类型的-String-方法和格式化描述符"><a href="#类型的-String-方法和格式化描述符" class="headerlink" title="类型的 String() 方法和格式化描述符"></a>类型的 String() 方法和格式化描述符</h3><p>如果类型定义了 <code>String()</code> 方法，它会被用在 <code>fmt.Printf()</code> 中生成默认的输出：等同于使用格式化描述符 <code>%v</code> 产生的输出。还有 <code>fmt.Print()</code> 和 <code>fmt.Println()</code> 也会自动使用 <code>String()</code> 方法。  </p>
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.7.md" target="_blank" rel="noopener">example</a>  </p>
<p>格式化描述符 <code>%T</code> 会给出类型的完全规格，<code>%#v</code> 会给出实例的完整输出，包括它的字段（在程序自动生成 <code>Go</code> 代码时也很有用）。  </p>
<p><strong>备注</strong></p>
<p>不要在 <code>String()</code> 方法里面调用涉及 <code>String()</code> 方法的方法，它会导致意料之外的错误，比如下面的例子，它导致了一个无限递归调用（<code>TT.String()</code> 调用 <code>fmt.Sprintf</code>，而 <code>fmt.Sprintf</code> 又会反过来调用 <code>TT.String()</code>…），很快就会导致内存溢出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TT <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t TT)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v"</span>, t)</span><br><span class="line">&#125;</span><br><span class="line">t.String()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map(集合)"></a>Map(集合)</h2><p>一种无序的键值的集合。可以迭代，不返回顺序。<br>通过key来快速检索。<br>声明时不需要知道 map 长度，map 可以动态增长。不存在固定长度或最大限制，但可以选择表明map的初始容量 <code>capacity</code>：<code>make(map[keytype]valuetype, cap)</code><br>未初始化的 map 的值是 nil。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量声明，不初始化的话，默认map是nil，nil map不能用来存放键值</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"><span class="comment">//或使用make</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line"><span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">//创建</span></span><br><span class="line">countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">countryCapitalMap[<span class="string">"France"</span>] = <span class="string">"Paris"</span> <span class="comment">//map插入key - value对</span></span><br><span class="line">countryCapitalMap[<span class="string">"Italy"</span>] = <span class="string">"罗马"</span></span><br><span class="line">countryCapitalMap[<span class="string">"Japan"</span>] = <span class="string">"东京"</span></span><br><span class="line">countryCapitalMap[<span class="string">"India "</span>] = <span class="string">"新德里"</span></span><br><span class="line"><span class="comment">/* 遍历输出 */</span></span><br><span class="line"><span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">    fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap[country])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 查看元素在map中是否存在 */</span></span><br><span class="line">capital, ok := countryCapitalMap[<span class="string">"美国"</span>] <span class="comment">//存在ok=true，不存在ok=false</span></span><br><span class="line">fmt.Println(capital)</span><br><span class="line">fmt.Println(ok)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"美国的首都是"</span>, capital)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"美国的首都不存在"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h3><ul>
<li><p>测试键值对  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, ok := map1[key1] <span class="comment">// 如果key1存在则ok == true，否则ok为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := map1[key1]; ok &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete()函数<br>删除Map的元素，参数为key。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(map1, key1)      <span class="comment">// 如果 key1 不存在，该操作不会产生错误。</span></span><br><span class="line"><span class="built_in">delete</span>(countryCapitalMap, <span class="string">"France"</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>for-range 用法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="用切片作为-map-的值"><a href="#用切片作为-map-的值" class="headerlink" title="用切片作为 map 的值"></a>用切片作为 map 的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>)</span><br><span class="line">mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]*[]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="map-类型的切片"><a href="#map-类型的切片" class="headerlink" title="map 类型的切片"></a>map 类型的切片</h3><p>必须用两次 <code>make()</code>，第一次分配切片，第二次分配切片中每个 map 元素：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Version A:</span></span><br><span class="line">    items := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="keyword">range</span> items &#123;</span><br><span class="line">        items[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">        items[i][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Version A: Value of items: %v\n"</span>, items)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Version B: NOT GOOD!</span></span><br><span class="line">    items2 := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items2 &#123;</span><br><span class="line">        item = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// item is only a copy of the slice element.</span></span><br><span class="line">        item[<span class="number">1</span>] = <span class="number">2</span> <span class="comment">// This 'item' will be lost on the next iteration.</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Version B: Value of items: %v\n"</span>, items2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">Version A: Value of items: [<span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>] <span class="keyword">map</span>[<span class="number">1</span>:<span class="number">2</span>]]</span><br><span class="line">Version B: Value of items: [<span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[] <span class="keyword">map</span>[]]</span><br></pre></td></tr></table></figure>
<p>注意，应当像 A 版本那样通过索引使用切片的 map 元素。在 B 版本中获得的项只是 map 值的一个拷贝而已，所以真正的 map 元素没有得到初始化。  </p>
<h3 id="map-的排序"><a href="#map-的排序" class="headerlink" title="map 的排序"></a>map 的排序</h3><p>map 默认是无序的。<br>如要排序，要将 key（或 value）拷贝到一个切片，在对切片排序（<code>sort</code> 包），然后用切片的 for-range 方法打印 key 和 value。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    barVal = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"alpha"</span>: <span class="number">34</span>, <span class="string">"bravo"</span>: <span class="number">56</span>, <span class="string">"charlie"</span>: <span class="number">23</span>,</span><br><span class="line">                            <span class="string">"delta"</span>: <span class="number">87</span>, <span class="string">"echo"</span>: <span class="number">56</span>, <span class="string">"foxtrot"</span>: <span class="number">12</span>,</span><br><span class="line">                            <span class="string">"golf"</span>: <span class="number">34</span>, <span class="string">"hotel"</span>: <span class="number">16</span>, <span class="string">"indio"</span>: <span class="number">87</span>,</span><br><span class="line">                            <span class="string">"juliet"</span>: <span class="number">65</span>, <span class="string">"kili"</span>: <span class="number">43</span>, <span class="string">"lima"</span>: <span class="number">98</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"unsorted:"</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Key: %v, Value: %v / "</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    keys := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(barVal))</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k, _ := <span class="keyword">range</span> barVal &#123;</span><br><span class="line">        keys[i] = k</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(keys)</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Println(<span class="string">"sorted:"</span>)</span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Key: %v, Value: %v / "</span>, k, barVal[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要一个排序的列表，最好使用结构体切片，这样更有效：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span> &#123;</span><br><span class="line">    key <span class="keyword">string</span></span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a>指针</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"Hello World!"</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">string</span> = &amp;s</span><br></pre></td></tr></table></figure>
<p>为了防止内存溢出，Go 语言不允许指针算法（如： <code>pointer+2</code>），因此 <code>c = *p++</code> 是非法的。  </p>
<hr>
<h2 id="接口（Interfaces）与反射（reflection）"><a href="#接口（Interfaces）与反射（reflection）" class="headerlink" title="接口（Interfaces）与反射（reflection）"></a>接口（Interfaces）与反射（reflection）</h2><p>接口提供了一种方式来 <strong>说明</strong> 对象的行为：如果谁能搞定这件事，它就可以用在这儿。<br>接口定义了一组方法（方法集），但不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。  </p>
<p>定义接口的格式：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span>&#123;   <span class="comment">// namer 是一个接口类型</span></span><br><span class="line">    Method1(param_list) return_type</span><br><span class="line">    Method2(param_list) return_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按约定，只包含一个方法的接口的名字由方法名加 <code>[e]r</code> 后缀组成，如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code>、<code>Logger</code>、<code>Converter</code> 等。  </p>
<p>类型（如结构体）实现接口方法集中的方法，每个方法的实现说明了次方法是如何作用于该类型的： <strong>即实现接口</strong>，同时方法集也构成了该类型的接口。  </p>
<p><strong>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口</strong>。  </p>
<p><strong>实现某个接口的类型（除了实现接口方法外）可以有其他的方法</strong>。  </p>
<p><strong>一个类型可以实现多个接口</strong>。  </p>
<p><strong>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）</strong>。  </p>
<p>即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。  </p>
<p>所有这些特性使得接口具有很大的灵活性。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    areaIntf = sq1      <span class="comment">// 赋值给接口类型变量</span></span><br><span class="line">    <span class="comment">// or:</span></span><br><span class="line">    <span class="comment">// areaIntf := Shaper(sq1)</span></span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    <span class="comment">// areaIntf := sq1</span></span><br><span class="line">    fmt.Printf(<span class="string">"The square has area: %f\n"</span>, areaIntf.Area())</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">float32</span> = sq1.Area()</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 <strong>多态</strong> 的 Go 版本，多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    length, width <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.length * r.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    r := Rectangle&#123;<span class="number">5</span>, <span class="number">3</span>&#125; <span class="comment">// Area() of Rectangle needs a value</span></span><br><span class="line">    q := &amp;Square&#123;<span class="number">5</span>&#125;      <span class="comment">// Area() of Square needs a pointer</span></span><br><span class="line">    <span class="comment">// shapes := []Shaper&#123;Shaper(r), Shaper(q)&#125;</span></span><br><span class="line">    <span class="comment">// or shorter</span></span><br><span class="line">    shapes := []Shaper&#123;r, q&#125;</span><br><span class="line">    fmt.Println(<span class="string">"Looping through shapes for area ..."</span>)</span><br><span class="line">    <span class="keyword">for</span> n, _ := <span class="keyword">range</span> shapes &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Shape details: "</span>, shapes[n])</span><br><span class="line">        fmt.Println(<span class="string">"Area of this shape is: "</span>, shapes[n].Area())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口嵌套接口"><a href="#接口嵌套接口" class="headerlink" title="接口嵌套接口"></a>接口嵌套接口</h3><p>一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(b Buffer) <span class="keyword">bool</span></span><br><span class="line">    Write(b Buffer) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Lock <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadWrite</span><br><span class="line">    Lock</span><br><span class="line">    Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型断言：如何检测和转换接口变量的类型"><a href="#类型断言：如何检测和转换接口变量的类型" class="headerlink" title="类型断言：如何检测和转换接口变量的类型"></a>类型断言：如何检测和转换接口变量的类型</h3><p>一个接口类型的变量 <code>varI</code> 中可以包含任何类型的值，必须有一种方式来检测它的 <strong>动态</strong> 类型，即运行时在变量中存储的值的实际类型。通常我们可以使用 <strong>类型断言</strong> 来测试在某个时刻 <code>varI</code> 是否包含类型 <code>T</code> 的值：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := varI.(T)       <span class="comment">// unchecked type assertion</span></span><br></pre></td></tr></table></figure>
<p><strong>varI 必须是一个接口变量</strong>，否则编译器会报错：<code>invalid type assertion: varI.(T) (non-interface type (type of varI) on left)</code> 。  </p>
<p>类型断言可能是无效的，更安全的方式是使用以下形式来进行类型断言：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := varI.(T); ok &#123;  <span class="comment">// checked type assertion</span></span><br><span class="line">    Process(v)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// varI is not of type T</span></span><br></pre></td></tr></table></figure>
<p>如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；  </p>
<p>否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误(panic)发生。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line">    s := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    s, ok := i.(<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">    f, ok := i.(<span class="keyword">float64</span>)</span><br><span class="line">    fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">    f = i.(<span class="keyword">float64</span>) <span class="comment">// 报错(panic)</span></span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">hello</span><br><span class="line">hello <span class="literal">true</span></span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br><span class="line"><span class="built_in">panic</span>: <span class="keyword">interface</span> conversion: <span class="keyword">interface</span> &#123;&#125; is <span class="keyword">string</span>, not <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">    /tmp/sandbox319904390/main.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0x220</span></span><br></pre></td></tr></table></figure>


<p><strong>应该总是使用上面的方式来进行类型断言</strong>。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">    side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> areaIntf Shaper</span><br><span class="line">    sq1 := <span class="built_in">new</span>(Square)</span><br><span class="line">    sq1.side = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    areaIntf = sq1</span><br><span class="line">    <span class="comment">// Is Square the type of areaIntf?</span></span><br><span class="line">    <span class="keyword">if</span> t, ok := areaIntf.(*Square); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"The type of areaIntf is: %T\n"</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u, ok := areaIntf.(*Circle); ok &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"The type of areaIntf is: %T\n"</span>, u)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"areaIntf does not contain a variable of type Circle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ci *Circle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ci.radius * ci.radius * math.Pi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型判断（选择）：type-switch"><a href="#类型判断（选择）：type-switch" class="headerlink" title="类型判断（选择）：type-switch"></a>类型判断（选择）：type-switch</h3><p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type。</code>  </p>
<p>接口变量的类型也可以使用一种特殊形式的 <code>switch</code> 来检测：<strong>type-switch</strong> ：<br>eg1：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := areaIntf.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Square:</span><br><span class="line">    fmt.Printf(<span class="string">"Type Square %T with value %v\n"</span>, t, t)</span><br><span class="line"><span class="keyword">case</span> *Circle:</span><br><span class="line">    fmt.Printf(<span class="string">"Type Circle %T with value %v\n"</span>, t, t)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"nil value: nothing to check?\n"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"Unexpected type %T\n"</span>, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type Square *main.Square with value &amp;&#123;<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>eg2：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    do(<span class="number">21</span>)</span><br><span class="line">    do(<span class="string">"hello"</span>)</span><br><span class="line">    do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Twice <span class="number">21</span> is <span class="number">42</span></span><br><span class="line"><span class="string">"hello"</span> is <span class="number">5</span> bytes long</span><br><span class="line">I don<span class="string">'t know about type bool!</span></span><br></pre></td></tr></table></figure>
<p>变量 <code>t</code> 得到了 <code>areaIntf</code> 的值和类型， 所有 <code>case</code> 语句中列举的类型（<code>nil</code> 除外）都必须实现对应的接口（在上例中即 <code>Shaper</code>），如果被检测类型没有在 <code>case</code> 语句列举的类型中，就会执行 <code>default</code> 语句。  </p>
<p>可以用 <code>type-switch</code> 进行运行时类型分析，但是在 <code>type-switch</code> 不允许有 <code>fallthrough</code> 。  </p>
<p>如果仅仅是测试变量的类型，不用它的值，那么就可以不需要赋值语句，比如：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> areaIntf.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *Square:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line"><span class="keyword">case</span> *Circle:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码片段展示了一个类型分类函数，它有一个可变长度参数，可以是任意类型的数组，它会根据数组元素的实际类型执行不同的动作：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">classifier</span><span class="params">(items ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, x := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a bool\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a float64\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">int64</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a int\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a nil\n"</span>, i)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is a string\n"</span>, i)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"Param #%d is unknown\n"</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以这样调用此方法：<code>classifier(13, -14.3, &quot;BELGIUM&quot;, complex(1, 2), nil, false)</code> 。  </p>
<p>在处理来自于外部的、类型未知的数据时，比如解析诸如 JSON 或 XML 编码的数据，类型测试和转换会非常有用。  </p>
<h3 id="测试一个值是否实现了某个接口"><a href="#测试一个值是否实现了某个接口" class="headerlink" title="测试一个值是否实现了某个接口"></a>测试一个值是否实现了某个接口</h3><p>假定 <code>v</code> 是一个值，然后我们想测试它是否实现了 <code>Stringer</code> 接口，可以这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sv, ok := v.(Stringer); ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"v implements String(): %s\n"</span>, sv.String()) <span class="comment">// note: sv, not v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是<strong>多态的本质</strong>。  </p>
<p>编写参数是接口变量的函数，这使得它们更具有一般性。  </p>
<p><strong>使用接口使代码更具有普适性。</strong>  </p>
<h3 id="使用方法集与接口"><a href="#使用方法集与接口" class="headerlink" title="使用方法集与接口"></a>使用方法集与接口</h3><p>作用于变量上的方法实际上是不区分变量到底是指针还是值的。当碰到接口类型值时，这会变得有点复杂，原因是接口变量中存储的具体值是不可寻址的，幸运的是，如果使用不当编译器会给出错误。  </p>
<p><strong>总结</strong>  </p>
<p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 <code>P</code> 直接可以辨识的：  </p>
<ul>
<li>指针方法可以通过指针调用</li>
<li>值方法可以通过值调用</li>
<li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li>
<li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li>
</ul>
<p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。  </p>
<p><strong>译注</strong>  </p>
<p>Go 语言规范定义了接口方法集的调用规则：  </p>
<ul>
<li>类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集</li>
<li>类型 T 的可调用方法集包含接受者为 T 的所有方法</li>
<li>类型 T 的可调用方法集不包含接受者为 *T 的方法  </li>
</ul>
<h3 id="第一个例子：使用-Sorter-接口排序"><a href="#第一个例子：使用-Sorter-接口排序" class="headerlink" title="第一个例子：使用 Sorter 接口排序"></a>第一个例子：使用 Sorter 接口排序</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.7.md" target="_blank" rel="noopener">The way to go 参考内容</a>  </p>
<h3 id="第二个例子：读和写"><a href="#第二个例子：读和写" class="headerlink" title="第二个例子：读和写"></a>第二个例子：读和写</h3><p><code>io</code> 包提供了用于读和写的接口 <code>io.Reader</code> 和 <code>io.Writer</code>：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个对象要是可读的，它必须实现 <code>io.Reader</code> 接口，这个接口只有一个签名是 <code>Read(p []byte) (n int, err error)</code> 的方法，它从调用它的对象上读取数据，并把读到的数据放入参数中的字节切片中，然后返回读取的字节数和一个 <code>error</code> 对象，如果没有错误发生返回 <code>nil</code>，如果已经到达输入的尾端，会返回 <code>io.EOF(&quot;EOF&quot;)</code>，如果读取的过程中发生了错误，就会返回具体的错误信息。类似地，一个对象要是可写的，它必须实现 <code>io.Writer</code> 接口，这个接口也只有一个签名是 <code>Write(p []byte) (n int, err error)</code> 的方法，它将指定字节切片中的数据写入调用它的对象里，然后返回实际写入的字节数和一个 <code>error</code> 对象（如果没有错误发生就是 <code>nil</code>）。  </p>
<p><code>io</code> 包里的 <code>Readers</code> 和 <code>Writers</code> 都是不带缓冲的，<code>bufio</code> 包里提供了对应的带缓冲的操作，在读写 <code>UTF-8</code> 编码的文本文件时它们尤其有用。  </p>
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.8.md" target="_blank" rel="noopener">The way to go 参考内容</a>  </p>
<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p><strong>空接口或者最小接口</strong> 不包含任何方法，它对实现不做任何要求：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>任何其他类型都实现了空接口，<code>any</code> 或 <code>Any</code> 是空接口一个很好的别名或缩写。  </p>
<p>可以给一个空接口类型的变量 <code>var val interface {}</code> 赋任何类型的值。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"ABC"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> val Any</span><br><span class="line">    val = <span class="number">5</span></span><br><span class="line">    fmt.Printf(<span class="string">"val has the value: %v\n"</span>, val)</span><br><span class="line">    val = str</span><br><span class="line">    fmt.Printf(<span class="string">"val has the value: %v\n"</span>, val)</span><br><span class="line">    pers1 := <span class="built_in">new</span>(Person)</span><br><span class="line">    pers1.name = <span class="string">"Rob Pike"</span></span><br><span class="line">    pers1.age = <span class="number">55</span></span><br><span class="line">    val = pers1</span><br><span class="line">    fmt.Printf(<span class="string">"val has the value: %v\n"</span>, val)</span><br><span class="line">    <span class="keyword">switch</span> t := val.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Type int %T\n"</span>, t)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Type string %T\n"</span>, t)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Type boolean %T\n"</span>, t)</span><br><span class="line">    <span class="keyword">case</span> *Person:</span><br><span class="line">        fmt.Printf(<span class="string">"Type pointer to Person %T\n"</span>, t)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Unexpected type %T"</span>, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">val has the value: <span class="number">5</span></span><br><span class="line">val has the value: ABC</span><br><span class="line">val has the value: &amp;&#123;Rob Pike <span class="number">55</span>&#125;</span><br><span class="line">Type pointer to Person *main.Person</span><br></pre></td></tr></table></figure>
<p>空接口在 <code>type-switch</code> 中联合 <code>lambda</code> 函数的用法：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> specialString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> whatIsThis specialString = <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeSwitch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    testFunc := <span class="function"><span class="keyword">func</span><span class="params">(any <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> v := any.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is a bool type"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is an int type"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is a float32 type"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is a string type"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> specialString:</span><br><span class="line">            fmt.Printf(<span class="string">"any %v is a special String!"</span>, v)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"unknown type!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    testFunc(whatIsThis)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    TypeSwitch()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">any hello is a special String!</span><br></pre></td></tr></table></figure>
<h3 id="构建通用类型或包含不同类型变量的数组"><a href="#构建通用类型或包含不同类型变量的数组" class="headerlink" title="构建通用类型或包含不同类型变量的数组"></a>构建通用类型或包含不同类型变量的数组</h3><p>通过使用空接口。让我们给空接口定一个别名类型 <code>Element</code>：<code>type Element interface{}</code><br>然后定义一个容器类型的结构体 <code>Vector</code>，它包含一个 <code>Element</code> 类型元素的切片：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vector <span class="keyword">struct</span> &#123;</span><br><span class="line">    a []Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vector</code> 里能放任何类型的变量，因为任何类型都实现了空接口，实际上 <code>Vector</code> 里放的每个元素可以是不同类型的变量。我们为它定义一个 <code>At()</code> 方法用于返回第 <code>i</code> 个元素：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span> <span class="title">At</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">Element</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.a[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定一个 <code>Set()</code> 方法用于设置第 <code>i</code> 个元素的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Vector)</span> <span class="title">Set</span><span class="params">(i <span class="keyword">int</span>, e Element)</span></span> &#123;</span><br><span class="line">    p.a[i] = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vector</code> 中存储的所有元素都是 <code>Element</code> 类型，要得到它们的原始类型（unboxing：拆箱）需要用到类型断言。  </p>
<h3 id="复制数据切片至空接口切片"><a href="#复制数据切片至空接口切片" class="headerlink" title="复制数据切片至空接口切片"></a>复制数据切片至空接口切片</h3><p>假设你有一个 <code>myType</code> 类型的数据切片，你想将切片中的数据复制到一个空接口切片中，必须使用 <code>for-range</code> 语句来一个一个显式地复制：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSlice []myType = FuncReturnSlice()</span><br><span class="line"><span class="keyword">var</span> interfaceSlice []<span class="keyword">interface</span>&#123;&#125; = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(dataSlice))</span><br><span class="line"><span class="keyword">for</span> i, d := <span class="keyword">range</span> dataSlice &#123;</span><br><span class="line">    interfaceSlice[i] = d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通用类型的节点数据结构"><a href="#通用类型的节点数据结构" class="headerlink" title="通用类型的节点数据结构"></a>通用类型的节点数据结构</h3><p>[The way to Go 参考内容]（<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.9.md#1194-%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84）" target="_blank" rel="noopener">https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.9.md#1194-%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84）</a>  </p>
<h3 id="接口到接口"><a href="#接口到接口" class="headerlink" title="接口到接口"></a>接口到接口</h3><p>[The way to Go 参考内容]（<a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.9.md#1195-%E6%8E%A5%E5%8F%A3%E5%88%B0%E6%8E%A5%E5%8F%A3）" target="_blank" rel="noopener">https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.9.md#1195-%E6%8E%A5%E5%8F%A3%E5%88%B0%E6%8E%A5%E5%8F%A3）</a>  </p>
<h3 id="反射包"><a href="#反射包" class="headerlink" title="反射包"></a>反射包</h3><p>反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。反射可以在运行时检查类型和变量，例如它的大小、方法和 <code>动态</code><br>的调用这些方法。这对于没有源代码的包尤其有用。这是一个强大的工具，除非真得有必要，否则应当避免使用或小心使用。  </p>
<p>变量的最基本信息就是类型和值：反射包的 <code>Type</code> 用来表示一个 Go 类型，反射包的 <code>Value</code> 为 Go 值提供了反射接口。 </p>
<p>实际上，反射是通过检查一个接口的值，变量首先被转换成空接口:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Value</span></span></span><br></pre></td></tr></table></figure>

<p>reflect.Type 和 reflect.Value 都有许多方法用于检查和操作它们。一个重要的例子是 Value 有一个 Type 方法返回 reflect.Value 的 Type。另一个是 Type 和 Value 都有 Kind 方法返回一个常量来表示类型：Uint、Float64、Slice 等等。同样 Value 有叫做 Int 和 Float 的方法可以获取存储在内部的值（跟 int64 和 float64 一样）  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span></span><br><span class="line">    Bool</span><br><span class="line">    Int</span><br><span class="line">    Int8</span><br><span class="line">    Int16</span><br><span class="line">    Int32</span><br><span class="line">    Int64</span><br><span class="line">    Uint</span><br><span class="line">    Uint8</span><br><span class="line">    Uint16</span><br><span class="line">    Uint32</span><br><span class="line">    Uint64</span><br><span class="line">    Uintptr</span><br><span class="line">    Float32</span><br><span class="line">    Float64</span><br><span class="line">    Complex64</span><br><span class="line">    Complex128</span><br><span class="line">    Array</span><br><span class="line">    Chan</span><br><span class="line">    Func</span><br><span class="line">    Interface</span><br><span class="line">    Map</span><br><span class="line">    Ptr</span><br><span class="line">    Slice</span><br><span class="line">    String</span><br><span class="line">    Struct</span><br><span class="line">    UnsafePointer</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于 float64 类型的变量 x，如果 <code>v:=reflect.ValueOf(x)</code>，那么 <code>v.Kind()</code> 返回 <code>reflect.Float64</code> ，所以下面的表达式是 <code>true</code><br><code>v.Kind() == reflect.Float64</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kind 总是返回底层类型：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> m MyInt = <span class="number">5</span></span><br><span class="line">v := reflect.ValueOf(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法 `v.Kind()` 返回 `reflect.Int`。</span></span><br></pre></td></tr></table></figure>
<p>变量 v 的 <code>Interface()</code> 方法可以得到还原（接口）值，所以可以这样打印 v 的值：<code>fmt.Println(v.Interface())</code>  </p>
<p>eg.  </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var x float64 = <span class="number">3.4</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"type:"</span>, reflect.TypeOf(x))     <span class="comment">// type: float64</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"value:"</span>, v)                    <span class="comment">// value: 3.4</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"type:"</span>, v.Type())              <span class="comment">// type: float64</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"kind:"</span>, v.Kind())              <span class="comment">// kind: float64</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"value:"</span>, v.<span class="keyword">Float</span>())            <span class="comment">// value: 3.4</span></span><br><span class="line">    fmt.<span class="keyword">Println</span>(v.<span class="keyword">Interface</span>())                  <span class="comment">// 3.4</span></span><br><span class="line">    fmt.Printf(<span class="string">"value is %5.2e\n"</span>, v.<span class="keyword">Interface</span>())   <span class="comment">// value is 3.40e+00</span></span><br><span class="line">    y := v.<span class="keyword">Interface</span>().(float64)</span><br><span class="line">    fmt.<span class="keyword">Println</span>(y)                              <span class="comment">// 3.4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过反射修改（设置）值：</strong>  </p>
<p>假设我们要把 x 的值改为 3.1415。Value 有一些方法可以完成这个任务，但是必须小心使用：<code>v.SetFloat(3.1415)</code>。</p>
<p>这将产生一个错误：<code>reflect.Value.SetFloat using unaddressable value</code>。</p>
<p>问题的原因是 v 不是可设置的（这里并不是说值不可寻址）。是否可设置是 Value 的一个属性，并且不是所有的反射值都有这个属性：可以使用 <code>CanSet()</code> 方法测试是否可设置。</p>
<p>在例子中我们看到 <code>v.CanSet()</code> 返回 false： <code>settability of v: false</code></p>
<p>当 <code>v := reflect.ValueOf(x)</code> 函数通过传递一个 x 拷贝创建了 v，那么 v 的改变并不能更改原始的 x。要想 v 的更改能作用到 x，那就必须传递 x 的地址 <code>v = reflect.ValueOf(&amp;x)</code>。</p>
<p>通过 Type() 我们看到 v 现在的类型是 <code>*float64</code> 并且仍然是不可设置的。</p>
<p>要想让其可设置我们需要使用 <code>Elem()</code> 函数，这间接的使用指针：<code>v = v.Elem()</code></p>
<p>现在 <code>v.CanSet()</code> 返回 true 并且 <code>v.SetFloat(3.1415)</code> 设置成功了！</p>
<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">    v := reflect.ValueOf(x)</span><br><span class="line">    <span class="comment">// setting a value:</span></span><br><span class="line">    <span class="comment">// v.SetFloat(3.1415) // Error: will panic: reflect.Value.SetFloat using unaddressable value</span></span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())        <span class="comment">// settability of v: false</span></span><br><span class="line">    v = reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">    fmt.Println(<span class="string">"type of v:"</span>, v.Type())             <span class="comment">// type of v: *float64</span></span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())    <span class="comment">// settability of v: false</span></span><br><span class="line">    v = v.Elem()</span><br><span class="line">    fmt.Println(<span class="string">"The Elem of v is: "</span>, v)        <span class="comment">// The Elem of v is:  &lt;float64 Value&gt;</span></span><br><span class="line">    fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())    <span class="comment">// settability of v: true</span></span><br><span class="line">    v.SetFloat(<span class="number">3.1415</span>) <span class="comment">// this works!</span></span><br><span class="line">    fmt.Println(v.Interface())      <span class="comment">// 3.1415</span></span><br><span class="line">    fmt.Println(v)      <span class="comment">// &lt;float64 Value&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射中有些内容是需要用地址去改变它的状态的。  </p>
<p><strong>反射结构：</strong>  </p>
<p>有些时候需要反射一个结构类型。<code>NumField()</code> 方法返回结构内的字段数量；通过一个 for 循环用索引取得每个字段的值 <code>Field(i)</code>。  </p>
<p>我们同样能够调用签名在结构上的方法，例如，使用索引 n 来调用：<code>Method(n).Call(nil)</code>。  </p>
<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotknownType <span class="keyword">struct</span> &#123;</span><br><span class="line">    s1, s2, s3 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n NotknownType)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n.s1 + <span class="string">" - "</span> + n.s2 + <span class="string">" - "</span> + n.s3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// variable to investigate:</span></span><br><span class="line"><span class="keyword">var</span> secret <span class="keyword">interface</span>&#123;&#125; = NotknownType&#123;<span class="string">"Ada"</span>, <span class="string">"Go"</span>, <span class="string">"Oberon"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    value := reflect.ValueOf(secret) <span class="comment">// &lt;main.NotknownType Value&gt;</span></span><br><span class="line">    typ := reflect.TypeOf(secret)    <span class="comment">// main.NotknownType</span></span><br><span class="line">    <span class="comment">// alternative:</span></span><br><span class="line">    <span class="comment">//typ := value.Type()  // main.NotknownType</span></span><br><span class="line">    fmt.Println(typ)</span><br><span class="line">    knd := value.Kind() <span class="comment">// struct</span></span><br><span class="line">    fmt.Println(knd)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate through the fields of the struct:</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; value.NumField(); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Field %d: %v\n"</span>, i, value.Field(i))</span><br><span class="line">        <span class="comment">// error: panic: reflect.Value.SetString using value obtained using unexported field</span></span><br><span class="line">        <span class="comment">//value.Field(i).SetString("C#")</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call the first method, which is String():</span></span><br><span class="line">    results := value.Method(<span class="number">0</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(results) <span class="comment">// [Ada - Go - Oberon]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果尝试更改一个值，会得到一个错误：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: reflect.Value.SetString using value obtained using unexported field</span><br></pre></td></tr></table></figure>

<p>这是因为结构中只有被导出字段（首字母大写）才是可设置的  </p>
<p>eg2.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">    s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">    typeOfT := s.Type()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">        f := s.Field(i)</span><br><span class="line">        fmt.Printf(<span class="string">"%d: %s %s = %v\n"</span>, i,</span><br><span class="line">            typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">    &#125;</span><br><span class="line">    s.Field(<span class="number">0</span>).SetInt(<span class="number">77</span>)</span><br><span class="line">    s.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"t is now"</span>, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">0</span>: A <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line"><span class="number">1</span>: B <span class="keyword">string</span> = skidoo</span><br><span class="line">t is now &#123;<span class="number">77</span> Sunset Strip&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Printf-和反射"><a href="#Printf-和反射" class="headerlink" title="Printf 和反射"></a>Printf 和反射</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.11.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="接口与动态类型"><a href="#接口与动态类型" class="headerlink" title="接口与动态类型"></a>接口与动态类型</h3><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/11.12.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h3 id="总结：Go-中的面向对象"><a href="#总结：Go-中的面向对象" class="headerlink" title="总结：Go 中的面向对象"></a>总结：Go 中的面向对象</h3><p>Go 没有类，而是松耦合的类型、方法对接口的实现。  </p>
<p>OO 语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？  </p>
<ul>
<li><p>封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层（参见 4.2 节的可见性规则）:  </p>
<p>  1）包范围内的：通过标识符首字母小写，<code>对象</code> 只在它所在的包内可见  </p>
<p>  2）可导出的：通过标识符首字母大写，<code>对象</code> 对所在包以外也可见  </p>
</li>
</ul>
<p>类型只拥有自己所在包中定义的方法。  </p>
<ul>
<li>继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现  </li>
<li>多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。  </li>
</ul>
<hr>
<h1 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h1><h2 id="strings-包"><a href="#strings-包" class="headerlink" title="strings 包"></a><code>strings</code> 包</h2><p>Go 中使用 <code>strings</code> 包对字符串进行操作。  </p>
<h3 id="前、后缀"><a href="#前、后缀" class="headerlink" title="前、后缀"></a>前、后缀</h3><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasSuffix(s, suffix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h3><p><code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code> :  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Contains(s, substr <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<h3 id="索引字符串位置"><a href="#索引字符串位置" class="headerlink" title="索引字符串位置"></a>索引字符串位置</h3><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的第一次出现的索引（<code>str</code> 的第一个字符的索引），<br>返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Index(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p><code>LastIndex</code> 返回 <code>str</code> 在 <code>s</code> 中最后出现的所有（第一个字符），<br>返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.LastIndex(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>建议用 <code>IndexRune</code> 查询非 ASCII 编码的字符在字符串中的位置（返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：  ）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strings.IndexRune(s <span class="keyword">string</span>, r <span class="keyword">rune</span>) <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line">strings.IndexRune(<span class="string">"chicken"</span>, <span class="number">99</span>)</span><br><span class="line">strings.IndexRune(<span class="string">"chicken"</span>, <span class="keyword">rune</span>(<span class="string">'k'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并范围一个新的字符串，如果 <code>n = -1</code> 啧替换所有有 <code>old</code> 为 <code>new</code>：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Replace(str, old, <span class="built_in">new</span>, n) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h3 id="统计字符串出现的次数"><a href="#统计字符串出现的次数" class="headerlink" title="统计字符串出现的次数"></a>统计字符串出现的次数</h3><p><code>Count</code> 用于统计字符串 <code>str</code> 中字符串 <code>s</code> 出现的非重叠次数：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Count(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<h3 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h3><p><code>Repeat</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Repeat(s, count <span class="keyword">int</span>) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h3 id="修改字符串大小写"><a href="#修改字符串大小写" class="headerlink" title="修改字符串大小写"></a>修改字符串大小写</h3><p><code>ToLower</code> 讲字符串中的 Unicode 字符全部转换为相应的小写字符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Tolower(s) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p><code>ToUpper</code> 讲字符串中的 Unicode 字符全部转换为相应的大写字符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.ToUpper(s) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h3 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h3><p><code>strings.TrimSpace(s)</code> 用于剔除字符串开头和结尾的空白符号；<br><code>strings.Trim(s, &quot;cut&quot;)</code> 用于剔除字符串开头和结尾的 <code>cut</code>；<br><code>TrimLeft</code> 或者 <code>TrimRight</code> 用于只剔除开头或结尾的字符串。  </p>
<h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p><code>strings.Fields(s)</code> 会利用 1 个或多个空白符号来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的 slice。<br><code>strings.Split(s, sep)</code> 用于自定义分割符号来对指定字符串进行分割，同样范围 slice。<br>因为这 2 个函数都会返回 slice，所以习惯使用 for - range 循环来对其进行处理。  </p>
<h3 id="拼接-slice-到字符串"><a href="#拼接-slice-到字符串" class="headerlink" title="拼接 slice 到字符串"></a>拼接 slice 到字符串</h3><p><code>Join</code> 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Join(sl [<span class="keyword">string</span>], sep <span class="keyword">string</span>) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h3 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h3><p><code>strings.NewReader(str)</code> 用于生成一个 ‘Reader’ 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其他类型读取内容的函数还有：<br><code>Read</code> 从 []byte 中读取内容；<br><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 byte 或者 rune。  </p>
<p>其他有关字符串操作的文档参考 <a href="http://golang.org/pkg/strings/" target="_blank" rel="noopener">官方文档</a> 或 <a href="http://docs.studygolang.com/pkg/strings/" target="_blank" rel="noopener">国内访问文档</a>。</p>
<hr>
<h2 id="Strconv-包"><a href="#Strconv-包" class="headerlink" title="Strconv 包"></a><code>Strconv</code> 包</h2><p>与字符串相关的类型转换。<br>包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：<code>strconv.IntSize</code>。<br>任何类型 T 转换为字符串总是成功的。<br>数字 → 字符串：</p>
<ul>
<li><code>strconv.Itoa(i int) string</code> 返回数字 i 所表示的字符串类型的十进制数。  </li>
<li><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code> 将64位浮点型数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>b</code>、<code>e</code>、<code>f</code> 或 <code>g</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示 float32，用 64 表示 float64。  </li>
</ul>
<p>将字符串转换为其他类型 tp 并不总是可能的，可能会在运行时抛出错误 <code>parsing &quot;…&quot;: invalid argument</code>。<br>字符串 → 数字类型：  </p>
<ul>
<li><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 int 型。  </li>
<li><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 float64 型。  </li>
</ul>
<p>利用多个返回值的特性（第 1 个是转换后的结果（若成功），第 2 个是可能出现的错误），一般使用如下形式进行从字符串到其它类型的转换：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val, err = strconv.Atoi(s)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="time-包：时间和日期"><a href="#time-包：时间和日期" class="headerlink" title="time 包：时间和日期"></a><code>time</code> 包：时间和日期</h2><p><code>time</code> 包提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数。<br>获取当前时间：<code>time.Now()</code>；  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t time.Time = time.Now()</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">t := time.Now()</span><br></pre></td></tr></table></figure>
<p>获取时间的一部分： <code>t.Day</code>、<code>t.Minute()</code>…<br>自定义时间格式化字符串：eg.<code>fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>08.03.2019</code><br>Duration 类型表示两个连续时刻所相差的<strong>纳秒数</strong>，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。<br>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个t转换为相应格式的字符串，你可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println((t.Format(<span class="string">"02 Jan 2006 15:04"</span>)))</span><br></pre></td></tr></table></figure>
<p>如果需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 <code>time.After</code> 或者 <code>time.Ticker</code>。<br>另外，<code>time.Sleep(Duration d)</code> 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。<br>其他关于时间操作的文档参考 <a href="http://golang.org/pkg/time/" target="_blank" rel="noopener">官方文档</a> 或 <a href="http://docs.studygolang.com/pkg/time/" target="_blank" rel="noopener">国内访问页面</a>。  </p>
<hr>
<h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><h2 id="if-else-结构"><a href="#if-else-结构" class="headerlink" title="if-else 结构"></a>if-else 结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if</span></span><br><span class="line"><span class="keyword">if</span> condition&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else...</span></span><br><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些例子：  </p>
<ol>
<li>判断一个字符串是否为空：</li>
</ol>
<ul>
<li><code>if str == &quot;&quot; {...}</code></li>
<li><code>if len(str) == 0 {...}</code></li>
</ul>
<ol start="2">
<li>判断运行 Go 程序的操作系统类型，这可以通过常量 <code>runtime.GOOS</code> 来判断。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> runtime.GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这段代码一般被放在 init() 函数中执行。 如以下示例演示如何根据操作系统来决定输入结束时的提示：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> prompt = <span class="string">"Enter a digit, e.g. 3 "</span>+ <span class="string">"or %s to quit."</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> runtime.GOOS == <span class="string">"windows"</span> &#123;</span><br><span class="line">        prompt = fmt.Sprintf(prompt, <span class="string">"Ctrl+Z, Enter"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// Unix-like</span></span><br><span class="line">        prompt = fmt.Sprintf(prompt, <span class="string">"Ctrl+D"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数 <code>Abs()</code> 用于返回一个整型数字的绝对值：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>isGrater</code> 用来比较两个整型数字的大小：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isGreater</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
if 可以包含一个初始化语句（如：给变量赋值），初始化语句后方必须加分号：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> val := <span class="number">10</span>; val &gt; max &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意 <code>:=</code> 声明的变量作用于仅在 if 结构中。如果变量在 if 结构之前就已经存在，那么在 if 结构中该变量原来的值会被隐藏。  <h3 id="comma-ok模式（pattern）"><a href="#comma-ok模式（pattern）" class="headerlink" title="comma,ok模式（pattern）"></a>comma,ok模式（pattern）</h3>Go 语言中函数经常用两个返回值来表示是否执行成功：返回某个值以及 true 表示成功；返回零值（或 nil）和 false 表示失败。也可以使用 error 类型的变量来代替第二个返回值：成功执行的话，error 的值为 nil，否则就会包含相应的错误信息。  </li>
</ol>
<p><strong>习惯用法</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">value, err := pack1.Function1(param1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"An error occured in pack1.Function1 with parameter %v"</span>, param1)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未发生错误，继续执行：</span></span><br><span class="line"><span class="comment">// 由于本例的函数调用者属于 main 函数，所以程序会直接停止运行。</span></span><br></pre></td></tr></table></figure>
<p>如果要在错误发生的同时终止程序的运行，可以使用 <code>os</code> 包的 <code>Exit</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Program stopping with error %v"</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// （此处的退出代码 1 可以使用外部脚本获取到）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当没有错误发生时，代码继续运行就是唯一要做的事情，所以 if 语句块后面不需要使用 else 分支。  </p>
<h2 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line"><span class="keyword">case</span> val1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> val2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试多个可能符合条件的值，使用逗号分隔，例如： <code>case val1, val2, val3</code>。  </li>
<li>每个 <code>case</code> 分支都是唯一的，从上至下逐一测试，直到匹配为止。  </li>
<li>一旦成功匹配某个分支，在执行完相应代码后就会退出整个 switch 代码块，所以不用 <code>break</code>。  </li>
<li>如果执行完 <code>case</code> 后还需要继续执行后续分支的代码，要使用 <code>fallthrough</code>。  </li>
<li>可以用 <code>return</code> 语句来提前结束代码块的执行。（还要时刻确保函数始终有返回值，switch 后再添加相应 <code>return</code>）  </li>
<li><code>switch</code> 后也可不跟变量，<code>case</code> 后跟 condition，用起来像链式 if-else。  </li>
<li><code>switch</code> 后也可跟一个初始化语句，需要加分号 <code>;</code>。 </li>
</ul>
<h2 id="for-结构"><a href="#for-结构" class="headerlink" title="for 结构"></a>for 结构</h2><h3 id="计数器形式"><a href="#计数器形式" class="headerlink" title="计数器形式"></a>计数器形式</h3><p>基本形式：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始化语句; 条件语句; 修饰语句 &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特别注意，永远不要在循环体内修改计数器！  </li>
</ul>
<p>同时使用多个计数器：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, N; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件判断的迭代形式"><a href="#条件判断的迭代形式" class="headerlink" title="条件判断的迭代形式"></a>条件判断的迭代形式</h3><p>基本形式：<code>for 条件语句 {}</code>  </p>
<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>基本形式：<code>for {}</code>  </p>
<ul>
<li>需要循环内用 <code>break</code> 或 <code>return</code> 退出循环体。（<code>break</code> 只是退出循环体，<code>return</code> 是提前对函数进行返回，不会执行后续代码）  </li>
<li>无限循环的经典应用是服务器，用于<strong>不断等待</strong>和<strong>接受新的请求</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t, err = p.Token(); err == <span class="literal">nil</span>; t, err = p.Token() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-range-结构"><a href="#for-range-结构" class="headerlink" title="for-range 结构"></a>for-range 结构</h3>用于迭代任何一个集合（数组、map）。<br>一般形式：<code>for ix, val := range coll {...}</code>  </li>
<li>需要注意，val始终是集合中索引的值的拷贝，对它修改不会影响集合内原值（除非 <code>val</code> 为指针）。  </li>
<li>一个字符串是 Unicode 编码的字符（或称之为 <code>rune</code>）集合，因此可可以用它迭代字符串：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pos, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Break-与-continue"><a href="#Break-与-continue" class="headerlink" title="Break 与 continue"></a>Break 与 continue</h2></li>
<li>一个 break 的作用范围是该语句出现后的最内部的结构。（只会跳出最内层循环）  </li>
<li>关键词 continue 忽略剩余循环体直接进入下一次循环过程，执行下次循环前需要判断循环条件。  </li>
<li>continue 只能用于 for 循环中。  </li>
</ul>
<h2 id="标签与-goto"><a href="#标签与-goto" class="headerlink" title="标签与 goto"></a>标签与 goto</h2><ul>
<li>标签名称是大小写敏感的，一般建议全用大写字母。  </li>
<li>配合 goto 跳出多层循环或模拟循环。  </li>
<li>不鼓励使用标签和 goto，会导致糟糕的程序设计，可被更可读的方案替代。 </li>
<li>一定要用的话，只使用正序的标签（先 goto，后标签），且两者间不能出现新的定义变量语句！  </li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>Go 中不允许函数重载（function overloading，指可以编写多个同名函数）。  </li>
<li>如果需要声明一个在外部定义的函数，只要给出函数名与函数签名，不用给出函数体：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flushICache</span><span class="params">(begin, end <span class="keyword">uintptr</span>)</span>    // <span class="title">implemented</span> <span class="title">externally</span></span></span><br></pre></td></tr></table></figure></li>
<li>函数可以被作为类型来声明使用：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> binOp <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="传参和返回"><a href="#传参和返回" class="headerlink" title="传参和返回"></a>传参和返回</h2><ul>
<li>分按值传递（call by value） 按引用传递（call by reference）。  </li>
<li>几乎在任何情况下，传递指针的消耗比传递副本来的少。  </li>
<li>在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。</li>
<li>如果函数要返回四到五个值，可以传递一个切片给函数（如果返回值具有相同类型）或者是传递一个结构体（如果返回值具有不同的类型）。因为传递一个指针允许直接修改变量的值，消耗也更少。</li>
</ul>
<h2 id="传递变长参数"><a href="#传递变长参数" class="headerlink" title="传递变长参数"></a>传递变长参数</h2><ul>
<li>变参函数：函数最有一个参数采用 <code>...type</code> 的形式。函数接受某个类型的 slice 的参数。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(a, b, arg ...<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>解决边长参数不是相同类型的方法：（1）使用结构；（2）使用空接口。  </li>
</ul>
<h2 id="defer-和追踪"><a href="#defer-和追踪" class="headerlink" title="defer 和追踪"></a>defer 和追踪</h2><ul>
<li>关键词 defer 让我们推迟到函数返回之前（或任意位置执行 <code>return</code> 语句之后）一刻才执行某个语句或函数。  </li>
<li>defer 一般用于释放某些已分配的资源。</li>
<li>多个 defer 行为被注册，会逆序执行（类似栈），  </li>
<li>defer 允许我们进行一些函数执行完成后的收尾工作：（1）关闭文件流；（2）解锁一个加锁的资源；（3）打印最终报告；（4）关闭数据库连接。  </li>
<li>用 defer 实现代码追踪。</li>
<li>用 defer 记录函数的参数与返回值。</li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>不需要导入就可使用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>close</td>
<td>用于管道通信</td>
</tr>
<tr>
<td>len、cap len</td>
<td>用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）</td>
</tr>
<tr>
<td>new、make</td>
<td>new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作,new() 是一个函数，不要忘记它的括号</td>
</tr>
<tr>
<td>copy、append</td>
<td>用于复制和连接切片</td>
</tr>
<tr>
<td>panic、recover</td>
<td>两者均用于错误处理机制</td>
</tr>
<tr>
<td>print、println</td>
<td>底层打印函数，在部署环境中建议使用 fmt 包</td>
</tr>
<tr>
<td>complex、real imag</td>
<td>用于创建和操作复数</td>
</tr>
</tbody></table>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>经常遇到的问题是栈溢出：大量递归调用导致程序栈内存分配耗尽。可通过一个名为懒惰求值的技术解决，Go 中可以使用管道（channel）和 goroutine来实现。</p>
<h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>eg. 函数 <code>strings.IndexFunc()</code><br>其函数签名是 <code>func IndexFunc(s string, f func(c int) bool) int</code>，它的返回值是在函数 <code>f(c)</code> 返回 true、-1 或从未返回时的索引值。  </p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>不想给函数起名字时，可以用匿名函数，例如： <code>func(x, y int) int { return x + y }</code>。<br>匿名函数不能独立存在，要赋值给变量（即保存函数的地址到变量中）：<code>fplus := func(x, y int) int { return x + y }</code>,然后用变量名来调用：<code>fplus(3,4)</code>，或直接对匿名函数进行调用：<code>func(x, y int) int { return x + y }(3, 4)</code>。  </p>
<h3 id="defer语句和匿名函数"><a href="#defer语句和匿名函数" class="headerlink" title="defer语句和匿名函数"></a>defer语句和匿名函数</h3><p>两者经常搭配，可用于改变函数的命名返回值。<br>匿名函数还可以配合 <code>go</code> 关键字来作为 goroutine 使用。<br>匿名函数被称之为闭包：被允许调用定义在起环境下的变量。闭包可使得某个函数捕捉到一些外部状态，如：函数被创建时的状态。或者说：一个闭包继承了函数所声明时的作用域。这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。<br>闭包经常被用作包装函数：会预先定义好 1 个或多个参数以用于包装。<br>另一个应用是用闭包来完成更加简洁的错误检查。  </p>
<h2 id="应用闭包：将函数作为返回值"><a href="#应用闭包：将函数作为返回值" class="headerlink" title="应用闭包：将函数作为返回值"></a>应用闭包：将函数作为返回值</h2><ul>
<li>闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。  </li>
<li>闭包中使用到的变量可以是在闭包函数体内声明的，也可以是在外部函数声明的。  </li>
</ul>
<h2 id="使用闭包调试"><a href="#使用闭包调试" class="headerlink" title="使用闭包调试"></a>使用闭包调试</h2><p>调试时需要准确知道哪个文件中的具体哪个函数正在执行。可以使用 <code>runtime</code> 或 <code>log</code> 包中的特殊函数来实现这样的功能。包 runtime 中的函数 <code>Caller()</code> 提供了相应的信息，因此可以在需要的时候实现一个 <code>where()</code> 闭包函数来打印函数执行的位置：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">where := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, file, line, _ := runtime.Caller(<span class="number">1</span>)</span><br><span class="line">log.Printf(<span class="string">"%s:%d"</span>, file, line)</span><br><span class="line">&#125;</span><br><span class="line">where()</span><br><span class="line"><span class="comment">// some code</span></span><br><span class="line">where()</span><br><span class="line"><span class="comment">// some more code</span></span><br><span class="line">where()</span><br></pre></td></tr></table></figure>
<p>也可以设置 <code>log</code> 包中的 flag 参数来实现：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.SetFlags(log.Llongfile)</span><br><span class="line">log.Print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>或使用一个更加简短版本的 <code>where</code> 函数：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> where = log.Print</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    where()</span><br><span class="line">    ... some code</span><br><span class="line">    where()</span><br><span class="line">    ... some code</span><br><span class="line">    where()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计算函数执行时间"><a href="#计算函数执行时间" class="headerlink" title="计算函数执行时间"></a>计算函数执行时间</h2><p>在计算开始签设置一个起始时候，在计算结束时的结束时间，求差值。<br>可用 <code>time</code> 包中的 <code>Now()</code> 和 <code>Sub</code> 函数：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start := time.Now()</span><br><span class="line">longCalculation()</span><br><span class="line">end := time.Now()</span><br><span class="line">delta := end.Sub(start)</span><br><span class="line">fmt.Printf(<span class="string">"longCalculation took this amount of time: %s\n"</span>, delta)</span><br></pre></td></tr></table></figure>

<h2 id="通过内存缓存来提升性能"><a href="#通过内存缓存来提升性能" class="headerlink" title="通过内存缓存来提升性能"></a>通过内存缓存来提升性能</h2><p>大量计算式，提升性能最有效的一种方式是<strong>避免重复计算</strong>。通过在内存中缓存和重复利用相同计算的结果，成为内存缓存。<br>eg. 求斐波那契数列：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"time"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LIM = <span class="number">41</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fibs [LIM]<span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result <span class="keyword">uint64</span> = <span class="number">0</span></span><br><span class="line">        start := time.Now()</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; LIM; i++ &#123;</span><br><span class="line">            result = fibonacci(i)</span><br><span class="line">            fmt.Printf(<span class="string">"fibonacci(%d) is: %d\n"</span>, i, result)</span><br><span class="line">        &#125;</span><br><span class="line">        end := time.Now()</span><br><span class="line">        delta := end.Sub(start)</span><br><span class="line">        fmt.Printf(<span class="string">"longCalculation took this amount of time: %s\n"</span>, delta)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// memoization: check if fibonacci(n) is already known in array:</span></span><br><span class="line">        <span class="keyword">if</span> fibs[n] != <span class="number">0</span> &#123;</span><br><span class="line">            res = fibs[n]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fibs[n] = res</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h1><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>内置在 Go 语言中的，150 个以上。  </p>
<ul>
<li><code>unsafe</code>: 包含了一些打破 Go 语言“类型安全”的命令，一般的程序中不会被使用，可用在 C/C++ 程序的调用中。</li>
<li><code>syscall</code>-<code>os</code>-<code>os/exec</code>:  <ul>
<li><code>os</code>: 提供给我们一个平台无关性的操作系统功能接口，采用类Unix设计，隐藏了不同操作系统间差异，让不同的文件系统和操作系统对象表现一致。  </li>
<li><code>os/exec</code>: 提供我们运行外部操作系统命令和程序的方式。  </li>
<li><code>syscall</code>: 底层的外部包，提供了操作系统底层调用的基本接口。</li>
</ul>
</li>
<li><code>archive/tar</code> 和 <code>/zip-compress</code>：压缩(解压缩)文件功能。</li>
<li><code>fmt</code>-<code>io</code>-<code>bufio</code>-<code>path/filepath</code>-<code>flag</code>:  <ul>
<li><code>fmt</code>: 提供了格式化输入输出功能。  </li>
<li><code>io</code>: 提供了基本输入输出功能，大多数是围绕系统功能的封装。  </li>
<li><code>bufio</code>: 缓冲输入输出功能的封装。  </li>
<li><code>path/filepath</code>: 用来操作在当前系统中的目标文件名路径。  </li>
<li><code>flag</code>: 对命令行参数的操作。　　</li>
</ul>
</li>
<li><code>strings</code>-<code>strconv</code>-<code>unicode</code>-<code>regexp</code>-<code>bytes</code>:  <ul>
<li><code>strings</code>: 提供对字符串的操作。  </li>
<li><code>strconv</code>: 提供将字符串转换为基础类型的功能。</li>
<li><code>unicode</code>: 为 unicode 型的字符串提供特殊的功能。</li>
<li><code>regexp</code>: 正则表达式功能。  </li>
<li><code>bytes</code>: 提供对字符型分片的操作。  </li>
<li><code>index/suffixarray</code>: 子字符串快速查询。</li>
</ul>
</li>
<li><code>math</code>-<code>math/cmath</code>-<code>math/big</code>-<code>math/rand</code>-<code>sort</code>:  <ul>
<li><code>math</code>: 基本的数学函数。  </li>
<li><code>math/cmath</code>: 对复数的操作。  </li>
<li><code>math/rand</code>: 伪随机数生成。  </li>
<li><code>sort</code>: 为数组排序和自定义集合。  </li>
<li><code>math/big</code>: 大数的实现和计算。  　　</li>
</ul>
</li>
<li><code>container</code>-<code>/list-ring-heap</code>: 实现对集合的操作。  <ul>
<li><code>list</code>: 双链表。</li>
<li><code>ring</code>: 环形链表。</li>
</ul>
</li>
<li><code>time</code>-<code>log</code>:  <ul>
<li><code>time</code>: 日期和时间的基本操作。  </li>
<li><code>log</code>: 记录程序运行时产生的日志,我们将在后面的章节使用它。</li>
</ul>
</li>
<li><code>encoding/json</code>-<code>encoding/xml</code>-<code>text/template</code>:<ul>
<li><code>encoding/json</code>: 读取并解码和写入并编码 JSON 数据。  </li>
<li><code>encoding/xml</code>:简单的 XML1.0 解析器。  </li>
<li><code>text/template</code>:生成像 HTML 一样的数据与文本混合的数据驱动模板。  </li>
</ul>
</li>
<li><code>net</code>-<code>net/http</code>-<code>html</code><ul>
<li><code>net</code>: 网络数据的基本操作。  </li>
<li><code>http</code>: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复。  </li>
<li><code>html</code>: HTML5 解析器。  </li>
</ul>
</li>
<li><code>runtime</code>: Go 程序运行时的交互操作，例如垃圾回收和协程创建。  </li>
<li><code>reflect</code>: 实现通过程序运行时反射，让程序操作任意类型的变量。  </li>
</ul>
<p><code>exp</code> 包中有许多将被编译为新包的实验性的包。它们将成为独立的包在下次稳定版本发布的时候。如果前一个版本已经存在了，它们将被作为过时的包被回收。然而 Go1.0 发布的时候并不包含过时或者实验性的包。</p>
<h2 id="regexp-包"><a href="#regexp-包" class="headerlink" title="regexp 包"></a>regexp 包</h2><p>正则表达式语法和使用见 <a href="http://en.wikipedia.org/wiki/Regular_expression" target="_blank" rel="noopener">维基百科</a><br>简单模式，用 <code>Match</code> 方法即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok, _ := regexp.Match(pat, []<span class="keyword">byte</span>(searchIn))        <span class="comment">// ok 将返回 true 或 false</span></span><br></pre></td></tr></table></figure>
<p>也可以用 <code>MatchString</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok, _ := regexp.MatchString(pat, searchIn)</span><br></pre></td></tr></table></figure>
<p>更多方法中，必须先将正则通过 <code>Compile</code> 方法返回一个 Regexp 对象。<br><code>Compile</code> 函数也可能返回一个错误，我们在使用时忽略对错误的判断是因为我们确信自己正则表达式是有效的。当用户输入或从数据中获取正则表达式的时候，我们有必要去检验它的正确性。另外我们也可以使用 <code>MustCompile</code> 方法，它可以像 <code>Compile</code> 方法一样检验正则的有效性，但是当正则不合法时程序将 panic。  </p>
<h2 id="锁和-sync-包"><a href="#锁和-sync-包" class="headerlink" title="锁和 sync 包"></a>锁和 sync 包</h2><p>多个线程同时操作一个变量时，可能会出错，需要锁。 这种锁的机制是通过 sync 包中 Mutex 来实现的。sync 来源于 “synchronized” 一词，这意味着线程将有序的对同一变量进行访问。<br><code>sync.Mutex</code> 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;      <span class="comment">// 假设 info 是一个需要上锁的放在共享内存中的变量</span></span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    <span class="comment">// ... other fields, e.g.: Str string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个函数要改变这个变量：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Update</span><span class="params">(info *Info)</span></span> &#123;</span><br><span class="line">    info.mu.Lock()</span><br><span class="line">    <span class="comment">// critical section:</span></span><br><span class="line">    info.Str = <span class="comment">// new value</span></span><br><span class="line">    <span class="comment">// end critical section</span></span><br><span class="line">    info.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg. 实现一个可以上锁的共享缓冲器:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyncedBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    sync.Mutex</span><br><span class="line">    buffer  bytes.Buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 sync 包中还有一个 <code>RWMutex</code> 锁：他能通过 <code>RLock()</code> 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 <code>Lock()</code> 将和普通的 <code>Mutex</code> 作用相同。包中还有一个方便的 <code>Once</code> 类型变量的方法 <code>once.Do(call)</code>，这个方法确保被调用函数只能被调用一次。  </p>
<p>相对简单的情况下，通过使用 sync 包可以解决同一时间只能一个线程访问变量或 map 类型数据的问题。如果这种方式导致程序明显变慢或者引起其他问题，我们要重新思考来通过 goroutines 和 channels 来解决问题，这是在 Go 语言中所提倡用来实现并发的技术。我们将在第 14 章对其深入了解，并在第 14.7 节中对这两种方式进行比较。</p>
<h2 id="精密计算和-big-包"><a href="#精密计算和-big-包" class="headerlink" title="精密计算和 big 包"></a>精密计算和 big 包</h2><p>对于整数的高精度计算 Go 语言中提供了 big 包。其中包含了 math 包：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型（可以表示为 2/5 或 3.1416 这样的分数，而不是无理数或 π）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存和处理开销使它们使用起来要比内置的数字类型慢很多。</p>
<p>大的整型数字是通过 big.NewInt(n) 来构造的，其中 n 为 int64 类型整数。而大有理数是用过 big.NewRat(N,D) 方法构造。N（分子）和 D（分母）都是 int64 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 Add() 和 Mul() 这样的方法。它们作用于作为 receiver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 big.Int 类型的临时变量来存放中间结果，所以这样的运算可通过内存链式存储。</p>
<h2 id="自定义包和可见性"><a href="#自定义包和可见性" class="headerlink" title="自定义包和可见性"></a>自定义包和可见性</h2><p>当写自己包的时候，要使用短小的不含有 <code>_</code>(下划线)的小写单词来为文件命名。  </p>
<p>import 的一般格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"包的路径或 URL 地址"</span>   <span class="comment">// 路径指当前目录的相对路径</span></span><br><span class="line"><span class="comment">// eg.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./pack1/pack1"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"github.com/org1/pack1”</span></span><br></pre></td></tr></table></figure>

<p>Import with _ :pack1包只导入其副作用，也就是说，只执行它的init函数并初始化其中的全局变量。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"./pack1/pack1"</span></span><br></pre></td></tr></table></figure>

<p>导入外部安装包：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> install codesite.ext/author/goExample/goex   <span class="comment">// ←网址</span></span><br></pre></td></tr></table></figure>
<p>将一个名为 <code>codesite.ext/author/goExample/goex</code> 的 map 安装在 <code>$GOROOT/src/</code> 目录下。  </p>
<p>在 <code>http://golang.org/cmd/goinstall/</code> 的 <code>go install</code> 文档中列出了一些广泛被使用的托管在网络代码仓库的包的导入路径  </p>
<p><strong>包的初始化:</strong></p>
<p>程序的执行开始于导入包，初始化 main 包然后调用 main 函数。  </p>
<p>一个没有导入的包将通过分配初始值给所有的包级变量和调用源码中定义的包级 init 函数来初始化。一个包可能有多个 init 函数甚至在一个源码文件中。它们的执行是无序的。这是最好的例子来测定包的值是否只依赖于相同包下的其他值或者函数。  </p>
<p>init 函数是不能被调用的。  </p>
<p>导入的包在包自身初始化前被初始化，而一个包在程序执行中只能初始化一次。  </p>
<h2 id="为自定义包使用-godoc"><a href="#为自定义包使用-godoc" class="headerlink" title="为自定义包使用 godoc"></a>为自定义包使用 godoc</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.6.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="使用-go-install-安装自定义包"><a href="#使用-go-install-安装自定义包" class="headerlink" title="使用 go install 安装自定义包"></a>使用 go install 安装自定义包</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.7.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="自定义包的目录结构、go-install-和-go-test"><a href="#自定义包的目录结构、go-install-和-go-test" class="headerlink" title="自定义包的目录结构、go install 和 go test"></a>自定义包的目录结构、go install 和 go test</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.8.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="通过-Git-打包和安装"><a href="#通过-Git-打包和安装" class="headerlink" title="通过 Git 打包和安装"></a>通过 Git 打包和安装</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.9.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="Go-的外部包和项目"><a href="#Go-的外部包和项目" class="headerlink" title="Go 的外部包和项目"></a>Go 的外部包和项目</h2><p>着手自己 Go 项目前，最好查下是否有存在的第三方包或项目可使用。大多可通过 go install 安装。  </p>
<p><a href="https://gowalker.org" target="_blank" rel="noopener">Go Walker</a> 支持查询。  </p>
<p>目前已经有许多非常好的外部库，如：</p>
<ul>
<li>MySQL(GoMySQL), PostgreSQL(go-pgsql), MongoDB (mgo, gomongo), CouchDB (couch-go), ODBC (godbcl), Redis (redis.go) and SQLite3 (gosqlite) database drivers</li>
<li>SDL bindings</li>
<li>Google’s Protocal Buffers(goprotobuf)</li>
<li>XML-RPC(go-xmlrpc)</li>
<li>Twitter(twitterstream)</li>
<li>OAuth libraries(GoAuth)</li>
</ul>
<h2 id="在-Go-程序中使用外部库"><a href="#在-Go-程序中使用外部库" class="headerlink" title="在 Go 程序中使用外部库"></a>在 Go 程序中使用外部库</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.11.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<hr>
<h1 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h1><h2 id="读取用户的输入"><a href="#读取用户的输入" class="headerlink" title="读取用户的输入"></a>读取用户的输入</h2><p>读取用户的键盘（控制台）输入，从键盘和标准输入 <code>os.Stdin</code> 读取输入，最简单的办法是用 <code>fmt</code> 包提供的 Scan 和 Sscan 开头的函数：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    firstName, lastName, s <span class="keyword">string</span></span><br><span class="line">    i                      <span class="keyword">int</span></span><br><span class="line">    f                      <span class="keyword">float32</span></span><br><span class="line">    input                  = <span class="string">"56.12 / 5212 / Go"</span></span><br><span class="line">    format                 = <span class="string">"%f / %d / %s"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Please enter your full name:"</span>)</span><br><span class="line">    fmt.Scanln(&amp;firstName, &amp;lastName)</span><br><span class="line">    <span class="comment">// fmt.Scanf("%s %s", &amp;firstName, &amp;lastName)</span></span><br><span class="line">    fmt.Printf(<span class="string">"Hi %s %s\n"</span>, firstName, lastName)</span><br><span class="line">    fmt.Sscanf(input, format, &amp;f, &amp;i, &amp;s)</span><br><span class="line">    fmt.Println(<span class="string">"Frome the string we read:"</span>, f, i, s)</span><br><span class="line">    <span class="comment">// 输出结果: From the string we read: 56.12 5212 Go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Scanln</code> 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。<code>Scanf</code> 与其类似，除了 <code>Scanf</code> 的第一个参数用作格式字符串，用来决定如何读取。<code>Sscan</code> 和以 <code>Sscan</code> 开头的函数则是从字符串读取，除此之外，与 <code>Scanf</code> 相同。如果这些函数读取到的结果与您预想的不同，您可以检查成功读入数据的个数和返回的错误。  </p>
<p>也可以用 <code>bufio</code> 包提供的缓冲读取（buffered reader）来读取数据：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inputReader *bufio.Reader</span><br><span class="line"><span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputReader = bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println(<span class="string">"Please enter some input:"</span>)</span><br><span class="line">    input, err = inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"The input was: %s\n"</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inputReader</code> 是一个指向 <code>bufio.Reader</code> 的指针。<code>inputReader := bufio.NewReader(os.Stdin)</code> 这行代码，将会创建一个读取器，并将其与标准输入绑定。  </p>
<p><code>bufio.NewReader()</code> 构造函数的签名为：<code>func NewReader(rd io.Reader) *Reader</code>  </p>
<p>该函数的实参可以是满足 <code>io.Reader</code> 接口的任意对象（任意包含有适当的 <code>Read()</code> 方法的对象，请参考<a href="11.8.md">章节11.8</a>），函数返回一个新的带缓冲的 <code>io.Reader</code> 对象，它将从指定读取器（例如 <code>os.Stdin</code>）读取内容。  </p>
<p>返回的读取器对象提供一个方法 <code>ReadString(delim byte)</code>，该方法从输入中读取内容，直到碰到 <code>delim</code> 指定的字符，然后将读取到的内容连同 <code>delim</code> 字符一起放到缓冲区。  </p>
<p><code>ReadString</code> 返回读取到的字符串，如果碰到错误则返回 <code>nil</code>。如果它一直读到文件结束，则返回读取到的字符串和 <code>io.EOF</code>。如果读取过程中没有碰到 <code>delim</code> 字符，将返回错误 <code>err != nil</code>。  </p>
<p>在上面的例子中，我们会读取键盘输入，直到回车键（\n）被按下。  </p>
<p>屏幕是标准输出 <code>os.Stdout</code>；<code>os.Stderr</code> 用于显示错误信息，大多数情况下等同于 <code>os.Stdout</code>。  </p>
<p>一般情况下，我们会省略变量声明，而使用 <code>:=</code>，例如：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">input, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>第二个例子从键盘读取输入，使用了 <code>switch</code> 语句：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println(<span class="string">"Please enter your name:"</span>)</span><br><span class="line">    input, err := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"There were errors reading, exiting program."</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Your name is %s"</span>, input)</span><br><span class="line">    <span class="comment">// For Unix: test with delimiter "\n", for Windows: test with "\r\n"</span></span><br><span class="line">    <span class="keyword">switch</span> input &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Philip\r\n"</span>:  fmt.Println(<span class="string">"Welcome Philip!"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Chris\r\n"</span>:   fmt.Println(<span class="string">"Welcome Chris!"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Ivo\r\n"</span>:     fmt.Println(<span class="string">"Welcome Ivo!"</span>)</span><br><span class="line">    <span class="keyword">default</span>: fmt.Printf(<span class="string">"You are not welcome here! Goodbye!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// version 2:   </span></span><br><span class="line">    <span class="keyword">switch</span> input &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Philip\r\n"</span>:  <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Ivo\r\n"</span>:     <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Chris\r\n"</span>:   fmt.Printf(<span class="string">"Welcome %s\n"</span>, input)</span><br><span class="line">    <span class="keyword">default</span>: fmt.Printf(<span class="string">"You are not welcome here! Goodbye!\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// version 3:</span></span><br><span class="line">    <span class="keyword">switch</span> input &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Philip\r\n"</span>, <span class="string">"Ivo\r\n"</span>:   fmt.Printf(<span class="string">"Welcome %s\n"</span>, input)</span><br><span class="line">    <span class="keyword">default</span>: fmt.Printf(<span class="string">"You are not welcome here! Goodbye!\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>在 Go 语言中，文件使用指向 <code>os.File</code> 类型的指针来表示的，也叫做文件句柄。我们在前面章节使用到过标准输入 <code>os.Stdin</code> 和标准输出 <code>os.Stdout</code>，他们的类型都是 <code>*os.File</code>：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputFile, inputError := os.Open(<span class="string">"input.dat"</span>)</span><br><span class="line">    <span class="keyword">if</span> inputError != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred on opening the inputfile\n"</span> +</span><br><span class="line">            <span class="string">"Does the file exist?\n"</span> +</span><br><span class="line">            <span class="string">"Have you got acces to it?\n"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// exit the function on error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> inputFile.Close()</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(inputFile)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        inputString, readerError := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"The input was: %s"</span>, inputString)</span><br><span class="line">        <span class="keyword">if</span> readerError == io.EOF &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量 <code>inputFile</code> 是 <code>*os.File</code> 类型的。该类型是一个结构，表示一个打开文件的描述符（文件句柄）。然后，使用 <code>os</code> 包里的 <code>Open</code> 函数来打开一个文件。该函数的参数是文件名，类型为 <code>string</code>。在上面的程序中，我们以只读模式打开 <code>input.dat</code> 文件。  </p>
<p>如果文件不存在或者程序没有足够的权限打开这个文件，Open函数会返回一个错误：<code>inputFile, inputError = os.Open(&quot;input.dat&quot;)</code>。如果文件打开正常，我们就使用 <code>defer inputFile.Close()</code> 语句确保在程序退出前关闭该文件。然后，我们使用 <code>bufio.NewReader</code> 来获得一个读取器变量。  </p>
<p>通过使用 <code>bufio</code> 包提供的读取器（写入器也类似），如上面程序所示，我们可以很方便的操作相对高层的 string 对象，而避免了去操作比较底层的字节。  </p>
<p>接着，我们在一个无限循环中使用 <code>ReadString(&#39;\n&#39;)</code> 或 <code>ReadBytes(&#39;\n&#39;)</code> 将文件的内容逐行（行结束符 ‘\n’）读取出来。  </p>
<p><strong>注意：</strong> 在之前的例子中，我们看到，Unix和Linux的行结束符是 \n，而Windows的行结束符是 \r\n。在使用 <code>ReadString</code> 和 <code>ReadBytes</code> 方法的时候，我们不需要关心操作系统的类型，直接使用 \n 就可以了。另外，我们也可以使用 <code>ReadLine()</code> 方法来实现相同的功能。  </p>
<p>一旦读取到文件末尾，变量 <code>readerError</code> 的值将变成非空（事实上，常量 <code>io.EOF</code> 的值是 true），我们就会执行 <code>return</code> 语句从而退出循环。  </p>
<p><strong>其他类似函数：</strong>  </p>
<p><strong>1) 将整个文件的内容读到一个字符串里：</strong>  </p>
<p>如果您想这么做，可以使用 <code>io/ioutil</code> 包里的 <code>ioutil.ReadFile()</code> 方法，该方法第一个返回值的类型是 <code>[]byte</code>，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 nil。请看示例 12.5。类似的，函数 <code>WriteFile()</code> 可以将 <code>[]byte</code> 的值写入文件。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inputFile := <span class="string">"products.txt"</span></span><br><span class="line">    outputFile := <span class="string">"products_copy.txt"</span></span><br><span class="line">    buf, err := ioutil.ReadFile(inputFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"File Error: %s\n"</span>, err)</span><br><span class="line">        <span class="comment">// panic(err.Error())</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, <span class="keyword">string</span>(buf))</span><br><span class="line">    err = ioutil.WriteFile(outputFile, buf, <span class="number">0644</span>) <span class="comment">// oct, not hex</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2) 带缓冲的读取</strong>  </p>
<p>在很多情况下，文件的内容是不按行划分的，或者干脆就是一个二进制文件。在这种情况下，<code>ReadString()</code>就无法使用了，我们可以使用 <code>bufio.Reader</code> 的 <code>Read()</code>，它只接收一个参数：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">...</span><br><span class="line">n, err := inputReader.Read(buf)</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">break</span>&#125;</span><br></pre></td></tr></table></figure>

<p>变量 n 的值表示读取到的字节数.  </p>
<p><strong>3) 按列读取文件中的数据</strong>  </p>
<p>如果数据是按列排列并用空格分隔的，你可以使用 <code>fmt</code> 包提供的以 FScan 开头的一系列函数来读取他们。请看以下程序，我们将 3 列的数据分别读入变量 v1、v2 和 v3 内，然后分别把他们添加到切片的尾部。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"products2.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> col1, col2, col3 []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> v1, v2, v3 <span class="keyword">string</span></span><br><span class="line">        _, err := fmt.Fscanln(file, &amp;v1, &amp;v2, &amp;v3)</span><br><span class="line">        <span class="comment">// scans until newline</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        col1 = <span class="built_in">append</span>(col1, v1)</span><br><span class="line">        col2 = <span class="built_in">append</span>(col2, v2)</span><br><span class="line">        col3 = <span class="built_in">append</span>(col3, v3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(col1)</span><br><span class="line">    fmt.Println(col2)</span><br><span class="line">    fmt.Println(col3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：  </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ABC FUNC GO]</span><br><span class="line">[<span class="number">40</span> <span class="number">56</span> <span class="number">45</span>]</span><br><span class="line">[<span class="number">150</span> <span class="number">280</span> <span class="number">356</span>]</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>path</code> 包里包含一个子包叫 <code>filepath</code>，这个子包提供了跨平台的函数，用于处理文件名和路径。例如 Base() 函数用于获得路径中的最后一个元素（不包含后面的分隔符）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"path/filepath"</span></span><br><span class="line">filename := filepath.Base(path)</span><br></pre></td></tr></table></figure>

<h3 id="compress-包：读取压缩文件"><a href="#compress-包：读取压缩文件" class="headerlink" title="compress 包：读取压缩文件"></a><code>compress</code> 包：读取压缩文件</h3><p><code>compress</code>包提供了读取压缩文件的功能，支持的压缩文件格式为：bzip2、flate、gzip、lzw 和 zlib。  </p>
<p>下面的程序展示了如何读取一个 gzip 文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fName := <span class="string">"MyFile.gz"</span></span><br><span class="line">    <span class="keyword">var</span> r *bufio.Reader</span><br><span class="line">    fi, err := os.Open(fName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"%v, Can't open %s: error: %s\n"</span>, os.Args[<span class="number">0</span>], fName,</span><br><span class="line">            err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fi.Close()</span><br><span class="line">    fz, err := gzip.NewReader(fi)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        r = bufio.NewReader(fi)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = bufio.NewReader(fz)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        line, err := r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Done reading file"</span>)</span><br><span class="line">            os.Exit(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// var outputWriter *bufio.Writer</span></span><br><span class="line">    <span class="comment">// var outputFile *os.File</span></span><br><span class="line">    <span class="comment">// var outputError os.Error</span></span><br><span class="line">    <span class="comment">// var outputString string</span></span><br><span class="line">    outputFile, outputError := os.OpenFile(<span class="string">"output.dat"</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> outputError != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"An error occurred with file opening or creation\n"</span>)</span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outputFile.Close()</span><br><span class="line"></span><br><span class="line">    outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line">    outputString := <span class="string">"hello world!\n"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">        outputWriter.WriteString(outputString)</span><br><span class="line">    &#125;</span><br><span class="line">    outputWriter.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了文件句柄，我们还需要 <code>bufio</code> 的 <code>Writer</code>。我们以只写模式打开文件 <code>output.dat</code>，如果文件不存在则自动创建：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputFile, outputError := os.OpenFile(<span class="string">"output.dat"</span>, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>OpenFile</code> 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符“|”连接），使用的文件权限。  </p>
<p>我们通常会用到以下标志：  </p>
<ul>
<li><code>os.O_RDONLY</code>：只读  </li>
<li><code>os.O_WRONLY</code>：只写  </li>
<li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。  </li>
<li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为0。</li>
</ul>
<p>在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用0。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。  </p>
<p>然后，我们创建一个写入器（缓冲区）对象：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputWriter := bufio.NewWriter(outputFile)</span><br></pre></td></tr></table></figure>

<p>接着，使用一个 for 循环，将字符串写入缓冲区，写 10 次：<code>outputWriter.WriteString(outputString)</code>  </p>
<p>缓冲区的内容紧接着被完全写入文件：<code>outputWriter.Flush()</code>  </p>
<p>如果写入的东西很简单，我们可以使用 <code>fmt.Fprintf(outputFile, &quot;Some test data.\n&quot;)</code> 直接将内容写入文件。<code>fmt</code> 包里的 F 开头的 Print 函数可以直接写入任何 <code>io.Writer</code>，包括文件。  </p>
<p>程序 <code>filewrite.go</code> 展示了不使用 <code>fmt.FPrintf</code> 函数，使用其他函数如何写文件：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Stdout.WriteString(<span class="string">"hello, world\n"</span>)</span><br><span class="line">    f, _ := os.OpenFile(<span class="string">"test"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    f.WriteString(<span class="string">"hello, world in a file\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>os.Stdout.WriteString(&quot;hello, world\n&quot;)</code>，我们可以输出到屏幕。  </p>
<p>我们以只写模式创建或打开文件”test”，并且忽略了可能发生的错误：<code>f, _ := os.OpenFile(&quot;test&quot;, os.O_CREATE|os.O_WRONLY, 0666)</code>  </p>
<p>我们不使用缓冲区，直接将内容写入文件：<code>f.WriteString( )</code>  </p>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>用 <code>io</code> 包：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filecopy.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CopyFile(<span class="string">"target.txt"</span>, <span class="string">"source.txt"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Copy done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line">    src, err := os.Open(srcName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> src.Close()</span><br><span class="line"></span><br><span class="line">    dst, err := os.Create(dstName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> dst.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> io.Copy(dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>defer</code> 的使用：当打开目标文件时发生了错误，那么 <code>defer</code> 仍然能够确保 <code>src.Close()</code> 执行。如果不这么做，文件会一直保持打开状态并占用资源。</p>
<h2 id="从命令行读参数"><a href="#从命令行读参数" class="headerlink" title="从命令行读参数"></a>从命令行读参数</h2><h3 id="os-包"><a href="#os-包" class="headerlink" title="os 包"></a>os 包</h3><p>os 包中有一个 string 类型的切片变量 <code>os.Args</code>，用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数。来看下面的打招呼程序：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os_args.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    who := <span class="string">"Alice "</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        who += strings.Join(os.Args[<span class="number">1</span>:], <span class="string">" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Good Morning"</span>, who)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 IDE 或编辑器中直接运行这个程序输出：<code>Good Morning Alice</code>  </p>
<p>我们在命令行运行 <code>os_args or ./os_args</code> 会得到同样的结果。  </p>
<p>但是我们在命令行加入参数，像这样：<code>os_args John Bill Marc Luke</code>，将得到这样的输出：<code>Good Morning Alice John Bill Marc Luke</code>  </p>
<p>这个命令行参数会放置在切片 <code>os.Args[]</code> 中（以空格分隔），从索引1开始（<code>os.Args[0]</code> 放的是程序本身的名字，在本例中是 <code>os_args</code>）。函数 <code>strings.Join</code> 以空格为间隔连接这些参数。  </p>
<h3 id="flag-包"><a href="#flag-包" class="headerlink" title="flag 包"></a>flag 包</h3><p>flag 包有一个扩展功能用来解析命令行选项。但是通常被用来替换基本常量，例如，在某些情况下我们希望在命令行给常量一些不一样的值。  </p>
<p>在 flag 包中有一个 Flag 被定义成一个含有如下字段的结构体：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flag <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name     <span class="keyword">string</span> <span class="comment">// name as it appears on command line</span></span><br><span class="line">    Usage    <span class="keyword">string</span> <span class="comment">// help message</span></span><br><span class="line">    Value    Value  <span class="comment">// value as set</span></span><br><span class="line">    DefValue <span class="keyword">string</span> <span class="comment">// default value (as text); for usage message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟 Unix 的 echo 功能：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span> <span class="comment">// command line option parser</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> NewLine = flag.Bool(<span class="string">"n"</span>, <span class="literal">false</span>, <span class="string">"print newline"</span>) <span class="comment">// echo -n flag, of type *bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Space   = <span class="string">" "</span></span><br><span class="line">    Newline = <span class="string">"\n"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.PrintDefaults()</span><br><span class="line">    flag.Parse() <span class="comment">// Scans the arg list and sets up flags</span></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            s += <span class="string">" "</span></span><br><span class="line">            <span class="keyword">if</span> *NewLine &#123; <span class="comment">// -n is parsed, flag becomes true</span></span><br><span class="line">                s += Newline</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s += flag.Arg(i)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.WriteString(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flag.Parse()</code> 扫描参数列表（或者常量列表）并设置 flag, <code>flag.Arg(i)</code> 表示第i个参数。<code>Parse()</code> 之后 <code>flag.Arg(i)</code> 全部可用，<code>flag.Arg(0)</code> 就是第一个真实的 flag，而不是像 <code>os.Args(0)</code> 放置程序的名字。  </p>
<p><code>flag.Narg()</code> 返回参数的数量。解析后 flag 或常量就可用了。<br><code>flag.Bool()</code> 定义了一个默认值是 <code>false</code> 的 flag：当在命令行出现了第一个参数（这里是 “n”），flag 被设置成 <code>true</code>（NewLine 是 <code>*bool</code> 类型）。flag 被解引用到 <code>*NewLine</code>，所以当值是 <code>true</code> 时将添加一个 Newline（”\n”）。  </p>
<p><code>flag.PrintDefaults()</code> 打印 flag 的使用帮助信息，本例中打印的是：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n=<span class="literal">false</span>: <span class="built_in">print</span> newline</span><br></pre></td></tr></table></figure>

<p><code>flag.VisitAll(fn func(*Flag))</code> 是另一个有用的功能：按照字典顺序遍历 flag，并且对每个标签调用 fn   </p>
<p>当在命令行（Windows）中执行：<code>echo.exe A B C</code>，将输出：<code>A B C</code>；执行 <code>echo.exe -n A B C</code>，将输出：  </p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="keyword">B</span></span><br><span class="line"><span class="keyword">C</span></span><br></pre></td></tr></table></figure>

<p>每个字符的输出都新起一行，每次都在输出的数据前面打印使用帮助信息：<code>-n=false: print newline</code>。  </p>
<p>对于 <code>flag.Bool</code> 你可以设置布尔型 flag 来测试你的代码，例如定义一个 flag <code>processedFlag</code>:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> processedFlag = flag.Bool(<span class="string">"proc"</span>, <span class="literal">false</span>, <span class="string">"nothing processed yet"</span>)</span><br></pre></td></tr></table></figure>

<p>在后面用如下代码来测试：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> *processedFlag &#123; <span class="comment">// found flag -proc</span></span><br><span class="line">    r = process()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要给 flag 定义其它类型，可以使用 <code>flag.Int()</code>，<code>flag.Float64()</code>，<code>flag.String()</code>。  </p>
<h2 id="用-buffer-读取文件"><a href="#用-buffer-读取文件" class="headerlink" title="用 buffer 读取文件"></a>用 buffer 读取文件</h2><p>使用了缓冲读取文件和命令行 flag 解析这两项技术。如果不加参数，那么你输入什么屏幕就打印什么。  </p>
<p>参数被认为是文件名，如果文件存在的话就打印文件内容到屏幕。命令行执行 <code>cat test</code> 测试输出。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(r *bufio.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf, err := r.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(os.Stdout, <span class="string">"%s"</span>, buf)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    <span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line">        cat(bufio.NewReader(os.Stdin))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err := os.Open(flag.Arg(i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"%s:error reading from %s: %s\n"</span>, os.Args[<span class="number">0</span>], flag.Arg(i), err.Error())</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        cat(bufio.NewReader(f))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用切片读写文件"><a href="#用切片读写文件" class="headerlink" title="用切片读写文件"></a>用切片读写文件</h2><p>切片提供了 Go 中处理 I/O 缓冲的标准方式，下面 <code>cat</code> 函数的第二版中，在一个切片缓冲内使用无限 for 循环（直到文件尾部 EOF）读取文件，并写入到标准输出（<code>os.Stdout</code>）。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> NBUF = <span class="number">512</span></span><br><span class="line">    <span class="keyword">var</span> buf [NBUF]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> nr, err := f.Read(buf[:]); <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nr &lt; <span class="number">0</span>:</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"cat: error reading: %s\n"</span>, err.Error())</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">case</span> nr == <span class="number">0</span>: <span class="comment">// EOF</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> nr &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nw, ew := os.Stdout.Write(buf[<span class="number">0</span>:nr]); nw != nr &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">"cat: error writing: %s\n"</span>, ew.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码来自于 <code>cat2.go</code>，使用了 os 包中的 <code>os.File</code> 和 <code>Read</code> 方法；<code>cat2.go</code> 与 <code>cat.go</code> 具有同样的功能。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> NBUF = <span class="number">512</span></span><br><span class="line">    <span class="keyword">var</span> buf [NBUF]<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> nr, err := f.Read(buf[:]); <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> nr &lt; <span class="number">0</span>:</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"cat: error reading: %s\n"</span>, err.Error())</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">case</span> nr == <span class="number">0</span>: <span class="comment">// EOF</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> nr &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nw, ew := os.Stdout.Write(buf[<span class="number">0</span>:nr]); nw != nr &#123;</span><br><span class="line">                fmt.Fprintf(os.Stderr, <span class="string">"cat: error writing: %s\n"</span>, ew.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse() <span class="comment">// Scans the arg list and sets up flags</span></span><br><span class="line">    <span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line">        cat(os.Stdin)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err := os.Open(flag.Arg(i))</span><br><span class="line">        <span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"cat: can't open %s: error %s\n"</span>, flag.Arg(i), err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        cat(f)</span><br><span class="line">        f.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用-defer-关闭文件"><a href="#用-defer-关闭文件" class="headerlink" title="用 defer 关闭文件"></a>用 defer 关闭文件</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">data</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    f, _ := os.OpenFile(name, os.O_RDONLY, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// idiomatic Go code!</span></span><br><span class="line">    contents, _ := ioutil.ReadAll(f)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(contents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 return 后执行了 <code>f.Close()</code>  </p>
<h2 id="使用接口的实际例子：fmt-Fprintf"><a href="#使用接口的实际例子：fmt-Fprintf" class="headerlink" title="使用接口的实际例子：fmt.Fprintf"></a>使用接口的实际例子：fmt.Fprintf</h2><p>例子程序 <code>io_interfaces.go</code> 很好的阐述了 io 包中的接口概念:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interfaces being used in the GO-package fmt</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// unbuffered</span></span><br><span class="line">    fmt.Fprintf(os.Stdout, <span class="string">"%s\n"</span>, <span class="string">"hello world! - unbuffered"</span>)</span><br><span class="line">    <span class="comment">// buffered: os.Stdout implements io.Writer</span></span><br><span class="line">    buf := bufio.NewWriter(os.Stdout)</span><br><span class="line">    <span class="comment">// and now so does buf.</span></span><br><span class="line">    fmt.Fprintf(buf, <span class="string">"%s\n"</span>, <span class="string">"hello world! - buffered"</span>)</span><br><span class="line">    buf.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world! - unbuffered</span><br><span class="line">hello world! - buffered</span><br></pre></td></tr></table></figure>

<p><code>fmt.Fprintf()</code> 函数的实际签名:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>其不是写入一个文件，而是写入一个 <code>io.Writer</code> 接口类型的变量，下面是 <code>Writer</code> 接口在 io 包中的定义：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fmt.Fprintf()</code> 依据指定的格式向第一个参数内写入字符串，第一个参数必须实现了 <code>io.Writer</code> 接口。<code>Fprintf()</code> 能够写入任何类型，只要其实现了 <code>Write</code> 方法，包括 <code>os.Stdout</code>,文件（例如 os.File），管道，网络连接，通道等等，同样的也可以使用 bufio 包中缓冲写入。bufio 包中定义了 <code>type Writer struct{...}</code>。  </p>
<p>bufio.Writer 实现了 Write 方法：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(nn <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>它还有一个工厂函数：传给它一个 <code>io.Writer</code> 类型的参数，它会返回一个带缓冲的 <code>bufio.Writer</code> 类型的 <code>io.Writer</code>:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span> <span class="params">(b *Writer)</span></span></span><br></pre></td></tr></table></figure>

<p>其适合任何形式的缓冲写入。  </p>
<p>在缓冲写入的最后千万不要忘了使用 <code>Flush()</code>，否则最后的输出不会被写入。  </p>
<h2 id="JSON-数据格式"><a href="#JSON-数据格式" class="headerlink" title="JSON 数据格式"></a>JSON 数据格式</h2><p>数据结构要在网络中传输或保存到文件，就必须对其编码和解码；目前存在很多编码格式：JSON，XML，gob，Google 缓冲协议等等。Go 语言支持所有这些编码格式。  </p>
<p>术语说明：  </p>
<ul>
<li>数据结构 –&gt; 指定格式 = <code>序列化</code> 或 <code>编码</code>（传输之前）</li>
<li>指定格式 –&gt; 数据格式 = <code>反序列化</code> 或 <code>解码</code>（传输之后）</li>
</ul>
<p>序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure）  </p>
<p>编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。  </p>
<p>JSON 有时候是首选，由于其格式上非常简洁。通常 JSON 被用于 web 后端和浏览器之间的通讯，但是在其它场景也同样的有用。  </p>
<p>一个简短的 JSON 片段：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"Person"</span>: &#123;</span><br><span class="line">        <span class="string">"FirstName"</span>: <span class="string">"Laura"</span>,</span><br><span class="line">        <span class="string">"LastName"</span>: <span class="string">"Lynn"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Type    <span class="keyword">string</span></span><br><span class="line">    City    <span class="keyword">string</span></span><br><span class="line">    Country <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VCard <span class="keyword">struct</span> &#123;</span><br><span class="line">    FirstName <span class="keyword">string</span></span><br><span class="line">    LastName  <span class="keyword">string</span></span><br><span class="line">    Addresses []*Address</span><br><span class="line">    Remark    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pa := &amp;Address&#123;<span class="string">"private"</span>, <span class="string">"Aartselaar"</span>, <span class="string">"Belgium"</span>&#125;</span><br><span class="line">    wa := &amp;Address&#123;<span class="string">"work"</span>, <span class="string">"Boom"</span>, <span class="string">"Belgium"</span>&#125;</span><br><span class="line">    vc := VCard&#123;<span class="string">"Jan"</span>, <span class="string">"Kersschot"</span>, []*Address&#123;pa, wa&#125;, <span class="string">"none"</span>&#125;</span><br><span class="line">    <span class="comment">// fmt.Printf("%v: \n", vc) // &#123;Jan Kersschot [0x126d2b80 0x126d2be0] none&#125;:</span></span><br><span class="line">    <span class="comment">// JSON format:</span></span><br><span class="line">    js, _ := json.Marshal(vc)</span><br><span class="line">    fmt.Printf(<span class="string">"JSON format: %s"</span>, js)</span><br><span class="line">    <span class="comment">// using an encoder:</span></span><br><span class="line">    file, _ := os.OpenFile(<span class="string">"vcard.json"</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    enc := json.NewEncoder(file)</span><br><span class="line">    err := enc.Encode(vc)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">"Error in encoding json"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>json.Marshal()</code> 的函数签名是 <code>func Marshal(v interface{}) ([]byte, error)</code>，下面是数据编码后的 JSON 文本（实际上是一个 []byte）：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"FirstName"</span>: <span class="string">"Jan"</span>,</span><br><span class="line">    <span class="string">"LastName"</span>: <span class="string">"Kersschot"</span>,</span><br><span class="line">    <span class="string">"Addresses"</span>: [&#123;</span><br><span class="line">        <span class="string">"Type"</span>: <span class="string">"private"</span>,</span><br><span class="line">        <span class="string">"City"</span>: <span class="string">"Aartselaar"</span>,</span><br><span class="line">        <span class="string">"Country"</span>: <span class="string">"Belgium"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">"Type"</span>: <span class="string">"work"</span>,</span><br><span class="line">        <span class="string">"City"</span>: <span class="string">"Boom"</span>,</span><br><span class="line">        <span class="string">"Country"</span>: <span class="string">"Belgium"</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">"Remark"</span>: <span class="string">"none"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出于安全考虑，在 web 应用中最好使用 <code>json.MarshalforHTML()</code> 函数，其对数据执行HTML转码，所以文本可以被安全地嵌在 HTML <code>&lt;script&gt;</code> 标签中。  </p>
<p><code>json.NewEncoder()</code> 的函数签名是 <code>func NewEncoder(w io.Writer) *Encoder</code>，返回的Encoder类型的指针可调用方法 <code>Encode(v interface{})</code>，将数据对象 v 的json编码写入 <code>io.Writer</code> w 中。  </p>
<p>JSON 与 Go 类型对应如下：  </p>
<ul>
<li>bool 对应 JSON 的 booleans</li>
<li>float64 对应 JSON 的 numbers</li>
<li>string 对应 JSON 的 strings</li>
<li>nil 对应 JSON 的 null</li>
</ul>
<p>不是所有的数据都可以编码为 JSON 类型：只有验证通过的数据结构才能被编码：  </p>
<ul>
<li><p>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map[string]T（T是 <code>json</code> 包中支持的任何类型）</p>
</li>
<li><p>Channel，复杂类型和函数类型不能被编码</p>
</li>
<li><p>不支持循环数据结构；它将引起序列化进入一个无限循环</p>
</li>
<li><p>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</p>
<p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.9.md" target="_blank" rel="noopener">反序列化、解码任意的数据、解码数据到结构、编码和解码流 参见</a>  </p>
</li>
</ul>
<h2 id="XML-数据格式"><a href="#XML-数据格式" class="headerlink" title="XML 数据格式"></a>XML 数据格式</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.10.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="用-Gob-传输数据"><a href="#用-Gob-传输数据" class="headerlink" title="用 Gob 传输数据"></a>用 Gob 传输数据</h2><p>Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；可以在 <code>encoding</code> 包中找到。这种格式的数据简称为 Gob （即 Go binary 的缩写）。类似于 Python 的 “pickle” 和 Java 的 “Serialization”。<br><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.11.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="Go-中的密码学"><a href="#Go-中的密码学" class="headerlink" title="Go 中的密码学"></a>Go 中的密码学</h2><p>Go 为加密提供了超过 30 个包：  </p>
<ul>
<li><code>hash</code> 包：实现了 <code>adler32</code>、<code>crc32</code>、<code>crc64</code> 和 <code>fnv</code> 校验；</li>
<li><code>crypto</code> 包：实现了其它的 hash 算法，比如 <code>md4</code>、<code>md5</code>、<code>sha1</code> 等。以及完整地实现了 <code>aes</code>、<code>blowfish</code>、<code>rc4</code>、<code>rsa</code>、<code>xtea</code> 等加密算法。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hash_sha1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hasher := sha1.New()</span><br><span class="line">    io.WriteString(hasher, <span class="string">"test"</span>)</span><br><span class="line">    b := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Result: %x\n"</span>, hasher.Sum(b))</span><br><span class="line">    fmt.Printf(<span class="string">"Result: %d\n"</span>, hasher.Sum(b))</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    hasher.Reset()</span><br><span class="line">    data := []<span class="keyword">byte</span>(<span class="string">"We shall overcome!"</span>)</span><br><span class="line">    n, err := hasher.Write(data)</span><br><span class="line">    <span class="keyword">if</span> n!=<span class="built_in">len</span>(data) || err!=<span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">"Hash write error: %v / %v"</span>, n, err)</span><br><span class="line">    &#125;</span><br><span class="line">    checksum := hasher.Sum(b)</span><br><span class="line">    fmt.Printf(<span class="string">"Result: %x\n"</span>, checksum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Result: a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</span><br><span class="line">Result: [<span class="number">169</span> <span class="number">74</span> <span class="number">143</span> <span class="number">229</span> <span class="number">204</span> <span class="number">177</span> <span class="number">155</span> <span class="number">166</span> <span class="number">28</span> <span class="number">76</span> <span class="number">8</span> <span class="number">115</span> <span class="number">211</span> <span class="number">145</span> <span class="number">233</span> <span class="number">135</span> <span class="number">152</span> <span class="number">47</span> <span class="number">187</span> <span class="number">211</span>]</span><br><span class="line">Result: e2222bfc59850bbb00a722e764a555603bb59b2a</span><br></pre></td></tr></table></figure>
<p>通过调用 <code>sha1.New()</code> 创建了一个新的 <code>hash.Hash</code> 对象，用来计算 SHA1 校验值。<code>Hash</code> 类型实际上是一个接口，它实现了 <code>io.Writer</code> 接口：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hash <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Write (via the embedded io.Writer interface) adds more data to the running hash.</span></span><br><span class="line">    <span class="comment">// It never returns an error.</span></span><br><span class="line">    io.Writer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum appends the current hash to b and returns the resulting slice.</span></span><br><span class="line">    <span class="comment">// It does not change the underlying hash state.</span></span><br><span class="line">    Sum(b []<span class="keyword">byte</span>) []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset resets the Hash to its initial state.</span></span><br><span class="line">    Reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Size returns the number of bytes Sum will return.</span></span><br><span class="line">    Size() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlockSize returns the hash's underlying block size.</span></span><br><span class="line">    <span class="comment">// The Write method must be able to accept any amount</span></span><br><span class="line">    <span class="comment">// of data, but it may operate more efficiently if all writes</span></span><br><span class="line">    <span class="comment">// are a multiple of the block size.</span></span><br><span class="line">    BlockSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 io.WriteString 或 hasher.Write 将给定的 []byte 附加到当前的 <code>hash.Hash</code> 对象中。</p>
<h1 id="错误处理与测试"><a href="#错误处理与测试" class="headerlink" title="错误处理与测试"></a>错误处理与测试</h1><p><strong>永远不要忽略错误，否则可能会导致程序崩溃！！</strong>  </p>
<p><code>panic and recover</code> 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value, err := pack1.Func1(param1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Error %s in pack1.Func1 with parameter %v"</span>, err.Error(), param1)</span><br><span class="line">    <span class="keyword">return</span>    <span class="comment">// or: return err</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Process(value)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 <code>fmt.Printf</code> 还可以使用 log 中对应的方法，如果程序中止也没关系的话甚至可以使用 <code>panic</code>  </p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go 有一个预先定义的 error 接口类型  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序处于错误状态时可以用 <code>os.Exit(1)</code> 来中止运行。  </p>
<h3 id="定义错误"><a href="#定义错误" class="headerlink" title="定义错误"></a>定义错误</h3><p>用 <code>errors</code>（必须先 import）包的 <code>errors.New</code> 函数接收合适的错误信息来创建：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">"math - square root of negative number"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errNotFound error = errors.New(<span class="string">"Not found error"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"error: %v"</span>, errNotFound)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error: Not found error</span></span><br></pre></td></tr></table></figure>
<p>用于计算平方根函数的参数测试：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New (<span class="string">"math - square root of negative number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// implementation of Sqrt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := Sqrt(<span class="number">-1</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Error: %s\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 fmt.Printf 会自动调用 String() 方法 （参见 10.7 节），所以错误信息 “Error: math - square root of negative number” 会打印出来。通常（错误信息）都会有像 “Error:” 这样的前缀，所以你的错误信息不要以大写字母开头。  </p>
<p>有不同错误条件可能发生，那么对实际的错误使用类型断言或类型判断（type-switch）是很有用的，并且可以根据错误场景做一些补救和恢复操作。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PathError records an error and the operation and file path that caused it.</span></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op <span class="keyword">string</span>    <span class="comment">// "open", "unlink", etc.</span></span><br><span class="line">    Path <span class="keyword">string</span>  <span class="comment">// The associated file.</span></span><br><span class="line">    Err error  <span class="comment">// Returned by the system call.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">" "</span> + e.Path + <span class="string">": "</span>+ e.Err.Error()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  err != nil</span></span><br><span class="line"><span class="keyword">if</span> e, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">    <span class="comment">// remedy situation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> err := err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> ParseError:</span><br><span class="line">        PrintParseError(err)</span><br><span class="line">    <span class="keyword">case</span> PathError:</span><br><span class="line">        PrintPathError(err)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"Not a special error, just %s\n"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：当 json.Decode 在解析 JSON 文档发生语法错误时，指定返回一个 SyntaxError 类型的错误：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="keyword">string</span> <span class="comment">// description of error</span></span><br><span class="line"><span class="comment">// error occurred after reading Offset bytes, from which line and columnnr can be obtained</span></span><br><span class="line">    Offset <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure>
<p>在调用代码中你可以像这样用类型断言测试错误是不是上面的类型：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> serr, ok := err.(*json.SyntaxError); ok &#123;</span><br><span class="line">    line, col := findLine(f, serr.Offset)</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"%s:%d:%d: %v"</span>, f.Name(), line, col, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包也可以用额外的方法（methods）定义特定的错误，比如 net.Error：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net</span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Timeout() <span class="keyword">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="keyword">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遵循同一种命名规范：错误类型以 “Error” 结尾，错误变量以 “err” 或 “Err” 开头。  </p>
<h3 id="用-fmt-创建错误对象"><a href="#用-fmt-创建错误对象" class="headerlink" title="用 fmt 创建错误对象"></a>用 fmt 创建错误对象</h3><p>可以用 <code>fmt.Errorf()</code> 来实现：它和 <code>fmt.Printf()</code> 完全一样，接收一个或多个格式占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"math: square root of negative number %g"</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子2：从命令行读取输入时，如果加了 help 标志，我们可以用有用的信息产生一个错误：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; (os.Args[<span class="number">1</span>] == <span class="string">"-h"</span> || os.Args[<span class="number">1</span>] == <span class="string">"--help"</span>) &#123;</span><br><span class="line">    err = fmt.Errorf(<span class="string">"usage: %s infile.txt outfile.txt"</span>, filepath.Base(os.Args[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行时异常和-panic"><a href="#运行时异常和-panic" class="headerlink" title="运行时异常和 panic"></a>运行时异常和 panic</h2><p>当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发<em>运行时 panic</em>，伴随着程序的崩溃抛出一个 <code>runtime.Error</code> 接口类型的值。这个错误值有个 <code>RuntimeError()</code> 方法用于区别普通错误。  </p>
<p><code>panic</code> 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 <code>panic</code> 函数产生一个中止程序的运行时错误。<code>panic</code> 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Starting the program"</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"A severe error occurred: stopping the program!"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Ending the program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Starting the program</span><br><span class="line"><span class="string">panic:</span> A severe error <span class="string">occurred:</span> stopping the program!</span><br><span class="line">panic PC=<span class="number">0x4f3038</span></span><br><span class="line">runtime.panic+<span class="number">0x99</span> <span class="regexp">/go/</span>src<span class="regexp">/pkg/</span>runtime/proc.<span class="string">c:</span><span class="number">1032</span></span><br><span class="line">       runtime.panic(<span class="number">0x442938</span>, <span class="number">0x4f08e8</span>)</span><br><span class="line">main.main+<span class="number">0xa5</span> <span class="string">E:</span><span class="regexp">/Go/</span>GoBoek<span class="regexp">/code examples/</span>chapter <span class="number">13</span>/panic.<span class="string">go:</span><span class="number">8</span></span><br><span class="line">       main.main()</span><br><span class="line">runtime.mainstart+<span class="number">0xf</span> <span class="number">386</span>/asm.<span class="string">s:</span><span class="number">84</span></span><br><span class="line">       runtime.mainstart()</span><br><span class="line">runtime.goexit <span class="regexp">/go/</span>src<span class="regexp">/pkg/</span>runtime/proc.<span class="string">c:</span><span class="number">148</span></span><br><span class="line">       runtime.goexit()</span><br><span class="line">---- Error run <span class="string">E:</span><span class="regexp">/Go/</span>GoBoek<span class="regexp">/code examples/</span>chapter <span class="number">13</span>/panic.exe with code Crashed</span><br><span class="line">---- Program exited with code <span class="number">-1073741783</span></span><br></pre></td></tr></table></figure>
<p>一个检查程序是否被已知用户启动的具体例子：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">"USER"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"Unknown user: no value for $USER"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在导入包的 init() 函数中检查这些。  </p>
<p>当发生错误必须中止程序时，<code>panic</code> 可以用于错误处理模式：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"ERROR occurred:"</span> + err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Go panicking</strong>：  </p>
<p>在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 <em>panicking</em>。  </p>
<p>标准库中有许多包含 <code>Must</code> 前缀的函数，像 <code>regexp.MustComplie</code> 和 <code>template.Must</code>；当正则表达式或模板中转入的转换字符串导致错误时，这些函数会 panic。  </p>
<p>不能随意地用 panic 中止程序，必须尽力补救错误让程序能继续执行。  </p>
<h2 id="从-panic-中恢复（Recover）"><a href="#从-panic-中恢复（Recover）" class="headerlink" title="从 panic 中恢复（Recover）"></a>从 panic 中恢复（Recover）</h2><p>这个（recover）内建函数被用于从 panic 或 错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。  </p>
<p><code>recover</code> 只能在 defer 修饰的函数中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 <code>recover</code> 会返回 nil，且没有其它效果。  </p>
<p>总结：panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protect</span><span class="params">(g <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">"done"</span>)</span><br><span class="line">        <span class="comment">// Println executes normally even if there is a panic</span></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"run time panic: %v"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    log.Println(<span class="string">"start"</span>)</span><br><span class="line">    g() <span class="comment">//   possible runtime-error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>log 包实现了简单的日志功能：默认的 log 对象向标准错误输出中写入并打印每条日志信息的日期和时间。除了 <code>Println</code> 和 <code>Printf</code> 函数，其它的致命性函数都会在写完日志信息后调用 os.Exit(1)，那些退出函数也是如此。而 Panic 效果的函数会在写完日志信息后调用 panic；可以在程序必须中止或发生了临界错误时使用它们，就像当 web 服务器不能启动时那样。  </p>
<p>一个展示 panic，defer 和 recover 怎么结合使用的完整例子：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// panic_recover.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">badCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"bad end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Panicing %s\r\n"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    badCall()</span><br><span class="line">    fmt.Printf(<span class="string">"After bad call\r\n"</span>) <span class="comment">// &lt;-- wordt niet bereikt</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Calling test\r\n"</span>)</span><br><span class="line">    test()</span><br><span class="line">    fmt.Printf(<span class="string">"Test completed\r\n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calling test</span><br><span class="line">Panicing bad end</span><br><span class="line"><span class="keyword">Test </span>completed</span><br></pre></td></tr></table></figure>

<h2 id="自定义包中的错误处理和-panicking"><a href="#自定义包中的错误处理和-panicking" class="headerlink" title="自定义包中的错误处理和 panicking"></a>自定义包中的错误处理和 panicking</h2><p>这是所有自定义包实现者应该遵守的最佳实践：  </p>
<p>1）<em>在包内部，总是应该从 panic 中 recover</em>：不允许显式的超出包范围的 panic()  </p>
<p>2）<em>向包的调用者返回错误值（而不是 panic）。</em>  </p>
<h2 id="一种用闭包处理错误的模式"><a href="#一种用闭包处理错误的模式" class="headerlink" title="一种用闭包处理错误的模式"></a>一种用闭包处理错误的模式</h2><p>模式中使用了两个帮助函数：<br>1）check：这是用来检查是否有错误和 panic 发生的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(err error)</span></span> &#123; <span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="built_in">panic</span>(err) &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>2）errorhandler：这是一个包装函数。接收一个 fType1 类型的函数 fn 并返回一个调用 fn 的函数。里面就包含有 defer/recover 机制，这在 <a href="13.3.md">13.3 节</a>中有相应描述。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorHandler</span><span class="params">(fn fType1)</span> <span class="title">fType1</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(a type1, b type2)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err, ok := <span class="built_in">recover</span>().(error); ok &#123;</span><br><span class="line">                log.Printf(<span class="string">"run time panic: %v"</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">        fn(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动外部命令和程序"><a href="#启动外部命令和程序" class="headerlink" title="启动外部命令和程序"></a>启动外部命令和程序</h2><p>os 包有一个 <code>StartProcess</code> 函数可以调用或启动外部系统命令和二进制可执行文件；它的第一个参数是要运行的进程，第二个参数用来传递选项或参数，第三个参数是含有系统环境基本信息的结构体。  </p>
<p>这个函数返回被启动进程的 id（pid），或者启动失败返回错误。  </p>
<p>exec 包中也有同样功能的更简单的结构体和函数；主要是 <code>exec.Command(name string, arg ...string)</code> 和 <code>Run()</code>。首先需要用系统命令或可执行文件的名字创建一个 <code>Command</code> 对象，然后用这个对象作为接收者调用 <code>Run()</code>。  </p>
<h2 id="Go-中的单元测试和基准测试"><a href="#Go-中的单元测试和基准测试" class="headerlink" title="Go 中的单元测试和基准测试"></a>Go 中的单元测试和基准测试</h2><p><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.7.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<p>测试的具体例子：<br><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.8.md" target="_blank" rel="noopener">The way to Go 参考内容</a>   </p>
<p>用（测试数据）表驱动测试：<br> <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.9.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<h2 id="性能调试：分析并优化-Go-程序"><a href="#性能调试：分析并优化-Go-程序" class="headerlink" title="性能调试：分析并优化 Go 程序"></a>性能调试：分析并优化 Go 程序</h2><p> 时间和内存消耗、用 go test 调试、用 pprof 调试： <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.10.md" target="_blank" rel="noopener">The way to Go 参考内容</a>  </p>
<hr>
<h1 id="协程（goroutine）与通道（channel）"><a href="#协程（goroutine）与通道（channel）" class="headerlink" title="协程（goroutine）与通道（channel）"></a>协程（goroutine）与通道（channel）</h1><p> <strong>不要通过共享内存来通信，而通过通信来共享内存。</strong>  </p>
<h2 id="并发、并行和协程"><a href="#并发、并行和协程" class="headerlink" title="并发、并行和协程"></a>并发、并行和协程</h2><p> 在 Go 中，应用程序并发处理的部分被称作 <code>goroutines（协程）</code>。  </p>
<p> Go 使用 <code>channels</code> 来同步协程。  </p>
<p> 协程是通过使用关键字 go 调用（执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：<code>go sum(bigArray)</code>，在后台计算总和。  </p>
<p>协程的栈会根据需要进行伸缩，不出现栈溢出；开发者不需要关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数不会得到任何的返回值。  </p>
<p>在一个协程中，比如它需要进行非常密集的运算，你可以在运算循环中周期的使用 runtime.Gosched()：这会让出处理器，允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。使用 Gosched() 可以使计算均匀分布，使通信不至于迟迟得不到响应。  </p>
<h3 id="并发和并行的差异"><a href="#并发和并行的差异" class="headerlink" title="并发和并行的差异"></a>并发和并行的差异</h3><p>Go 的并发原语提供了良好的并发设计基础：表达程序结构以便表示独立地执行的动作。  </p>
<p>在当前的运行时（2012 年一月）实现中，Go 默认没有并行指令，只有一个独立的核心或处理器被专门用于 Go 程序，不论它启动了多少个协程；所以这些协程是并发运行的，但他们不是并行运行的：同一时间只有一个协程会处在运行状态。  </p>
<h3 id="使用-GOMAXPROCS"><a href="#使用-GOMAXPROCS" class="headerlink" title="使用 GOMAXPROCS"></a>使用 GOMAXPROCS</h3><p>在 gc 编译器下（6g 或者 8g）你必须设置 GOMAXPROCS 为一个大于默认值 1 的数值来允许运行时支持使用多于 1 个的操作系统线程，所有的协程都会共享同一个线程除非将 GOMAXPROCS 设置为一个大于 1 的数。当 GOMAXPROCS 大于 1 时，会有一个线程池管理许多的线程。通过 gccgo 编译器 GOMAXPROCS 有效的与运行中的协程数量相等。假设 n 是机器上处理器或者核心的数量。如果你设置环境变量 GOMAXPROCS&gt;=n，或者执行 runtime.GOMAXPROCS(n)，接下来协程会被分割（分散）到 n 个处理器上。更多的处理器并不意味着性能的线性提升。有这样一个经验法则，对于 n 个核心的情况设置 GOMAXPROCS 为 n-1 以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1 + GOMAXPROCS &gt; 1。</p>
<p>所以如果在某一时间只有一个协程在执行，不要设置 GOMAXPROCS！  </p>
<p>总结：GOMAXPROCS 等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行。  </p>
<h3 id="如何用命令行指定使用的核心数量"><a href="#如何用命令行指定使用的核心数量" class="headerlink" title="如何用命令行指定使用的核心数量"></a>如何用命令行指定使用的核心数量</h3><p>使用 <code>flags</code> 包，如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numCores = flag.Int(<span class="string">"n"</span>, <span class="number">2</span>, <span class="string">"number of CPU cores to use"</span>)</span><br><span class="line"></span><br><span class="line">in main()</span><br><span class="line">flag.Parse()</span><br><span class="line">runtime.GOMAXPROCS(*numCores)</span><br></pre></td></tr></table></figure>

<p>协程可以通过调用<code>runtime.Goexit()</code>来停止，尽管这样做几乎没有必要。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"In main()"</span>)</span><br><span class="line">    <span class="keyword">go</span> longWait()</span><br><span class="line">    <span class="keyword">go</span> shortWait()</span><br><span class="line">    fmt.Println(<span class="string">"About to sleep in main()"</span>)</span><br><span class="line">    <span class="comment">// sleep works with a Duration in nanoseconds (ns) !</span></span><br><span class="line">    time.Sleep(<span class="number">10</span> * <span class="number">1e9</span>)</span><br><span class="line">    fmt.Println(<span class="string">"At the end of main()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longWait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Beginning longWait()"</span>)</span><br><span class="line">    time.Sleep(<span class="number">5</span> * <span class="number">1e9</span>) <span class="comment">// sleep for 5 seconds</span></span><br><span class="line">    fmt.Println(<span class="string">"End of longWait()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortWait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Beginning shortWait()"</span>)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>) <span class="comment">// sleep for 2 seconds</span></span><br><span class="line">    fmt.Println(<span class="string">"End of shortWait()"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：  </p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">In</span></span> <span class="function"><span class="title">main</span>()</span></span><br><span class="line"><span class="variable">About</span> <span class="variable">to</span> <span class="variable">sleep</span> <span class="variable"><span class="keyword">in</span></span> <span class="function"><span class="title">main</span>()</span></span><br><span class="line"><span class="variable">Beginning</span> <span class="function"><span class="title">longWait</span>()</span></span><br><span class="line"><span class="variable">Beginning</span> <span class="function"><span class="title">shortWait</span>()</span></span><br><span class="line"><span class="variable">End</span> <span class="variable">of</span> <span class="function"><span class="title">shortWait</span>()</span></span><br><span class="line"><span class="variable">End</span> <span class="variable">of</span> <span class="function"><span class="title">longWait</span>()</span></span><br><span class="line"><span class="variable">At</span> <span class="variable">the</span> <span class="variable">end</span> <span class="variable">of</span> <span class="function"><span class="title">main</span>() <span class="comment">// after 10s</span></span></span><br></pre></td></tr></table></figure>

<p>当 <code>main()</code> 函数返回的时候，程序退出：它不会等待任何其他非 main 协程的结束。这就是为什么在服务器程序中，每一个请求都会启动一个协程来处理，<code>server()</code> 函数必须保持运行状态。通常使用一个无限循环来达到这样的目的。  </p>
<h3 id="Go-协程（goroutines）和协程（coroutines）"><a href="#Go-协程（goroutines）和协程（coroutines）" class="headerlink" title="Go 协程（goroutines）和协程（coroutines）"></a>Go 协程（goroutines）和协程（coroutines）</h3><p>在其他语言中，比如 C#，Lua 或者 Python 都有协程的概念。这个名字表明它和 Go协程有些相似，但有两点不同：  </p>
<ul>
<li>Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的  </li>
<li>Go 协程通过通道来通信；协程通过让出和恢复操作来通信  </li>
</ul>
<p>Go 协程比协程更强大，也很容易从协程的逻辑复用到 Go 协程。  </p>
<h2 id="协程间的信道"><a href="#协程间的信道" class="headerlink" title="协程间的信道"></a>协程间的信道</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Go 有一种特殊的类型，<em>通道（channel）<em>，就像一个可以用于发送类型化数据的管道，由其负责协程之间的通信，从而避开所有由共享内存导致的陷阱；这种通过通道进行通信的方式保证了同步性。数据在通道中进行传递：</em>在任何给定时间，一个数据被设计为只有一个协程可以对其访问，所以不会发生数据竞争。</em> 数据的所有权（可以读写数据的能力）也因此被传递。  </p>
<p>声明通道：<code>var identifier chan datatype</code>  </p>
<p>未初始化的通道的值是nil。  </p>
<p>所以通道只能传输一种类型的数据，比如 <code>chan int</code> 或者 <code>chan string</code>，所有的类型都可以用于通道，空接口 <code>interface{}</code> 也可以。甚至可以（有时非常有用）创建通道的通道。  </p>
<p>通道实际上是类型化消息的队列：使数据得以传输。它是先进先出（FIFO）的结构所以可以保证发送给他们的元素的顺序（有些人知道，通道可以比作 Unix shells 中的双向管道（two-way pipe））。通道也是引用类型，所以我们使用 <code>make()</code> 函数来给它分配内存。这里先声明了一个字符串通道 ch1，然后创建了它（实例化）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>

<p>可以更短： <code>ch1 := make(chan string)</code>  </p>
<p>构建一个int通道的通道： <code>chanOfChans := make(chan int)</code>  </p>
<p>或者函数通道：<code>funcChan := make(chan func())</code>  </p>
<p>所以通道是对象的第一类型：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。另外它们是类型化的，允许类型检查，比如尝试使用整数通道发送一个指针。  </p>
<h3 id="通信操作符-lt"><a href="#通信操作符-lt" class="headerlink" title="通信操作符 &lt;-"></a>通信操作符 &lt;-</h3><p>这个操作符直观的标示了数据的传输：信息按照箭头的方向流动。</p>
<p>流向通道（发送）</p>
<p><code>ch &lt;- int1</code> 表示：用通道 ch 发送变量 int1（双目运算符，中缀 = 发送）  </p>
<p>从通道流出（接收），三种方式：  </p>
<p><code>int2 = &lt;- ch</code> 表示：变量 int2 从通道 ch（一元运算的前缀操作符，前缀 = 接收）接收数据（获取新值）；假设 int2 已经声明过了，如果没有的话可以写成：<code>int2 := &lt;- ch</code>。  </p>
<p><code>&lt;- ch</code> 可以单独调用获取通道的（下一个）值，当前值会被丢弃，但是可以用来验证，所以以下代码是合法的：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;- ch != <span class="number">1000</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作符 &lt;- 也被用来发送和接收，Go 尽管不必要，为了可读性，通道的命名通常以 <code>ch</code> 开头或者包含 <code>chan</code>。通道的发送和接收操作都是自动的：它们通常一气呵成。例子：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> sendData(ch)</span><br><span class="line">    <span class="keyword">go</span> getData(ch)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Washington"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tripoli"</span></span><br><span class="line">    ch &lt;- <span class="string">"London"</span></span><br><span class="line">    ch &lt;- <span class="string">"Beijing"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tokyo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// time.Sleep(2e9)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        input = &lt;-ch</span><br><span class="line">        fmt.Printf(<span class="string">"%s "</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Washington</span> Tripoli London <span class="keyword">Beijing </span>tokyo</span><br></pre></td></tr></table></figure>

<p><code>main()</code> 函数中启动了两个协程：<code>sendData()</code> 通过通道 ch 发送了 5 个字符串，<code>getData()</code> 按顺序接收它们并打印出来。  </p>
<p>如果 2 个协程需要通信，你必须给他们同一个通道作为参数才行。  </p>
<p>协程之间的同步非常重要：  </p>
<ul>
<li>main() 等待了 1 秒让两个协程完成，如果不这样，sendData() 就没有机会输出。</li>
<li>getData() 使用了无限循环：它随着 sendData() 的发送完成和 ch 变空也结束了。</li>
<li>如果我们移除一个或所有 <code>go</code> 关键字，程序无法运行，Go 运行时会抛出 panic：</li>
</ul>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---- Error run E:/Go/Goboek/<span class="keyword">code</span> examples/chapter <span class="number">14</span>/goroutine2.exe <span class="keyword">with</span> <span class="keyword">code</span> Crashed ---- Program exited <span class="keyword">with</span> <span class="keyword">code</span> <span class="number">-2147483645</span>: panic: all goroutines are asleep-deadlock!</span><br></pre></td></tr></table></figure>

<p>为什么会这样？运行时会检查所有的协程（也许只有一个是这种情况）是否在等待（可以读取或者写入某个通道），意味着程序无法处理。这是死锁（deadlock）形式，运行时可以检测到这种情况。  </p>
<p>注意：不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。  </p>
<h3 id="通道阻塞"><a href="#通道阻塞" class="headerlink" title="通道阻塞"></a>通道阻塞</h3><p>1）对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。  </p>
<p>2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。  </p>
<h3 id="通过一个（或多个）通道交换数据进行协程同步"><a href="#通过一个（或多个）通道交换数据进行协程同步" class="headerlink" title="通过一个（或多个）通道交换数据进行协程同步"></a>通过一个（或多个）通道交换数据进行协程同步</h3><p>通信是一种同步形式：通过通道，两个协程在通信（协程会和）中某刻同步交换数据。无缓冲通道成为了多个协程同步的完美工具。  </p>
<p>甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态。Go 运行时会检查并 panic，停止程序。死锁几乎完全是由糟糕的设计导致的。  </p>
<p>无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道。  </p>
<h3 id="同步通道-使用带缓冲的通道"><a href="#同步通道-使用带缓冲的通道" class="headerlink" title="同步通道-使用带缓冲的通道"></a>同步通道-使用带缓冲的通道</h3><p>一个无缓冲通道只能包含 1 个元素，有时显得很局限。我们给通道提供了一个缓存，可以在扩展的 <code>make</code> 命令中设置它的容量，如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf := <span class="number">100</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, buf)</span><br></pre></td></tr></table></figure>

<p>buf 是通道可以同时容纳的元素（这里是 string）个数  </p>
<p>在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。  </p>
<p>缓冲容量和类型无关，所以可以（尽管可能导致危险）给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 <code>cap</code> 函数可以返回缓冲区的容量。  </p>
<p>如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是0或者未设置，通信仅在收发双方准备好的情况下才可以成功。  </p>
<p>同步：<code>ch :=make(chan type, value)</code>  </p>
<ul>
<li>value == 0 -&gt; synchronous, unbuffered (阻塞）</li>
<li>value &gt; 0 -&gt; asynchronous, buffered（非阻塞）取决于value元素</li>
</ul>
<p>若使用通道的缓冲，你的程序会在“请求”激增的时候表现更好：更具弹性，专业术语叫：更具有伸缩性（scalable）。要在首要位置使用无缓冲通道来设计算法，只在不确定的情况下使用缓冲。  </p>
<h3 id="协程中用通道输出结果"><a href="#协程中用通道输出结果" class="headerlink" title="协程中用通道输出结果"></a>协程中用通道输出结果</h3><p>为了知道计算何时完成，可以通过信道回报。在例子 <code>go sum(bigArray)</code> 中，要这样写：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(bigArray, ch) <span class="comment">// bigArray puts the calculated sum on ch</span></span><br><span class="line"><span class="comment">// .. do something else for a while</span></span><br><span class="line">sum := &lt;- ch <span class="comment">// wait for, and retrieve the sum</span></span><br></pre></td></tr></table></figure>

<p>也可以使用通道来达到同步的目的，这个很有效的用法在传统计算机中称为信号量（semaphore）。或者换个方式：通过通道发送信号告知处理已经完成（在协程中）。  </p>
<p>在其他协程运行时让 main 程序无限阻塞的通常做法是在 <code>main</code> 函数的最后放置一个{}。 </p>
<p>也可以使用通道让 <code>main</code> 程序等待协程完成，就是所谓的信号量模式：  </p>
<h3 id="信号量模式"><a href="#信号量模式" class="headerlink" title="信号量模式"></a>信号量模式</h3><p>协程通过在通道 <code>ch</code> 中放置一个值来处理结束的信号。<code>main</code> 协程等待 <code>&lt;-ch</code> 直到从中获取到值。  </p>
<p>我们期望从这个通道中获取返回的结果，像这样：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    ch &lt;- someComputation() <span class="comment">// when it completes, signal on the channel.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// allocate a channel.</span></span><br><span class="line">    <span class="keyword">go</span> compute(ch)      <span class="comment">// stat something in a goroutines</span></span><br><span class="line">    doSomethingElseForAWhile()</span><br><span class="line">    result := &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个信号也可以是其他的，不返回结果，比如下面这个协程中的匿名函数（lambda）协程：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">    ch &lt;- <span class="number">1</span> <span class="comment">// Send a signal; value does not matter</span></span><br><span class="line">&#125;()</span><br><span class="line">doSomethingElseForAWhile()</span><br><span class="line">&lt;- ch   <span class="comment">// Wait for goroutine to finish; discard sent value.</span></span><br></pre></td></tr></table></figure>

<p>或者等待两个协程完成，每一个都会对切片s的一部分进行排序，片段如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">// doSort is a lambda function, so a closure which knows the channel done:</span></span><br><span class="line">doSort := <span class="function"><span class="keyword">func</span><span class="params">(s []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    sort(s)</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">i := pivot(s)</span><br><span class="line"><span class="keyword">go</span> doSort(s[:i])</span><br><span class="line"><span class="keyword">go</span> doSort(s[i:])</span><br><span class="line">&lt;-done</span><br><span class="line">&lt;-done</span><br></pre></td></tr></table></figure>

<p>下边的代码，用完整的信号量模式对长度为N的 float64 切片进行了 N 个<code>doSomething()</code> 计算并同时完成，通道 sem 分配了相同的长度（切包含空接口类型的元素），待所有的计算都完成后，发送信号（通过放入值）。在循环中从通道 sem 不停的接收数据来等待所有的协程完成。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> empty Empty</span><br><span class="line">...</span><br><span class="line">data := <span class="built_in">make</span>([]<span class="keyword">float64</span>, N)</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">float64</span>, N)</span><br><span class="line">sem := <span class="built_in">make</span>(<span class="keyword">chan</span> Empty, N)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> i, xi := <span class="keyword">range</span> data &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>, xi <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">        res[i] = doSomething(i, xi)</span><br><span class="line">        sem &lt;- empty</span><br><span class="line">    &#125; (i, xi)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait for goroutines to finish</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123; &lt;-sem &#125;</span><br></pre></td></tr></table></figure>

<p>注意闭合：<code>i</code>、<code>xi</code> 都是作为参数传入闭合函数的，从外层循环中隐藏了变量 <code>i</code> 和 <code>xi</code>。让每个协程有一份 <code>i</code> 和 <code>xi</code> 的拷贝；另外，for 循环的下一次迭代会更新所有协程中 <code>i</code> 和 <code>xi</code> 的值。切片 <code>res</code> 没有传入闭合函数，因为协程不需要单独拷贝一份。切片 <code>res</code> 也在闭合函数中但并不是参数。  </p>
<h3 id="实现并行的-for-循环"><a href="#实现并行的-for-循环" class="headerlink" title="实现并行的 for 循环"></a>实现并行的 for 循环</h3><p>在 for 循环中并行计算迭代可能带来很好的性能提升。不过所有的迭代都必须是独立完成的。for 循环的每一个迭代是并行完成的：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>, v <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">        doSomething(i, v)</span><br><span class="line">        ...</span><br><span class="line">    &#125; (i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用带缓冲通道实现一个信号量"><a href="#用带缓冲通道实现一个信号量" class="headerlink" title="用带缓冲通道实现一个信号量"></a>用带缓冲通道实现一个信号量</h3><p>信号量是实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题，比如没有实现信号量的 <code>sync</code> 的 Go 包，使用带缓冲的通道可以轻松实现：  </p>
<ul>
<li>带缓冲通道的容量和要同步的资源容量相同</li>
<li>通道的长度（当前存放的元素个数）与当前资源被使用的数量相同</li>
<li>容量减去通道的长度就是未处理的资源个数（标准信号量的整数值）</li>
</ul>
<p>不用管通道中存放的是什么，只关注长度；因此我们创建了一个长度可变但容量为0（字节）的通道：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Empty <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> semaphore <span class="keyword">chan</span> Empty</span><br></pre></td></tr></table></figure>

<p>将可用资源的数量N来初始化信号量 <code>semaphore</code>：<code>sem = make(semaphore, N)</code>  </p>
<p>然后直接对信号量进行操作：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquire n resources</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">P</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    e := <span class="built_in">new</span>(Empty)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        s &lt;- e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release n resouces</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">V</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; n; i++&#123;</span><br><span class="line">        &lt;- s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用来实现一个互斥的例子：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mutexes */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.P(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">Unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s.V(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* signal-wait */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">Wait</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s.P(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s semaphore)</span> <span class="title">Signal</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s.V(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给通道使用-for-循环"><a href="#给通道使用-for-循环" class="headerlink" title="给通道使用 for 循环"></a>给通道使用 for 循环</h3><p><code>for</code> 循环的 <code>range</code> 语句可以用在通道 <code>ch</code> 上，便可以从通道中获取值，像这样：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"The value is %v\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习惯用法：通道迭代模式<br>这个模式用到了后边14.6章示例 producer_consumer.go 的生产者-消费者模式，通常，需要从包含了地址索引字段 items 的容器给通道填入元素。为容器的类型定义一个方法 <code>Iter()</code>，返回一个只读的通道（参见第 14.2.8 节）items，如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *container)</span> <span class="title">Iter</span> <span class="params">()</span> &lt;- <span class="title">chan</span> <span class="title">item</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> item)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; c.Len(); i++&#123;    <span class="comment">// or use a for-range loop</span></span><br><span class="line">            ch &lt;- c.items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在协程里，一个 for 循环迭代容器 c 中的元素（对于树或图的算法，这种简单的 for 循环可以替换为深度优先搜索）。  </p>
<p>调用这个方法的代码可以这样迭代容器：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> container.Iter() &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>可以运行在自己的协程中，所以上边的迭代用到了一个通道和两个协程（可能运行在两个线程上）。就有了一个特殊的生产者-消费者模式。如果程序在协程给通道写完值之前结束，协程不会被回收；设计如此。这种行为看起来是错误的，但是通道是一种线程安全的通信。在这种情况下，协程尝试写入一个通道，而这个通道永远不会被读取，这可能是个 bug 而并非期望它被静默的回收。  </p>
<p>习惯用法：生产者消费者模式  </p>
<p>假设你有 <code>Produce()</code> 函数来产生 <code>Consume</code> 函数需要的值。它们都可以运行在独立的协程中，生产者在通道中放入给消费者读取的值。整个处理过程可以替换为无限循环：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    Consume(Produce())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通道的方向"><a href="#通道的方向" class="headerlink" title="通道的方向"></a>通道的方向</h3><p>通道类型可以用注解来表示它只发送或者只接收：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> send_only <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>        <span class="comment">// channel can only receive data</span></span><br><span class="line"><span class="keyword">var</span> recv_only &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>        <span class="comment">// channel can only send data</span></span><br></pre></td></tr></table></figure>
<p>只接收的通道（&lt;-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。通道创建的时候都是双向的，但也可以分配有方向的通道变量，就像以下代码：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// bidirectional</span></span><br><span class="line"><span class="keyword">go</span> source(c)</span><br><span class="line"><span class="keyword">go</span> sink(c)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">source</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> &#123; ch &lt;- <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sink</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123; &lt;-ch &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习惯用法：管道和选择器模式  </p>
<p>更具体的例子还有协程处理它从通道接收的数据并发送给输出通道：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sendChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">receiveChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> processChannel(sendChan, receiveChan)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processChannel</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, out <span class="keyword">chan</span>&lt;- <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> inValue := <span class="keyword">range</span> in &#123;</span><br><span class="line">        result := ... <span class="comment">/// processing inValue</span></span><br><span class="line">        out &lt;- result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用方向注解来限制协程对通道的操作。  </p>
<p>这里有一个来自 Go 指导的很赞的例子，打印了输出的素数，使用选择器（‘筛’）作为它的算法。每个 prime 都有一个选择器，如下图：  </p>
<p><img src="/images/the_way_to_go_14.2_fig14.2.png" alt="">  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.package main</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Send the sequence 2, 3, 4, ... to channel 'ch'.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">        ch &lt;- i <span class="comment">// Send 'i' to channel 'ch'.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy the values from channel 'in' to channel 'out',</span></span><br><span class="line"><span class="comment">// removing those divisible by 'prime'.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(in, out <span class="keyword">chan</span> <span class="keyword">int</span>, prime <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i := &lt;-in <span class="comment">// Receive value of new variable 'i' from 'in'.</span></span><br><span class="line">        <span class="keyword">if</span> i%prime != <span class="number">0</span> &#123;</span><br><span class="line">            out &lt;- i <span class="comment">// Send 'i' to channel 'out'.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The prime sieve: Daisy-chain filter processes together.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// Create a new channel.</span></span><br><span class="line">    <span class="keyword">go</span> generate(ch)      <span class="comment">// Start generate() as a goroutine.</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        prime := &lt;-ch</span><br><span class="line">        fmt.Print(prime, <span class="string">" "</span>)</span><br><span class="line">        ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">        <span class="keyword">go</span> filter(ch, ch1, prime)</span><br><span class="line">        ch = ch1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协程 <code>filter(in, out chan int, prime int)</code> 拷贝整数到输出通道，丢弃掉可以被 prime 整除的数字。然后每个 prime 又开启了一个新的协程，生成器和选择器并发请求。  </p>
<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">11</span> <span class="number">13</span> <span class="number">17</span> <span class="number">19</span> <span class="number">23</span> <span class="number">29</span> <span class="number">31</span> <span class="number">37</span> <span class="number">41</span> <span class="number">43</span> <span class="number">47</span> <span class="number">53</span> <span class="number">59</span> <span class="number">61</span> <span class="number">67</span> <span class="number">71</span> <span class="number">73</span> <span class="number">79</span> <span class="number">83</span> <span class="number">89</span> <span class="number">97</span> <span class="number">101</span></span><br><span class="line"><span class="number">103</span> <span class="number">107</span> <span class="number">109</span> <span class="number">113</span> <span class="number">127</span> <span class="number">131</span> <span class="number">137</span> <span class="number">139</span> <span class="number">149</span> <span class="number">151</span> <span class="number">157</span> <span class="number">163</span> <span class="number">167</span> <span class="number">173</span> <span class="number">179</span> <span class="number">181</span> <span class="number">191</span> <span class="number">193</span> <span class="number">197</span> <span class="number">199</span> <span class="number">211</span> <span class="number">223</span></span><br><span class="line"><span class="number">227</span> <span class="number">229</span> <span class="number">233</span> <span class="number">239</span> <span class="number">241</span> <span class="number">251</span> <span class="number">257</span> <span class="number">263</span> <span class="number">269</span> <span class="number">271</span> <span class="number">277</span> <span class="number">281</span> <span class="number">283</span> <span class="number">293</span> <span class="number">307</span> <span class="number">311</span> <span class="number">313</span> <span class="number">317</span> <span class="number">331</span> <span class="number">337</span> <span class="number">347</span> <span class="number">349</span></span><br><span class="line"><span class="number">353</span> <span class="number">359</span> <span class="number">367</span> <span class="number">373</span> <span class="number">379</span> <span class="number">383</span> <span class="number">389</span> <span class="number">397</span> <span class="number">401</span> <span class="number">409</span> <span class="number">419</span> <span class="number">421</span> <span class="number">431</span> <span class="number">433</span> <span class="number">439</span> <span class="number">443</span> <span class="number">449</span> <span class="number">457</span> <span class="number">461</span> <span class="number">463</span> <span class="number">467</span> <span class="number">479</span></span><br><span class="line"><span class="number">487</span> <span class="number">491</span> <span class="number">499</span> <span class="number">503</span> <span class="number">509</span> <span class="number">521</span> <span class="number">523</span> <span class="number">541</span> <span class="number">547</span> <span class="number">557</span> <span class="number">563</span> <span class="number">569</span> <span class="number">571</span> <span class="number">577</span> <span class="number">587</span> <span class="number">593</span> <span class="number">599</span> <span class="number">601</span> <span class="number">607</span> <span class="number">613</span> <span class="number">617</span> <span class="number">619</span></span><br><span class="line"><span class="number">631</span> <span class="number">641</span> <span class="number">643</span> <span class="number">647</span> <span class="number">653</span> <span class="number">659</span> <span class="number">661</span> <span class="number">673</span> <span class="number">677</span> <span class="number">683</span> <span class="number">691</span> <span class="number">701</span> <span class="number">709</span> <span class="number">719</span> <span class="number">727</span> <span class="number">733</span> <span class="number">739</span> <span class="number">743</span> <span class="number">751</span> <span class="number">757</span> <span class="number">761</span> <span class="number">769</span></span><br><span class="line"><span class="number">773</span> <span class="number">787</span> <span class="number">797</span> <span class="number">809</span> <span class="number">811</span> <span class="number">821</span> <span class="number">823</span> <span class="number">827</span> <span class="number">829</span> <span class="number">839</span> <span class="number">853</span> <span class="number">857</span> <span class="number">859</span> <span class="number">863</span> <span class="number">877</span> <span class="number">881</span> <span class="number">883</span> <span class="number">887</span> <span class="number">907</span> <span class="number">911</span> <span class="number">919</span> <span class="number">929</span></span><br><span class="line"><span class="number">937</span> <span class="number">941</span> <span class="number">947</span> <span class="number">953</span> <span class="number">967</span> <span class="number">971</span> <span class="number">977</span> <span class="number">983</span> <span class="number">991</span> <span class="number">997</span> <span class="number">1009</span> <span class="number">1013.</span>..</span><br></pre></td></tr></table></figure>

<p>第二个版本引入了上边的习惯用法：函数 <code>sieve</code>、<code>generate</code> 和 <code>filter</code> 都是工厂；它们创建通道并返回，而且使用了协程的 lambda 函数。<code>main</code> 函数现在短小清晰：它调用 <code>sieve()</code> 返回了包含素数的通道，然后通过 <code>fmt.Println(&lt;-primes)</code> 打印出来。  </p>
<p>版本2：示例 14.8-sieve2.go:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send the sequence 2, 3, 4, ... to returned channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter out input values divisible by 'prime', send rest to returned channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(in <span class="keyword">chan</span> <span class="keyword">int</span>, prime <span class="keyword">int</span>)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i := &lt;-in; i%prime != <span class="number">0</span> &#123;</span><br><span class="line">                out &lt;- i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sieve</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch := generate()</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            prime := &lt;-ch</span><br><span class="line">            ch = filter(ch, prime)</span><br><span class="line">            out &lt;- prime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    primes := sieve()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(&lt;-primes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="协程的同步：关闭通道-测试阻塞的通道"><a href="#协程的同步：关闭通道-测试阻塞的通道" class="headerlink" title="协程的同步：关闭通道-测试阻塞的通道"></a>协程的同步：关闭通道-测试阻塞的通道</h2><p>通道可以被显式的关闭；尽管它们和文件不同：不必每次都关闭。只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道。只有发送者需要关闭通道，接收者永远不会需要。  </p>
<p>继续看示例 goroutine2.go：我们如何在通道的 <code>sendData()</code> 完成的时候发送一个信号，<code>getData()</code> 又如何检测到通道是否关闭或阻塞？  </p>
<p>第一个可以通过函数 <code>close(ch)</code> 来完成：这个将通道标记为无法通过发送操作 <code>&lt;-</code> 接受更多的值；给已经关闭的通道发送或者再次关闭都会导致运行时的 panic。在创建一个通道后使用 defer 语句是个不错的办法（类似这种情况）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">float64</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>第二个问题可以使用逗号，ok 操作符：用来检测通道是否被关闭。  </p>
<p>如何来检测可以收到没有被阻塞（或者通道没有被关闭）？  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch   <span class="comment">// ok is true if v received value</span></span><br></pre></td></tr></table></figure>

<p>通常和 if 语句一起使用：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := &lt;-ch; ok &#123;</span><br><span class="line">  process(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者在 for 循环中接收的时候，当关闭或者阻塞的时候使用 break：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">process(v)</span><br></pre></td></tr></table></figure>

<p>在示例程序 14.2 中使用这些可以改进为版本 goroutine3.go，输出相同。</p>
<p>实现非阻塞通道的读取，需要使用 select。</p>
<p>示例 14.9-goroutine3.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> sendData(ch)</span><br><span class="line">    getData(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Washington"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tripoli"</span></span><br><span class="line">    ch &lt;- <span class="string">"London"</span></span><br><span class="line">    ch &lt;- <span class="string">"Beijing"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tokio"</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        input, open := &lt;-ch</span><br><span class="line">        <span class="keyword">if</span> !open &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"%s "</span>, input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改变了以下代码：  </p>
<ul>
<li>现在只有 <code>sendData()</code> 是协程，<code>getData()</code> 和 <code>main()</code> 在同一个线程中：  </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> sendData(ch)</span><br><span class="line">getData(ch)</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>sendData()</code> 函数的最后，关闭了通道：  </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">"Washington"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tripoli"</span></span><br><span class="line">    ch &lt;- <span class="string">"London"</span></span><br><span class="line">    ch &lt;- <span class="string">"Beijing"</span></span><br><span class="line">    ch &lt;- <span class="string">"Tokio"</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 for 循环的 <code>getData()</code> 中，在每次接收通道的数据之前都使用 <code>if !open</code> 来检测：  </li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        input, open := &lt;-ch</span><br><span class="line">        <span class="keyword">if</span> !open &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"%s "</span>, input)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 for-range 语句来读取通道是更好的办法，因为这会自动检测通道是否关闭：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> input := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    process(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阻塞和生产者-消费者模式：  </p>
<p>在第 14.2.10 节的通道迭代器中，两个协程经常是一个阻塞另外一个。如果程序工作在多核心的机器上，大部分时间只用到了一个处理器。可以通过使用带缓冲（缓冲空间大于 0）的通道来改善。比如，缓冲大小为 100，迭代器在阻塞之前，至少可以从容器获得 100 个元素。如果消费者协程在独立的内核运行，就有可能让协程不会出现阻塞。  </p>
<p>由于容器中元素的数量通常是已知的，需要让通道有足够的容量放置所有的元素。这样，迭代器就不会阻塞（尽管消费者协程仍然可能阻塞）。然后，这样有效的加倍了迭代容器所需要的内存使用量，所以通道的容量需要限制一下最大值。记录运行时间和性能测试可以帮助你找到最小的缓存容量带来最好的性能。  </p>
<h2 id="使用-select-切换协程"><a href="#使用-select-切换协程" class="headerlink" title="使用 select 切换协程"></a>使用 select 切换协程</h2><p>从不同的并发执行的协程中获取值可以通过关键字<code>select</code>来完成，它和<code>switch</code>控制语句非常相似（章节5.3）也被称作通信开关；它的行为像是“你准备好了吗”的轮询机制；<code>select</code>监听进入通道的数据，也可以是用通道发送值的时候。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> u:= &lt;- ch1:</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// no value ready to be received</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>default</code> 语句是可选的；fallthrough 行为，和普通的 switch 相似，是不允许的。在任何一个 case 中执行 <code>break</code> 或者 <code>return</code>，select 就结束了。  </p>
<p><code>select</code> 做的就是：选择处理列出的多个通信情况中的一个。  </p>
<ul>
<li>如果都阻塞了，会等待直到其中一个可以处理</li>
<li>如果多个可以处理，随机选择一个</li>
<li>如果没有通道操作可以处理并且写了 <code>default</code> 语句，它就会执行：<code>default</code> 永远是可运行的（这就是准备好了，可以执行）。</li>
</ul>
<p>在 <code>select</code> 中使用发送操作并且有 <code>default</code> 可以确保发送不被阻塞！如果没有 <code>default</code>，select 就会一直阻塞。  </p>
<p><code>select</code> 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 <code>break</code> 语句使循环退出。  </p>
<p>在程序 goroutine_select.go中有 2 个通道 <code>ch1</code> 和 <code>ch2</code>，三个协程 <code>pump1()</code>、<code>pump2()</code> 和 <code>suck()</code>。这是一个典型的生产者消费者模式。在无限循环中，<code>ch1</code> 和 <code>ch2</code> 通过 <code>pump1()</code> 和 <code>pump2()</code> 填充整数；<code>suck()</code> 也是在无限循环中轮询输入的，通过 <code>select</code> 语句获取 <code>ch1</code> 和 <code>ch2</code> 的整数并输出。选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。  </p>
<p>示例 14.10-goroutine_select.go：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> pump1(ch1)</span><br><span class="line">    <span class="keyword">go</span> pump2(ch2)</span><br><span class="line">    <span class="keyword">go</span> suck(ch1, ch2)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        ch &lt;- i * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pump2</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">        ch &lt;- i + <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">suck</span><span class="params">(ch1, ch2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-ch1:</span><br><span class="line">            fmt.Printf(<span class="string">"Received on channel 1: %d\n"</span>, v)</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-ch2:</span><br><span class="line">            fmt.Printf(<span class="string">"Received on channel 2: %d\n"</span>, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：  </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Received on channel <span class="number">2</span>: <span class="number">5</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">6</span></span><br><span class="line">Received on channel <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">7</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">8</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">9</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">10</span></span><br><span class="line">Received on channel <span class="number">1</span>: <span class="number">2</span></span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">11</span></span><br><span class="line">...</span><br><span class="line">Received on channel <span class="number">2</span>: <span class="number">47404</span></span><br><span class="line">Received on channel <span class="number">1</span>: <span class="number">94346</span></span><br><span class="line">Received on channel <span class="number">1</span>: <span class="number">94348</span></span><br></pre></td></tr></table></figure>

<h2 id="通道、超时和计时器（Ticker）"><a href="#通道、超时和计时器（Ticker）" class="headerlink" title="通道、超时和计时器（Ticker）"></a>通道、超时和计时器（Ticker）</h2><p><code>time</code> 包中包含了 <code>time.Ticker</code> 结构体，这个对象以指定的时间间隔重复的向通道 C 发送时间值：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ticker <span class="keyword">struct</span> &#123;</span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time <span class="comment">// the channel on which the ticks are delivered.</span></span><br><span class="line">    <span class="comment">// contains filtered or unexported fields</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间间隔的单位是 ns（纳秒，int64），在工厂函数 <code>time.NewTicker</code> 中以 <code>Duration</code> 类型的参数传入：<code>func Newticker(dur) *Ticker</code>。  </p>
<p>在协程周期性的执行一些事情（打印状态日志，输出，计算等等）的时候非常有用。  </p>
<p>调用 <code>Stop()</code> 使计时器停止，在 <code>defer</code> 语句中使用。这些都很好的适应 <code>select</code> 语句:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(updateInterval)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> u:= &lt;-ch1:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;-ch2:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">    logState(status) <span class="comment">// call some logging function logState</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// no value ready to be received</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>time.Tick()</code> 函数声明为 <code>Tick(d Duration) &lt;-chan Time</code>，当你想返回一个通道而不必关闭它的时候这个函数非常有用：它以 d 为周期给返回的通道发送时间，d是纳秒数。如果需要像下边的代码一样，限制处理频率（函数 <code>client.Call()</code> 是一个 RPC 调用，这里暂不赘述：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line"></span><br><span class="line">rate_per_sec := <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> dur Duration = <span class="number">1e9</span> / rate_per_sec</span><br><span class="line">chRate := time.Tick(dur) <span class="comment">// a tick every 1/10th of a second</span></span><br><span class="line"><span class="keyword">for</span> req := <span class="keyword">range</span> requests &#123;</span><br><span class="line">    &lt;- chRate <span class="comment">// rate limit our Service.Method RPC calls</span></span><br><span class="line">    <span class="keyword">go</span> client.Call(<span class="string">"Service.Method"</span>, req, ...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只会按照指定频率处理请求：<code>chRate</code> 阻塞了更高的频率。每秒处理的频率可以根据机器负载（和/或）资源的情况而增加或减少。  </p>
<p>定时器（Timer）结构体看上去和计时器（Ticker）结构体的确很像（构造为 <code>NewTimer(d Duration)</code>），但是它只发送一次时间，在 <code>Dration d</code> 之后。  </p>
<p>还有 <code>time.After(d)</code> 函数，声明如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure>

<p>在 <code>Duration d</code> 之后，当前时间被发到返回的通道；所以它和 <code>NewTimer(d).C</code> 是等价的；它类似 <code>Tick()</code>，但是 <code>After()</code> 只发送一次时间。下边有个很具体的示例，很好的阐明了 <code>select</code> 中 <code>default</code> 的作用：  </p>
<p>示例 14.11：timer_goroutine.go)：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tick := time.Tick(<span class="number">1e8</span>)</span><br><span class="line">    boom := time.After(<span class="number">5e8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            fmt.Println(<span class="string">"tick."</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-boom:</span><br><span class="line">            fmt.Println(<span class="string">"BOOM!"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"    ."</span>)</span><br><span class="line">            time.Sleep(<span class="number">5e7</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：  </p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">tick.</span><br><span class="line">BOOM!</span><br></pre></td></tr></table></figure>

<p>习惯用法：简单超时模式  </p>
<p>要从通道 <code>ch</code> 中接收数据，但是最多等待1秒。先创建一个信号通道，然后启动一个 <code>lambda</code> 协程，协程在给通道发送数据之前是休眠的：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1e9</span>) <span class="comment">// one second</span></span><br><span class="line">        timeout &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>select</code> 语句接收 <code>ch</code> 或者 <code>timeout</code> 的数据：如果 <code>ch</code> 在 1 秒内没有收到数据，就选择到了 <code>time</code> 分支并放弃了 <code>ch</code> 的读取。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="comment">// a read from ch has occured</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">        <span class="comment">// the read from ch has timed out</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种形式：取消耗时很长的同步调用  </p>
<p>也可以使用 <code>time.After()</code> 函数替换 <code>timeout-channel</code>。可以在 <code>select</code> 中通过 <code>time.After()</code> 发送的超时信号来停止协程的执行。以下代码，在 <code>timeoutNs</code> 纳秒后执行 <code>select</code> 的 <code>timeout</code> 分支后，执行<code>client.Call</code> 的协程也随之结束，不会给通道 <code>ch</code> 返回值：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- client.Call(<span class="string">"Service.Method"</span>, args, &amp;reply) &#125; ()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> resp := &lt;-ch</span><br><span class="line">    <span class="comment">// use resp and reply</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeoutNs):</span><br><span class="line">    <span class="comment">// call timed out</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意缓冲大小设置为 1 是必要的，可以避免协程死锁以及确保超时的通道可以被垃圾回收。此外，需要注意在有多个 <code>case</code> 符合条件时， <code>select</code> 对 <code>case</code> 的选择是伪随机的，如果上面的代码稍作修改如下，则 <code>select</code> 语句可能不会在定时器超时信号到来时立刻选中 <code>time.After(timeoutNs)</code> 对应的 <code>case</code>，因此协程可能不会严格按照定时器设置的时间结束。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; ch &lt;- <span class="number">1</span> &#125; &#125; ()</span><br><span class="line">L:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(timeoutNs):</span><br><span class="line">        <span class="comment">// call timed out</span></span><br><span class="line">        <span class="keyword">break</span> L</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种形式：假设程序从多个复制的数据库同时读取。只需要一个答案，需要接收首先到达的答案，<code>Query</code> 函数获取数据库的连接切片并请求。并行请求每一个数据库并返回收到的第一个响应：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Query</span><span class="params">(conns []conn, query <span class="keyword">string</span>)</span> <span class="title">Result</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, conn := <span class="keyword">range</span> conns &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c Conn)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- c.DoQuery(query):</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(conn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;- ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次声明，结果通道 <code>ch</code> 必须是带缓冲的：以保证第一个发送进来的数据有地方可以存放，确保放入的首个数据总会成功，所以第一个到达的值会被获取而与执行的顺序无关。正在执行的协程可以总是可以使用 <code>runtime.Goexit()</code> 来停止。  </p>
<p>在应用中缓存数据：  </p>
<p>应用程序中用到了来自数据库（或者常见的数据存储）的数据时，经常会把数据缓存到内存中，因为从数据库中获取数据的操作代价很高；如果数据库中的值不发生变化就没有问题。但是如果值有变化，我们需要一个机制来周期性的从数据库重新读取这些值：缓存的值就不可用（过期）了，而且我们也不希望用户看到陈旧的数据。  </p>
<h2 id="协程和恢复（recover）"><a href="#协程和恢复（recover）" class="headerlink" title="协程和恢复（recover）"></a>协程和恢复（recover）</h2><p>一个用到 <code>recover</code> 的程序停掉了服务器内部一个失败的协程而不影响其他协程的工作。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(workChan &lt;-<span class="keyword">chan</span> *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> work := <span class="keyword">range</span> workChan &#123;</span><br><span class="line">        <span class="keyword">go</span> safelyDo(work)   <span class="comment">// start the goroutine for that work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safelyDo</span><span class="params">(work *Work)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">"Work failed with %s in %v"</span>, err, work)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    do(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的代码，如果 <code>do(work)</code> 发生 panic，错误会被记录且协程会退出并释放，而其他协程不受影响。  </p>
<p>因为 <code>recover</code> 总是返回 <code>nil</code>，除非直接在 <code>defer</code> 修饰的函数中调用，<code>defer</code> 修饰的代码可以调用那些自身可以使用 <code>panic</code> 和 <code>recover</code> 避免失败的库例程（库函数）。举例，<code>safelyDo()</code> 中 <code>defer</code> 修饰的函数可能在调用 <code>recover</code> 之前就调用了一个 <code>logging</code> 函数，<code>panicking</code> 状态不会影响 <code>logging</code> 代码的运行。因为加入了恢复模式，函数 <code>do</code>（以及它调用的任何东西）可以通过调用 <code>panic</code> 来摆脱不好的情况。但是恢复是在 <code>panicking</code> 的协程内部的：不能被另外一个协程恢复。  </p>
<h2 id="新旧模型对比：任务和worker-（锁vs协程）"><a href="#新旧模型对比：任务和worker-（锁vs协程）" class="headerlink" title="新旧模型对比：任务和worker （锁vs协程）"></a>新旧模型对比：任务和worker （锁vs协程）</h2><p>假设我们需要处理很多任务；一个worker处理一项任务。任务可以被定义为一个结构体（具体的细节在这里并不重要）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// some state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>旧模式：使用共享内存进行同步  </p>
<p>由各个任务组成的任务池共享内存；为了同步各个worker以及避免资源竞争，我们需要对任务池进行加锁保护：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    Mu      sync.Mutex</span><br><span class="line">    Tasks   []Task</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sync.Mutex(是互斥锁：它用来在代码中保护临界区资源：同一时间只有一个go协程（goroutine）可以进入该临界区。如果出现了同一时间多个go协程都进入了该临界区，则会产生竞争：Pool结构就不能保证被正确更新。在传统的模式中（经典的面向对象的语言中应用得比较多，比如C++,JAVA,C#)，worker代码可能这样写：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(pool *Pool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        pool.Mu.lock()</span><br><span class="line">        <span class="comment">// begin critical section:</span></span><br><span class="line">        task := pool.Task[<span class="number">0</span>]        <span class="comment">// take the first task</span></span><br><span class="line">        pool.Tasks = pool.Task[<span class="number">1</span>:]  <span class="comment">// update the pool of tasks</span></span><br><span class="line">        <span class="comment">// end critical section</span></span><br><span class="line">        pool.Mu.Unlock()</span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些worker有许多都可以并发执行；他们可以在go协程中启动。一个worker先将pool锁定，从pool获取第一项任务，再解锁和处理任务。加锁保证了同一时间只有一个go协程可以进入到pool中：一项任务有且只能被赋予一个worker。如果不加锁，则工作协程可能会在<code>task:=pool.Task[0]</code>发生切换，导致<code>pool.Tasks=pool.Task[1:]</code>结果异常：一些worker获取不到任务，而一些任务可能被多个worker得到。加锁实现同步的方式在工作协程比较少时可以工作的很好，但是当工作协程数量很大，任务量也很多时，处理效率将会因为频繁的加锁/解锁开销而降低。当工作协程数增加到一个阈值时，程序效率会急剧下降，这就成为了瓶颈。  </p>
<p>新模式：使用通道  </p>
<p>使用通道进行同步：使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker在协程中启动，其数量N应该根据任务数量进行调整。  </p>
<p>主线程扮演着Master节点角色，可能写成如下形式：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pending, done := <span class="built_in">make</span>(<span class="keyword">chan</span> *Task), <span class="built_in">make</span>(<span class="keyword">chan</span> *Task)</span><br><span class="line">    <span class="keyword">go</span> sendWork(pending)       <span class="comment">// put tasks with work on the channel</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;   <span class="comment">// start N goroutines to do work</span></span><br><span class="line">        <span class="keyword">go</span> Worker(pending, done)</span><br><span class="line">    &#125;</span><br><span class="line">    consumeWork(done)          <span class="comment">// continue with the processed tasks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker的逻辑比较简单：从pending通道拿任务，处理后将其放到done通道中：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(in, out <span class="keyword">chan</span> *Task)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里并不使用锁：从通道得到新任务的过程没有任何竞争。随着任务数量增加，worker数量也应该相应增加，同时性能并不会像第一种方式那样下降明显。在pending通道中存在一份任务的拷贝，第一个worker从pending通道中获得第一个任务并进行处理，这里并不存在竞争（对一个通道读数据和写数据的整个过程是原子性的)。某一个任务会在哪一个worker中被执行是不可知的，反过来也是。worker数量的增多也会增加通信的开销，这会对性能有轻微的影响。  </p>
<p>从这个简单的例子中可能很难看出第二种模式的优势，但含有复杂锁运用的程序不仅在编写上显得困难，也不容易编写正确，使用第二种模式的话，就无需考虑这么复杂的东西了。  </p>
<p>因此，第二种模式对比第一种模式而言，不仅性能是一个主要优势，而且还有个更大的优势：代码显得更清晰、更优雅。一个更符合go语言习惯的worker写法：  </p>
<p><strong>IDIOM: Use an in- and out-channel instead of locking</strong>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(in, out <span class="keyword">chan</span> *Task)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        t := &lt;-in</span><br><span class="line">        process(t)</span><br><span class="line">        out &lt;- t</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于任何可以建模为Master-Worker范例的问题，一个类似于worker使用通道进行通信和交互、Master进行整体协调的方案都能完美解决。如果系统部署在多台机器上，各个机器上执行Worker协程，Master和Worker之间使用netchan或者RPC进行通信（见下章）。  </p>
<p>怎么选择是该使用锁还是通道？  </p>
<p>通道是一个较新的概念，本节我们着重强调了在go协程里通道的使用，但这并不意味着经典的锁方法就不能使用。go语言让你可以根据实际问题进行选择：创建一个优雅、简单、可读性强、在大多数场景性能表现都能很好的方案。如果你的问题适合使用锁，也不要忌讳使用它。go语言注重实用，什么方式最能解决你的问题就用什么方式，而不是强迫你使用一种编码风格。下面列出一个普遍的经验法则：  </p>
<ul>
<li><p>使用锁的情景：</p>
<ul>
<li>访问共享数据结构中的缓存信息</li>
<li>保存应用程序上下文和状态信息数据</li>
</ul>
</li>
<li><p>使用通道的情景：</p>
<ul>
<li>与异步操作的结果进行交互</li>
<li>分发任务</li>
<li>传递数据所有权</li>
</ul>
</li>
</ul>
<p>当你发现你的锁使用规则变得很复杂时，可以反省使用通道会不会使问题变得简单些。  </p>
<h2 id="惰性生成器的实现"><a href="#惰性生成器的实现" class="headerlink" title="惰性生成器的实现"></a>惰性生成器的实现</h2><p>生成器是指当被调用时返回一个序列中下一个值的函数，例如：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generateInteger() =&gt; <span class="number">0</span></span><br><span class="line">generateInteger() =&gt; <span class="number">1</span></span><br><span class="line">generateInteger() =&gt; <span class="number">2</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>生成器每次返回的是序列中下一个值而非整个序列；这种特性也称之为惰性求值：只在你需要时进行求值，同时保留相关变量资源（内存和cpu）：这是一项在需要时对表达式进行求值的技术。例如，生成一个无限数量的偶数序列：要产生这样一个序列并且在一个一个的使用可能会很困难，而且内存会溢出！但是一个含有通道和go协程的函数能轻易实现这个需求。  </p>
<p>在14.12的例子中，我们实现了一个使用 int 型通道来实现的生成器。通道被命名为<code>yield</code>和<code>resume</code>，这些词经常在协程代码中使用。  </p>
<p>示例 14.12 lazy_evaluation.go：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resume <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integers</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    yield := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            yield &lt;- count</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> yield</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateInteger</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;-resume</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resume = integers()</span><br><span class="line">    fmt.Println(generateInteger())  <span class="comment">//=&gt; 0</span></span><br><span class="line">    fmt.Println(generateInteger())  <span class="comment">//=&gt; 1</span></span><br><span class="line">    fmt.Println(generateInteger())  <span class="comment">//=&gt; 2    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个细微的区别是从通道读取的值可能会是稍早前产生的，并不是在程序被调用时生成的。如果确实需要这样的行为，就得实现一个请求响应机制。当生成器生成数据的过程是计算密集型且各个结果的顺序并不重要时，那么就可以将生成器放入到go协程实现并行化。但是得小心，使用大量的go协程的开销可能会超过带来的性能增益。  </p>
<p>这些原则可以概括为：通过巧妙地使用空接口、闭包和高阶函数，我们能实现一个通用的惰性生产器的工厂函数<code>BuildLazyEvaluator</code>（这个应该放在一个工具包中实现）。工厂函数需要一个函数和一个初始状态作为输入参数，返回一个无参、返回值是生成序列的函数。传入的函数需要计算出下一个返回值以及下一个状态参数。在工厂函数中，创建一个通道和无限循环的go协程。返回值被放到了该通道中，返回函数稍后被调用时从该通道中取得该返回值。每当取得一个值时，下一个值即被计算。在下面的例子中，定义了一个<code>evenFunc</code>函数，其是一个惰性生成函数：在main函数中，我们创建了前10个偶数，每个都是通过调用<code>even()</code>函数取得下一个值的。为此，我们需要在<code>BuildLazyIntEvaluator</code>函数中具体化我们的生成函数，然后我们能够基于此做出定义。  </p>
<p>示例 14.13 general_lazy_evalution1.go：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> EvalFunc <span class="function"><span class="keyword">func</span><span class="params">(Any)</span> <span class="params">(Any, Any)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    evenFunc := <span class="function"><span class="keyword">func</span><span class="params">(state Any)</span> <span class="params">(Any, Any)</span></span> &#123;</span><br><span class="line">        os := state.(<span class="keyword">int</span>)</span><br><span class="line">        ns := os + <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> os, ns</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    even := BuildLazyIntEvaluator(evenFunc, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%vth even: %v\n"</span>, i, even())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildLazyEvaluator</span><span class="params">(evalFunc EvalFunc, initState Any)</span> <span class="title">func</span><span class="params">()</span> <span class="title">Any</span></span> &#123;</span><br><span class="line">    retValChan := <span class="built_in">make</span>(<span class="keyword">chan</span> Any)</span><br><span class="line">    loopFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> actState Any = initState</span><br><span class="line">        <span class="keyword">var</span> retVal Any</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            retVal, actState = evalFunc(actState)</span><br><span class="line">            retValChan &lt;- retVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    retFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">Any</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;- retValChan</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> loopFunc()</span><br><span class="line">    <span class="keyword">return</span> retFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildLazyIntEvaluator</span><span class="params">(evalFunc EvalFunc, initState Any)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ef := BuildLazyEvaluator(evalFunc, initState)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ef().(<span class="keyword">int</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>th even: <span class="number">0</span></span><br><span class="line"><span class="number">1</span>th even: <span class="number">2</span></span><br><span class="line"><span class="number">2</span>th even: <span class="number">4</span></span><br><span class="line"><span class="number">3</span>th even: <span class="number">6</span></span><br><span class="line"><span class="number">4</span>th even: <span class="number">8</span></span><br><span class="line"><span class="number">5</span>th even: <span class="number">10</span></span><br><span class="line"><span class="number">6</span>th even: <span class="number">12</span></span><br><span class="line"><span class="number">7</span>th even: <span class="number">14</span></span><br><span class="line"><span class="number">8</span>th even: <span class="number">16</span></span><br><span class="line"><span class="number">9</span>th even: <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h2 id="实现-Futures-模式"><a href="#实现-Futures-模式" class="headerlink" title="实现 Futures 模式"></a>实现 Futures 模式</h2><p>所谓Futures就是指：有时候在你使用某一个值之前需要先对其进行计算。这种情况下，你就可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕了。  </p>
<p>Futures模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于Futures需要返回一个值。  </p>
<p>参考条目文献给出了一个很精彩的例子：假设我们有一个矩阵类型，我们需要计算两个矩阵A和B乘积的逆，首先我们通过函数<code>Inverse(M)</code>分别对其进行求逆运算，在将结果相乘。如下函数<code>InverseProduct()</code>实现了如上过程：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InverseProduct</span><span class="params">(a Matrix, b Matrix)</span></span> &#123;</span><br><span class="line">    a_inv := Inverse(a)</span><br><span class="line">    b_inv := Inverse(b)</span><br><span class="line">    <span class="keyword">return</span> Product(a_inv, b_inv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，a和b的求逆矩阵需要先被计算。那么为什么在计算b的逆矩阵时，需要等待a的逆计算完成呢？显然不必要，这两个求逆运算其实可以并行执行的。换句话说，调用<code>Product</code>函数只需要等到<code>a_inv</code>和<code>b_inv</code>的计算完成。如下代码实现了并行计算方式：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InverseProduct</span><span class="params">(a Matrix, b Matrix)</span></span> &#123;</span><br><span class="line">    a_inv_future := InverseFuture(a)   <span class="comment">// start as a goroutine</span></span><br><span class="line">    b_inv_future := InverseFuture(b)   <span class="comment">// start as a goroutine</span></span><br><span class="line">    a_inv := &lt;-a_inv_future</span><br><span class="line">    b_inv := &lt;-b_inv_future</span><br><span class="line">    <span class="keyword">return</span> Product(a_inv, b_inv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InverseFuture</code>函数起了一个<code>goroutine</code>协程，在其执行闭包运算，该闭包会将矩阵求逆结果放入到future通道中：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InverseFuture</span><span class="params">(a Matrix)</span> <span class="title">chan</span> <span class="title">Matrix</span></span> &#123;</span><br><span class="line">    future := <span class="built_in">make</span>(<span class="keyword">chan</span> Matrix)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        future &lt;- Inverse(a)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当开发一个计算密集型库时，使用Futures模式设计API接口是很有意义的。在你的包使用Futures模式，且能保持友好的API接口。此外，Futures可以通过一个异步的API暴露出来。这样你可以以最小的成本将包中的并行计算移到用户代码中。（参见参考文件18：<a href="http://www.golangpatterns.info/concurrency/futures" target="_blank" rel="noopener">http://www.golangpatterns.info/concurrency/futures</a>）  </p>
<hr>
<h1 id="网络，模板和网页应用"><a href="#网络，模板和网页应用" class="headerlink" title="网络，模板和网页应用"></a>网络，模板和网页应用</h1><p>go在编写web应用方面非常得力。因为目前它还没有GUI（Graphic User Interface 即图形化用户界面）的框架，通过文本或者模板展现的html界面是目前go编写应用程序的唯一方式。（**译者注：实际上在翻译的时候，已经有了一些不太成熟的GUI库例如：go ui。）  </p>
<h2 id="tcp服务器"><a href="#tcp服务器" class="headerlink" title="tcp服务器"></a>tcp服务器</h2><p>这部分我们将使用TCP协议和在14章讲到的协程范式编写一个简单的客户端-服务器应用，一个（web）服务器应用需要响应众多客户端的并发请求：go会为每一个客户端产生一个协程用来处理请求。我们需要使用net包中网络通信的功能。它包含了用于TCP/IP以及UDP协议、域名解析等方法。  </p>
<p>服务器代码，单独的一个文件：  </p>
<p>示例 15.1 server.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Starting the server ..."</span>)</span><br><span class="line">    <span class="comment">// 创建 listener</span></span><br><span class="line">    listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:50000"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Error listening"</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听并接受来自客户端的连接</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        conn, err := listener.Accept()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Error accepting"</span>, err.Error())</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// 终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">go</span> doServerStuff(conn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doServerStuff</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</span><br><span class="line">        <span class="built_in">len</span>, err := conn.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Error reading"</span>, err.Error())</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">//终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"Received data: %v"</span>, <span class="keyword">string</span>(buf[:<span class="built_in">len</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>main()</code>创建了一个<code>net.Listener</code>的变量，他是一个服务器的基本函数：用来监听和接收来自客户端的请求（来自localhost即IP地址为127.0.0.1端口为50000基于TCP协议）。这个<code>Listen()</code>函数可以返回一个<code>error</code>类型的错误变量。用一个无限for循环的<code>listener.Accept()</code>来等待客户端的请求。客户端的请求将产生一个<code>net.Conn</code>类型的连接变量。然后一个独立的协程使用这个连接执行<code>doServerStuff()</code>，开始使用一个512字节的缓冲<code>data</code>来读取客户端发送来的数据并且把它们打印到服务器的终端，<code>len</code>获取客户端发送的数据字节数；当客户端发送的所有数据都被读取完成时，协程就结束了。这段程序会为每一个客户端连接创建一个独立的协程。必须先运行服务器代码，再运行客户端代码。  </p>
<p>客户端代码写在另外一个文件client.go中：  </p>
<p>示例 15.2 client.go  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//打开连接:</span></span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:50000"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//由于目标计算机积极拒绝而无法创建连接</span></span><br><span class="line">        fmt.Println(<span class="string">"Error dialing"</span>, err.Error())</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// 终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inputReader := bufio.NewReader(os.Stdin)</span><br><span class="line">    fmt.Println(<span class="string">"First, what is your name?"</span>)</span><br><span class="line">    clientName, _ := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">// fmt.Printf("CLIENTNAME %s", clientName)</span></span><br><span class="line">    trimmedClient := strings.Trim(clientName, <span class="string">"\r\n"</span>) <span class="comment">// Windows 平台下用 "\r\n"，Linux平台下使用 "\n"</span></span><br><span class="line">    <span class="comment">// 给服务器发送信息直到程序退出：</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"What to send to the server? Type Q to quit."</span>)</span><br><span class="line">        input, _ := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">        trimmedInput := strings.Trim(input, <span class="string">"\r\n"</span>)</span><br><span class="line">        <span class="comment">// fmt.Printf("input:--%s--", input)</span></span><br><span class="line">        <span class="comment">// fmt.Printf("trimmedInput:--%s--", trimmedInput)</span></span><br><span class="line">        <span class="keyword">if</span> trimmedInput == <span class="string">"Q"</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        _, err = conn.Write([]<span class="keyword">byte</span>(trimmedClient + <span class="string">" says: "</span> + trimmedInput))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端通过<code>net.Dial</code>创建了一个和服务器之间的连接  </p>
<p>它通过无限循环中的os.Stdin接收来自键盘的输入直到输入了“Q”。注意使用<code>\r</code>和<code>\n</code>换行符分割字符串（在windows平台下使用<code>\r\n</code>）。接下来分割后的输入通过<code>connection</code>的<code>Write</code>方法被发送到服务器。  </p>
<p>当然，服务器必须先启动好，如果服务器并未开始监听，客户端是无法成功连接的。  </p>
<p>如果在服务器没有开始监听的情况下运行客户端程序，客户端会停止并打印出以下错误信息：<code>对tcp 127.0.0.1:50000发起连接时产生错误：由于目标计算机的积极拒绝而无法创建连接</code>。  </p>
<p>打开控制台并转到服务器和客户端可执行程序所在的目录，Windows系统下输入server.exe（或者只输入server），Linux系统下输入./server。  </p>
<p>接下来控制台出现以下信息：<code>Starting the server ...</code>  </p>
<p>在Windows系统中，我们可以通过CTRL/C停止程序。  </p>
<p>然后开启2个或者3个独立的控制台窗口，然后分别输入client回车启动客户端程序  </p>
<p>以下是服务器的输出：  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting the<span class="built_in"> Server </span><span class="built_in">..</span>.</span><br><span class="line">Received data: IVO says: Hi Server, what<span class="string">'s up ?</span></span><br><span class="line"><span class="string">Received data: CHRIS says: Are you busy server ?</span></span><br><span class="line"><span class="string">Received data: MARC says: Don'</span>t forget our appointment tomorrow !</span><br></pre></td></tr></table></figure>
<p>当客户端输入 Q 并结束程序时，服务器会输出以下信息：  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">Error</span> reading WSARecv tcp 127.0.0.1:50000: The specified<span class="built_in"> network </span>name is <span class="literal">no</span> longer available.</span><br></pre></td></tr></table></figure>
<p>在网络编程中<code>net.Dial</code>函数是非常重要的，一旦你连接到远程系统，就会返回一个Conn类型接口，我们可以用它发送和接收数据。<code>Dial</code>函数巧妙的抽象了网络结构及传输。所以IPv4或者IPv6，TCP或者UDP都可以使用这个公用接口。  </p>
<p>下边这个示例先使用TCP协议连接远程80端口，然后使用UDP协议连接，最后使用TCP协议连接IPv6类型的地址：  </p>
<p>示例 15.3 dial.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make a connection with www.example.org:</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"192.0.32.10:80"</span>) <span class="comment">// tcp ipv4</span></span><br><span class="line">    checkConnection(conn, err)</span><br><span class="line">    conn, err = net.Dial(<span class="string">"udp"</span>, <span class="string">"192.0.32.10:80"</span>) <span class="comment">// udp</span></span><br><span class="line">    checkConnection(conn, err)</span><br><span class="line">    conn, err = net.Dial(<span class="string">"tcp"</span>, <span class="string">"[2620:0:2d0:200::10]:80"</span>) <span class="comment">// tcp ipv6</span></span><br><span class="line">    checkConnection(conn, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkConnection</span><span class="params">(conn net.Conn, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"error %v connecting!"</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Connection is made with %v\n"</span>, conn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下边也是一个使用net包从socket中打开，写入，读取数据的例子：  </p>
<p>示例 15.4 socket.go  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        host          = <span class="string">"www.apache.org"</span></span><br><span class="line">        port          = <span class="string">"80"</span></span><br><span class="line">        remote        = host + <span class="string">":"</span> + port</span><br><span class="line">        msg    <span class="keyword">string</span> = <span class="string">"GET / \n"</span></span><br><span class="line">        data          = <span class="built_in">make</span>([]<span class="keyword">uint8</span>, <span class="number">4096</span>)</span><br><span class="line">        read          = <span class="literal">true</span></span><br><span class="line">        count         = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 创建一个socket</span></span><br><span class="line">    con, err := net.Dial(<span class="string">"tcp"</span>, remote)</span><br><span class="line">    <span class="comment">// 发送我们的消息，一个http GET请求</span></span><br><span class="line">    io.WriteString(con, msg)</span><br><span class="line">    <span class="comment">// 读取服务器的响应</span></span><br><span class="line">    <span class="keyword">for</span> read &#123;</span><br><span class="line">        count, err = con.Read(data)</span><br><span class="line">        read = (err == <span class="literal">nil</span>)</span><br><span class="line">        fmt.Printf(<span class="keyword">string</span>(data[<span class="number">0</span>:count]))</span><br><span class="line">    &#125;</span><br><span class="line">    con.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个简单的网页服务器"><a href="#一个简单的网页服务器" class="headerlink" title="一个简单的网页服务器"></a>一个简单的网页服务器</h2><p>Http是一个比tcp更高级的协议，它描述了客户端浏览器如何与网页服务器进行通信。Go有自己的<code>net/http</code>包，我们来看看它。我们从一些简单的示例开始，<br>首先编写一个“Hello world!”：查看示例15.6  </p>
<p>我们引入了<code>http</code>包并启动了网页服务器，和15.1的<code>net.Listen(&quot;tcp&quot;, &quot;localhost:50000&quot;)</code>函数的tcp服务器是类似的，使用<code>http.ListenAndServe(&quot;localhost:8080&quot;, nil)</code>函数，如果成功会返回空，否则会返回一个错误（可以指定localhost为其他地址，8080是指定的端口号）  </p>
<p><code>http.URL</code>描述了web服务器的地址，内含存放了url字符串的<code>Path</code>属性；<code>http.Request</code>描述了客户端请求，内含一个<code>URL</code>属性  </p>
<p>如果<code>req</code>请求是一个POST类型的html表单，“var1”就是html表单中一个输入属性的名称，然后用户输入的值就可以通过GO代码：<code>req.FormValue(&quot;var1&quot;)</code>获取到（请看<a href="15.4.md">章节15.4</a>）。还有一种方法就是先执行<code>request.ParseForm()</code>然后再获取<code>request.Form[&quot;var1&quot;]</code>的第一个返回参数，就像这样：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var1, found := request.Form[<span class="string">"var1"</span>]</span><br></pre></td></tr></table></figure>
<p>第二个参数<code>found</code>就是<code>true</code>，如果<code>var1</code>并未出现在表单中，<code>found</code>就是<code>false</code>  </p>
<p>表单属性实际上是一个<code>map[string][]string</code>类型。网页服务器返回了一个<code>http.Response</code>，它是通过<code>http.ResponseWriter</code>对象输出的，这个对象整合了HTTP服务器的返回结果；通过对它写入内容，我们就将数据发送给了HTTP客户端。  </p>
<p>现在我们还需要编写网页服务器必须执行的程序，它是如何处理请求的呢。这是在<code>http.HandleFunc</code>函数中完成的，就是在这个例子中当根路径“/”（url地址是<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ）被请求的时候（或者这个服务器上的其他地址），<code>HelloServer</code>函数就被执行了。这个函数是<code>http.HandlerFunc</code>类型的，它们通常用使用Prehandler来命名，在前边加了一个Pref前缀。  </p>
<p><code>http.HandleFunc</code>注册了一个处理函数(这里是<code>HelloServer</code>)来处理对应<code>/</code>的请求。  </p>
<p><code>/</code>可以被替换为其他特定的url比如<code>/create</code>，<code>/edit</code>等等；你可以为每一个特定的url定义一个单独的处理函数。这个函数需要两个参数：第一个是<code>ReponseWriter</code>类型的<code>w</code>；第二个是请求<code>req</code>。程序向<code>w</code>写入了<code>Hello</code>和<code>r.URL.Path[1:]</code>组成的字符串后边的<code>[1:]</code>表示“创建一个从第一个字符到结尾的子切片”，用来丢弃掉路径开头的“/”，<code>fmt.Fprintf()</code>函数完成了本次写入（请看章节12.8）；另外一种写法是<code>io.WriteString(w, &quot;hello, world!\n&quot;)</code>  </p>
<p>总结：第一个参数是请求的路径，第二个参数是处理这个路径请求的函数的引用。  </p>
<p>示例 15.6 hello_world_webserver.go  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloServer</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Inside HelloServer handler"</span>)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello,"</span>+req.URL.Path[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, HelloServer)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">"localhost:8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用命令行启动程序，会打开一个命令窗口显示如下文字：  </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting Process <span class="string">E:</span><span class="regexp">/Go/</span>GoBoek<span class="regexp">/code_examples/</span>chapter_14/hello_world_webserver.exe</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后打开你的浏览器并输入url地址：<code>http://localhost:8080/world</code>，浏览器就会出现文字：<code>Hello, world</code>，网页服务器会响应你在<code>:8080/</code>后边输入的内容  </p>
<p>使用<code>fmt.Println</code>在控制台打印状态，在每个handler被请求的时候，在他们内部打印日志会很有帮助  </p>
<p>注：<br>1）前两行（没有错误处理代码）可以替换成以下写法：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, http.HandlerFunc(HelloServer))</span><br></pre></td></tr></table></figure>
<p>2）<code>fmt.Fprint</code>和<code>fmt.Fprintf</code>都是用来写入<code>http.ResponseWriter</code>的不错的函数（他们实现了<code>io.Writer</code>）。<br>比如我们可以使用  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Fprintf(w, <span class="string">"&lt;h1&gt;%s&lt;h1&gt;&lt;div&gt;%s&lt;/div&gt;"</span>, title, body)</span><br></pre></td></tr></table></figure>
<p>来构建一个非常简单的网页并插入<code>title</code>和<code>body</code>的值  </p>
<p>如果你需要更多复杂的替换，使用模板包（请看章节15.7）<br>3）如果你需要使用安全的https连接，使用<code>http.ListenAndServeTLS()</code>代替<code>http.ListenAndServe()</code><br>4）<code>http.HandleFunc(&quot;/&quot;, Hfunc)</code>中的<code>HFunc</code>是一个处理函数，如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HFunc</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用这种方式：<code>http.Handle(&quot;/&quot;, http.HandlerFunc(HFunc))</code>  </p>
<p>上边的<code>HandlerFunc</code>只是一个类型名称，它定义如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure>
<p>它是一个可以把普通的函数当做HTTP处理器的适配器。如果<code>f</code>函数声明的合适，<code>HandlerFunc(f)</code>就是一个执行了<code>f</code>函数的处理器对象。  </p>
<p><code>http.Handle</code>的第二个参数也可以是<code>T</code>的一个obj对象：<code>http.Handle(&quot;/&quot;, obj)</code>给T提供了<code>ServeHTTP</code>方法，实现了http的<code>Handler</code>接口：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(obj *Typ)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个用法在章节15.8类型<code>Counter</code>和<code>Chan</code>上使用过。只要实现了<code>http.Handler</code>，<code>http</code>包就可以处理任何HTTP请求。  </p>
<h2 id="访问并读取页面"><a href="#访问并读取页面" class="headerlink" title="访问并读取页面"></a>访问并读取页面</h2><p>在下边这个程序中，数组中的url都将被访问：会发送一个简单的<code>http.Head()</code>请求查看返回值；它的声明如下：<code>func Head(url string) (r *Response, err error)</code>  </p>
<p>返回状态码会被打印出来。  </p>
<p>示例 15.7 poll_url.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"http://www.google.com/"</span>,</span><br><span class="line">    <span class="string">"http://golang.org/"</span>,</span><br><span class="line">    <span class="string">"http://blog.golang.org/"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Execute an HTTP HEAD request for all url's</span></span><br><span class="line">    <span class="comment">// and returns the HTTP status string or an error string.</span></span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">        resp, err := http.Head(url)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Error:"</span>, url, err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(url, <span class="string">": "</span>, resp.Status)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：  </p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//www.google.com/ : 302 Found</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//golang.org/ : 200 OK</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//blog.golang.org/ : 200 OK</span></span><br></pre></td></tr></table></figure>
<p><strong><em>译者注</em></strong> 由于国内的网络环境现状，很有可能见到如下超时错误提示：  </p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>http://www.google.com/ Head http://www.google.com/: dial tcp 216.58.221.100:80: connectex: A connection attempt failed because the connected pa</span><br><span class="line">rty did not properly respond after a period of time, or established connection failed because connected host has failed to respond.</span><br></pre></td></tr></table></figure>
<p>在下边的程序中我们使用<code>http.Get()</code>获取网页内容； <code>Get</code>的返回值<code>res</code>中的<code>Body</code>属性包含了网页内容，然后我们用<code>ioutil.ReadAll</code>把它读出来：  </p>
<p>示例 15.8 http_fetch.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res, err := http.Get(<span class="string">"http://www.google.com"</span>)</span><br><span class="line">    checkError(err)</span><br><span class="line">    data, err := ioutil.ReadAll(res.Body)</span><br><span class="line">    checkError(err)</span><br><span class="line">    fmt.Printf(<span class="string">"Got: %q"</span>, <span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"Get : %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问不存在的网站时，这里有一个<code>CheckError</code>输出错误的例子：  </p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2011</span>/<span class="number">09</span>/<span class="number">30</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">15</span> Get: Get http:<span class="comment">//www.google.bex: dial tcp www.google.bex:80:GetHostByName: No such host is known.</span></span><br></pre></td></tr></table></figure>
<p><strong><em>译者注</em></strong> 和上一个例子相似，你可以把google.com更换为一个国内可以顺畅访问的网址进行测试  </p>
<p>在下边的程序中，我们获取一个twitter用户的状态，通过<code>xml</code>包将这个状态解析成为一个结构：  </p>
<p>示例 15.9 twitter_status.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/xml"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这个结构会保存解析后的返回数据。</span></span><br><span class="line"><span class="comment">他们会形成有层级的XML，可以忽略一些无用的数据*/</span></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">    Text <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    XMLName xml.Name</span><br><span class="line">    Status  Status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 发起请求查询推特Goodland用户的状态</span></span><br><span class="line">    response, _ := http.Get(<span class="string">"http://twitter.com/users/Googland.xml"</span>)</span><br><span class="line">    <span class="comment">// 初始化XML返回值的结构</span></span><br><span class="line">    user := User&#123;xml.Name&#123;<span class="string">""</span>, <span class="string">"user"</span>&#125;, Status&#123;<span class="string">""</span>&#125;&#125;</span><br><span class="line">    <span class="comment">// 将XML解析为我们的结构</span></span><br><span class="line">    xml.Unmarshal(response.Body, &amp;user)</span><br><span class="line">    fmt.Printf(<span class="string">"status: %s"</span>, user.Status.Text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：  </p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status: Robot cars invade California, on orders from Google: Google has been testing self-driving cars ... http:<span class="regexp">//</span>bit.ly<span class="regexp">/cbtpUN http:/</span><span class="regexp">/retwt.me/</span><span class="number">97</span>p&lt;<span class="keyword">exit</span> code=<span class="string">"0"</span> msg=<span class="string">"process exited normally"</span><span class="regexp">/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>译者注</strong> 和上边的示例相似，你可能无法获取到xml数据，另外由于go版本的更新，<code>xml.Unmarshal</code>函数的第一个参数需是[]byte类型，而无法传入<code>Body</code>。  </p>
<p>我们会在章节15.4中用到<code>http</code>包中的其他重要的函数：  </p>
<ul>
<li><code>http.Redirect(w ResponseWriter, r *Request, url string, code int)</code>：这个函数会让浏览器重定向到url（是请求的url的相对路径）以及状态码。</li>
<li><code>http.NotFound(w ResponseWriter, r *Request)</code>：这个函数将返回网页没有找到，HTTP 404错误。</li>
<li><code>http.Error(w ResponseWriter, error string, code int)</code>：这个函数返回特定的错误信息和HTTP代码。</li>
<li>另<code>http.Request</code>对象的一个重要属性<code>req</code>：<code>req.Method</code>，这是一个包含<code>GET</code>或<code>POST</code>字符串，用来描述网页是以何种方式被请求的。</li>
</ul>
<p>go为所有的HTTP状态码定义了常量，比如：  </p>
<pre><code>http.StatusContinue     = 100
http.StatusOK           = 200
http.StatusFound        = 302
http.StatusBadRequest       = 400
http.StatusUnauthorized     = 401
http.StatusForbidden        = 403
http.StatusNotFound     = 404
http.StatusInternalServerError  = 500</code></pre><p>你可以使用<code>w.header().Set(&quot;Content-Type&quot;, &quot;../..&quot;)</code>设置头信息  </p>
<p>比如在网页应用发送html字符串的时候，在输出之前执行<code>w.Header().Set(&quot;Content-Type&quot;, &quot;text/html&quot;)</code>。  </p>
<h2 id="写一个简单的网页应用"><a href="#写一个简单的网页应用" class="headerlink" title="写一个简单的网页应用"></a>写一个简单的网页应用</h2><p>下边的程序在端口8088上启动了一个网页服务器；<code>SimpleServer</code>会处理<code>/test1</code>url使它在浏览器输出<code>hello world</code>。<code>FormServer</code>会处理<code>/test2</code>url：如果url最初由浏览器请求，那么它就是一个<code>GET</code>请求，并且返回一个<code>form</code>常量，包含了简单的<code>input</code>表单，这个表单里有一个文本框和一个提交按钮。当在文本框输入一些东西并点击提交按钮的时候，会发起一个<code>POST</code>请求。<code>FormServer</code>中的代码用到了<code>switch</code>来区分两种情况。在<code>POST</code>情况下，使用<code>request.FormValue(&quot;inp&quot;)</code>通过文本框的<code>name</code>属性<code>inp</code>来获取内容，并写回浏览器页面。在控制台启动程序并在浏览器中打开url<code>http://localhost:8088/test2</code>来测试这个程序：</p>
<p>示例 15.10 simple_webserver.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> form = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;form action="#" method="post" name="bar"&gt;</span></span><br><span class="line"><span class="string">            &lt;input type="text" name="in" /&gt;</span></span><br><span class="line"><span class="string">            &lt;input type="submit" value="submit"/&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* handle a simple get request */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleServer</span><span class="params">(w http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    io.WriteString(w, <span class="string">"&lt;h1&gt;hello, world&lt;/h1&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormServer</span><span class="params">(w http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">    <span class="keyword">switch</span> request.Method &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"GET"</span>:</span><br><span class="line">        <span class="comment">/* display the form to the user */</span></span><br><span class="line">        io.WriteString(w, form)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"POST"</span>:</span><br><span class="line">        <span class="comment">/* handle the form data, note that ParseForm must</span></span><br><span class="line"><span class="comment">           be called before we can extract form data */</span></span><br><span class="line">        <span class="comment">//request.ParseForm();</span></span><br><span class="line">        <span class="comment">//io.WriteString(w, request.Form["in"][0])</span></span><br><span class="line">        io.WriteString(w, request.FormValue(<span class="string">"in"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/test1"</span>, SimpleServer)</span><br><span class="line">    http.HandleFunc(<span class="string">"/test2"</span>, FormServer)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8088"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：当使用字符串常量表示html文本的时候，包含<code>&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code>对于让浏览器识别它收到了一个html非常重要。  </p>
<p>更安全的做法是在处理器中使用<code>w.Header().Set(&quot;Content-Type&quot;, &quot;text/html&quot;)</code>在写入返回之前将<code>header</code>的<code>content-type</code>设置为<code>text/html</code>  </p>
<p><code>content-type</code>会让浏览器认为它可以使用函数<code>http.DetectContentType([]byte(form))</code>来处理收到的数据  </p>
<hr>
<h1 id="常用资料"><a href="#常用资料" class="headerlink" title="常用资料"></a>常用资料</h1><h2 id="Go-关键字"><a href="#Go-关键字" class="headerlink" title="Go 关键字"></a>Go 关键字</h2><ul>
<li><p>25 个关键字  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>      <span class="keyword">default</span>       <span class="function"><span class="keyword">func</span>     <span class="title">interface</span>   <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>       <span class="keyword">defer</span>         <span class="keyword">go</span>       <span class="keyword">map</span>         <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>       <span class="keyword">else</span>          <span class="keyword">goto</span>     <span class="keyword">package</span>     <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>      <span class="keyword">fallthrough</span>   <span class="keyword">if</span>       <span class="keyword">range</span>       <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>   <span class="keyword">for</span>           <span class="keyword">import</span>   <span class="keyword">return</span>      <span class="keyword">var</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>36 个预定义标识符  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内建常量: <span class="literal">true</span> <span class="literal">false</span> <span class="literal">iota</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">内建类型: <span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span></span><br><span class="line">          <span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line">          <span class="keyword">float32</span> <span class="keyword">float64</span> <span class="keyword">complex128</span> <span class="keyword">complex64</span></span><br><span class="line">          <span class="keyword">bool</span> <span class="keyword">byte</span> <span class="keyword">rune</span> <span class="keyword">string</span> error</span><br><span class="line"></span><br><span class="line">内建函数: <span class="built_in">make</span> <span class="built_in">len</span> <span class="built_in">cap</span> <span class="built_in">new</span> <span class="built_in">append</span> <span class="built_in">copy</span> <span class="built_in">close</span> <span class="built_in">delete</span></span><br><span class="line">          <span class="built_in">complex</span> <span class="built_in">real</span> <span class="built_in">imag</span></span><br><span class="line">          <span class="built_in">panic</span> <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="文件读写参数"><a href="#文件读写参数" class="headerlink" title="文件读写参数"></a>文件读写参数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span></span><br><span class="line"></span><br><span class="line">第二个参数</span><br><span class="line">O_RDONLY    打开只读文件</span><br><span class="line">O_WRONLY    打开只写文件</span><br><span class="line">O_RDWR  打开既可以读取又可以写入文件</span><br><span class="line">O_APPEND    写入文件时将数据追加到文件尾部</span><br><span class="line">O_CREATE    如果文件不存在，则创建一个新的文件</span><br><span class="line">O_EXCL  文件必须不存在，然后会创建一个新的文件</span><br><span class="line">O_SYNC  打开同步I/<span class="number">0</span></span><br><span class="line">O_TRUNC 文件打开时可以截断</span><br><span class="line"></span><br><span class="line">第三个参数就是权限模式</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/07/Hello-World/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/11/Go-Common-Mistakes/" rel="next" title="Go 中常见错误">
      Go 中常见错误 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#声明"><span class="nav-number">1.</span> <span class="nav-text">声明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">1.1.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单变量声明"><span class="nav-number">1.1.1.</span> <span class="nav-text">单变量声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多变量声明"><span class="nav-number">1.1.2.</span> <span class="nav-text">多变量声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">1.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单维数组声明"><span class="nav-number">1.2.1.</span> <span class="nav-text">单维数组声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多维数组"><span class="nav-number">1.2.2.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组操作"><span class="nav-number">1.2.3.</span> <span class="nav-text">数组操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切片"><span class="nav-number">1.3.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#切片声明"><span class="nav-number">1.3.1.</span> <span class="nav-text">切片声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切片的操作"><span class="nav-number">1.3.2.</span> <span class="nav-text">切片的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切片和垃圾回收"><span class="nav-number">1.3.3.</span> <span class="nav-text">切片和垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针"><span class="nav-number">1.4.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指针声明"><span class="nav-number">1.4.1.</span> <span class="nav-text">指针声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组指针"><span class="nav-number">1.4.2.</span> <span class="nav-text">数组指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体"><span class="nav-number">1.5.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义结构体"><span class="nav-number">1.5.1.</span> <span class="nav-text">定义结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体指针"><span class="nav-number">1.5.2.</span> <span class="nav-text">结构体指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用工厂方法创建结构体实例"><span class="nav-number">1.5.3.</span> <span class="nav-text">使用工厂方法创建结构体实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带标签的结构体"><span class="nav-number">1.5.4.</span> <span class="nav-text">带标签的结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名字段和内嵌结构体"><span class="nav-number">1.5.5.</span> <span class="nav-text">匿名字段和内嵌结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-number">1.6.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数和方法的区别"><span class="nav-number">1.6.1.</span> <span class="nav-text">函数和方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法和未导出字段"><span class="nav-number">1.6.2.</span> <span class="nav-text">方法和未导出字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内嵌类型的方法和继承"><span class="nav-number">1.6.3.</span> <span class="nav-text">内嵌类型的方法和继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在类型中嵌入功能"><span class="nav-number">1.6.4.</span> <span class="nav-text">在类型中嵌入功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多重继承"><span class="nav-number">1.6.5.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和其他面向对象语言比较-Go-的类型和方法"><span class="nav-number">1.6.6.</span> <span class="nav-text">和其他面向对象语言比较 Go 的类型和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型的-String-方法和格式化描述符"><span class="nav-number">1.6.7.</span> <span class="nav-text">类型的 String() 方法和格式化描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-集合"><span class="nav-number">1.7.</span> <span class="nav-text">Map(集合)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map的基本操作"><span class="nav-number">1.7.1.</span> <span class="nav-text">Map的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用切片作为-map-的值"><span class="nav-number">1.7.2.</span> <span class="nav-text">用切片作为 map 的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-类型的切片"><span class="nav-number">1.7.3.</span> <span class="nav-text">map 类型的切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-的排序"><span class="nav-number">1.7.4.</span> <span class="nav-text">map 的排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针-1"><span class="nav-number">1.8.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口（Interfaces）与反射（reflection）"><span class="nav-number">1.9.</span> <span class="nav-text">接口（Interfaces）与反射（reflection）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#接口嵌套接口"><span class="nav-number">1.9.1.</span> <span class="nav-text">接口嵌套接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型断言：如何检测和转换接口变量的类型"><span class="nav-number">1.9.2.</span> <span class="nav-text">类型断言：如何检测和转换接口变量的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型判断（选择）：type-switch"><span class="nav-number">1.9.3.</span> <span class="nav-text">类型判断（选择）：type-switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试一个值是否实现了某个接口"><span class="nav-number">1.9.4.</span> <span class="nav-text">测试一个值是否实现了某个接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用方法集与接口"><span class="nav-number">1.9.5.</span> <span class="nav-text">使用方法集与接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一个例子：使用-Sorter-接口排序"><span class="nav-number">1.9.6.</span> <span class="nav-text">第一个例子：使用 Sorter 接口排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二个例子：读和写"><span class="nav-number">1.9.7.</span> <span class="nav-text">第二个例子：读和写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空接口"><span class="nav-number">1.9.8.</span> <span class="nav-text">空接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建通用类型或包含不同类型变量的数组"><span class="nav-number">1.9.9.</span> <span class="nav-text">构建通用类型或包含不同类型变量的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制数据切片至空接口切片"><span class="nav-number">1.9.10.</span> <span class="nav-text">复制数据切片至空接口切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用类型的节点数据结构"><span class="nav-number">1.9.11.</span> <span class="nav-text">通用类型的节点数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口到接口"><span class="nav-number">1.9.12.</span> <span class="nav-text">接口到接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射包"><span class="nav-number">1.9.13.</span> <span class="nav-text">反射包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Printf-和反射"><span class="nav-number">1.9.14.</span> <span class="nav-text">Printf 和反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口与动态类型"><span class="nav-number">1.9.15.</span> <span class="nav-text">接口与动态类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结：Go-中的面向对象"><span class="nav-number">1.9.16.</span> <span class="nav-text">总结：Go 中的面向对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用包"><span class="nav-number">2.</span> <span class="nav-text">常用包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#strings-包"><span class="nav-number">2.1.</span> <span class="nav-text">strings 包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前、后缀"><span class="nav-number">2.1.1.</span> <span class="nav-text">前、后缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串包含关系"><span class="nav-number">2.1.2.</span> <span class="nav-text">字符串包含关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引字符串位置"><span class="nav-number">2.1.3.</span> <span class="nav-text">索引字符串位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串替换"><span class="nav-number">2.1.4.</span> <span class="nav-text">字符串替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#统计字符串出现的次数"><span class="nav-number">2.1.5.</span> <span class="nav-text">统计字符串出现的次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复字符串"><span class="nav-number">2.1.6.</span> <span class="nav-text">重复字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改字符串大小写"><span class="nav-number">2.1.7.</span> <span class="nav-text">修改字符串大小写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修剪字符串"><span class="nav-number">2.1.8.</span> <span class="nav-text">修剪字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分割字符串"><span class="nav-number">2.1.9.</span> <span class="nav-text">分割字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拼接-slice-到字符串"><span class="nav-number">2.1.10.</span> <span class="nav-text">拼接 slice 到字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从字符串中读取内容"><span class="nav-number">2.1.11.</span> <span class="nav-text">从字符串中读取内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Strconv-包"><span class="nav-number">2.2.</span> <span class="nav-text">Strconv 包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#time-包：时间和日期"><span class="nav-number">2.3.</span> <span class="nav-text">time 包：时间和日期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#控制结构"><span class="nav-number">3.</span> <span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if-else-结构"><span class="nav-number">3.1.</span> <span class="nav-text">if-else 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#comma-ok模式（pattern）"><span class="nav-number">3.1.1.</span> <span class="nav-text">comma,ok模式（pattern）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-结构"><span class="nav-number">3.2.</span> <span class="nav-text">switch 结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-结构"><span class="nav-number">3.3.</span> <span class="nav-text">for 结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计数器形式"><span class="nav-number">3.3.1.</span> <span class="nav-text">计数器形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件判断的迭代形式"><span class="nav-number">3.3.2.</span> <span class="nav-text">条件判断的迭代形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无限循环"><span class="nav-number">3.3.3.</span> <span class="nav-text">无限循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-range-结构"><span class="nav-number">3.3.4.</span> <span class="nav-text">for-range 结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Break-与-continue"><span class="nav-number">3.4.</span> <span class="nav-text">Break 与 continue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标签与-goto"><span class="nav-number">3.5.</span> <span class="nav-text">标签与 goto</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#传参和返回"><span class="nav-number">4.1.</span> <span class="nav-text">传参和返回</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传递变长参数"><span class="nav-number">4.2.</span> <span class="nav-text">传递变长参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer-和追踪"><span class="nav-number">4.3.</span> <span class="nav-text">defer 和追踪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内置函数"><span class="nav-number">4.4.</span> <span class="nav-text">内置函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归函数"><span class="nav-number">4.5.</span> <span class="nav-text">递归函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数作为参数"><span class="nav-number">4.6.</span> <span class="nav-text">函数作为参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">4.7.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defer语句和匿名函数"><span class="nav-number">4.7.1.</span> <span class="nav-text">defer语句和匿名函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用闭包：将函数作为返回值"><span class="nav-number">4.8.</span> <span class="nav-text">应用闭包：将函数作为返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用闭包调试"><span class="nav-number">4.9.</span> <span class="nav-text">使用闭包调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算函数执行时间"><span class="nav-number">4.10.</span> <span class="nav-text">计算函数执行时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过内存缓存来提升性能"><span class="nav-number">4.11.</span> <span class="nav-text">通过内存缓存来提升性能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#包（package）"><span class="nav-number">5.</span> <span class="nav-text">包（package）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库"><span class="nav-number">5.1.</span> <span class="nav-text">标准库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#regexp-包"><span class="nav-number">5.2.</span> <span class="nav-text">regexp 包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁和-sync-包"><span class="nav-number">5.3.</span> <span class="nav-text">锁和 sync 包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#精密计算和-big-包"><span class="nav-number">5.4.</span> <span class="nav-text">精密计算和 big 包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义包和可见性"><span class="nav-number">5.5.</span> <span class="nav-text">自定义包和可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为自定义包使用-godoc"><span class="nav-number">5.6.</span> <span class="nav-text">为自定义包使用 godoc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-go-install-安装自定义包"><span class="nav-number">5.7.</span> <span class="nav-text">使用 go install 安装自定义包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义包的目录结构、go-install-和-go-test"><span class="nav-number">5.8.</span> <span class="nav-text">自定义包的目录结构、go install 和 go test</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-Git-打包和安装"><span class="nav-number">5.9.</span> <span class="nav-text">通过 Git 打包和安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-的外部包和项目"><span class="nav-number">5.10.</span> <span class="nav-text">Go 的外部包和项目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-Go-程序中使用外部库"><span class="nav-number">5.11.</span> <span class="nav-text">在 Go 程序中使用外部库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读写数据"><span class="nav-number">6.</span> <span class="nav-text">读写数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#读取用户的输入"><span class="nav-number">6.1.</span> <span class="nav-text">读取用户的输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件读写"><span class="nav-number">6.2.</span> <span class="nav-text">文件读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读文件"><span class="nav-number">6.2.1.</span> <span class="nav-text">读文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compress-包：读取压缩文件"><span class="nav-number">6.2.2.</span> <span class="nav-text">compress 包：读取压缩文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写文件"><span class="nav-number">6.2.3.</span> <span class="nav-text">写文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件拷贝"><span class="nav-number">6.3.</span> <span class="nav-text">文件拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从命令行读参数"><span class="nav-number">6.4.</span> <span class="nav-text">从命令行读参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#os-包"><span class="nav-number">6.4.1.</span> <span class="nav-text">os 包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flag-包"><span class="nav-number">6.4.2.</span> <span class="nav-text">flag 包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-buffer-读取文件"><span class="nav-number">6.5.</span> <span class="nav-text">用 buffer 读取文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用切片读写文件"><span class="nav-number">6.6.</span> <span class="nav-text">用切片读写文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-defer-关闭文件"><span class="nav-number">6.7.</span> <span class="nav-text">用 defer 关闭文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用接口的实际例子：fmt-Fprintf"><span class="nav-number">6.8.</span> <span class="nav-text">使用接口的实际例子：fmt.Fprintf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-数据格式"><span class="nav-number">6.9.</span> <span class="nav-text">JSON 数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XML-数据格式"><span class="nav-number">6.10.</span> <span class="nav-text">XML 数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-Gob-传输数据"><span class="nav-number">6.11.</span> <span class="nav-text">用 Gob 传输数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-中的密码学"><span class="nav-number">6.12.</span> <span class="nav-text">Go 中的密码学</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误处理与测试"><span class="nav-number">7.</span> <span class="nav-text">错误处理与测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#错误处理"><span class="nav-number">7.1.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义错误"><span class="nav-number">7.1.1.</span> <span class="nav-text">定义错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-fmt-创建错误对象"><span class="nav-number">7.1.2.</span> <span class="nav-text">用 fmt 创建错误对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时异常和-panic"><span class="nav-number">7.2.</span> <span class="nav-text">运行时异常和 panic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从-panic-中恢复（Recover）"><span class="nav-number">7.3.</span> <span class="nav-text">从 panic 中恢复（Recover）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义包中的错误处理和-panicking"><span class="nav-number">7.4.</span> <span class="nav-text">自定义包中的错误处理和 panicking</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一种用闭包处理错误的模式"><span class="nav-number">7.5.</span> <span class="nav-text">一种用闭包处理错误的模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动外部命令和程序"><span class="nav-number">7.6.</span> <span class="nav-text">启动外部命令和程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-中的单元测试和基准测试"><span class="nav-number">7.7.</span> <span class="nav-text">Go 中的单元测试和基准测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能调试：分析并优化-Go-程序"><span class="nav-number">7.8.</span> <span class="nav-text">性能调试：分析并优化 Go 程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#协程（goroutine）与通道（channel）"><span class="nav-number">8.</span> <span class="nav-text">协程（goroutine）与通道（channel）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发、并行和协程"><span class="nav-number">8.1.</span> <span class="nav-text">并发、并行和协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发和并行的差异"><span class="nav-number">8.1.1.</span> <span class="nav-text">并发和并行的差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-GOMAXPROCS"><span class="nav-number">8.1.2.</span> <span class="nav-text">使用 GOMAXPROCS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何用命令行指定使用的核心数量"><span class="nav-number">8.1.3.</span> <span class="nav-text">如何用命令行指定使用的核心数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-协程（goroutines）和协程（coroutines）"><span class="nav-number">8.1.4.</span> <span class="nav-text">Go 协程（goroutines）和协程（coroutines）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程间的信道"><span class="nav-number">8.2.</span> <span class="nav-text">协程间的信道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">8.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通信操作符-lt"><span class="nav-number">8.2.2.</span> <span class="nav-text">通信操作符 &lt;-</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道阻塞"><span class="nav-number">8.2.3.</span> <span class="nav-text">通道阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过一个（或多个）通道交换数据进行协程同步"><span class="nav-number">8.2.4.</span> <span class="nav-text">通过一个（或多个）通道交换数据进行协程同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步通道-使用带缓冲的通道"><span class="nav-number">8.2.5.</span> <span class="nav-text">同步通道-使用带缓冲的通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协程中用通道输出结果"><span class="nav-number">8.2.6.</span> <span class="nav-text">协程中用通道输出结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量模式"><span class="nav-number">8.2.7.</span> <span class="nav-text">信号量模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现并行的-for-循环"><span class="nav-number">8.2.8.</span> <span class="nav-text">实现并行的 for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用带缓冲通道实现一个信号量"><span class="nav-number">8.2.9.</span> <span class="nav-text">用带缓冲通道实现一个信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给通道使用-for-循环"><span class="nav-number">8.2.10.</span> <span class="nav-text">给通道使用 for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道的方向"><span class="nav-number">8.2.11.</span> <span class="nav-text">通道的方向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程的同步：关闭通道-测试阻塞的通道"><span class="nav-number">8.3.</span> <span class="nav-text">协程的同步：关闭通道-测试阻塞的通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-select-切换协程"><span class="nav-number">8.4.</span> <span class="nav-text">使用 select 切换协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通道、超时和计时器（Ticker）"><span class="nav-number">8.5.</span> <span class="nav-text">通道、超时和计时器（Ticker）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协程和恢复（recover）"><span class="nav-number">8.6.</span> <span class="nav-text">协程和恢复（recover）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新旧模型对比：任务和worker-（锁vs协程）"><span class="nav-number">8.7.</span> <span class="nav-text">新旧模型对比：任务和worker （锁vs协程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#惰性生成器的实现"><span class="nav-number">8.8.</span> <span class="nav-text">惰性生成器的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现-Futures-模式"><span class="nav-number">8.9.</span> <span class="nav-text">实现 Futures 模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络，模板和网页应用"><span class="nav-number">9.</span> <span class="nav-text">网络，模板和网页应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp服务器"><span class="nav-number">9.1.</span> <span class="nav-text">tcp服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个简单的网页服务器"><span class="nav-number">9.2.</span> <span class="nav-text">一个简单的网页服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问并读取页面"><span class="nav-number">9.3.</span> <span class="nav-text">访问并读取页面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写一个简单的网页应用"><span class="nav-number">9.4.</span> <span class="nav-text">写一个简单的网页应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用资料"><span class="nav-number">10.</span> <span class="nav-text">常用资料</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-关键字"><span class="nav-number">10.1.</span> <span class="nav-text">Go 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件读写参数"><span class="nav-number">10.2.</span> <span class="nav-text">文件读写参数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rtk"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">rtk</p>
  <div class="site-description" itemprop="description">冷萃少冰不加糖</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/reitake" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;reitake" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/rrrrrtk" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;rrrrrtk" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rtk</span>
</div><span class="post-meta-item-icon">
    <i class="fa fa-clock-o"></i>
</span>
<span id="sitetime"></span>
<script language="javascript">
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
    year - 作为date对象的年份，为4位年份值
    month - 0-11之间的整数，做为date对象的月份
    day - 1-31之间的整数，做为date对象的天数
    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
    minutes - 0-59之间的整数，做为date对象的分钟数
    seconds - 0-59之间的整数，做为date对象的秒数
    microseconds - 0-999之间的整数，做为date对象的毫秒数 */
    var t1 = Date.UTC(2019,03,07,10,00,00); //建站时间
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒 ~喵~";
  }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
  siteTime();
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'FY0k4GNyVIFSqBrIxPq7yN7t-gzGzoHsz',
      appKey     : 'FqCFfTcVczkkBx9SyMlf7myz',
      placeholder: "喵w ヾﾉ≧w≦)o",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
