<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="AoeMgN9r3ZTJhZZgqjfb4tkZf3qRjujP-1gjzMb-x80">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"reitake.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Go 语言常用包笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang pkg Notes">
<meta property="og:url" content="https://reitake.github.io/2019/03/20/Golang-pkg/index.html">
<meta property="og:site_name" content="My Notes Blog">
<meta property="og:description" content="Go 语言常用包笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-03-20T14:16:19.000Z">
<meta property="article:modified_time" content="2020-12-07T13:34:32.954Z">
<meta property="article:author" content="rtk">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://reitake.github.io/2019/03/20/Golang-pkg/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Golang pkg Notes | My Notes Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">My Notes Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">生活不易 喵声叹气</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-fw fa-gears"></i>工具</a>

  </li>
        <li class="menu-item menu-item-others">

    <a href="/others/" rel="section"><i class="fa fa-fw fa-spinner"></i>不务正业</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://reitake.github.io/2019/03/20/Golang-pkg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="rtk">
      <meta itemprop="description" content="冷萃少冰不加糖">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="My Notes Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Golang pkg Notes
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-20 22:16:19" itemprop="dateCreated datePublished" datetime="2019-03-20T22:16:19+08:00">2019-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 21:34:32" itemprop="dateModified" datetime="2020-12-07T21:34:32+08:00">2020-12-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8C%E8%AF%AD%E8%A8%80%E3%80%8D-Go/" itemprop="url" rel="index"><span itemprop="name">「语言」- Go</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/03/20/Golang-pkg/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/03/20/Golang-pkg/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <center> <font color="#bababa">

<p><strong><em>Go 语言常用包笔记</em></strong></p>
<p></font></center></p>
<a id="more"></a>

<hr>
<h1 id="bufio-包"><a href="#bufio-包" class="headerlink" title="bufio 包"></a><code>bufio</code> 包</h1><p>实现了带缓存的 I/O 操作。  </p>
<h2 id="Read-相关函数"><a href="#Read-相关函数" class="headerlink" title="Read 相关函数"></a>Read 相关函数</h2><h3 id="NewReaderSize、NewReader"><a href="#NewReaderSize、NewReader" class="headerlink" title="NewReaderSize、NewReader"></a>NewReaderSize、NewReader</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="keyword">int</span>)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>

<p>NewReaderSize 将 rd 封装成一个带缓存的 bufio.Reader 对象，缓存大小由 size 指定（如果小于 16 则会被设置为 16）。  </p>
<p>如果 rd 的基类型就是有足够缓存的 bufio.Reader 类型，则直接将 rd 转换为基类型返回。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>

<p>NewReader 相当于 NewReaderSize(rd, 4096)。  </p>
<p>bufio.Reader 实现了如下接口：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io.Reader</span><br><span class="line">io.WriterTo</span><br><span class="line">io.ByteScanner</span><br><span class="line">io.RuneScanner</span><br></pre></td></tr></table></figure>

<h3 id="Peek"><a href="#Peek" class="headerlink" title="Peek"></a>Peek</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p>Peek 返回缓存的一个切片，该切片引用缓存中前 n 个字节的数据，该操作不会将数据读出，只是引用，引用的数据在下一次读取操作之前是有效的。如果切片长度小于 n，则返回一个错误信息说明原因。如果 n 大于缓存的总大小，则返回 ErrBufferFull。  </p>
<h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>Read 从 b 中读出数据到 p 中，返回读出的字节数和遇到的错误。  </p>
<p>如果缓存不为空，则只能读出缓存中的数据，不会从底层 io.Reader中提取数据，如果缓存为空，则：  </p>
<p>1、len(p) &gt;= 缓存大小，则跳过缓存，直接从底层 io.Reader 中读出到 p 中。  </p>
<p>2、len(p) &lt; 缓存大小，则先将数据从底层 io.Reader 中读取到缓存中，再从缓存读取到 p 中。  </p>
<h3 id="Buffered"><a href="#Buffered" class="headerlink" title="Buffered"></a>Buffered</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>Buffered 返回缓存中未读取的数据的长度。  </p>
<h3 id="Discard"><a href="#Discard" class="headerlink" title="Discard"></a>Discard</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Discard</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(discarded <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>Discard 跳过后续的 n 个字节的数据，返回跳过的字节数。  </p>
<p>如果结果小于 n，将返回错误信息。  </p>
<p>如果 n 小于缓存中的数据长度，则不会从底层提取数据。  </p>
<h3 id="ReadSlice"><a href="#ReadSlice" class="headerlink" title="ReadSlice"></a>ReadSlice</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadSlice</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ReadSlice 在 b 中查找 delim 并返回 delim 及其之前的所有数据。  </p>
<p>该操作会读出数据，返回的切片是已读出的数据的引用，切片中的数据在下一次读取操作之前是有效的。  </p>
<p>如果找到 delim，则返回查找结果，err 返回 nil。  </p>
<p>如果未找到 delim，则：  </p>
<p>1、缓存不满，则将缓存填满后再次查找。  </p>
<p>2、缓存是满的，则返回整个缓存，err 返回 ErrBufferFull。  </p>
<p>如果未找到 delim 且遇到错误（通常是 io.EOF），则返回缓存中的所有数据和遇到的错误。<br>因为返回的数据有可能被下一次的读写操作修改，所以大多数操作<strong>应该使用 ReadBytes 或 ReadString，它们返回的是数据的拷贝</strong>。  </p>
<h3 id="ReadLine"><a href="#ReadLine" class="headerlink" title="ReadLine"></a>ReadLine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadLine</span><span class="params">()</span> <span class="params">(line []<span class="keyword">byte</span>, isPrefix <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadLine 是一个低水平的行读取原语，大多数情况下，应该使用</span></span><br><span class="line"><span class="comment">// ReadBytes('\n') 或 ReadString('\n')，或者使用一个 Scanner。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ReadLine 通过调用 ReadSlice 方法实现，返回的也是缓存的切片。用于</span></span><br><span class="line"><span class="comment">// 读取一行数据，不包括行尾标记（\n 或 \r\n）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 只要能读出数据，err 就为 nil。如果没有数据可读，则 isPrefix 返回</span></span><br><span class="line"><span class="comment">// false，err 返回 io.EOF。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果找到行尾标记，则返回查找结果，isPrefix 返回 false。</span></span><br><span class="line"><span class="comment">// 如果未找到行尾标记，则：</span></span><br><span class="line"><span class="comment">// 1、缓存不满，则将缓存填满后再次查找。</span></span><br><span class="line"><span class="comment">// 2、缓存是满的，则返回整个缓存，isPrefix 返回 true。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 整个数据尾部“有一个换行标记”和“没有换行标记”的读取结果是一样。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果 ReadLine 读取到换行标记，则调用 UnreadByte 撤销的是换行标记，</span></span><br><span class="line"><span class="comment">// 而不是返回的数据。</span></span><br></pre></td></tr></table></figure>

<h3 id="ReadBytes、ReadString"><a href="#ReadBytes、ReadString" class="headerlink" title="ReadBytes、ReadString"></a>ReadBytes、ReadString</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ReadBytes 功能同 ReadSlice，只不过返回的是缓存的拷贝。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ReadString 功能同 ReadBytes，只不过返回的是字符串。  </p>
<h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Reset</span><span class="params">(r io.Reader)</span></span></span><br></pre></td></tr></table></figure>

<p>Reset 将 b 的底层 Reader 重新指定为 r，同时丢弃缓存中的所有数据，复位<br>所有标记和错误信息。 bufio.Reader。  </p>
<h3 id="示例1：Peek、Read、Discard、Buffered"><a href="#示例1：Peek、Read、Discard、Buffered" class="headerlink" title="示例1：Peek、Read、Discard、Buffered"></a>示例1：Peek、Read、Discard、Buffered</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sr := strings.NewReader(<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"</span>)</span><br><span class="line">    buf := bufio.NewReaderSize(sr, <span class="number">0</span>)</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(buf.Buffered()) <span class="comment">// 0</span></span><br><span class="line">    s, _ := buf.Peek(<span class="number">5</span>)</span><br><span class="line">    s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>] = <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d   %q\n"</span>, buf.Buffered(), s) <span class="comment">// 16   "abcDE"</span></span><br><span class="line"></span><br><span class="line">    buf.Discard(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n, err := <span class="number">0</span>, error(<span class="literal">nil</span>); err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        n, err = buf.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">"%d   %q   %v\n"</span>, buf.Buffered(), b[:n], err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5   "bcDEFGHIJK"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 0   "LMNOP"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 6   "QRSTUVWXYZ"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 0   "123456"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 0   "7890"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// 0   ""   EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例2：ReadLine"><a href="#示例2：ReadLine" class="headerlink" title="示例2：ReadLine"></a>示例2：ReadLine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sr := strings.NewReader(<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ\n1234567890"</span>)</span><br><span class="line">    buf := bufio.NewReaderSize(sr, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, isPrefix, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, <span class="literal">false</span>, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, isPrefix, err = buf.ReadLine()</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %t   %v\n"</span>, line, isPrefix, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFGHIJKLMNOP"   true   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// "QRSTUVWXYZ"   false   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// "1234567890"   false   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// ""   false   EOF</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部有一个换行标记</span></span><br><span class="line">    buf = bufio.NewReaderSize(strings.NewReader(<span class="string">"ABCDEFG\n"</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, isPrefix, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, <span class="literal">false</span>, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, isPrefix, err = buf.ReadLine()</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %t   %v\n"</span>, line, isPrefix, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFG"   false   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// ""   false   EOF</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部没有换行标记</span></span><br><span class="line">    buf = bufio.NewReaderSize(strings.NewReader(<span class="string">"ABCDEFG"</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, isPrefix, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, <span class="literal">false</span>, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, isPrefix, err = buf.ReadLine()</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %t   %v\n"</span>, line, isPrefix, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFG"   false   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// ""   false   EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例3：ReadSlice"><a href="#示例3：ReadSlice" class="headerlink" title="示例3：ReadSlice"></a>示例3：ReadSlice</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 尾部有换行标记</span></span><br><span class="line">    buf := bufio.NewReaderSize(strings.NewReader(<span class="string">"ABCDEFG\n"</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, err = buf.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %v\n"</span>, line, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFG\n"   &lt;nil&gt;</span></span><br><span class="line">    <span class="comment">// ""   EOF</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"----------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾部没有换行标记</span></span><br><span class="line">    buf = bufio.NewReaderSize(strings.NewReader(<span class="string">"ABCDEFG"</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line, err := []<span class="keyword">byte</span>&#123;<span class="number">0</span>&#125;, error(<span class="literal">nil</span>); <span class="built_in">len</span>(line) &gt; <span class="number">0</span> &amp;&amp; err == <span class="literal">nil</span>; &#123;</span><br><span class="line">        line, err = buf.ReadSlice(<span class="string">'\n'</span>)</span><br><span class="line">        fmt.Printf(<span class="string">"%q   %v\n"</span>, line, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// "ABCDEFG"   EOF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Write-相关函数"><a href="#Write-相关函数" class="headerlink" title="Write 相关函数"></a>Write 相关函数</h2><h3 id="NewWriterSize、NewWriter"><a href="#NewWriterSize、NewWriter" class="headerlink" title="NewWriterSize、NewWriter"></a>NewWriterSize、NewWriter</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(wr io.Writer, size <span class="keyword">int</span>)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="comment">// NewWriterSize 将 wr 封装成一个带缓存的 bufio.Writer 对象，</span></span><br><span class="line"><span class="comment">// 缓存大小由 size 指定（如果小于 4096 则会被设置为 4096）。</span></span><br><span class="line"><span class="comment">// 如果 wr 的基类型就是有足够缓存的 bufio.Writer 类型，则直接将</span></span><br><span class="line"><span class="comment">// wr 转换为基类型返回。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(wr io.Writer)</span> *<span class="title">Writer</span></span></span><br><span class="line"><span class="comment">// NewWriter 相当于 NewWriterSize(wr, 4096)</span></span><br></pre></td></tr></table></figure>

<p>bufio.Writer 实现了如下接口：  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">io</span><span class="selector-class">.Writer</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReaderFrom</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ByteWriter</span></span><br></pre></td></tr></table></figure>

<h3 id="WriteString"><a href="#WriteString" class="headerlink" title="WriteString"></a>WriteString</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<p>WriteString 功能同 Write，只不过写入的是字符串。  </p>
<h3 id="WriteRune"><a href="#WriteRune" class="headerlink" title="WriteRune"></a>WriteRune</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(size <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>WriteRune 向 b 写入 r 的 UTF-8 编码，返回 r 的编码长度。  </p>
<h3 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Flush</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Flush 将缓存中的数据提交到底层的 io.Writer 中。</p>
<h3 id="Available"><a href="#Available" class="headerlink" title="Available"></a>Available</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Available</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>Available 返回缓存中未使用的空间的长度。  </p>
<h3 id="Buffered-1"><a href="#Buffered-1" class="headerlink" title="Buffered"></a>Buffered</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Buffered</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>Buffered 返回缓存中未提交的数据的长度。  </p>
<h3 id="Reset-1"><a href="#Reset-1" class="headerlink" title="Reset"></a>Reset</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">Reset</span><span class="params">(w io.Writer)</span></span></span><br></pre></td></tr></table></figure>
<p>Reset 将 b 的底层 Writer 重新指定为 w，同时丢弃缓存中的所有数据，复位所有标记和错误信息。相当于创建了一个新的 bufio.Writer。  </p>
<h3 id="示例1：Available、Buffered、WriteString、Flush"><a href="#示例1：Available、Buffered、WriteString、Flush" class="headerlink" title="示例1：Available、Buffered、WriteString、Flush"></a>示例1：Available、Buffered、WriteString、Flush</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    buf := bufio.NewWriterSize(os.Stdout, <span class="number">0</span>)</span><br><span class="line">    fmt.Println(buf.Available(), buf.Buffered()) <span class="comment">// 4096 0</span></span><br><span class="line"></span><br><span class="line">    buf.WriteString(<span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>)</span><br><span class="line">    fmt.Println(buf.Available(), buf.Buffered()) <span class="comment">// 4070 26</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存后统一输出，避免终端频繁刷新，影响速度</span></span><br><span class="line">    buf.Flush() <span class="comment">// ABCDEFGHIJKLMNOPQRSTUVWXYZ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="type-ReadWriter"><a href="#type-ReadWriter" class="headerlink" title="type ReadWriter"></a>type ReadWriter</h2><p>ReadWriter 集成了 bufio.Reader 和 bufio.Writer。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Reader</span><br><span class="line">    *Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReadWriter</span><span class="params">(r *Reader, w *Writer)</span> *<span class="title">ReadWriter</span></span></span><br></pre></td></tr></table></figure>
<p>NewReadWriter 将 r 和 w 封装成一个 bufio.ReadWriter 对象。  </p>
<h2 id="type-Scanner"><a href="#type-Scanner" class="headerlink" title="type Scanner"></a>type Scanner</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scanner <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// Scanner 提供了一个方便的接口来读取数据，例如遍历多行文本中的行。Scan 方法会通过</span></span><br><span class="line"><span class="comment">// 一个“匹配函数”读取数据中符合要求的部分，跳过不符合要求的部分。“匹配函数”由调</span></span><br><span class="line"><span class="comment">// 用者指定。本包中提供的匹配函数有“行匹配函数”、“字节匹配函数”、“字符匹配函数”</span></span><br><span class="line"><span class="comment">// 和“单词匹配函数”，用户也可以自定义“匹配函数”。默认的“匹配函数”为“行匹配函</span></span><br><span class="line"><span class="comment">// 数”，用于获取数据中的一行内容（不包括行尾标记）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Scanner 使用了缓存，所以匹配部分的长度不能超出缓存的容量。默认缓存容量为 4096 -</span></span><br><span class="line"><span class="comment">// bufio.MaxScanTokenSize，用户可以通过 Buffer 方法指定自定义缓存及其最大容量。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Scan 在遇到下面的情况时会终止扫描并返回 false（扫描一旦终止，将无法再继续）：</span></span><br><span class="line"><span class="comment">// 1、遇到 io.EOF</span></span><br><span class="line"><span class="comment">// 2、遇到读写错误</span></span><br><span class="line"><span class="comment">// 3、“匹配部分”的长度超过了缓存的长度</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果需要对错误进行更多的控制，或“匹配部分”超出缓存容量，或需要连续扫描，则应该</span></span><br><span class="line"><span class="comment">// 使用 bufio.Reader</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScanner</span><span class="params">(r io.Reader)</span> *<span class="title">Scanner</span></span></span><br></pre></td></tr></table></figure>
<p>NewScanner 创建一个 Scanner 来扫描 r，默认匹配函数为 ScanLines。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Buffer</span><span class="params">(buf []<span class="keyword">byte</span>, max <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>Buffer 用于设置自定义缓存及其可扩展范围，如果 max 小于 len(buf)，则 buf 的尺寸将固定不可调。Buffer 必须在第一次 Scan 之前设置，否则会引发 panic。  </p>
<p>默认情况下，Scanner 会使用一个 4096 - bufio.MaxScanTokenSize 大小的内部缓存。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Split</span><span class="params">(split SplitFunc)</span></span></span><br></pre></td></tr></table></figure>
<p>Split 用于设置“匹配函数”，这个函数必须在调用 Scan 前执行。  </p>
<h2 id="type-SplitFunc"><a href="#type-SplitFunc" class="headerlink" title="type SplitFunc"></a>type SplitFunc</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="comment">// SplitFunc 用来定义“匹配函数”，data 是缓存中的数据。atEOF 标记数据是否读完。</span></span><br><span class="line"><span class="comment">// advance 返回 data 中已处理的数据的长度。token 返回找到的“匹配部分”，“匹配</span></span><br><span class="line"><span class="comment">// 部分”可以是缓存的切片，也可以是自己新建的数据（比如 bufio.errorRune）。“匹</span></span><br><span class="line"><span class="comment">// 配部分”将在 Scan 之后通过 Bytes 和 Text 反馈给用户。err 返回错误信息。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果在 data 中无法找到一个完整的“匹配部分”则应返回 (0, nil, nil)，以便告诉</span></span><br><span class="line"><span class="comment">// Scanner 向缓存中填充更多数据，然后再次扫描（Scan 会自动重新扫描）。如果缓存已</span></span><br><span class="line"><span class="comment">// 经达到最大容量还没有找到，则 Scan 会终止并返回 false。</span></span><br><span class="line"><span class="comment">// 如果 data 为空，则“匹配函数”将不会被调用，意思是在“匹配函数”中不必考虑</span></span><br><span class="line"><span class="comment">// data 为空的情况。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 如果 err != nil，扫描将终止，如果 err == ErrFinalToken，则 Scan 将返回 true，</span></span><br><span class="line"><span class="comment">// 表示扫描正常结束，如果 err 是其它错误，则 Scan 将返回 false，表示扫描出错。错误</span></span><br><span class="line"><span class="comment">// 信息可以在 Scan 之后通过 Err 方法获取。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SplitFunc 的作用很简单，从 data 中找出你感兴趣的数据，然后返回，同时返回已经处理</span></span><br><span class="line"><span class="comment">// 的数据的长度。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Scan</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<p>Scan 开始一次扫描过程，如果匹配成功，可以通过 Bytes() 或 Text() 方法取出结果，如果遇到错误，则终止扫描，并返回 false。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>Bytes 将最后一次扫描出的“匹配部分”作为一个切片引用返回，下一次的 Scan 操作会覆盖本次引用的内容。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Text</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>Text 将最后一次扫描出的“匹配部分”作为字符串返回（返回副本）。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Scanner)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Err 返回扫描过程中遇到的非 EOF 错误，供用户调用，以便获取错误信息。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanBytes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>ScanBytes 是一个“匹配函数”用来找出 data 中的单个字节并返回。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanRunes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>ScanRunes 是一个“匹配函数”，用来找出 data 中单个 UTF8 字符的编码。如果 UTF8 编码错误，则 token 会返回 “\xef\xbf\xbd”（即：U+FFFD），但只消耗 data 中的一个字节。  </p>
<p>这使得调用者无法区分“真正的U+FFFD字符”和“解码错误的返回值”。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanLines</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ScanLines 是一个“匹配函数”，用来找出 data 中的单行数据并返回（包括空行）。  </p>
<p>行尾标记可以是 \n 或 \r\n（返回值不包含行尾标记）  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScanWords</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>ScanWords 是一个“匹配函数”，用来找出 data 中以空白字符分隔的单词。  </p>
<p>空白字符由 unicode.IsSpace 定义。  </p>
<h3 id="示例1：扫描"><a href="#示例1：扫描" class="headerlink" title="示例1：扫描"></a>示例1：扫描</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 逗号分隔的字符串，最后一项为空</span></span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">"1,2,3,4,"</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    <span class="comment">// 定义匹配函数（查找逗号分隔的字符串）</span></span><br><span class="line">    onComma := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(data); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> data[i] == <span class="string">','</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>, data[:i], <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atEOF &#123;</span><br><span class="line">            <span class="comment">// 告诉 Scanner 扫描结束。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, data, bufio.ErrFinalToken</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 告诉 Scanner 没找到匹配项，让 Scan 填充缓存后再次扫描。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定匹配函数</span></span><br><span class="line">    scanner.Split(onComma)</span><br><span class="line">    <span class="comment">// 开始扫描</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%q "</span>, scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否因为遇到错误而结束</span></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintln(os.Stderr, <span class="string">"reading input:"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例2：待检查扫描"><a href="#示例2：待检查扫描" class="headerlink" title="示例2：待检查扫描"></a>示例2：待检查扫描</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="string">"1234 5678 1234567901234567890 90"</span></span><br><span class="line">    scanner := bufio.NewScanner(strings.NewReader(input))</span><br><span class="line">    <span class="comment">// 自定义匹配函数</span></span><br><span class="line">    split := <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 获取一个单词</span></span><br><span class="line">        advance, token, err = bufio.ScanWords(data, atEOF)</span><br><span class="line">        <span class="comment">// 判断其能否转换为整数，如果不能则返回错误</span></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; token != <span class="literal">nil</span> &#123;</span><br><span class="line">            _, err = strconv.ParseInt(<span class="keyword">string</span>(token), <span class="number">10</span>, <span class="number">32</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里包含了 return 0, nil, nil 的情况</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置匹配函数</span></span><br><span class="line">    scanner.Split(split)</span><br><span class="line">    <span class="comment">// 开始扫描</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Invalid input: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="bytes-包"><a href="#bytes-包" class="headerlink" title="bytes 包"></a><code>bytes</code> 包</h1><p>对于传入 []byte 的函数，都不会修改传入的参数，返回值要么是参数的副本，要么是参数的切片。  </p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="将s中所有字符修改为大写（小写、标题）格式返回"><a href="#将s中所有字符修改为大写（小写、标题）格式返回" class="headerlink" title="将s中所有字符修改为大写（小写、标题）格式返回"></a>将s中所有字符修改为大写（小写、标题）格式返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用指定的映射表将-s-中的所有字符修改为大写（小写、标题）格式返回"><a href="#使用指定的映射表将-s-中的所有字符修改为大写（小写、标题）格式返回" class="headerlink" title="使用指定的映射表将 s 中的所有字符修改为大写（小写、标题）格式返回"></a>使用指定的映射表将 s 中的所有字符修改为大写（小写、标题）格式返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpperSpecial</span><span class="params">(_case unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLowerSpecial</span><span class="params">(_case unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitleSpecial</span><span class="params">(_case unicode.SpecialCase, s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="将-s-中的所有单词的首字符修改为-Title-格式返回"><a href="#将-s-中的所有单词的首字符修改为-Title-格式返回" class="headerlink" title="将 s 中的所有单词的首字符修改为 Title 格式返回"></a>将 s 中的所有单词的首字符修改为 Title 格式返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Title</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>BUG: 不能很好的处理以 Unicode 标点符号分隔的单词  </p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="比较两个-byte的字典顺序"><a href="#比较两个-byte的字典顺序" class="headerlink" title="比较两个[]byte的字典顺序"></a>比较两个[]byte的字典顺序</h3><p>nil 参数相当于空[]byte</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compare</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>a &lt;  b 返回 -1<br>a == b 返回 0<br>a &gt;  b 返回 1</p>
<h3 id="判断a、b是否相等"><a href="#判断a、b是否相等" class="headerlink" title="判断a、b是否相等"></a>判断a、b是否相等</h3><p>nil 相当于空[]byte  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Equal</span><span class="params">(a, b []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<h3 id="判断s，t是否相似"><a href="#判断s，t是否相似" class="headerlink" title="判断s，t是否相似"></a>判断s，t是否相似</h3><p>忽略大写、小写、标题三种格式的区别。<br>参考 <code>unicode.SimpleFold</code> 函数  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EqualFold</span><span class="params">(s, t []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><h3 id="去掉-s-左右两边包含在cutset中的字符（返回s的切片）"><a href="#去掉-s-左右两边包含在cutset中的字符（返回s的切片）" class="headerlink" title="去掉 s 左右两边包含在cutset中的字符（返回s的切片）"></a>去掉 s 左右两边包含在cutset中的字符（返回s的切片）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeft</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s []<span class="keyword">byte</span>, cutset <span class="keyword">string</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="去掉s两边符合f要求的字符（返回s的切片）"><a href="#去掉s两边符合f要求的字符（返回s的切片）" class="headerlink" title="去掉s两边符合f要求的字符（返回s的切片）"></a>去掉s两边符合f要求的字符（返回s的切片）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimLeftFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRightFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="去掉s两边的空白-unicode-IsSpace-（返回s的切片）"><a href="#去掉s两边的空白-unicode-IsSpace-（返回s的切片）" class="headerlink" title="去掉s两边的空白(unicode.IsSpace)（返回s的切片）"></a>去掉s两边的空白(unicode.IsSpace)（返回s的切片）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="去掉-s-的前缀-prefix（后缀-suffix）（返回-s-的切片）"><a href="#去掉-s-的前缀-prefix（后缀-suffix）（返回-s-的切片）" class="headerlink" title="去掉 s 的前缀 prefix（后缀 suffix）（返回 s 的切片）"></a>去掉 s 的前缀 prefix（后缀 suffix）（返回 s 的切片）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSuffix</span><span class="params">(s, suffix []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>

<h2 id="拆合"><a href="#拆合" class="headerlink" title="拆合"></a>拆合</h2><h3 id="Split按seq分割"><a href="#Split按seq分割" class="headerlink" title="Split按seq分割"></a>Split按seq分割</h3><p>Split 以 sep 为分隔符将 s 切分成多个子串，结果不包含分隔符。<br>如果 sep 为空，则将 s 切分成 Unicode 字符列表。<br>SplitN 可以指定切分次数 n，超出 n 的部分将不进行切分。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitN</span><span class="params">(s, sep []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="SplitAfter"><a href="#SplitAfter" class="headerlink" title="SplitAfter"></a>SplitAfter</h3><p>功能同 Split，只不过结果包含分隔符（在各个子串尾部）。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfter</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SplitAfterN</span><span class="params">(s, sep []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Fields-空白符分割"><a href="#Fields-空白符分割" class="headerlink" title="Fields 空白符分割"></a>Fields 空白符分割</h3><p>以连续空白为分隔符将 s 切分成多个子串，结果不包含分隔符。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fields</span><span class="params">(s []<span class="keyword">byte</span>)</span> [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="以符合-f-的字符为分隔符将-s-切分成多个子串，结果不包含分隔符"><a href="#以符合-f-的字符为分隔符将-s-切分成多个子串，结果不包含分隔符" class="headerlink" title="以符合 f 的字符为分隔符将 s 切分成多个子串，结果不包含分隔符"></a>以符合 f 的字符为分隔符将 s 切分成多个子串，结果不包含分隔符</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FieldsFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) [][]<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Join，sep为连接符"><a href="#Join，sep为连接符" class="headerlink" title="Join，sep为连接符"></a>Join，sep为连接符</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(s [][]<span class="keyword">byte</span>, sep []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="把子串b重复count次吼返回"><a href="#把子串b重复count次吼返回" class="headerlink" title="把子串b重复count次吼返回"></a>把子串b重复count次吼返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Repeat</span><span class="params">(b []<span class="keyword">byte</span>, count <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := []<span class="keyword">byte</span>(<span class="string">"  Hello   World !  "</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, bytes.Split(b, []<span class="keyword">byte</span>&#123;<span class="string">' '</span>&#125;))</span><br><span class="line">    <span class="comment">// ["" "" "Hello" "" "" "World" "!" "" ""]</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, bytes.Fields(b))</span><br><span class="line">    <span class="comment">// ["Hello" "World" "!"]</span></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bytes.ContainsRune([]<span class="keyword">byte</span>(<span class="string">" !"</span>), r)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, bytes.FieldsFunc(b, f))</span><br><span class="line">    <span class="comment">// ["Hello" "World"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2><h3 id="判断前缀、后缀"><a href="#判断前缀、后缀" class="headerlink" title="判断前缀、后缀"></a>判断前缀、后缀</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<h3 id="是否包含子串subslice-或字符r"><a href="#是否包含子串subslice-或字符r" class="headerlink" title="是否包含子串subslice 或字符r"></a>是否包含子串subslice 或字符r</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(b, subslice []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsRune</span><span class="params">(b []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<h3 id="是否包含chars中任一字符"><a href="#是否包含chars中任一字符" class="headerlink" title="是否包含chars中任一字符"></a>是否包含chars中任一字符</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContainsAny</span><span class="params">(b []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<h3 id="查找子串seq（字节c、字符r）在s中第一次出现的位置"><a href="#查找子串seq（字节c、字符r）在s中第一次出现的位置" class="headerlink" title="查找子串seq（字节c、字符r）在s中第一次出现的位置"></a>查找子串seq（字节c、字符r）在s中第一次出现的位置</h3><p>找不到则返回-1  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexByte</span><span class="params">(s []<span class="keyword">byte</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexRune</span><span class="params">(s []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="查找chars中任一字符在s中第一次出现的位置"><a href="#查找chars中任一字符在s中第一次出现的位置" class="headerlink" title="查找chars中任一字符在s中第一次出现的位置"></a>查找chars中任一字符在s中第一次出现的位置</h3><p>找不到则返回-1  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="查找符合f的字符在s中第一次出现的位置"><a href="#查找符合f的字符在s中第一次出现的位置" class="headerlink" title="查找符合f的字符在s中第一次出现的位置"></a>查找符合f的字符在s中第一次出现的位置</h3><p>找不到则返回-1  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="功能同上，只不过查找最后一次出现的位置"><a href="#功能同上，只不过查找最后一次出现的位置" class="headerlink" title="功能同上，只不过查找最后一次出现的位置"></a>功能同上，只不过查找最后一次出现的位置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndex</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexByte</span><span class="params">(s []<span class="keyword">byte</span>, c <span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexAny</span><span class="params">(s []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LastIndexFunc</span><span class="params">(s []<span class="keyword">byte</span>, f <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<h3 id="获取seq在s中出现的次数（不重叠）"><a href="#获取seq在s中出现的次数（不重叠）" class="headerlink" title="获取seq在s中出现的次数（不重叠）"></a>获取seq在s中出现的次数（不重叠）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><h3 id="s中前n个old替换为new，n-lt-0则替换全部"><a href="#s中前n个old替换为new，n-lt-0则替换全部" class="headerlink" title="s中前n个old替换为new，n&lt;0则替换全部"></a>s中前n个old替换为new，n&lt;0则替换全部</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Replace</span><span class="params">(s, old, <span class="built_in">new</span> []<span class="keyword">byte</span>, n <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="将-s-中的字符替换为-mapping-r-的返回值"><a href="#将-s-中的字符替换为-mapping-r-的返回值" class="headerlink" title="将 s 中的字符替换为 mapping(r) 的返回值"></a>将 s 中的字符替换为 mapping(r) 的返回值</h3><p>如果 mapping 返回负值，则丢弃该字符  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> []<span class="title">byte</span>) []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<h3 id="将s转换为-rune类型返回"><a href="#将s转换为-rune类型返回" class="headerlink" title="将s转换为[]rune类型返回"></a>将s转换为[]rune类型返回</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runes</span><span class="params">(s []<span class="keyword">byte</span>)</span> []<span class="title">rune</span></span></span><br></pre></td></tr></table></figure>

<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><h3 id="type-Reader"><a href="#type-Reader" class="headerlink" title="type Reader"></a>type Reader</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>将 b 包装成 bytes.Reader 对象。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(b []<span class="keyword">byte</span>)</span> *<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>
<p>bytes.Reader 实现了如下接口：  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReadSeeker</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReaderAt</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.WriterTo</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ByteScanner</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.RuneScanner</span></span><br></pre></td></tr></table></figure>
<p>返回未读取部分的数据长度：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>返回底层数据的总长度，方便ReadAt使用，返回值永远不变：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int64</span></span></span><br></pre></td></tr></table></figure>
<p>将底层数据切换为 b，同时复位所有标记（读取位置等信息）  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Reset</span><span class="params">(b []<span class="keyword">byte</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b1 := []<span class="keyword">byte</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line">    b2 := []<span class="keyword">byte</span>(<span class="string">"Hello 世界！"</span>)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>)</span><br><span class="line">    rd := bytes.NewReader(b1)</span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf) <span class="comment">// "Hello "</span></span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf) <span class="comment">// "World!"</span></span><br><span class="line"></span><br><span class="line">    rd.Reset(b2)</span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf) <span class="comment">// "Hello "</span></span><br><span class="line">    fmt.Printf(<span class="string">"Size:%d, Len:%d\n"</span>, rd.Size(), rd.Len())</span><br><span class="line">    <span class="comment">// Size:15, Len:9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Buffer"><a href="#type-Buffer" class="headerlink" title="type Buffer"></a>type Buffer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Buffer <span class="keyword">struct</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>将 buf 包装成 bytes.Buffer 对象：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBuffer</span><span class="params">(buf []<span class="keyword">byte</span>)</span> *<span class="title">Buffer</span></span></span><br></pre></td></tr></table></figure>
<p>将 s 转换为 []byte 后，包装成 bytes.Buffer 对象：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBufferString</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Buffer</span></span></span><br></pre></td></tr></table></figure>
<p>Buffer 本身就是一个缓存（内存块），没有底层数据，缓存的容量会根据需要自动调整。大多数情况下，使用 new(Buffer) 就足以初始化一个 Buffer 了。  </p>
<p>bytes.Buffer 实现了如下接口：  </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReadWriter</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ReaderFrom</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.WriterTo</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ByteWeriter</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.ByteScanner</span></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.RuneScanner</span></span><br></pre></td></tr></table></figure>
<p>未读取部分的数据长度：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>缓存的容量：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Cap</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>读取前 n 字节的数据并以切片形式返回，如果数据长度小于 n，则全部读取。<br>切片只在下一次读写操作前合法。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Next</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>读取第一个 delim 及其之前的内容，返回遇到的错误（一般是 io.EOF）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadBytes</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadString</span><span class="params">(delim <span class="keyword">byte</span>)</span> <span class="params">(line <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>写入 r 的 UTF-8 编码，返回写入的字节数和 nil。<br>保留 err 是为了匹配 bufio.Writer 的 WriteRune 方法。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>写入 s，返回写入的字节数和 nil：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>引用未读取部分的数据切片（不移动读取位置）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Bytes</span><span class="params">()</span> []<span class="title">byte</span></span></span><br></pre></td></tr></table></figure>
<p>返回未读取部分的数据字符串（不移动读取位置）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>自动增加缓存容量，以保证有 n 字节的剩余空间。<br>如果 n 小于 0 或无法增加容量则会 panic。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Grow</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>将数据长度截短到 n 字节，如果 n 小于 0 或大于 Cap 则 panic：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Truncate</span><span class="params">(n <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>重设缓冲区，清空所有数据（包括初始内容）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Reset</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>eg.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rd := bytes.NewBufferString(<span class="string">"Hello World!"</span>)</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// 获取数据切片</span></span><br><span class="line">    b := rd.Bytes()</span><br><span class="line">    <span class="comment">// 读出一部分数据，看看切片有没有变化</span></span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, rd.String()) <span class="comment">// World!</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n\n"</span>, b)         <span class="comment">// Hello World!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一部分数据，看看切片有没有变化</span></span><br><span class="line">    rd.Write([]<span class="keyword">byte</span>(<span class="string">"abcdefg"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, rd.String()) <span class="comment">// World!abcdefg</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n\n"</span>, b)         <span class="comment">// Hello World!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再读出一部分数据，看看切片有没有变化</span></span><br><span class="line">    rd.Read(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, rd.String()) <span class="comment">// abcdefg</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, b)           <span class="comment">// Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="errors-包"><a href="#errors-包" class="headerlink" title="errors 包"></a><code>errors</code> 包</h1><p>Go 语言使用 error 类型来返回函数执行过程中遇到的错误，如果返回的 error 值为 nil，则表示未遇到错误，否则 error 会返回一个字符串，用于说明遇到了什么错误。  </p>
<p>其实 error 只是一个接口，定义如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以用任何类型去实现它（只要添加一个 Error() 方法即可），也就是说，error 可以是任何类型，这意味着，函数返回的 error 值实际可以包含任意信息，不一定是字符串（当然字符串是必须的）。  </p>
<p>error 不一定表示一个错误，它可以表示任何信息，比如 io 包中就用 error 类型的 io.EOF 表示数据读取结束，而不是遇到了什么错误。再比如 path/filepath 包中用 error 类型的 filepath.SkipDir 表示跳过当前目录，继续遍历下一个目录，而不是遇到了什么错误。  </p>
<h2 id="error-New-函数"><a href="#error-New-函数" class="headerlink" title="error.New()函数"></a><code>error.New()</code>函数</h2><p>errors 包实现了一个最简单的 error 类型，只包含一个字符串，它可以记录大多数情况下遇到的错误信息。errors 包的用法也很简单，只有一个 New 函数，用于生成一个最简单的 error 对象：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串 text 包装成一个 error 对象返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>eg：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> 遇到错误 &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"遇到了某某错误"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义error类型"><a href="#自定义error类型" class="headerlink" title="自定义error类型"></a>自定义<code>error</code>类型</h2><p>如果你的程序需要记录更多的错误信息，比如时间、数值等信息，可以声明一个自定义的 error 类型。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span> &#123;</span><br><span class="line">    err   <span class="keyword">string</span></span><br><span class="line">    time  time.Time</span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s %d 次。时间：%v"</span>, m.err, m.count, m.time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newErr</span><span class="params">(s <span class="keyword">string</span>, i <span class="keyword">int</span>)</span> *<span class="title">myError</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;myError&#123;</span><br><span class="line">        err:   s,</span><br><span class="line">        time:  time.Now(),</span><br><span class="line">        count: i,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">return</span> newErr(<span class="string">"遇到某某情况"</span>, count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> err := SomeFunc(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="fmt-包"><a href="#fmt-包" class="headerlink" title="fmt 包"></a><code>fmt</code> 包</h1><p>实现了格式化I/O函数。<a href="http://docscn.studygolang.com/pkg/fmt/" target="_blank" rel="noopener">文档</a>  </p>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><p>通用占位符：  </p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">v</span></span>  值的默认格式。当打印结构体时，“加号”标记（%+v）会添加字段名</span><br><span class="line"><span class="tag">%<span class="selector-id">#v</span></span>　相应值的Go语法表示</span><br><span class="line"><span class="tag">%<span class="selector-tag">T</span></span>  相应值的类型的Go语法表示</span><br><span class="line"><span class="tag">%</span>%  字面上的百分号，并非值的占位符</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Sample <span class="keyword">struct</span> &#123;</span><br><span class="line">    a   <span class="keyword">int</span></span><br><span class="line">    str <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">new</span>(Sample)</span><br><span class="line">    s.a = <span class="number">1</span></span><br><span class="line">    s.str = <span class="string">"hello"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, *s)　<span class="comment">//&#123;1 hello&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *s) <span class="comment">//  &#123;a:1 str:hello&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, *s) <span class="comment">// main.Sample&#123;a:1, str:"hello"&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, *s)   <span class="comment">//  main.Sample</span></span><br><span class="line">    fmt.Printf(<span class="string">"%%\n"</span>, s.a) <span class="comment">//  %  %!(EXTRA int=1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布尔值：  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%t</span>   <span class="literal">true</span> <span class="string">或</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>整数值：  </p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">b</span></span>  二进制表示</span><br><span class="line"><span class="tag">%<span class="selector-tag">c</span></span>  相应Unicode码点所表示的字符</span><br><span class="line"><span class="tag">%<span class="selector-tag">d</span></span>  十进制表示</span><br><span class="line"><span class="tag">%<span class="selector-tag">o</span></span>  八进制表示</span><br><span class="line"><span class="tag">%<span class="selector-tag">q</span></span>  单引号围绕的字符字面值，由Go语法安全地转义</span><br><span class="line"><span class="tag">%<span class="selector-tag">x</span></span>  十六进制表示，字母形式为小写 a-f</span><br><span class="line"><span class="tag">%<span class="selector-tag">X</span></span>  十六进制表示，字母形式为大写 A-F</span><br><span class="line"><span class="tag">%<span class="selector-tag">U</span></span>  Unicode格式：U+1234，等同于 "U+%04X"</span><br></pre></td></tr></table></figure>
<p>浮点及复数：  </p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">b</span></span>  无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat中的 'b' 转换格式一致。例如 -123456p-78</span><br><span class="line"><span class="tag">%<span class="selector-tag">e</span></span>  科学计数法，例如 -1234.456e+78</span><br><span class="line"><span class="tag">%<span class="selector-tag">E</span></span>  科学计数法，例如 -1234.456E+78</span><br><span class="line"><span class="tag">%<span class="selector-tag">f</span></span>  有小数点而无指数，例如 123.456</span><br><span class="line"><span class="tag">%<span class="selector-tag">g</span></span>  根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</span><br><span class="line"><span class="tag">%<span class="selector-tag">G</span></span>  根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</span><br></pre></td></tr></table></figure>
<p>字符串和bytes的slice表示：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">s</span></span>  字符串或切片的无解译字节</span><br><span class="line"><span class="tag">%<span class="selector-tag">q</span></span>  双引号围绕的字符串，由Go语法安全地转义</span><br><span class="line"><span class="tag">%<span class="selector-tag">x</span></span>  十六进制，小写字母，每字节两个字符</span><br><span class="line"><span class="tag">%<span class="selector-tag">X</span></span>  十六进制，大写字母，每字节两个字符</span><br></pre></td></tr></table></figure>
<p>指针：  </p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">p</span></span>  十六进制表示，前缀 0x</span><br></pre></td></tr></table></figure>
<p>这里没有 ‘u’ 标记。若整数为无符号类型，他们就会被打印成无符号的。类似地，这里也不需要指定操作数的大小（int8，int64）。  </p>
<p>对于％ｖ来说默认的格式是：  </p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool:                    %t</span><br><span class="line"><span class="keyword">int</span>, int8 etc.:          %d</span><br><span class="line">uint, uint8 etc.:        %d, %x <span class="keyword">if</span> printed with %#v</span><br><span class="line">float32, complex64, etc: %g</span><br><span class="line"><span class="keyword">string</span>:                  %s</span><br><span class="line">chan:                    %p</span><br><span class="line">pointer:                 %p</span><br></pre></td></tr></table></figure>
<p>对于复合对象，里面的元素使用如下规则进行打印：  </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">struct:</span>             &#123;field0 field1 ...&#125;</span><br><span class="line">array, <span class="string">slice:</span>       [elem0  elem1 ...]</span><br><span class="line"><span class="string">maps:</span>               map[<span class="string">key1:</span>value1 <span class="string">key2:</span>value2]</span><br><span class="line">pointer to <span class="string">above:</span>   &amp;&#123;&#125;, &amp;[], &amp;map[]</span><br></pre></td></tr></table></figure>
<p>宽度和精度：<br>宽度是在％之后的值，如果没有指定，则使用该值的默认值，精度是跟在宽度之后的值，如果没有指定，也是使用要打印的值的默认精度．例如：％９.２f，宽度９，精度２  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%f:   <span class="built_in"> default </span>width,<span class="built_in"> default </span>precision</span><br><span class="line">%9f    width 9,<span class="built_in"> default </span>precision</span><br><span class="line">%.2f  <span class="built_in"> default </span>width, precision 2</span><br><span class="line">%9.2f  width 9, precision 2</span><br><span class="line">%9.f   width 9, precision 0</span><br></pre></td></tr></table></figure>
<p>对数值而言，宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。但对于 %g/%G 而言，精度为所有数字的总数。例如，对于123.45，格式 %6.2f会打印123.45，而 %.4g 会打印123.5。%e 和 %f 的默认精度为6；但对于 %g 而言，它的默认精度为确定该值所必须的最小位数。  </p>
<p>对大多数值而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。对字符串而言，精度为输出的最大字符数，如果必要的话会直接截断。  </p>
<p>宽度是指”必要的最小宽度”. 若结果字符串的宽度超过指定宽度时, 指定宽度就会失效。  </p>
<p>其他标志：  </p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+   总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。</span><br><span class="line">-   左对齐</span><br><span class="line">#   备用格式：为八进制添加前导 <span class="number">0</span>（%#o），为十六进制添加前导 <span class="number">0</span>x（%#x）或<span class="number">0</span>X（%#X），为 %p（%#p）去掉前导 <span class="number">0</span>x；对于 %q，若 strconv.CanBackquote</span><br><span class="line">    返回 true，就会打印原始（即反引号围绕的）字符串；如果是可打印字符，%U（%#U）会写出该字符的Unicode编码形式（如字符 x 会被打印成 U+<span class="number">0078</span> <span class="string">'x'</span>）。</span><br><span class="line"><span class="string">' '</span> （空格）为数值中省略的正负号留出空白（% d）；以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</span><br><span class="line"><span class="number">0</span>   填充前导的<span class="number">0</span>而非空格；对于数字，这会将填充移到正负号之后</span><br></pre></td></tr></table></figure>
<p>对于每一个 Printf 类的函数，都有一个 Print 函数，该函数不接受任何格式化，它等价于对每一个操作数都应用 %v。另一个变参函数 Println 会在操作数之间插入空白，并在末尾追加一个换行符  </p>
<p>格式化错误：  </p>
<p>如果给占位符提供了无效的实参（如将一个字符串提供给％d），便会出现格式化错误．所有的错误都始于“%!”，有时紧跟着单个字符（占位符），并以小括号括住的描述结尾。  </p>
<h2 id="Scanning"><a href="#Scanning" class="headerlink" title="Scanning"></a>Scanning</h2><p>一组类似的函数通过扫描已格式化的文本来产生值。  </p>
<p>Scan、Scanf 和 Scanln 从os.Stdin 中读取；<br>Fscan、Fscanf 和 Fscanln 从指定的 io.Reader 中读取；<br>Sscan、Sscanf 和 Sscanln 从实参字符串中读取。<br>Scanln、Fscanln 和 Sscanln在换行符处停止扫描，且需要条目紧随换行符之后；<br>Scanf、Fscanf 和 Sscanf需要输入换行符来匹配格式中的换行符；<br>其它函数则将换行符视为空格。  </p>
<p>Scanf、Fscanf 和 Sscanf 根据格式字符串解析实参，类似于 Printf。例如，%x会将一个整数扫描为十六进制数，而 %v 则会扫描该值的默认表现格式。  </p>
<p>格式化类似于 Printf，但也有例外，如下所示：  </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%p 没有实现</span><br><span class="line">%T 没有实现</span><br><span class="line">%e %E %f %F %g %G 都完全等价，且可扫描任何浮点数或复合数值</span><br><span class="line">%s 和 %v 在扫描字符串时会将其中的空格作为分隔符</span><br><span class="line">标记 <span class="comment"># 和 + 没有实现</span></span><br></pre></td></tr></table></figure>
<p>在输入Scanf中，宽度可以理解成输入的文本（％5s表示输入５个字符），而Scanf没有精度这种说法（没有%5.2f，只有 %5f）  </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Errorf 根据于格式说明符进行格式化，并将字符串作为满足 error 的值返回，其返回类型是error(功能同Sprintf，只不过把结果字符串包装成error类型).  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := fmt.Errorf(<span class="string">"%s%d"</span>, <span class="string">"error:"</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(a)</span><br></pre></td></tr></table></figure>
<h3 id="Fprint、Fprintf、Fprintln"><a href="#Fprint、Fprintf、Fprintln" class="headerlink" title="Fprint、Fprintf、Fprintln"></a>Fprint、Fprintf、Fprintln</h3><p>对于每一个 Printf 类的函数，都有一个 Print 函数，该函数不接受任何格式化，它等价于对每一个操作数都应用 %v。另一个变参函数 Println 会在操作数之间插入空白，并在末尾追加一个换行符  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>　</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Fprint 使用其操作数的默认格式进行格式化并写入到 w。当两个连续的操作数均不为字符串时，它们之间就会添加空格。它返回写入的字节数以及任何遇到的错误。<br>Fprintf 根据于格式说明符进行格式化并写入到 w。它返回写入的字节数以及任何遇到的写入错误。<br>Fprintln 使用其操作数的默认格式进行格式化并写入到 w。其操作数之间总是添加空格，且总在最后追加一个换行符。它返回写入的字节数以及任何遇到的错误。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="string">"asdf"</span></span><br><span class="line">    fmt.Fprintln(os.Stdout, a)          <span class="comment">//asdf</span></span><br><span class="line">    fmt.Fprintf(os.Stdout, <span class="string">"%.2s\n"</span>, a) <span class="comment">//as</span></span><br><span class="line">    fmt.Fprint(os.Stdout, a)            <span class="comment">//asdf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Fscan、Fscanf、Fscanln"><a href="#Fscan、Fscanf、Fscanln" class="headerlink" title="Fscan、Fscanf、Fscanln"></a>Fscan、Fscanf、Fscanln</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Fscan 扫描从 r 中读取的文本，并将连续由空格分隔的值存储为连续的实参。换行符计为空格。它返回成功扫描的条目数。若它少于实参数，err 就会报告原因。<br>Fscanf 扫描从 r 中读取的文本，并将连续由空格分隔的值存储为连续的实参，其格式由 format 决定。它返回成功解析的条目数。<br>Fscanln 类似于 Sscan，但它在换行符处停止扫描，且最后的条目之后必须为换行符或 EOF。<br>注：Fscan类的也是由空格进行分割的．  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">"hello 1"</span>)</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">    fmt.Fscanln(r, &amp;a, &amp;b)</span><br><span class="line">    fmt.Println(a, b)　　　　　　　　 <span class="comment">//hello 1</span></span><br><span class="line">    r1 := strings.NewReader(<span class="string">"helloworld 2"</span>)</span><br><span class="line">    fmt.Fscanf(r1, <span class="string">"hello%s%d"</span>, &amp;a, &amp;b) 　</span><br><span class="line">    fmt.Println(a, b)　　　　　　　　<span class="comment">//world 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Print、Printf、Println"><a href="#Print、Printf、Println" class="headerlink" title="Print、Printf、Println"></a>Print、Printf、Println</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Print 使用其操作数的默认格式进行格式化并写入到标准输出。当两个连续的操作数均不为字符串时，它们之间就会添加空格。它返回写入的字节数以及任何遇到的错误。<br>Printf 根据格式说明符进行格式化并写入到标准输出。它返回写入的字节数以及任何遇到的写入错误。<br>使用其操作数的默认格式进行格式化并写入到标准输出。其操作数之间总是添加空格，且总在最后追加一个换行符。它返回写入的字节数以及任何遇到的错误。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"hello,world!"</span></span><br><span class="line">    fmt.Println(s)     <span class="comment">//hello,world!</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, s)    <span class="comment">//hello,world!</span></span><br><span class="line">    fmt.Print(s)           <span class="comment">//hello,world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于 <code>Fprint(os.Stdout,...)</code>  </p>
<h3 id="Scan、Scanf、Scanln"><a href="#Scan、Scanf、Scanln" class="headerlink" title="Scan、Scanf、Scanln"></a>Scan、Scanf、Scanln</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Scan 扫描从标准输入中读取的文本，并将连续由空格分隔的值存储为连续的实参。换行符计为空格。它返回成功扫描的条目数。若它少于实参数，err 就会报告原因。<br>Scanf 扫描从标准输入中读取的文本，并将连续由空格分隔的值存储为连续的实参，其格式由 format 决定。它返回成功扫描的条目数。<br>Scanln 类似于 Scan，但它在换行符处停止扫描，且最后的条目之后必须为换行符或 EOF。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">    fmt.Scanln(&amp;a, &amp;b)   <span class="comment">// 2,1</span></span><br><span class="line">    fmt.Println(a, b)        <span class="comment">//输出２　１</span></span><br><span class="line">    fmt.Scanf(<span class="string">"%s%d"</span>, &amp;a, &amp;b)　<span class="comment">//2 1</span></span><br><span class="line">    fmt.Println(a, b)　　<span class="comment">//输出２　１</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sprint、Sprintf、Sprintln"><a href="#Sprint、Sprintf、Sprintln" class="headerlink" title="Sprint、Sprintf、Sprintln"></a>Sprint、Sprintf、Sprintln</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>Sprint 使用其操作数的默认格式进行格式化并返回其结果字符串。当两个连续的操作数均不为字符串时，它们之间就会添加空格。<br>Sprintf 根据于格式说明符进行格式化并返回其结果字符串。<br>Sprintln 使用其操作数的默认格式进行格式化并写返回其结果字符串。其操作数之间总是添加空格，且总在最后追加一个换行符。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := fmt.Sprintf(<span class="string">"%s,%d"</span>, <span class="string">"hello"</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(a)       <span class="comment">//hello,1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sscan、Sscanf、Sscanln"><a href="#Sscan、Sscanf、Sscanln" class="headerlink" title="Sscan、Sscanf、Sscanln"></a>Sscan、Sscanf、Sscanln</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="keyword">string</span>, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Sscan 扫描实参 string，并将连续由空格分隔的值存储为连续的实参。换行符计为空格。它返回成功扫描的条目数。若它少于实参数，err 就会报告原因。<br>Scanf 扫描实参 string，并将连续由空格分隔的值存储为连续的实参，其格式由 format 决定。它返回成功解析的条目数。<br>Sscanln 类似于 Sscan，但它在换行符处停止扫描，且最后的条目之后必须为换行符或 EOF。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    fmt.Sscan(<span class="string">"hello 1"</span>, &amp;a, &amp;b) <span class="comment">//hello 1</span></span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">    fmt.Sscanf(<span class="string">"helloworld 2 "</span>, <span class="string">"hello%s%d"</span>, &amp;a, &amp;c) <span class="comment">//world 2</span></span><br><span class="line">    fmt.Println(a, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="type-1"><a href="#type-1" class="headerlink" title="type"></a>type</h2><h3 id="type-Formatter"><a href="#type-Formatter" class="headerlink" title="type Formatter"></a>type Formatter</h3><p>用于实现对象的自定义格式输出  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Formatter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Format 用来处理当对象遇到 c 标记时的输出方式（c 相当于 %s 中的 s）</span></span><br><span class="line">    <span class="comment">// f 用来获取占位符的宽度、精度、扩展标记等信息，同时实现最终的输出</span></span><br><span class="line">    <span class="comment">// c 是要处理的标记</span></span><br><span class="line">    Format(f State, c <span class="keyword">rune</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-GoStringer"><a href="#type-GoStringer" class="headerlink" title="type GoStringer"></a>type GoStringer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GoStringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// GoString 获取对象的 Go 语法文本形式（以 %#v 格式输出的文本）</span></span><br><span class="line">    GoString() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type-ScanState"><a href="#type-ScanState" class="headerlink" title="type ScanState"></a>type ScanState</h3><p>ScanState 会返回扫描状态给自定义的 Scanner<br>Scanner 可能会做字符的实时扫描<br>或者通过 ScanState 获取以空格分割的 token  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ScanState <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// ReadRune 从输入对象中读出一个 Unicode 字符</span></span><br><span class="line">    <span class="comment">//world 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在 Scanln、Fscanln 或 Sscanln 中调用该方法<br>该方法会在遇到 ‘\n’ 或读取超过指定的宽度时返回 EOFReadRune() (r rune, size int, err error)<br>UnreadRune 撤消最后一次的 ReadRune 操作UnreadRune() error<br>SkipSpace 跳过输入数据中的空格<br>在 Scanln、Fscanln、Sscanln 操作中，换行符会被当作 EOF<br>在其它 Scan 操作中，换行符会被当作空格SkipSpace()<br>如果参数 skipSpace 为 true，则 Token 会跳过输入数据中的空格<br>然后返回满足函数 f 的连续字符，如果 f 为 nil，则使用 !unicode.IsSpace 来代替 f<br>在 Scanln、Fscanln、Sscanln 操作中，换行符会被当作 EOF<br>在其它 Scan 操作中，换行符会被当作空格<br>返回的 token 是一个切片，返回的数据可能在下一次调用 Token 的时候被修改Token(skipSpace bool, f func(rune) bool) (token []byte, err error)<br>Width 返回宽度值以及宽度值是否被设置Width() (wid int, ok bool)<br>因为 ReadRune 已经通过接口实现，所以 Read 可能永远不会被 Scan 例程调用<br>一个 ScanState 的实现，可能会选择废弃 Read 方法，而使其始终返回一个错误信息Read(buf []byte) (n int, err error)}</p>
<h3 id="type-Scanner-1"><a href="#type-Scanner-1" class="headerlink" title="type Scanner"></a>type Scanner</h3><p>Scanner 由任何拥有 Scan 方法的值实现，它将输入扫描成值的表示，并将其结果存储到接收者中，该接收者必须为可用的指针。Scan 方法会被 Scan、Scanf 或 Scanln 的任何实现了它的实参所调用。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scanner <span class="keyword">interface</span> &#123;</span><br><span class="line">    Scan(state ScanState, verb <span class="keyword">rune</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-State"><a href="#type-State" class="headerlink" title="type State"></a>type State</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write 函数用于打印出已格式化的输出。</span></span><br><span class="line">    Write(b []<span class="keyword">byte</span>) (ret <span class="keyword">int</span>, err error)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Width 返回宽度选项的值以及它是否已被设置。</span></span><br><span class="line">    Width() (wid <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Precision 返回精度选项的值以及它是否已被设置。</span></span><br><span class="line">    Precision() (prec <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flag 返回标记 c（一个字符）是否已被设置。</span></span><br><span class="line">    Flag(c <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Stringer"><a href="#type-Stringer" class="headerlink" title="type Stringer"></a>type Stringer</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// String 获取对象的文本形式</span></span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="net-http-包"><a href="#net-http-包" class="headerlink" title="net/http 包"></a><code>net/http</code> 包</h1><p><a href="http://docscn.studygolang.com/pkg/net/http/" target="_blank" rel="noopener">文档</a>  </p>
<p>http包包含http客户端和服务端的实现,利用Get,Head,Post,以及PostForm实现HTTP或者HTTPS的请求。  </p>
<p>当客户端使用完response body后必须使用close对其进行关闭：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">"http://example.com/"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        ErrHeaderTooLong        = &amp;ProtocolError&#123;<span class="string">"header too long"</span>&#125;</span><br><span class="line">        ErrShortBody            = &amp;ProtocolError&#123;<span class="string">"entity body too short"</span>&#125;</span><br><span class="line">        ErrNotSupported         = &amp;ProtocolError&#123;<span class="string">"feature not supported"</span>&#125;</span><br><span class="line">        ErrUnexpectedTrailer    = &amp;ProtocolError&#123;<span class="string">"trailer header without chunked transfer encoding"</span>&#125;</span><br><span class="line">        ErrMissingContentLength = &amp;ProtocolError&#123;<span class="string">"missing ContentLength in HEAD response"</span>&#125;</span><br><span class="line">        ErrNotMultipart         = &amp;ProtocolError&#123;<span class="string">"request Content-Type isn't multipart/form-data"</span>&#125;</span><br><span class="line">        ErrMissingBoundary      = &amp;ProtocolError&#123;<span class="string">"no multipart boundary param in Content-Type"</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        ErrWriteAfterFlush = errors.New(<span class="string">"Conn.Write called after Flush"</span>)</span><br><span class="line">        ErrBodyNotAllowed  = errors.New(<span class="string">"http: request method or response status code does not allow body"</span>)</span><br><span class="line">        ErrHijacked        = errors.New(<span class="string">"Conn has been hijacked"</span>)</span><br><span class="line">        ErrContentLength   = errors.New(<span class="string">"Conn.Write wrote more than the declared Content-Length"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> DefaultClient = &amp;Client&#123;&#125; <span class="comment">//默认客户端,被Get,Head以及Post使用</span></span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = NewServeMux()<span class="comment">//Serve使用的默认ServeMux</span></span><br><span class="line"><span class="keyword">var</span> ErrBodyReadAfterClose = errors.New(<span class="string">"http: invalid Read on closed Body"</span>)<span class="comment">//当读取一个request或者response body是在这个body已经关闭之后,便会返回该错误.这种错误主要发生情况是:当http handler调用writeheader或者write关于responsewrite之后进行读操作.</span></span><br><span class="line"><span class="keyword">var</span> ErrHandlerTimeout = errors.New(<span class="string">"http: Handler timeout"</span>)<span class="comment">//超时错误</span></span><br><span class="line"><span class="keyword">var</span> ErrLineTooLong = internal.ErrLineTooLong<span class="comment">//当读取格式错误的分块编码时便会出现该错误.</span></span><br><span class="line"><span class="keyword">var</span> ErrMissingFile = errors.New(<span class="string">"http: no such file"</span>)<span class="comment">//当利用FormFile进行文件请求时,如果文件不存在或者请求中没有该文件就会出现该错误.</span></span><br><span class="line"><span class="keyword">var</span> ErrNoCookie = errors.New(<span class="string">"http: named cookie not present"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrNoLocation = errors.New(<span class="string">"http: no Location header in response"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanonicalHeaderKey</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span>//返回<span class="title">header</span> <span class="title">key</span>的规范化形式,规范化形式是以"-"为分隔符,每一部分都是首字母大写,其他字母小写.例如"<span class="title">accept</span>-<span class="title">encoding</span>" 的标准化形式是 "<span class="title">Accept</span>-<span class="title">Encoding</span>".</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DetectContentType</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">string</span>//检查给定数据的内容类型<span class="title">Content</span>-<span class="title">Type</span>,最多检测512<span class="title">byte</span>数据,如果有效的话,该函数返回一个<span class="title">MIME</span>类型,否则的话,返回一个"<span class="title">application</span>/<span class="title">octet</span>-<span class="title">stream</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Error</span><span class="params">(w ResponseWriter, error <span class="keyword">string</span>, code <span class="keyword">int</span>)</span>//利用指定的错误信息和<span class="title">Http</span> <span class="title">code</span>来响应请求,其中错误信息必须是纯文本.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NotFound</span><span class="params">(w ResponseWriter, r *Request)</span>//返回<span class="title">HTTP404</span> <span class="title">not</span> <span class="title">found</span>错误</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span>//将<span class="title">handler</span>按照指定的格式注册到<span class="title">DefaultServeMux</span>,<span class="title">ServeMux</span>解释了模式匹配规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)//同上，主要用来实现动态文件内容的展示，这点与<span class="title">ServerFile</span><span class="params">()</span>不同的地方。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span>//监听<span class="title">TCP</span>网络地址<span class="title">addr</span>然后调用具有<span class="title">handler</span>的<span class="title">Serve</span>去处理连接请求.通常情况下<span class="title">Handler</span>是<span class="title">nil</span>,使用默认的<span class="title">DefaultServeMux</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServeTLS</span><span class="params">(addr <span class="keyword">string</span>, certFile <span class="keyword">string</span>, keyFile <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span>//该函数与<span class="title">ListenAndServe</span>功能基本相同,二者不同之处是该函数需要<span class="title">HTTPS</span>连接.也就是说,必须给该服务<span class="title">Serve</span>提供一个包含整数的秘钥的文件,如果证书是由证书机构签署的,那么证书文件必须是服务证书之后跟着<span class="title">CA</span>证书.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeFile</span><span class="params">(w ResponseWriter, r *Request, name <span class="keyword">string</span>)</span>//利用指定的文件或者目录的内容来响应相应的请求.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCookie</span><span class="params">(w ResponseWriter, cookie *Cookie)</span>//给<span class="title">w</span>设定<span class="title">cookie</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StatusText</span><span class="params">(code <span class="keyword">int</span>)</span> <span class="title">string</span>//对于<span class="title">http</span>状态码返回文本表示,如果这个<span class="title">code</span>未知,则返回空的字符串.</span></span><br></pre></td></tr></table></figure>

<p>eg.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// http.NotFound(w, r)//用于设置404问题</span></span><br><span class="line">    <span class="comment">// http.Error(w, "404 page not found", 404) //状态码需和描述相符</span></span><br><span class="line"></span><br><span class="line">    http.ServeFile(w, r, <span class="string">"1.txt"</span>) <span class="comment">//将1.txt中内容在w中显示.</span></span><br><span class="line">    cookie := &amp;http.Cookie&#123;</span><br><span class="line">        Name:  http.CanonicalHeaderKey(<span class="string">"uid-test"</span>), <span class="comment">//Name值为Uid-Test</span></span><br><span class="line">        Value: <span class="string">"1234"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    r.AddCookie(cookie)</span><br><span class="line">    fmt.Println(r.Cookie(<span class="string">"uid-test"</span>)) <span class="comment">//&lt;nil&gt; http: named cookie not present</span></span><br><span class="line">    fmt.Println(r.Cookie(<span class="string">"Uid-Test"</span>)) <span class="comment">//Uid-Test=1234 &lt;nil&gt;</span></span><br><span class="line">    fmt.Println(r.Cookies())          <span class="comment">//[Uid-Test=1234]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    stat := http.StatusText(<span class="number">200</span>)</span><br><span class="line">    fmt.Println(stat) <span class="comment">//状态码200对应的状态OK</span></span><br><span class="line"></span><br><span class="line">    stringtype := http.DetectContentType([]<span class="keyword">byte</span>(<span class="string">"test"</span>))</span><br><span class="line">    fmt.Println(stringtype) <span class="comment">//text/plain; charset=utf-8</span></span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/test"</span>, Test)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MaxBytesReader</span><span class="params">(w ResponseWriter, r io.ReadCloser, n <span class="keyword">int64</span>)</span> <span class="title">io</span>.<span class="title">ReadCloser</span>//该函数类似于<span class="title">io</span>.<span class="title">LimitReader</span>但是该函数是用来限制请求体的大小.与<span class="title">io</span>.<span class="title">LimitReader</span>不同的是,该函数返回一个<span class="title">ReaderCloser</span>,当读超过限制时,返回一个<span class="title">non</span>-<span class="title">EOF</span>,并且当<span class="title">Close</span>方法调用时,关闭底层的<span class="title">reader</span>.该函数组织客户端恶意发送大量请求,浪费服务器资源.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseHTTPVersion</span><span class="params">(vers <span class="keyword">string</span>)</span> <span class="params">(major, minor <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span>//解析<span class="title">http</span>字符串版本进行解析,"<span class="title">HTTP</span>/1.0" 返回 <span class="params">(1, 0, <span class="literal">true</span>)</span>//注解析的字符串必须以<span class="title">HTTP</span>开始才能够正确解析，<span class="title">HTTP</span>区分大小写，其他诸如<span class="title">http</span>或者<span class="title">Http</span>都不能够正确解析。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseTime</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="params">(t time.Time, err error)</span>//解析时间头<span class="params">(例如data:header)</span>,解析格式如下面三种<span class="params">(HTTP/1.1中允许的)</span>:<span class="title">TimeFormat</span>, <span class="title">time</span>.<span class="title">RFC850</span>, <span class="title">and</span> <span class="title">time</span>.<span class="title">ANSIC</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProxyFromEnvironment</span><span class="params">(req *Request)</span> <span class="params">(*url.URL, error)</span>//该函数返回一个指定请求的代理<span class="title">URL</span>,这是由环境变量<span class="title">HTTP_PROXY</span>,<span class="title">HTTPS_PROXY</span>以及<span class="title">NO_PROXY</span>决定的,对于<span class="title">https</span>请求,<span class="title">HTTPS_PROXY</span>优先级高于<span class="title">HTTP_PROXY</span>,环境值可能是一个<span class="title">URL</span>或者一个<span class="title">host</span>:<span class="title">port</span>,其中这两种类型都是<span class="title">http</span>调度允许的,如果不是这两种类型的数值便会返回错误.如果在环境中没有定义代理或者代理不应该用于该请求<span class="params">(定义为NO_PROXY)</span>,将会返回一个<span class="title">nil</span> <span class="title">URL</span>和一个<span class="title">nil</span> <span class="title">error</span>.作为一个特例,如果请求<span class="title">rul</span>是"<span class="title">localhost</span>",无论有没有<span class="title">port</span>,那么将返回一个<span class="title">nil</span> <span class="title">rul</span>和一个<span class="title">nil</span> <span class="title">error</span>.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProxyURL</span><span class="params">(fixedURL *url.URL)</span> <span class="title">func</span><span class="params">(*Request)</span> <span class="params">(*url.URL, error)</span>//返回一个用于传输的代理函数,该函数总是返回相同的<span class="title">URL</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Redirect</span><span class="params">(w ResponseWriter, r *Request, urlStr <span class="keyword">string</span>, code <span class="keyword">int</span>)</span>//返回一个重定向的<span class="title">url</span>给指定的请求,这个重定向<span class="title">url</span>可能是一个相对请求路径的一个相对路径.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serve</span><span class="params">(l net.Listener, handler Handler)</span> <span class="title">error</span>//该函数接受<span class="title">listener</span> <span class="title">l</span>的传入<span class="title">http</span>连接,对于每一个连接创建一个新的服务协程,这个服务协程读取请求然后调用<span class="title">handler</span>来给他们响应.<span class="title">handler</span>一般为<span class="title">nil</span>,这样默认的<span class="title">DefaultServeMux</span>被使用.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ServeContent</span><span class="params">(w ResponseWriter, req *Request, name <span class="keyword">string</span>, modtime time.Time, content io.ReadSeeker)</span>//该函数使用提供的<span class="title">ReaderSeeker</span>提供的内容来恢复请求,该函数相对于<span class="title">io</span>.<span class="title">Copy</span>的优点是可以处理范围类请求,设定<span class="title">MIME</span>类型,并且处理了<span class="title">If</span>-<span class="title">Modified</span>-<span class="title">Since</span>请求.如果未设定<span class="title">content</span>-<span class="title">type</span>类型,该函数首先通过文件扩展名来判断类型,如果失效的话,读取<span class="title">content</span>的第一块数据并将他传递给<span class="title">DetectContentType</span>进行类型判断.<span class="title">name</span>可以不被使用,更进一步说,他可以为空并且不在<span class="title">respone</span>中返回.如果<span class="title">modtime</span>不是0时间,该时间则体现在<span class="title">response</span>的最后一次修改的<span class="title">header</span>中,如果请求包括一个<span class="title">If</span>-<span class="title">Modified</span>-<span class="title">Since</span> <span class="title">header</span>,该函数利用<span class="title">modtime</span>来决定是否发送该<span class="title">content</span>.该函数利用<span class="title">Seek</span>功能来决定<span class="title">content</span>的大小.</span></span><br></pre></td></tr></table></figure>

<h3 id="type-Client"><a href="#type-Client" class="headerlink" title="type Client"></a><strong>type Client</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client<span class="comment">//Client是一个http客户端,默认客户端(DefaultClient)将使用默认的发送机制的客户端.Client的Transport字段一般会含有内部状态(缓存TCP连接),因此Client类型值应尽量被重用而不是创建新的。多个协程并发使用Clients是安全的.</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Transport指定执行独立、单次HTTP请求的机制如果Transport为nil,则使用DefaultTransport。</span></span><br><span class="line">    Transport RoundTripper</span><br><span class="line">    <span class="comment">// CheckRedirect指定处理重定向的策略,如果CheckRedirect非nil,client将会在调用重定向之前调用它。</span></span><br><span class="line">    <span class="comment">// 参数req和via是将要执行的请求和已经执行的请求（时间越久的请求优先执行),如果CheckRedirect返回一个错误,</span></span><br><span class="line">　　 <span class="comment">//client的GetGet方法不会发送请求req,而是回之前得到的响应和该错误。</span></span><br><span class="line">    <span class="comment">// 如果CheckRedirect为nil，会采用默认策略：在连续10次请求后停止。</span></span><br><span class="line">    CheckRedirect <span class="function"><span class="keyword">func</span><span class="params">(req *Request, via []*Request)</span> <span class="title">error</span></span></span><br><span class="line">    <span class="comment">// Jar指定cookie管理器,如果Jar为nil,在请求中不会发送cookie,在回复中cookie也会被忽略。</span></span><br><span class="line">    Jar CookieJar</span><br><span class="line">    <span class="comment">// Timeout指定Client请求的时间限制,该超时限制包括连接时间、重定向和读取response body时间。</span></span><br><span class="line">    <span class="comment">// 计时器会在Head,Get,Post或Do方法返回后开始计时并在读到response.body后停止计时。</span></span><br><span class="line">　　<span class="comment">// Timeout为零值表示不设置超时。</span></span><br><span class="line">    <span class="comment">// Client的Transport字段必须支持CancelRequest方法,否则Client会在尝试用Head,Get,Post或Do方法执行请求时返回错误。</span></span><br><span class="line">    <span class="comment">// Client的Transport字段默认值（DefaultTransport）支持CancelRequest方法。</span></span><br><span class="line">    Timeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client的方法：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(resp *Response, err error)</span>//<span class="title">Do</span>发送<span class="title">http</span>请求并且返回一个<span class="title">http</span>响应,遵守<span class="title">client</span>的策略,如重定向,<span class="title">cookies</span>以及<span class="title">auth</span>等.错误经常是由于策略引起的,当<span class="title">err</span>是<span class="title">nil</span>时,<span class="title">resp</span>总会包含一个非<span class="title">nil</span>的<span class="title">resp</span>.<span class="title">body</span>.当调用者读完<span class="title">resp</span>.<span class="title">body</span>之后应该关闭它,如果<span class="title">resp</span>.<span class="title">body</span>没有关闭,则<span class="title">Client</span>底层<span class="title">RoundTripper</span>将无法重用存在的<span class="title">TCP</span>连接去服务接下来的请求,如果<span class="title">resp</span>.<span class="title">body</span>非<span class="title">nil</span>,则必须对其进行关闭.通常来说,经常使用<span class="title">Get</span>,<span class="title">Post</span>,或者<span class="title">PostForm</span>来替代<span class="title">Do</span>.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">//利用get方法请求指定的url.Get请求指定的页面信息，并返回实体主体。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Head</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">//利用head方法请求指定的url，Head只返回页面的首部。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Post</span><span class="params">(url <span class="keyword">string</span>, bodyType <span class="keyword">string</span>, body io.Reader)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">//利用post方法请求指定的URl,如果body也是一个io.Closer,则在请求之后关闭它</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">PostForm</span><span class="params">(url <span class="keyword">string</span>, data url.Values)</span> <span class="params">(resp *Response, err error)</span></span></span><br><span class="line"><span class="comment">//利用post方法请求指定的url,利用data的key和value作为请求体.</span></span><br></pre></td></tr></table></figure>

<p>http中Client客户端的参数设定解析如上面描述所示，Client具有Do，Get，Head，Post以及PostForm等方法。 其中Do方法可以对Request进行一系列的设定，而其他的对request设定较少。如果Client使用默认的Client，则其中的Get，Head，Post以及PostForm方法相当于默认的http.Get,http.Post,http.Head以及http.PostForm函数。举例说明其用法。其中Get，Head，Post以及PostForm用法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    requestUrl := <span class="string">"http://www.baidu.com"</span></span><br><span class="line">    <span class="comment">// request, err := http.Get(requestUrl)</span></span><br><span class="line">    <span class="comment">// request, err := http.Head(requestUrl)</span></span><br><span class="line">    postvalue := url.Values&#123;</span><br><span class="line">        <span class="string">"username"</span>: &#123;<span class="string">"xiaoming"</span>&#125;,</span><br><span class="line">        <span class="string">"address"</span>:  &#123;<span class="string">"beijing"</span>&#125;,</span><br><span class="line">        <span class="string">"subject"</span>:  &#123;<span class="string">"Hello"</span>&#125;,</span><br><span class="line">        <span class="string">"from"</span>:     &#123;<span class="string">"china"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// request, err := http.PostForm(requestUrl, postvalue)</span></span><br><span class="line"></span><br><span class="line">    body := bytes.NewBufferString(postvalue.Encode())</span><br><span class="line">    request, err := http.Post(requestUrl, <span class="string">"text/html"</span>, body)  <span class="comment">//Post方法</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> request.Body.Close()</span><br><span class="line">    fmt.Println(request.StatusCode)</span><br><span class="line">    <span class="keyword">if</span> request.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">        rb, err := ioutil.ReadAll(request.Body)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(rb)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(rb))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Do方法可以灵活的对request进行配置，然后进行请求。利用http.Client以及http.NewRequest来模拟请求。模拟request中带有cookie的请求。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">// "encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    request, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://www.baidu.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    cookie := &amp;http.Cookie&#123;Name: <span class="string">"userId"</span>, Value: strconv.Itoa(<span class="number">12345</span>)&#125;</span><br><span class="line"></span><br><span class="line">    request.AddCookie(cookie) <span class="comment">//request中添加cookie</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置request的header</span></span><br><span class="line">    request.Header.Set(<span class="string">"Accept"</span>, <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Accept-Charset"</span>, <span class="string">"GBK,utf-8;q=0.7,*;q=0.3"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip,deflate,sdch"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN,zh;q=0.8"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Cache-Control"</span>, <span class="string">"max-age=0"</span>)</span><br><span class="line">    request.Header.Set(<span class="string">"Connection"</span>, <span class="string">"keep-alive"</span>)</span><br><span class="line"></span><br><span class="line">    response, err := client.Do(request)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">    fmt.Println(response.StatusCode)</span><br><span class="line">    <span class="keyword">if</span> response.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">        r, err := ioutil.ReadAll(response.Body)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(r))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-CloseNotifier-接口"><a href="#type-CloseNotifier-接口" class="headerlink" title="type CloseNotifier 接口"></a><strong>type CloseNotifier 接口</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CloseNotifier<span class="comment">//该接口被ResponseWriter用来实时检测底层连接是否已经断开.如果客户端已经断开连接,该机制可以在服务端响应之前取消二者之间的长连接.</span></span><br><span class="line"><span class="keyword">type</span> CloseNotifier <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// 当客户端断开连接时,CloseNotifier接受一个通知</span></span><br><span class="line">        CloseNotify() &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CloseNotifier经常被ResponseWriter用来检测底层连接是否已经断开，举例如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    http.ServeFile(w, r, <span class="string">"test.go"</span>)</span><br><span class="line">    <span class="keyword">var</span> closenotify http.CloseNotifier</span><br><span class="line">    closenotify = w.(http.CloseNotifier)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-closenotify.CloseNotify():</span><br><span class="line">        fmt.Println(<span class="string">"cut"</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Duration(<span class="number">100</span>) * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/test"</span>, Test)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-ConnState-int"><a href="#type-ConnState-int" class="headerlink" title="type ConnState int"></a><strong>type ConnState int</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConnState <span class="comment">//表示客户端连接服务端的状态  </span></span><br><span class="line"><span class="keyword">type</span> ConnState <span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>其中ConnState常用状态变量如下:  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// StateNew代表一个新的连接，将要立刻发送请求。</span></span><br><span class="line">    <span class="comment">// 连接从这个状态开始，然后转变为StateAlive或StateClosed。</span></span><br><span class="line">    StateNew ConnState = <span class="literal">iota</span></span><br><span class="line">    <span class="comment">// StateActive代表一个已经读取了请求数据1到多个字节的连接。</span></span><br><span class="line">    <span class="comment">// 用于StateAlive的Server.ConnState回调函数在将连接交付给处理器之前被触发，</span></span><br><span class="line">    <span class="comment">// 等到请求被处理完后，Server.ConnState回调函数再次被触发。</span></span><br><span class="line">    <span class="comment">// 在请求被处理后，连接状态改变为StateClosed、StateHijacked或StateIdle。</span></span><br><span class="line">    StateActive</span><br><span class="line">    <span class="comment">// StateIdle代表一个已经处理完了请求、处在闲置状态、等待新请求的连接。</span></span><br><span class="line">    <span class="comment">// 连接状态可以从StateIdle改变为StateActive或StateClosed。</span></span><br><span class="line">    StateIdle</span><br><span class="line">    <span class="comment">// 代表一个被劫持的连接。这是一个终止状态，不会转变为StateClosed。</span></span><br><span class="line">    StateHijacked</span><br><span class="line">    <span class="comment">// StateClosed代表一个关闭的连接。</span></span><br><span class="line">    <span class="comment">// 这是一个终止状态。被劫持的连接不会转变为StateClosed。</span></span><br><span class="line">    StateClosed</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ConnState)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>  //状态的字符形式表示</span></span><br><span class="line">fmt.Println(http.StateActive)          <span class="comment">//active</span></span><br><span class="line">fmt.Println(http.StateActive.String()) <span class="comment">//active</span></span><br></pre></td></tr></table></figure>

<h3 id="type-Cookie-struct"><a href="#type-Cookie-struct" class="headerlink" title="type Cookie struct"></a><strong>type Cookie struct</strong></h3><p>type Cookie//常用SetCooker用来给http的请求或者http的response设置cookie  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name       <span class="keyword">string</span>  <span class="comment">//名字</span></span><br><span class="line">        Value      <span class="keyword">string</span>  <span class="comment">//值</span></span><br><span class="line">        Path       <span class="keyword">string</span>   <span class="comment">//路径</span></span><br><span class="line">        Domain     <span class="keyword">string</span>   </span><br><span class="line">        Expires    time.Time <span class="comment">//过期时间</span></span><br><span class="line">        RawExpires <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// MaxAge=0 意味着 没有'Max-Age'属性指定.</span></span><br><span class="line">        <span class="comment">// MaxAge&lt;0 意味着 立即删除cookie</span></span><br><span class="line">        <span class="comment">// MaxAge&gt;0 意味着设定了MaxAge属性,并且其单位是秒</span></span><br><span class="line">        MaxAge   <span class="keyword">int</span></span><br><span class="line">        Secure   <span class="keyword">bool</span></span><br><span class="line">        HttpOnly <span class="keyword">bool</span></span><br><span class="line">        Raw      <span class="keyword">string</span></span><br><span class="line">        Unparsed []<span class="keyword">string</span> <span class="comment">// 未解析的属性值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func (c *Cookie) String() string//该函数返回cookie的序列化结果。如果只设置了Name和Value字段，序列化结果可用于HTTP请求的Cookie头或者HTTP回复的Set-Cookie头；如果设置了其他字段，序列化结果只能用于HTTP回复的Set-Cookie头。  </p>
<p>type CookieJar//在http请求中，CookieJar管理存储和使用cookies.Cookiejar的实现必须被多协程并发使用时是安全的.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CookieJar <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// SetCookies 处理从url接收到的cookie,是否存储这个cookies取决于jar的策略和实现</span></span><br><span class="line">        SetCookies(u *url.URL, cookies []*Cookie)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cookies 返回发送到指定url的cookies</span></span><br><span class="line">        Cookies(u *url.URL) []*Cookie</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Dir-string"><a href="#type-Dir-string" class="headerlink" title="type Dir string"></a><strong>type Dir string</strong></h3><p>type Dir//使用一个局限于指定目录树的本地文件系统实现一个文件系统.一个空目录被当做当前目录”.”  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dir <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dir)</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(File, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="type-File-接口"><a href="#type-File-接口" class="headerlink" title="type File 接口"></a><strong>type File 接口</strong></h3><p>type File //File是通过FileSystem的Open方法返回的,并且能够被FileServer实现.该方法与*os.File行为表现一样.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">interface</span> &#123;</span><br><span class="line">        io.Closer</span><br><span class="line">        io.Reader</span><br><span class="line">        Readdir(count <span class="keyword">int</span>) ([]os.FileInfo, error)</span><br><span class="line">        Seek(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>) (<span class="keyword">int64</span>, error)</span><br><span class="line">        Stat() (os.FileInfo, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>type FileSystem 接口</strong>  </p>
<p>type FileSystem//实现了对一系列指定文件的访问,其中文件路径之间通过分隔符进行分割.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileSystem <span class="keyword">interface</span> &#123;</span><br><span class="line">        Open(name <span class="keyword">string</span>) (File, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Flusher-接口"><a href="#type-Flusher-接口" class="headerlink" title="type Flusher 接口"></a><strong>type Flusher 接口</strong></h3><p>type Flusher //responsewriters允许http控制器将缓存数据刷新入client.然而如果client是通过http代理连接服务器,这个缓存数据也可能是在整个response结束后才能到达客户端.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flusher <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// Flush将任何缓存数据发送到client</span></span><br><span class="line">        Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Handler-接口"><a href="#type-Handler-接口" class="headerlink" title="type Handler 接口"></a><strong>type Handler 接口</strong></h3><p>type Handler //实现Handler接口的对象可以注册到HTTP服务端，为指定的路径或者子树提供服务。ServeHTTP应该将回复的header和数据写入ResponseWriter接口然后返回。返回意味着该请求已经结束，HTTP服务端可以转移向该连接上的下一个请求。  </p>
<p>//如果ServeHTTP崩溃panic,那么ServeHTTP的调用者假定这个panic的影响与活动请求是隔离的,二者互不影响.调用者恢复panic,将stack trace记录到错误日志中,然后挂起这个连接.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">        ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>func FileServer(root FileSystem) Handler // FileServer返回一个使用FileSystem接口提供文件访问服务的HTTP处理器。可以使用httpDir来使用操作系统的FileSystem接口实现。其主要用来实现静态文件的展示。  </p>
<p>func NotFoundHandler() Handler //返回一个简单的请求处理器,该处理器对任何请求都会返回”404 page not found”  </p>
<p>func RedirectHandler(url string, code int) Handler//使用给定的状态码将它接受到的任何请求都重定向到给定的url  </p>
<p>func StripPrefix(prefix string, h Handler) Handler//将请求url.path中移出指定的前缀,然后将省下的请求交给handler h来处理,对于那些不是以指定前缀开始的路径请求,该函数返回一个http 404 not found 的错误.  </p>
<p>func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler //具有超时限制的handler,该函数返回的新Handler调用h中的ServerHTTP来处理每次请求,但是如果一次调用超出时间限制,那么就会返回给请求者一个503服务请求不可达的消息,并且在ResponseWriter返回超时错误.  </p>
<p>其中FileServer经常和StripPrefix一起连用，用来实现静态文件展示，举例如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">"/test/"</span>, http.FileServer(http.Dir(<span class="string">"/home/work/"</span>))) <span class="comment">///home/work/test/中必须有内容</span></span><br><span class="line">    http.Handle(<span class="string">"/download/"</span>, http.StripPrefix(<span class="string">"/download/"</span>, http.FileServer(http.Dir(<span class="string">"/home/work/"</span>))))</span><br><span class="line">    http.Handle(<span class="string">"/tmpfiles/"</span>, http.StripPrefix(<span class="string">"/tmpfiles/"</span>, http.FileServer(http.Dir(<span class="string">"/tmp"</span>)))) <span class="comment">//127.0.0.1:9999/tmpfiles/访问的本地文件/tmp中的内容</span></span><br><span class="line">    http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-HandlerFunc"><a href="#type-HandlerFunc" class="headerlink" title="type HandlerFunc"></a><strong>type HandlerFunc</strong></h3><p>type HandlerFunc//HandlerFunc type是一个适配器，通过类型转换我们可以将普通的函数作为HTTP处理器使用。如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure>

<p>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) //ServeHttp调用f(w,r)  </p>
<p>type Header//代表在http header中的key-value对  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span>//将<span class="title">key</span>,<span class="title">value</span>组成键值对添加到<span class="title">header</span>中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span>  //<span class="title">header</span>中删除对应的<span class="title">key</span>-<span class="title">value</span>对</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span> //获取指定<span class="title">key</span>的第一个<span class="title">value</span>,如果<span class="title">key</span>没有对应的<span class="title">value</span>,则返回"",为了获取一个<span class="title">key</span>的多个值,用<span class="title">CanonicalHeaderKey</span>来获取标准规范格式.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span> //给一个<span class="title">key</span>设定为相应的<span class="title">value</span>.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Write</span><span class="params">(w io.Writer)</span> <span class="title">error</span>//利用线格式来写<span class="title">header</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">WriteSubset</span><span class="params">(w io.Writer, exclude <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span> <span class="title">error</span>//利用线模式写<span class="title">header</span>,如果<span class="title">exclude</span>不为<span class="title">nil</span>,则在<span class="title">exclude</span>中包含的<span class="title">exclude</span>[<span class="title">key</span>] == <span class="title">true</span>不被写入.</span></span><br></pre></td></tr></table></figure>

<h3 id="type-Hijacker-接口"><a href="#type-Hijacker-接口" class="headerlink" title="type Hijacker 接口"></a><strong>type Hijacker 接口</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hijacker <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// Hijack让调用者接管连接,在调用Hijack()后,http server库将不再对该连接进行处理,对于该连接的管理和关闭责任将由调用者接管.</span></span><br><span class="line">        Hijack() (net.Conn, *bufio.ReadWriter, error) <span class="comment">//conn表示连接对象，bufrw代表该连接的读写缓存对象。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HiJack</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    hj, ok := w.(http.Hijacker)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        http.Error(w, <span class="string">"webserver doesn't support hijacking"</span>, http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn, bufrw, err := hj.Hijack()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line">    bufrw.WriteString(<span class="string">"Now we're speaking raw TCP. Say hi: \n"</span>)</span><br><span class="line">    bufrw.Flush()</span><br><span class="line"></span><br><span class="line">    fmt.Fprintf(bufrw, <span class="string">"You said: %s Bye.\n"</span>, <span class="string">"Good"</span>)</span><br><span class="line">    bufrw.Flush()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/hijack"</span>, HiJack)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9999"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-ProtocolError"><a href="#type-ProtocolError" class="headerlink" title="type ProtocolError"></a><strong>type ProtocolError</strong></h3><p>type ProtocolError //http请求解析错误  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(err *ProtocolError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="type-Reques-struct"><a href="#type-Reques-struct" class="headerlink" title="type Reques struct"></a><strong>type Reques struct</strong></h3><p>type Request//代表客户端给服务器端发送的一个请求.该字段在服务器端和客户端使用时区别很大.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Method指定HTTP方法(GET,POST,PUT等)默认使用GET方法。</span></span><br><span class="line">    Method <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// URL在服务端表示被请求的URI(uniform resource identifier,统一资源标识符)，在客户端表示要访问的URL。</span></span><br><span class="line">    <span class="comment">// 在服务端,URL字段是解析请求行的URI（保存在RequestURI字段）得到的,对大多数请求来说,除了Path和RawQuery之外的字段都是空字符串。</span></span><br><span class="line">    <span class="comment">// 在客户端,URL的Host字段指定了要连接的服务器,而Request的Host字段指定要发送的HTTP请求的Host头的值。</span></span><br><span class="line">    URL *url.URL</span><br><span class="line">    <span class="comment">// 接收到的请求的协议版本。client的Request总是使用HTTP/1.1</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// "HTTP/1.0"</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// Header字段用来表示HTTP请求的头域。如果header（多行键值对格式）为：</span></span><br><span class="line">    <span class="comment">//    accept-encoding: gzip, deflate</span></span><br><span class="line">    <span class="comment">//    Accept-Language: en-us</span></span><br><span class="line">    <span class="comment">//    Connection: keep-alive</span></span><br><span class="line">    <span class="comment">// 则：</span></span><br><span class="line">    <span class="comment">//    Header = map[string][]string&#123;</span></span><br><span class="line">    <span class="comment">//        "Accept-Encoding": &#123;"gzip, deflate"&#125;,</span></span><br><span class="line">    <span class="comment">//        "Accept-Language": &#123;"en-us"&#125;,</span></span><br><span class="line">    <span class="comment">//        "Connection": &#123;"keep-alive"&#125;,</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// HTTP规定header的键名（头名）是区分大小写的，请求的解析器通过规范化头域的键名来实现这点,即首字母大写,其他字母小写,通过"-"进行分割。</span></span><br><span class="line">    <span class="comment">// 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// Body是请求的主体.对于客户端请求来说,一个nil body意味着没有body,http Client的Transport字段负责调用Body的Close方法。</span></span><br><span class="line">    <span class="comment">// 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF.Server会关闭请求主体，而ServeHTTP处理器不需要关闭Body字段。</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// ContentLength记录相关内容的长度.如果为-1,表示长度未知,如果values&gt;=0，表示可以从Body字段读取ContentLength字节数据。</span></span><br><span class="line">    <span class="comment">// 在客户端,如果Body非nil而该字段为0,表示不知道Body的长度。</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示"identity"编码。</span></span><br><span class="line">    <span class="comment">// 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除"chunked"传输编码。</span></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接。</span></span><br><span class="line">    Close <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 对于服务器端请求,Host指定URL指向的主机,可能的格式是host:port.对于客户请求,Host用来重写请求的Host头,如过该字段为""，Request.Write方法会使用URL.Host来进行赋值。</span></span><br><span class="line">    Host <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据.本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    Form url.Values</span><br><span class="line">    <span class="comment">// PostForm是解析好的POST或PUT的表单数据.本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。</span></span><br><span class="line">    PostForm url.Values</span><br><span class="line">    <span class="comment">// MultipartForm是解析好的多部件表单，包括上传的文件.本字段只有在调用ParseMultipartForm后才有效。http客户端中会忽略MultipartForm并且使用Body替代</span></span><br><span class="line">    MultipartForm *multipart.Form</span><br><span class="line">    <span class="comment">// Trailer指定了在发送请求体之后额外的headers,在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。</span></span><br><span class="line">    <span class="comment">// （客户端会声明哪些trailer会发送）在处理器从Body读取时，不能使用本字段.在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。</span></span><br><span class="line">    <span class="comment">// （如果客户端发送了这些键值对），此时才可以访问本字段。</span></span><br><span class="line">    <span class="comment">// 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射.(值可以是nil或其终值),ContentLength字段必须是0或-1，以启用"chunked"传输编码发送请求。</span></span><br><span class="line">    <span class="comment">// 在开始发送请求后,Trailer可以在读取请求主体期间被修改，一旦请求主体返回EOF，调用者就不可再修改Trailer。</span></span><br><span class="line">    <span class="comment">// 几乎没有HTTP客户端、服务端或代理支持HTTP trailer。</span></span><br><span class="line">    Trailer Header</span><br><span class="line">    <span class="comment">// RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址,该字段经常用于日志.本字段不是ReadRequest函数填写的，也没有定义格式。</span></span><br><span class="line">    <span class="comment">// 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为"IP:port"格式的地址.客户端会忽略请求中的RemoteAddr字段。</span></span><br><span class="line">    RemoteAddr <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// RequestURI是客户端发送到服务端的请求中未修改的URI(参见RFC 2616,Section 5.1),如果在http请求中设置该字段便会报错.</span></span><br><span class="line">    RequestURI <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息,本字段不是ReadRequest函数填写的。</span></span><br><span class="line">    <span class="comment">// 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。</span></span><br><span class="line">    <span class="comment">// 客户端会忽略请求中的TLS字段。</span></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>func NewRequest(method, urlStr string, body io.Reader) (*Request, error) //利用指定的method,url以及可选的body返回一个新的请求.如果body参数实现了io.Closer接口，Request返回值的Body 字段会被设置为body，并会被Client类型的Do、Post和PostForm方法以及Transport.RoundTrip方法关闭。  </p>
<p>func ReadRequest(b *bufio.Reader) (req *Request, err error)//从b中读取和解析一个请求.  </p>
<p>func (r *Request) AddCookie(c *Cookie) //给request添加cookie,AddCookie向请求中添加一个cookie.按照RFC 6265 section 5.4的规则,AddCookie不会添加超过一个Cookie头字段.这表示所有的cookie都写在同一行,用分号分隔（cookie内部用逗号分隔属性）  </p>
<p>func (r <em>Request) Cookie(name string) (</em>Cookie, error)//返回request中指定名name的cookie，如果没有发现，返回ErrNoCookie  </p>
<p>func (r <em>Request) Cookies() []</em>Cookie//返回该请求的所有cookies  </p>
<p>func (r *Request) SetBasicAuth(username, password string)//利用提供的用户名和密码给http基本权限提供具有一定权限的header。当使用http基本授权时，用户名和密码是不加密的  </p>
<p>func (r *Request) UserAgent() string//如果在request中发送，该函数返回客户端的user-Agent</p>
<p>用法eg.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    req, err := http.NewRequest(<span class="string">"GET"</span>, <span class="string">"http://www.baidu.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.SetBasicAuth(<span class="string">"test"</span>, <span class="string">"123456"</span>)</span><br><span class="line">    fmt.Println(req.Proto)</span><br><span class="line">    cookie := &amp;http.Cookie&#123;</span><br><span class="line">        Name:  <span class="string">"test"</span>,</span><br><span class="line">        Value: <span class="string">"12"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    req.AddCookie(cookie)                     <span class="comment">//添加cookie</span></span><br><span class="line">    fmt.Println(req.Cookie(<span class="string">"test"</span>))           <span class="comment">//获取cookie</span></span><br><span class="line">    fmt.Println(req.Cookies())                <span class="comment">//获取cookies</span></span><br><span class="line">    req.Header.Set(<span class="string">"User-Agent"</span>, <span class="string">"useragent"</span>) <span class="comment">//设定ua</span></span><br><span class="line">    fmt.Println(req.UserAgent())</span><br><span class="line"></span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">        content, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">        fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)//对于指定格式的key，FormFile返回符合条件的第一个文件，如果有必要的话，该函数会调用ParseMultipartForm和ParseForm。  </p>
<p>func (r *Request) FormValue(key string) string//返回key获取的队列中第一个值。在查询过程中post和put中的主题参数优先级高于url中的value。为了访问相同key的多个值，调用ParseForm然后直接检查RequestForm。  </p>
<p>func (r <em>Request) MultipartReader() (</em>multipart.Reader, error)//如果这是一个有多部分组成的post请求，该函数将会返回一个MIME 多部分reader，否则的话将会返回一个nil和error。使用本函数代替ParseMultipartForm可以将请求body当做流stream来处理。  </p>
<p>func (r *Request) ParseForm() error//解析URL中的查询字符串，并将解析结果更新到r.Form字段。对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。ParseMultipartForm会自动调用ParseForm。重复调用本方法是无意义的。  </p>
<p>func (r *Request) ParseMultipartForm(maxMemory int64) error //ParseMultipartForm将请求的主体作为multipart/form-data解析。请求的整个主体都会被解析，得到的文件记录最多 maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。如果必要，ParseMultipartForm会自行调用 ParseForm。重复调用本方法是无意义的。  </p>
<p>func (r *Request) PostFormValue(key string) string//返回post或者put请求body指定元素的第一个值，其中url中的参数被忽略。  </p>
<p>func (r *Request) ProtoAtLeast(major, minor int) bool//检测在request中使用的http协议是否至少是major.minor  </p>
<p>func (r *Request) Referer() string//如果request中有refer，那么refer返回相应的url。Referer在request中是拼错的，这个错误从http初期就已经存在了。该值也可以从Headermap中利用Header[“Referer”]获取；在使用过程中利用Referer这个方法而不是map的形式的好处是在编译过程中可以检查方法的错误，而无法检查map中key的错误。  </p>
<p> func (r *Request) Write(w io.Writer) error//Write方法以有线格式将HTTP/1.1请求写入w（用于将请求写入下层TCPConn等）。本方法会考虑请求的如下字段：Host URL Method (defaults to “GET”) Header ContentLength TransferEncoding Body<br>　如果存在Body，ContentLength字段&lt;= 0且TransferEncoding字段未显式设置为[“identity”]，Write方法会显式添加”Transfer-Encoding: chunked”到请求的头域。Body字段会在发送完请求后关闭。  </p>
<p> func (r *Request) WriteProxy(w io.Writer) error//该函数与Write方法类似，但是该方法写的request是按照http代理的格式去写。尤其是，按照RFC 2616 Section 5.1.2，WriteProxy会使用绝对URI（包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，WriteProxy都会使用r.Host或r.URL.Host设置Host头。</p>
<h3 id="type-Response-struct"><a href="#type-Response-struct" class="headerlink" title="type Response struct"></a><strong>type Response struct</strong></h3><p>type Response//指对于一个http请求的响应response  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">    Status     <span class="keyword">string</span> <span class="comment">// 例如"200 OK"</span></span><br><span class="line">    StatusCode <span class="keyword">int</span>    <span class="comment">// 例如200</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// 例如"HTTP/1.0"</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 主协议号：例如1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 副协议号：例如0</span></span><br><span class="line">    <span class="comment">// Header保管header的key values，如果response中有多个header中具有相同的key，那么Header中保存为该键对应用逗号分隔串联起来的这些头的值// 被本结构体中的其他字段复制保管的头（如ContentLength）会从Header中删掉。Header中的键都是规范化的，参见CanonicalHeaderKey函数</span></span><br><span class="line">    Header Header</span><br><span class="line">    <span class="comment">// Body代表response的主体。http的client和Transport确保这个body永远非nil，即使response没有body或body长度为0。调用者也需要关闭这个body// 如果服务端采用"chunked"传输编码发送的回复，Body字段会自动进行解码。</span></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line">    <span class="comment">// ContentLength记录相关内容的长度。</span></span><br><span class="line">    <span class="comment">// 其值为-1表示长度未知（采用chunked传输编码）</span></span><br><span class="line">    <span class="comment">// 除非对应的Request.Method是"HEAD"，其值&gt;=0表示可以从Body读取的字节数</span></span><br><span class="line">    ContentLength <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示"identity"编码。</span></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line">    <span class="comment">// Close记录头域是否指定应在读取完主体后关闭连接。（即Connection头）</span></span><br><span class="line">    <span class="comment">// 该值是给客户端的建议，Response.Write方法的ReadResponse函数都不会关闭连接。</span></span><br><span class="line">    Close <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Trailer字段保存和头域相同格式的trailer键值对，和Header字段相同类型</span></span><br><span class="line">    Trailer Header</span><br><span class="line">    <span class="comment">// Request是用来获取此回复的请求，Request的Body字段是nil（因为已经被用掉了）这个字段是被Client类型发出请求并获得回复后填充的</span></span><br><span class="line">    Request *Request</span><br><span class="line">    <span class="comment">// TLS包含接收到该回复的TLS连接的信息。 对未加密的回复，本字段为nil。返回的指针是被（同一TLS连接接收到的）回复共享的，不应被修改。</span></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func Get(url string) (resp *Response, err error)//利用GET方法对一个指定的URL进行请求，如果response是如下重定向中的一个代码，则Get之后将会调用重定向内容，最多10次重定向。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">301</span> (永久重定向，告诉客户端以后应该从新地址访问)</span><br><span class="line"><span class="number">302</span> (暂时性重定向，作为HTTP1<span class="number">.0</span>的标准，以前叫做Moved Temporarily，现在叫做Found。现在使用只是为了兼容性处理，包括PHP的默认Location重定向用到也是<span class="number">302</span>)，注：<span class="number">303</span>和<span class="number">307</span>其实是对<span class="number">302</span>的细化。</span><br><span class="line"><span class="number">303</span> (对于Post请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URl)</span><br><span class="line"><span class="number">307</span> (临时重定向，对于Post请求，表示请求还没有被处理，客户端应该向Location里的URL重新发起Post请求)</span><br></pre></td></tr></table></figure>

<p>//如果有太多次重定向或者有一个http协议错误将会导致错误。当err为nil时，resp总是包含一个非nil的resp.body，Get是对DefaultClient.Get的一个包装。  </p>
<p>func Head(url string) (resp *Response, err error)//该函数功能见net中Head方法功能。该方法与默认的defaultClient中Head方法一致。  </p>
<p>func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)//该方法与默认的defaultClient中Post方法一致。  </p>
<p>func PostForm(url string, data url.Values) (resp *Response, err error)//该方法与默认的defaultClient中PostForm方法一致。</p>
<p>func ReadResponse(r <em>bufio.Reader, req *Request) (</em>Response, error)//ReadResponse从r读取并返回一个HTTP 回复。req参数是可选的，指定该回复对应的请求（即是对该请求的回复）。如果是nil，将假设请 求是GET请求。客户端必须在结束resp.Body的读取后关闭它。读取完毕并关闭后，客户端可以检查resp.Trailer字段获取回复的 trailer的键值对。（本函数主要用在客户端从下层获取回复）  </p>
<p>func (r <em>Response) Cookies() []</em>Cookie//解析cookie并返回在header中利用set-Cookie设定的cookie值。  </p>
<p>func (r <em>Response) Location() (</em>url.URL, error)//返回response中Location的header值的url。如果该值存在的话，则对于请求问题可以解决相对重定向的问题，如果该值为nil，则返回ErrNOLocation的错误。  </p>
<p>func (r *Response) ProtoAtLeast(major, minor int) bool//判定在response中使用的http协议是否至少是major.minor的形式。  </p>
<p>func (r *Response) Write(w io.Writer) error//将response中信息按照线性格式写入w中。</p>
<p><strong>type ResponseWriter 接口</strong>  </p>
<p>type ResponseWriter//该接口被http handler用来构建一个http response  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Header返回一个Header类型值，该值会被WriteHeader方法发送.在调用WriteHeader或Write方法后再改变header值是不起作用的。</span></span><br><span class="line">    Header() Header</span><br><span class="line">    <span class="comment">// WriteHeader该方法发送HTTP回复的头域和状态码。如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)</span></span><br><span class="line">    <span class="comment">// 因此，显示调用WriterHeader主要用于发送错误状态码。</span></span><br><span class="line">    WriteHeader(<span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// Write向连接中写入数据，该数据作为HTTP response的一部分。如果被调用时还没有调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)</span></span><br><span class="line">    <span class="comment">// 如果Header中没有"Content-Type"键，本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值。</span></span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-RoundTripper-接口"><a href="#type-RoundTripper-接口" class="headerlink" title="type RoundTripper 接口"></a><strong>type RoundTripper 接口</strong></h3><p>type RoundTripper//该函数是一个执行简单http事务的接口，该接口在被多协程并发使用时必须是安全的。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RoundTripper <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// RoundTrip执行单次HTTP事务，返回request的response，RoundTrip不应试图解析该回复。</span></span><br><span class="line">    <span class="comment">// 尤其要注意，只要RoundTrip获得了一个回复，不管该回复的HTTP状态码如何，它必须将返回值err设置为nil。</span></span><br><span class="line">    <span class="comment">// 非nil的返回值err应该留给获取回复失败的情况。类似的，RoundTrip不能试图管理高层协议，如重定向、认证或者cookie。</span></span><br><span class="line">    <span class="comment">// RoundTrip除了从请求的主体读取并关闭主体之外，不能够对请求做任何修改，包括（请求的）错误。</span></span><br><span class="line">    <span class="comment">// RoundTrip函数接收的请求的URL和Header字段必须保证是初始化了的。</span></span><br><span class="line">    RoundTrip(*Request) (*Response, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func NewFileTransport(fs FileSystem) RoundTripper //该函数返回一个RoundTripper接口，服务指定的文件系统。 返回的RoundTripper接口会忽略接收的请求中的URL主机及其他绝大多数属性。该函数的典型应用是给Transport类型的值注册”file”协议。如下所示：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t := &amp;http.Transport&#123;&#125;</span><br><span class="line">t.RegisterProtocol(<span class="string">"file"</span>, http.NewFileTransport(http.Dir(<span class="string">"/"</span>)))</span><br><span class="line">c := &amp;http.Client&#123;Transport: t&#125;</span><br><span class="line">res, err := c.Get(<span class="string">"file:///etc/passwd"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="type-ServeMux"><a href="#type-ServeMux" class="headerlink" title="*type ServeMux *"></a>*<em>type ServeMux *</em></h3><p>type ServeMux //该函数是一个http请求多路复用器，它将每一个请求的URL和一个注册模式的列表进行匹配，然后调用和URL最匹配的模式的处理器进行后续操作。模式是固定的、由根开始的路径，如”/favicon.ico”，或由根开始的子树，如”/images/“ （注意结尾的斜杠）。较长的模式优先于较短的模式，因此如果模式”/images/“和”/images/thumbnails/“都注册了处理器，后一 个处理器会用于路径以”/images/thumbnails/“开始的请求，前一个处理器会接收到其余的路径在”/images/“子树下的请求。<br>注意，因为以斜杠结尾的模式代表一个由根开始的子树，模式”/“会匹配所有的未被其他注册的模式匹配的路径，而不仅仅是路径”/“。  </p>
<p>模式也能（可选地）以主机名开始，表示只匹配该主机上的路径。指定主机的模式优先于一般的模式，因此一个注册了两个模式”/codesearch”和”codesearch.google.com/“的处理器不会接管目标为”<a href="http://www.google.com/&quot;的请求。" target="_blank" rel="noopener">http://www.google.com/&quot;的请求。</a>  </p>
<p>ServeMux还会负责对URL路径的过滤，将任何路径中包含”.”或”..”元素的请求重定向到等价的没有这两种元素的URL。（参见path.Clean函数）  </p>
<p>func NewServeMux() *ServeMux //初始化一个新的ServeMux  </p>
<p>func (mux *ServeMux) Handle(pattern string, handler Handler) //将handler注册为指定的模式，如果该模式已经有了handler，则会出错panic。  </p>
<p>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))//将handler注册为指定的模式</p>
<p>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) //根据指定的r.Method,r.Host以及r.RUL.Path返回一个用来处理给定请求的handler。该函数总是返回一个非nil的 handler，如果path不是一个规范格式，则handler会重定向到其规范path。Handler总是返回匹配该请求的的已注册模式；在内建重 定向处理器的情况下，pattern会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，本方法将返回一个内建的”404 page not found”处理器和一个空字符串模式。</p>
<p>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)  //该函数用于将最接近请求url模式的handler分配给指定的请求。  </p>
<p>举例说明servemux的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"just for test!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"/home"</span>)))</span><br><span class="line">    mux.HandleFunc(<span class="string">"/test"</span>, Test)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9999"</span>, mux)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Server-struct"><a href="#type-Server-struct" class="headerlink" title="type Server struct"></a><strong>type Server struct</strong></h3><p>type Server //该结构体定义一些用来运行HTTP Server的参数，如果Server默认为0的话，那么这也是一个有效的配置。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr           <span class="keyword">string</span>        <span class="comment">// 监听的TCP地址，如果为空字符串会使用":http"</span></span><br><span class="line">    Handler        Handler       <span class="comment">// 调用的处理器，如为nil会调用http.DefaultServeMux</span></span><br><span class="line">    ReadTimeout    time.Duration <span class="comment">// 请求的读取操作在超时前的最大持续时间</span></span><br><span class="line">    WriteTimeout   time.Duration <span class="comment">// 回复的写入操作在超时前的最大持续时间</span></span><br><span class="line">    MaxHeaderBytes <span class="keyword">int</span>           <span class="comment">// 请求的头域最大长度，如为0则用DefaultMaxHeaderBytes</span></span><br><span class="line">    TLSConfig      *tls.Config   <span class="comment">// 可选的TLS配置，用于ListenAndServeTLS方法</span></span><br><span class="line">    <span class="comment">// TLSNextProto（可选地）指定一个函数来在一个NPN型协议升级出现时接管TLS连接的所有权。</span></span><br><span class="line">    <span class="comment">// 映射的键为商谈的协议名；映射的值为函数，该函数的Handler参数应处理HTTP请求，</span></span><br><span class="line">    <span class="comment">// 并且初始化Handler.ServeHTTP的*Request参数的TLS和RemoteAddr字段（如果未设置）。</span></span><br><span class="line">    <span class="comment">// 连接在函数返回时会自动关闭。</span></span><br><span class="line">    TLSNextProto <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">(*Server, *tls.Conn, Handler)</span></span></span><br><span class="line">    <span class="comment">// ConnState字段指定一个可选的回调函数，该函数会在一个与客户端的连接改变状态时被调用。</span></span><br><span class="line">    <span class="comment">// 参见ConnState类型和相关常数获取细节。</span></span><br><span class="line">    ConnState <span class="function"><span class="keyword">func</span><span class="params">(net.Conn, ConnState)</span></span></span><br><span class="line">    <span class="comment">// ErrorLog指定一个可选的日志记录器，用于记录接收连接时的错误和处理器不正常的行为。</span></span><br><span class="line">    <span class="comment">// 如果本字段为nil，日志会通过log包的标准日志记录器写入os.Stderr。</span></span><br><span class="line">    ErrorLog *log.Logger</span><br><span class="line">    <span class="comment">// 内含隐藏或非导出字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func (srv *Server) ListenAndServe() error//监听TCP网络地址srv.Addr然后调用Serve来处理接下来连接的请求。如果srv.Addr是空的话，则使用“:http”。  </p>
<p>func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error//ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve方法处理接收到的连接。必须提供证书文件和对应的私钥文 件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使 用”:https”。  </p>
<p>func (srv *Server) Serve(l net.Listener) error//接受Listener l的连接，创建一个新的服务协程。该服务协程读取请求然后调用srv.Handler来应答。实际上就是实现了对某个端口进行监听，然后创建相应的连接。  </p>
<p>func (s *Server) SetKeepAlivesEnabled(v bool)//该函数控制是否http的keep-alives能够使用，默认情况下，keep-alives总是可用的。只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。  </p>
<p>举例说明Server的用法：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintln(w, <span class="string">"just for test!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newserver := http.Server&#123;</span><br><span class="line">        Addr:         <span class="string">":9992"</span>,</span><br><span class="line">        ReadTimeout:  <span class="number">0</span>,</span><br><span class="line">        WriteTimeout: <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(<span class="string">"/home"</span>)))</span><br><span class="line">    mux.HandleFunc(<span class="string">"/test"</span>, Test)</span><br><span class="line"></span><br><span class="line">    newserver.Handler = mux</span><br><span class="line">    err := newserver.ListenAndServe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="comment">// err := http.ListenAndServe(":9999", mux)</span></span><br><span class="line">    <span class="comment">// if err != nil &#123;</span></span><br><span class="line">    <span class="comment">//     fmt.Println(err)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-Transport-struct"><a href="#type-Transport-struct" class="headerlink" title="type Transport struct"></a><strong>type Transport struct</strong></h3><p>type Transport  //该结构体实现了RoundTripper接口，支持HTTP，HTTPS以及HTTP代理，TranSport也能缓存连接供将来使用。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transport <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Proxy指定一个对给定请求返回代理的函数。如果该函数返回了非nil的错误值，请求的执行就会中断并返回该错误。</span></span><br><span class="line">    <span class="comment">// 如果Proxy为nil或返回nil的*URL值，将不使用代理。</span></span><br><span class="line">    Proxy <span class="function"><span class="keyword">func</span><span class="params">(*Request)</span> <span class="params">(*url.URL, error)</span></span></span><br><span class="line">    <span class="comment">// Dial指定创建未加密TCP连接的dial函数。如果Dial为nil，会使用net.Dial。</span></span><br><span class="line">    Dial <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span></span><br><span class="line">　　<span class="comment">// DialTls利用一个可选的dial函数来为非代理的https请求创建一个TLS连接。如果DialTLS为nil的话，那么使用Dial和TLSClientConfig。</span></span><br><span class="line">　　<span class="comment">//如果DialTLS被设定，那么Dial钩子不被用于HTTPS请求和TLSClientConfig并且TLSHandshakeTimeout被忽略。返回的net.conn默认已经经过了TLS握手协议。</span></span><br><span class="line">　　DialTLS <span class="function"><span class="keyword">func</span><span class="params">(network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> </span><br><span class="line">    <span class="comment">// TLSClientConfig指定用于tls.Client的TLS配置信息。如果该字段为nil，会使用默认的配置信息。</span></span><br><span class="line">    TLSClientConfig *tls.Config</span><br><span class="line">    <span class="comment">// TLSHandshakeTimeout指定等待TLS握手完成的最长时间。零值表示不设置超时。</span></span><br><span class="line">    TLSHandshakeTimeout time.Duration</span><br><span class="line">    <span class="comment">// 如果DisableKeepAlives为真，不同HTTP请求之间TCP连接的重用将被阻止。</span></span><br><span class="line">    DisableKeepAlives <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 如果DisableCompression为真，会禁止Transport在请求中没有Accept-Encoding头时，</span></span><br><span class="line">    <span class="comment">// 主动添加"Accept-Encoding: gzip"头，以获取压缩数据。</span></span><br><span class="line">    <span class="comment">// 如果Transport自己请求gzip并得到了压缩后的回复，它会主动解压缩回复的主体。</span></span><br><span class="line">    <span class="comment">// 但如果用户显式的请求gzip压缩数据，Transport是不会主动解压缩的。</span></span><br><span class="line">    DisableCompression <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 如果MaxIdleConnsPerHost不为0，会控制每个主机下的最大闲置连接数目。</span></span><br><span class="line">    <span class="comment">// 如果MaxIdleConnsPerHost为0，会使用DefaultMaxIdleConnsPerHost。</span></span><br><span class="line">    MaxIdleConnsPerHost <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// ResponseHeaderTimeout指定在发送完请求（包括其可能的主体）之后，</span></span><br><span class="line">    <span class="comment">// 等待接收服务端的回复的头域的最大时间。零值表示不设置超时。</span></span><br><span class="line">    <span class="comment">// 该时间不包括读取回复主体的时间。</span></span><br><span class="line">    ResponseHeaderTimeout time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func (t *Transport) CancelRequest(req *Request)//通过关闭连接来取消传送中的请求。  </p>
<p>func (t *Transport) CloseIdleConnections()//关闭所有之前请求但目前处于空闲状态的连接。该方法并不中断任何正在使用的连接。  </p>
<p>func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)//RegisterProtocol注册一个新的名为scheme的协议。t会将使用scheme协议的请求转交给rt。rt有责任模拟HTTP请求的语义。RegisterProtocol可以被其他包用于提供”ftp”或”file”等协议的实现。  </p>
<p>func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)//该函数实现了RoundTripper接口，对于高层http客户端支持，例如处理cookies以及重定向，查看Get，Post以及Client类型。</p>
<hr>
<h1 id="io-ioutil-包"><a href="#io-ioutil-包" class="headerlink" title="io/ioutil 包"></a><code>io/ioutil</code> 包</h1><h2 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h2><h3 id="Discard-1"><a href="#Discard-1" class="headerlink" title="Discard"></a>Discard</h3><p>Discard 是一个 io.Writer 接口，调用它的 Write 方法将不做任何事情并且始终成功返回。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Discard io.Writer = devNull(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="ReadAll"><a href="#ReadAll" class="headerlink" title="ReadAll"></a>ReadAll</h3><p>ReadAll 读取 r 中的所有数据，返回读取的数据和遇到的错误。<br>如果读取成功，则 err 返回 nil，而不是 EOF，因为 ReadAll 定义为读取所有数据，所以不会把 EOF 当做错误处理。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h3><p>ReadFile 读取文件中的所有数据，返回读取的数据和遇到的错误。  </p>
<p>如果读取成功，则 err 返回 nil，而不是 EOF。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h3><p>WriteFile 向文件中写入数据，写入前会清空文件。  </p>
<p>如果文件不存在，则会以指定的权限创建该文件。  </p>
<p>返回遇到的错误。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="keyword">string</span>, data []<span class="keyword">byte</span>, perm os.FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="ReadDir"><a href="#ReadDir" class="headerlink" title="ReadDir"></a>ReadDir</h3><p>ReadDir 读取指定目录中的所有目录和文件（不包括子目录）。  </p>
<p>返回读取到的文件信息列表和遇到的错误，列表是经过排序的。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="keyword">string</span>)</span> <span class="params">([]os.FileInfo, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="NopCloser"><a href="#NopCloser" class="headerlink" title="NopCloser"></a>NopCloser</h3><p>NopCloser 将 r 包装为一个 ReadCloser 类型，但 Close 方法不做任何事情。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NopCloser</span><span class="params">(r io.Reader)</span> <span class="title">io</span>.<span class="title">ReadCloser</span></span></span><br></pre></td></tr></table></figure>

<h3 id="TempFile"><a href="#TempFile" class="headerlink" title="TempFile"></a>TempFile</h3><p>TempFile 在 dir 目录中创建一个以 prefix 为前缀的临时文件，并将其以读写模式打开。返回创建的文件对象和遇到的错误。  </p>
<p>如果 dir 为空，则在默认的临时目录中创建文件（参见 os.TempDir），多次调用会创建不同的临时文件，调用者可以通过 f.Name() 获取文件的完整路径。  </p>
<p>调用本函数所创建的临时文件，应该由调用者自己删除。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, prefix <span class="keyword">string</span>)</span> <span class="params">(f *os.File, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="TempDir"><a href="#TempDir" class="headerlink" title="TempDir"></a>TempDir</h3><p>TempDir 功能同 TempFile，只不过创建的是目录，返回目录的完整路径。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, prefix <span class="keyword">string</span>)</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>读取目录：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rd, err := ioutil.ReadDir(<span class="string">"/"</span>)</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">for</span> _, fi := <span class="keyword">range</span> rd &#123;</span><br><span class="line">        <span class="keyword">if</span> fi.IsDir() &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"[%s]\n"</span>, fi.Name())</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(fi.Name())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>临时目录、临时文件：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建临时目录</span></span><br><span class="line">    dir, err := ioutil.TempDir(<span class="string">""</span>, <span class="string">"Test"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> os.Remove(dir) <span class="comment">// 用完删除</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时文件</span></span><br><span class="line">    f, err := ioutil.TempFile(dir, <span class="string">"Test"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> os.Remove(f.Name()) <span class="comment">// 用完删除</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, f.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="os-包"><a href="#os-包" class="headerlink" title="os 包"></a><code>os</code> 包</h1><h2 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h2><h3 id="获取当前目录、改变目录"><a href="#获取当前目录、改变目录" class="headerlink" title="获取当前目录、改变目录"></a>获取当前目录、改变目录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getwd</span><span class="params">()</span> <span class="params">(dir <span class="keyword">string</span>, err error)</span>    //获取当前目录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chdir</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="title">error</span>            // 修改当前目录</span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(os.Getwd())</span><br><span class="line">  os.Chdir(<span class="string">"/Users/rtk"</span>)</span><br><span class="line">  fmt.Println(os.Getwd())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chmod</span><span class="params">(name <span class="keyword">string</span>, mode FileMode)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">eg. 将文件改为不可读：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(os.Getwd())</span><br><span class="line">  os.Chdir(<span class="string">"/Users/xujie/Desktop"</span>)</span><br><span class="line">  os.Chmod(<span class="string">"file.txt"</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取用户识别码uid-和-群组识别码gid"><a href="#获取用户识别码uid-和-群组识别码gid" class="headerlink" title="获取用户识别码uid 和 群组识别码gid"></a>获取用户识别码uid 和 群组识别码gid</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getuid</span><span class="params">()</span>  <span class="title">int</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getegid</span><span class="params">()</span>  <span class="title">int</span>  // 有效的用户识别码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Geteuid</span><span class="params">()</span> <span class="title">int</span>  // 有效的群组识别码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getgid</span><span class="params">()</span>  <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="查看用户所属组的列表"><a href="#查看用户所属组的列表" class="headerlink" title="查看用户所属组的列表"></a>查看用户所属组的列表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getgroups</span><span class="params">()</span> <span class="params">([]<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="返回底层系统的内存页面大小"><a href="#返回底层系统的内存页面大小" class="headerlink" title="返回底层系统的内存页面大小"></a>返回底层系统的内存页面大小</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getpagesize</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取主机名称"><a href="#获取主机名称" class="headerlink" title="获取主机名称"></a>获取主机名称</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hostname</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前进程id、父进程id"><a href="#获取当前进程id、父进程id" class="headerlink" title="获取当前进程id、父进程id"></a>获取当前进程id、父进程id</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getpid</span><span class="params">()</span>       // 获取当前进程<span class="title">id</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getppid</span><span class="params">()</span>      // 获取父进程<span class="title">id</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取文件的状态"><a href="#获取文件的状态" class="headerlink" title="获取文件的状态"></a>获取文件的状态</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(FileInfo, error)</span></span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  filename := <span class="string">"/Users/xujie/Desktop/file.txt"</span></span><br><span class="line">  file,_:=os.Stat(filename)</span><br><span class="line">  fmt.Println(file.Name())</span><br><span class="line">  fmt.Println(file.IsDir())</span><br><span class="line">  fmt.Println(file.Size())</span><br><span class="line">  fmt.Println(file.Mode())</span><br><span class="line">  fmt.Println(file.Sys())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err error)</span> <span class="title">bool</span>        // 文件存在,但是由系统产生错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err error)</span> <span class="title">bool</span>     // 目录或者文件不存在时返回<span class="title">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPermission</span><span class="params">(err error)</span><span class="title">bool</span>    // 检测是不是由于权限不足导致的错误</span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  filename := <span class="string">"file.txt"</span></span><br><span class="line">  _, err := os.Stat(filename);</span><br><span class="line">  fmt.Println(os.IsExist(err))</span><br><span class="line">  fmt.Println(os.IsNotExist(err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建文件夹、删除文件或文件夹"><a href="#创建文件夹、删除文件或文件夹" class="headerlink" title="创建文件夹、删除文件或文件夹"></a>创建文件夹、删除文件或文件夹</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mkdir</span><span class="params">(name <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveAll</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span>   // 删除文件夹下所有文件</span></span><br></pre></td></tr></table></figure>

<h3 id="修改文件夹或文件的名称"><a href="#修改文件夹或文件的名称" class="headerlink" title="修改文件夹或文件的名称"></a>修改文件夹或文件的名称</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="移动文件夹或文件"><a href="#移动文件夹或文件" class="headerlink" title="移动文件夹或文件"></a>移动文件夹或文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rename</span><span class="params">(oldpath, newpath <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法创建文件是默认的权限为0666,如果已经存在同名的文件,则调用此方法,会覆盖掉原来的文件  </p>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*File, error)</span></span></span><br></pre></td></tr></table></figure>
<p>如果打开的文件不存在,则会返回错误 <code>open file1.txt: no such file or directory</code>  </p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>要注意的是，os.open() 打开的文件是只读的，写入不成功，需要：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span></span><br><span class="line"></span><br><span class="line">第二个参数</span><br><span class="line">O_RDONLY    打开只读文件</span><br><span class="line">O_WRONLY    打开只写文件</span><br><span class="line">O_RDWR  打开既可以读取又可以写入文件</span><br><span class="line">O_APPEND    写入文件时将数据追加到文件尾部</span><br><span class="line">O_CREATE    如果文件不存在，则创建一个新的文件</span><br><span class="line">O_EXCL  文件必须不存在，然后会创建一个新的文件</span><br><span class="line">O_SYNC  打开同步I/<span class="number">0</span></span><br><span class="line">O_TRUNC 文件打开时可以截断</span><br><span class="line"></span><br><span class="line">第三个参数就是权限模式</span><br></pre></td></tr></table></figure>
<p>例子：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 进入桌面目录</span></span><br><span class="line">  os.Chdir(<span class="string">"/Users/xujie/Desktop"</span>)</span><br><span class="line">  <span class="comment">// 创建一个文件夹</span></span><br><span class="line"> file,error:= os.OpenFile(<span class="string">"file.txt"</span>,os.O_RDWR,<span class="number">0666</span>)</span><br><span class="line"> <span class="comment">// 如果是要追加内容：</span></span><br><span class="line"> <span class="comment">// file,error:= os.OpenFile("file.txt",os.O_RDWR|os.O_APPEND,0666)</span></span><br><span class="line"> <span class="keyword">defer</span> file.Close()</span><br><span class="line"> <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line"> &#125;</span><br><span class="line"> _,error = file.WriteString(<span class="string">"你好"</span>)</span><br><span class="line">  _,error = file.WriteString(<span class="string">"从天有一个书"</span>)</span><br><span class="line">  fmt.Println(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 进入桌面目录</span></span><br><span class="line">  os.Chdir(<span class="string">"/Users/xujie/Desktop"</span>)</span><br><span class="line"> file,error:= os.Open(<span class="string">"file.txt"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">defer</span> file.Close()</span><br><span class="line"> <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line">  fileInfo,_ := file.Stat()</span><br><span class="line">  fmt.Println(fileInfo.Size())</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建缓冲区</span></span><br><span class="line"> data := <span class="built_in">make</span>([]<span class="keyword">byte</span>,fileInfo.Size())</span><br><span class="line"> <span class="comment">// 一次性读取所有内容到缓冲区中</span></span><br><span class="line"> _,error = file.Read(data)</span><br><span class="line"></span><br><span class="line"> fmt.Println(error)</span><br><span class="line"> fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure>

<h3 id="检测文件是否是同一个"><a href="#检测文件是否是同一个" class="headerlink" title="检测文件是否是同一个"></a>检测文件是否是同一个</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SameFile</span><span class="params">(fi1, fi2 FileInfo)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>
<p>就算是同一个文件,没在同一个路径下也会返回false，判断依据如下<br>这意味着两个基础结构的 inode 字段是相同的  </p>
<h3 id="获取文件模式相关信息"><a href="#获取文件模式相关信息" class="headerlink" title="获取文件模式相关信息"></a>获取文件模式相关信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m FileMode)</span> <span class="title">IsDir</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m FileMode)</span> <span class="title">IsRegular</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m FileMode)</span> <span class="title">Perm</span><span class="params">()</span> <span class="title">FileMode</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m FileMode)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fileInfo1,_:= os.Stat(<span class="string">"/Users/xujie/Desktop/DataParser.zip"</span>)</span><br><span class="line">  fmt.Println(fileInfo1.Mode().String())</span><br><span class="line">  fmt.Println(fileInfo1.Mode().IsRegular())</span><br><span class="line">  fmt.Println(fileInfo1.Mode().IsDir())</span><br><span class="line">  fmt.Println(fileInfo1.Mode().Perm())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="把文件所在的目录切换为当前目录"><a href="#把文件所在的目录切换为当前目录" class="headerlink" title="把文件所在的目录切换为当前目录"></a>把文件所在的目录切换为当前目录</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chdir</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="查看文件名称"><a href="#查看文件名称" class="headerlink" title="查看文件名称"></a>查看文件名称</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="如何查看所有文件夹下的所有文件和文件数量"><a href="#如何查看所有文件夹下的所有文件和文件数量" class="headerlink" title="如何查看所有文件夹下的所有文件和文件数量"></a>如何查看所有文件夹下的所有文件和文件数量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Readdir</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]FileInfo, error)</span></span></span><br><span class="line"><span class="comment">// n 表示读取目录下文件的最大数量,n &lt; 0 表示全部 </span></span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file,_ := os.Open(<span class="string">"/Users/xujie/Desktop/未命名文件夹"</span>)</span><br><span class="line">  files,_ := file.Readdir(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">for</span> _,f := <span class="keyword">range</span>  files &#123;</span><br><span class="line">    fmt.Println(f.Name())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件夹的下面文件的名称"><a href="#读取文件夹的下面文件的名称" class="headerlink" title="读取文件夹的下面文件的名称"></a>读取文件夹的下面文件的名称</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Readdirnames</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(names []<span class="keyword">string</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file,_ := os.Open(<span class="string">"/Users/xujie/Desktop/未命名文件夹"</span>)</span><br><span class="line">  fileNames,_ := file.Readdirnames(<span class="number">-1</span>)</span><br><span class="line">  <span class="keyword">for</span> _,name := <span class="keyword">range</span>  fileNames &#123;</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取临时陌路的文件夹路径"><a href="#获取临时陌路的文件夹路径" class="headerlink" title="获取临时陌路的文件夹路径"></a>获取临时陌路的文件夹路径</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="判断字符是否是支持的路径分隔符"><a href="#判断字符是否是支持的路径分隔符" class="headerlink" title="判断字符是否是支持的路径分隔符"></a>判断字符是否是支持的路径分隔符</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPathSeparator</span><span class="params">(c <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> fmt.Println(os.IsPathSeparator(<span class="string">'c'</span>))</span><br><span class="line">  fmt.Println(os.IsPathSeparator(<span class="string">'\\'</span>))</span><br><span class="line">  fmt.Println(os.IsPathSeparator(<span class="string">'/'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Getenv</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LookupEnv</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">//key区分大小写</span></span><br></pre></td></tr></table></figure>

<h3 id="查找指定环境变量"><a href="#查找指定环境变量" class="headerlink" title="查找指定环境变量"></a>查找指定环境变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func</span> <span class="title">Expand</span><span class="params">(s <span class="keyword">string</span>, mapping <span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">string</span>) <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExpandEnv</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取文件对应的unix文件描述符"><a href="#获取文件对应的unix文件描述符" class="headerlink" title="获取文件对应的unix文件描述符"></a>获取文件对应的unix文件描述符</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Fd</span><span class="params">()</span> <span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Chown修改文件的用户ID和组ID"><a href="#Chown修改文件的用户ID和组ID" class="headerlink" title="Chown修改文件的用户ID和组ID"></a>Chown修改文件的用户ID和组ID</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chown</span><span class="params">(name <span class="keyword">string</span>, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="修改文件权限-1"><a href="#修改文件权限-1" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chmod</span><span class="params">(mode FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="强制改变文件大小"><a href="#强制改变文件大小" class="headerlink" title="强制改变文件大小"></a>强制改变文件大小</h3><p>两个方法：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Truncate</span><span class="params">(name <span class="keyword">string</span>, size <span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span><span class="title">Truncate</span><span class="params">(size <span class="keyword">int64</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>减小文件大小会造成内容丢失。  </p>
<h3 id="链接-硬链接"><a href="#链接-硬链接" class="headerlink" title="链接 硬链接"></a>链接 硬链接</h3><p>硬链接(hard link, 也称链接)就是一个文件的一个或多个文件名。再说白点，所谓链接无非是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Link</span><span class="params">(oldname, newname <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="同步保存当前文件的内容"><a href="#同步保存当前文件的内容" class="headerlink" title="同步保存当前文件的内容"></a>同步保存当前文件的内容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Sync</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file,error := os.OpenFile(<span class="string">"/Users/xujie/Desktop/file.txt"</span>,os.O_RDWR,<span class="number">0777</span>)</span><br><span class="line">  <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line">  &#125;</span><br><span class="line">  file.WriteString(<span class="string">"新内容"</span>)</span><br><span class="line">  file.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewFile使用给出的Unix文件描述符和名称创建一个文件"><a href="#NewFile使用给出的Unix文件描述符和名称创建一个文件" class="headerlink" title="NewFile使用给出的Unix文件描述符和名称创建一个文件"></a>NewFile使用给出的Unix文件描述符和名称创建一个文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Lstat返回一个描述name指定的文件对象的FileInfo"><a href="#Lstat返回一个描述name指定的文件对象的FileInfo" class="headerlink" title="Lstat返回一个描述name指定的文件对象的FileInfo"></a>Lstat返回一个描述name指定的文件对象的FileInfo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lstat</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(fi FileInfo, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Lstat返回一个描述name指定的文件对象的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接的信息，本函数不会试图跳转该链接。如果出错，返回的错误值为*PathError类型   </p>
<h3 id="查看所有环境变量、清除环境变量"><a href="#查看所有环境变量、清除环境变量" class="headerlink" title="查看所有环境变量、清除环境变量"></a>查看所有环境变量、清除环境变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Environ</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Clearenv</span><span class="params">()</span> []<span class="title">string</span>  //慎用！！</span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前程序可执行的文件地址"><a href="#获取当前程序可执行的文件地址" class="headerlink" title="获取当前程序可执行的文件地址"></a>获取当前程序可执行的文件地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Executable</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="让程序已给定的状态码退出"><a href="#让程序已给定的状态码退出" class="headerlink" title="让程序已给定的状态码退出"></a>让程序已给定的状态码退出</h3><p>Exit让当前程序以给出的状态码code退出。一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Exit</span><span class="params">(code <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="设置环和取消环境变量"><a href="#设置环和取消环境变量" class="headerlink" title="设置环和取消环境变量"></a>设置环和取消环境变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unsetenv</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Setenv</span><span class="params">(key, value <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    os.Setenv(<span class="string">"TMPDIR"</span>, <span class="string">"/my/tmp"</span>)</span><br><span class="line">    <span class="keyword">defer</span> os.Unsetenv(<span class="string">"TMPDIR"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建软链接"><a href="#创建软链接" class="headerlink" title="创建软链接"></a>创建软链接</h3><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">软连接和硬链接的区别</a>  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Symlink</span><span class="params">(oldname, newname <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取软链接文件对应的实际文件路径地址"><a href="#获取软链接文件对应的实际文件路径地址" class="headerlink" title="获取软链接文件对应的实际文件路径地址"></a>获取软链接文件对应的实际文件路径地址</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Readlink</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="更改指定文件的访问和修改时间"><a href="#更改指定文件的访问和修改时间" class="headerlink" title="更改指定文件的访问和修改时间"></a>更改指定文件的访问和修改时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chtimes</span><span class="params">(name <span class="keyword">string</span>, atime time.Time, mtime time.Time)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>第二个参数访问时间 第三个参数修改时间  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Chtimes(<span class="string">"/Users/xujie/Desktop/file.txt"</span>,time.Now(),time.Now().Add(time.Hour * <span class="number">24</span>))</span><br></pre></td></tr></table></figure>

<h3 id="创建文件夹-并设置权限"><a href="#创建文件夹-并设置权限" class="headerlink" title="创建文件夹,并设置权限"></a>创建文件夹,并设置权限</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MkdirAll</span><span class="params">(path <span class="keyword">string</span>, perm FileMode)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>规则：  </p>
<ul>
<li>如果已经存在同名文件夹,则此方法不做任何事情</li>
<li>文件夹里面所有文件都是同样的权限</li>
</ul>
<h3 id="设置文章的读写位置"><a href="#设置文章的读写位置" class="headerlink" title="设置文章的读写位置"></a>设置文章的读写位置</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(ret <span class="keyword">int64</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>Seek设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">eg：</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> file,error := os.Open(<span class="string">"/Users/xujie/Desktop/file.txt"</span>)</span><br><span class="line"> <span class="keyword">defer</span>  file.Close()</span><br><span class="line"> <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> offset := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line"> data := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">10</span>)</span><br><span class="line"> totalData := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">0</span>,<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// 设置偏移量 </span></span><br><span class="line">  file.Seek(offset,<span class="number">0</span>)</span><br><span class="line">  offset += <span class="number">10</span></span><br><span class="line">  <span class="comment">// 读取数据</span></span><br><span class="line">  _,error = file.Read(data)</span><br><span class="line">   <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">     fmt.Println(error)</span><br><span class="line">     <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 拼接数据</span></span><br><span class="line">  totalData = <span class="built_in">append</span>(totalData,data...)</span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"> &#125;</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(totalData))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file.Seek(offset,0) offset = 0</code> 从文件中读取10个数据,之后偏移量设置为offset = 10,则从文件内容第11个字节开始读取，当Read方法读取文件到结尾时,会返回EOF标识,这个时候程序退出for循环  </p>
<h3 id="修改文件权限-2"><a href="#修改文件权限-2" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lchown</span><span class="params">(name <span class="keyword">string</span>, uid, gid <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="管道的用法"><a href="#管道的用法" class="headerlink" title="管道的用法"></a>管道的用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pipe</span><span class="params">()</span> <span class="params">(r *File, w *File, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>这个方法主要在协程之间进行数据传递，r.read 方法会等待接受w文件中写数据  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  r,w,error := os.Pipe()</span><br><span class="line">  <span class="keyword">go</span> write(w)</span><br><span class="line">  data := <span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1000</span>)</span><br><span class="line">  <span class="comment">// 如果数据没有写入w中,则此方法一直在等待</span></span><br><span class="line">  n,_ := r.Read(data)</span><br><span class="line">  <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(<span class="string">"读取数据："</span>)</span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(data[:n]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(w *os.File)</span></span>&#123;</span><br><span class="line">  time.AfterFunc(time.Second* <span class="number">2</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     w.WriteString(<span class="string">"ABCD"</span>)</span><br><span class="line">     w.WriteString(<span class="string">"EFGH"</span>)</span><br><span class="line">     fmt.Println(<span class="string">"数据已写入w"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建系统错误"><a href="#创建系统错误" class="headerlink" title="创建系统错误"></a>创建系统错误</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSyscallError</span><span class="params">(syscall <span class="keyword">string</span>, err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="通过pid查找进行进程"><a href="#通过pid查找进行进程" class="headerlink" title="通过pid查找进行进程"></a>通过pid查找进行进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindProcess</span><span class="params">(pid <span class="keyword">int</span>)</span> <span class="params">(*Process, error)</span></span></span><br></pre></td></tr></table></figure>
<p>查找增加运行的进程,但是在 Unix 系统上，无论过程是否存在，FindProcess 都会成功并为给定的 PID 返回一个 Process  </p>
<h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Process)</span> <span class="title">Kill</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> pid := os.Getpid()</span><br><span class="line"> process,error := os.FindProcess(pid)</span><br><span class="line"> <span class="keyword">if</span> error != <span class="literal">nil</span>&#123;</span><br><span class="line">   fmt.Println(error)</span><br><span class="line"> &#125;</span><br><span class="line"> process.Kill()</span><br><span class="line"> <span class="comment">// 进行杀死 下面就不会执行了</span></span><br><span class="line"> fmt.Println(pid)</span><br><span class="line"> fmt.Println(process)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放与进程p关联的任何资源"><a href="#释放与进程p关联的任何资源" class="headerlink" title="释放与进程p关联的任何资源"></a>释放与进程p关联的任何资源</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Process)</span> <span class="title">Release</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>Release释放进程p绑定的所有资源， 使它们（资源）不能再被（进程p）使用。只有没有调用Wait方法时才需要调用本方法  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Process)</span> <span class="title">Signal</span><span class="params">(sig Signal)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Process)</span> <span class="title">Wait</span><span class="params">()</span> <span class="params">(ProcessState, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">Exited</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">Pid</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">Success</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">Sys</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">SysUsage</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">SystemTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProcessState)</span> <span class="title">UserTime</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyscallError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="runtime-包"><a href="#runtime-包" class="headerlink" title="runtime 包"></a><code>runtime</code> 包</h1><p>runtime 包 提供了运行时与系统的交互,比如控制协程函数，触发垃圾立即回收等等底层操作  </p>
<h2 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h2><h3 id="获取GO的信息"><a href="#获取GO的信息" class="headerlink" title="获取GO的信息"></a>获取GO的信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOROOT</span><span class="params">()</span> <span class="title">string</span>    // 获取<span class="title">GOROOT</span>环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Version</span><span class="params">()</span> <span class="title">string</span>   // 获取<span class="title">GO</span>的版本号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumCPU</span><span class="params">()</span> <span class="title">int</span>       // 获取本机逻辑<span class="title">CPU</span>个数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GOMAXPROCS</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span>  // 设置最大可同时执行的最大<span class="title">CPU</span>数</span></span><br><span class="line"><span class="comment">// 设置可同时执行的最大CPU数，并返回先前的设置。 </span></span><br><span class="line"><span class="comment">// 若 n &lt; 1，它就不会更改当前设置。</span></span><br></pre></td></tr></table></figure>

<h3 id="设置cpu-profile记录的速率"><a href="#设置cpu-profile记录的速率" class="headerlink" title="设置cpu profile记录的速率"></a>设置cpu profile记录的速率</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCPUProfileRate</span><span class="params">(hz <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>SetCPUProfileRate设置CPU profile记录的速率为平均每秒hz次。如果hz&lt;=0，SetCPUProfileRate会关闭profile的记录。如果记录器在执行，该速率必须在关闭之后才能修改。  </p>
<p>绝大多数使用者应使用runtime/pprof包或testing包的-test.cpuprofile选项而非直接使用SetCPUProfileRate  </p>
<h3 id="立即执行一次垃圾回收"><a href="#立即执行一次垃圾回收" class="headerlink" title="立即执行一次垃圾回收"></a>立即执行一次垃圾回收</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="给变量绑定方法，当垃圾回收的时候进行监听"><a href="#给变量绑定方法，当垃圾回收的时候进行监听" class="headerlink" title="给变量绑定方法，当垃圾回收的时候进行监听"></a>给变量绑定方法，当垃圾回收的时候进行监听</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFinalizer</span><span class="params">(x, f <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>注意x必须是指针类型,f 函数的参数一定要和x保持一致,或者写interface{},不然程序会报错  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i *Student = <span class="built_in">new</span>(Student)</span><br><span class="line">  runtime.SetFinalizer(i, <span class="function"><span class="keyword">func</span><span class="params">(i *Student)</span></span> &#123;</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"垃圾回收了"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  runtime.GC()</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看内存申请和分配统计信息"><a href="#查看内存申请和分配统计信息" class="headerlink" title="查看内存申请和分配统计信息"></a>查看内存申请和分配统计信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadMemStats</span><span class="params">(m *MemStats)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MemStats <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 一般统计</span></span><br><span class="line">    Alloc      <span class="keyword">uint64</span> <span class="comment">// 已申请且仍在使用的字节数</span></span><br><span class="line">    TotalAlloc <span class="keyword">uint64</span> <span class="comment">// 已申请的总字节数（已释放的部分也算在内）</span></span><br><span class="line">    Sys        <span class="keyword">uint64</span> <span class="comment">// 从系统中获取的字节数（下面XxxSys之和）</span></span><br><span class="line">    Lookups    <span class="keyword">uint64</span> <span class="comment">// 指针查找的次数</span></span><br><span class="line">    Mallocs    <span class="keyword">uint64</span> <span class="comment">// 申请内存的次数</span></span><br><span class="line">    Frees      <span class="keyword">uint64</span> <span class="comment">// 释放内存的次数</span></span><br><span class="line">    <span class="comment">// 主分配堆统计</span></span><br><span class="line">    HeapAlloc    <span class="keyword">uint64</span> <span class="comment">// 已申请且仍在使用的字节数</span></span><br><span class="line">    HeapSys      <span class="keyword">uint64</span> <span class="comment">// 从系统中获取的字节数</span></span><br><span class="line">    HeapIdle     <span class="keyword">uint64</span> <span class="comment">// 闲置span中的字节数</span></span><br><span class="line">    HeapInuse    <span class="keyword">uint64</span> <span class="comment">// 非闲置span中的字节数</span></span><br><span class="line">    HeapReleased <span class="keyword">uint64</span> <span class="comment">// 释放到系统的字节数</span></span><br><span class="line">    HeapObjects  <span class="keyword">uint64</span> <span class="comment">// 已分配对象的总个数</span></span><br><span class="line">    <span class="comment">// L低层次、大小固定的结构体分配器统计，Inuse为正在使用的字节数，Sys为从系统获取的字节数</span></span><br><span class="line">    StackInuse  <span class="keyword">uint64</span> <span class="comment">// 引导程序的堆栈</span></span><br><span class="line">    StackSys    <span class="keyword">uint64</span></span><br><span class="line">    MSpanInuse  <span class="keyword">uint64</span> <span class="comment">// mspan结构体</span></span><br><span class="line">    MSpanSys    <span class="keyword">uint64</span></span><br><span class="line">    MCacheInuse <span class="keyword">uint64</span> <span class="comment">// mcache结构体</span></span><br><span class="line">    MCacheSys   <span class="keyword">uint64</span></span><br><span class="line">    BuckHashSys <span class="keyword">uint64</span> <span class="comment">// profile桶散列表</span></span><br><span class="line">    GCSys       <span class="keyword">uint64</span> <span class="comment">// GC元数据</span></span><br><span class="line">    OtherSys    <span class="keyword">uint64</span> <span class="comment">// 其他系统申请</span></span><br><span class="line">    <span class="comment">// 垃圾收集器统计</span></span><br><span class="line">    NextGC       <span class="keyword">uint64</span> <span class="comment">// 会在HeapAlloc字段到达该值（字节数）时运行下次GC</span></span><br><span class="line">    LastGC       <span class="keyword">uint64</span> <span class="comment">// 上次运行的绝对时间（纳秒）</span></span><br><span class="line">    PauseTotalNs <span class="keyword">uint64</span></span><br><span class="line">    PauseNs      [<span class="number">256</span>]<span class="keyword">uint64</span> <span class="comment">// 近期GC暂停时间的循环缓冲，最近一次在[(NumGC+255)%256]</span></span><br><span class="line">    NumGC        <span class="keyword">uint32</span></span><br><span class="line">    EnableGC     <span class="keyword">bool</span></span><br><span class="line">    DebugGC      <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 每次申请的字节数的统计，61是C代码中的尺寸分级数</span></span><br><span class="line">    BySize [<span class="number">61</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">        Size    <span class="keyword">uint32</span></span><br><span class="line">        Mallocs <span class="keyword">uint64</span></span><br><span class="line">        Frees   <span class="keyword">uint64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看程序"><a href="#查看程序" class="headerlink" title="查看程序"></a>查看程序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MemProfileRecord)</span> <span class="title">InUseBytes</span><span class="params">()</span> <span class="title">int64</span>   // <span class="title">InUseBytes</span>返回正在使用的字节数（<span class="title">AllocBytes</span> – <span class="title">FreeBytes</span>）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MemProfileRecord)</span> <span class="title">InUseObjects</span><span class="params">()</span> <span class="title">int64</span> //<span class="title">InUseObjects</span>返回正在使用的对象数（<span class="title">AllocObjects</span> - <span class="title">FreeObjects</span>）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *MemProfileRecord)</span> <span class="title">Stack</span><span class="params">()</span> []<span class="title">uintptr</span>    // <span class="title">Stack</span>返回关联至此记录的调用栈踪迹，即<span class="title">r</span>.<span class="title">Stack0</span>的前缀。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MemProfile</span><span class="params">(p []MemProfileRecord, inuseZero <span class="keyword">bool</span>)</span> <span class="params">(n <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="comment">// 获取内存profile记录历史</span></span><br></pre></td></tr></table></figure>
<p>MemProfile返回当前内存profile中的记录数n。若len(p)&gt;=n，MemProfile会将此分析报告复制到p中并返回(n, true)；如果len(p)&lt; n，MemProfile则不会更改p，而只返回(n, false)。  </p>
<p>如果inuseZero为真，该profile就会包含无效分配记录（其中r.AllocBytes&gt;0，而r.AllocBytes==r.FreeBytes。这些内存都是被申请后又释放回运行时环境的）。  </p>
<p>大多数调用者应当使用runtime/pprof包或testing包的-test.memprofile标记，而非直接调用MemProfile  </p>
<h3 id="执行一个断点"><a href="#执行一个断点" class="headerlink" title="执行一个断点"></a>执行一个断点</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Breakpoint</span><span class="params">()</span></span></span><br><span class="line">runtime.Breakpoint()</span><br></pre></td></tr></table></figure>

<h3 id="获取程序调用go协程的栈踪迹历史"><a href="#获取程序调用go协程的栈踪迹历史" class="headerlink" title="获取程序调用go协程的栈踪迹历史"></a>获取程序调用go协程的栈踪迹历史</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stack</span><span class="params">(buf []<span class="keyword">byte</span>, all <span class="keyword">bool</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>Stack将调用其的go程的调用栈踪迹格式化后写入到buf中并返回写入的字节数。若all为true，函数会在写入当前go程的踪迹信息后，将其它所有go程的调用栈踪迹都格式化写入到buf中。  </p>
<h3 id="获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号"><a href="#获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号" class="headerlink" title="获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号"></a>获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Caller</span><span class="params">(skip <span class="keyword">int</span>)</span> <span class="params">(pc <span class="keyword">uintptr</span>, file <span class="keyword">string</span>, line <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  pc,file,line,ok := runtime.Caller(<span class="number">0</span>)</span><br><span class="line">  fmt.Println(pc)</span><br><span class="line">  fmt.Println(file)</span><br><span class="line">  fmt.Println(line)</span><br><span class="line">  fmt.Println(ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取与当前堆栈记录相关链的调用栈踪迹"><a href="#获取与当前堆栈记录相关链的调用栈踪迹" class="headerlink" title="获取与当前堆栈记录相关链的调用栈踪迹"></a>获取与当前堆栈记录相关链的调用栈踪迹</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Callers</span><span class="params">(skip <span class="keyword">int</span>, pc []<span class="keyword">uintptr</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>
<p>函数把当前go程调用栈上的调用栈标识符填入切片pc中，返回写入到pc中的项数。实参skip为开始在pc中记录之前所要跳过的栈帧数，0表示Callers自身的调用栈，1表示Callers所在的调用栈。返回写入p的项数。  </p>
<h3 id="获取一个标识调用栈标识符pc对应的调用栈"><a href="#获取一个标识调用栈标识符pc对应的调用栈" class="headerlink" title="获取一个标识调用栈标识符pc对应的调用栈"></a>获取一个标识调用栈标识符pc对应的调用栈</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncForPC</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> *<span class="title">Func</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span>    // 获取调用栈所调用的函数的名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">FileLine</span><span class="params">(pc <span class="keyword">uintptr</span>)</span> <span class="params">(file <span class="keyword">string</span>, line <span class="keyword">int</span>)</span></span>     </span><br><span class="line"><span class="comment">// 获取调用栈所调用的函数的所在的源文件名和行号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Func)</span> <span class="title">Entry</span><span class="params">()</span> <span class="title">uintptr</span>  // 获取该调用栈的调用栈标识符</span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前进程执行的cgo调用次数"><a href="#获取当前进程执行的cgo调用次数" class="headerlink" title="获取当前进程执行的cgo调用次数"></a>获取当前进程执行的cgo调用次数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumCgoCall</span><span class="params">()</span> <span class="title">int64</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前存在的go协程数"><a href="#获取当前存在的go协程数" class="headerlink" title="获取当前存在的go协程数"></a>获取当前存在的go协程数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumGoroutine</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="终止掉当前的go协程"><a href="#终止掉当前的go协程" class="headerlink" title="终止掉当前的go协程"></a>终止掉当前的go协程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>Goexit终止调用它的go协程,其他协程不受影响,Goexit会在终止该go协程前执行所有的defer函数，前提是defer必须在它前面定义,如果在main go协程调用本方法,会终止该go协程,但不会让main返回,因为main函数没有返回,程序会继续执行其他go协程,当其他go协程执行完毕后,程序就会崩溃.  </p>
<h3 id="让其他go协程优先执行-等其他协程执行完后-在执行当前的协程"><a href="#让其他go协程优先执行-等其他协程执行完后-在执行当前的协程" class="headerlink" title="让其他go协程优先执行,等其他协程执行完后,在执行当前的协程"></a>让其他go协程优先执行,等其他协程执行完后,在执行当前的协程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取活跃的go协程的堆栈profile以及记录个数"><a href="#获取活跃的go协程的堆栈profile以及记录个数" class="headerlink" title="获取活跃的go协程的堆栈profile以及记录个数"></a>获取活跃的go协程的堆栈profile以及记录个数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GoroutineProfile</span><span class="params">(p []StackRecord)</span> <span class="params">(n <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程"><a href="#将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程" class="headerlink" title="将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程"></a>将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LockOSThread</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>将调用的go程绑定到它当前所在的操作系统线程。除非调用的go程退出或调用UnlockOSThread，否则它将总是在该线程中执行，而其它go程则不能进入该线程  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnlockOSThread</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// 解除go协程与操作系统线程的绑定关系</span></span><br></pre></td></tr></table></figure>
<p>将调用的go程解除和它绑定的操作系统线程。若调用的go程未调用LockOSThread，UnlockOSThread不做操作  </p>
<h3 id="获取线程创建profile中的记录个数"><a href="#获取线程创建profile中的记录个数" class="headerlink" title="获取线程创建profile中的记录个数"></a>获取线程创建profile中的记录个数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ThreadCreateProfile</span><span class="params">(p []StackRecord)</span> <span class="params">(n <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>返回线程创建profile中的记录个数。如果len(p)&gt;=n，本函数就会将profile中的记录复制到p中并返回(n, true)。若len(p)&lt; n，则不会更改p，而只返回(n, false)。  </p>
<p>绝大多数使用者应当使用runtime/pprof包，而非直接调用ThreadCreateProfile。  </p>
<h3 id="控制阻塞profile记录go协程阻塞事件的采样率"><a href="#控制阻塞profile记录go协程阻塞事件的采样率" class="headerlink" title="控制阻塞profile记录go协程阻塞事件的采样率"></a>控制阻塞profile记录go协程阻塞事件的采样率</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetBlockProfileRate</span><span class="params">(rate <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>SetBlockProfileRate控制阻塞profile记录go程阻塞事件的采样频率。对于一个阻塞事件，平均每阻塞rate纳秒，阻塞profile记录器就采集一份样本。  </p>
<p>要在profile中包括每一个阻塞事件，需传入rate=1；要完全关闭阻塞profile的记录，需传入rate&lt;=0。  </p>
<h3 id="返回当前阻塞profile中的记录个数"><a href="#返回当前阻塞profile中的记录个数" class="headerlink" title="返回当前阻塞profile中的记录个数"></a>返回当前阻塞profile中的记录个数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BlockProfile</span><span class="params">(p []BlockProfileRecord)</span> <span class="params">(n <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>BlockProfile返回当前阻塞profile中的记录个数。如果len(p)&gt;=n，本函数就会将此profile中的记录复制到p中并返回(n, true)。如果len(p)&lt; ，本函数则不会修改p，而只返回(n, false)。  </p>
<p>绝大多数使用者应当使用runtime/pprof包或testing包的-test.blockprofile标记， 而非直接调用 BlockProfile。  </p>
<hr>
<h1 id="sort-包"><a href="#sort-包" class="headerlink" title="sort 包"></a><code>sort</code> 包</h1><p>sort包中实现了３种基本的排序算法：插入排序．快排和堆排序．和其他语言中一样，这三种方式都是不公开的，他们只在sort包内部使用．所以用户在使用sort包进行排序时无需考虑使用那种排序方式，sort.Interface定义的三个方法：获取数据集合长度的Len()方法、比较两个元素大小的Less()方法和交换两个元素位置的Swap()方法，就可以顺利对数据集合进行排序。sort包会根据实际数据自动选择高效的排序算法。  </p>
<h2 id="type-Interface"><a href="#type-Interface" class="headerlink" title="type Interface"></a>type Interface</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">    Len() <span class="keyword">int</span>    <span class="comment">// Len 为集合内元素的总数</span></span><br><span class="line">  </span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span>　<span class="comment">//如果index为i的元素小于index为j的元素，则返回true，否则返回false</span></span><br><span class="line"></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)  <span class="comment">// Swap 交换索引为 i 和 j 的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何实现了 sort.Interface 的类型（一般为集合），均可使用该包中的方法进行排序。这些方法要求集合内列出元素的索引为整数。  </p>
<p>golang自身实现的interface有三种，Float64Slice，IntSlice，StringSlice  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义interface&#123;&#125;,并实现sort.Interface接口的三个方法</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c IntSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c[i], c[j] = c[j], c[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c[i] &lt; c[j]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := IntSlice&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>&#125;</span><br><span class="line">    b := []<span class="keyword">float64</span>&#123;<span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">5.3</span>, <span class="number">3.4</span>&#125;</span><br><span class="line">    c := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(sort.IsSorted(a)) <span class="comment">//false</span></span><br><span class="line">    <span class="keyword">if</span> !sort.IsSorted(a) &#123;</span><br><span class="line">        sort.Sort(a) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !sort.Float64sAreSorted(b) &#123;</span><br><span class="line">        sort.Float64s(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !sort.IntsAreSorted(c) &#123;</span><br><span class="line">        sort.Ints(c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(a)<span class="comment">//[1 2 3 5 7]</span></span><br><span class="line">    fmt.Println(b)<span class="comment">//[1.1 2.3 3.4 5.3]</span></span><br><span class="line">    fmt.Println(c)<span class="comment">// [1 2 3 4 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Search-二分法查找"><a href="#Search-二分法查找" class="headerlink" title="Search 二分法查找"></a>Search 二分法查找</h2><p><code>func Search(n int, f func(int) bool) int</code>  </p>
<p>使用二分法查找（常用于一个已排序、可索引的数据结构，如数组、切片），查找范围是[0:n],返回能使f(i)=true的最小i（0 &lt;= i &lt; n)，并且会假定，如果f(i)=true，则f(i+1)=true，即对于切片[0:n]，i之前的切片元素会使f()函数返回false，i及i之后的元素会使f()函数返回true。但是，当在切片中无法找到时f(i)=true的i时（此时切片元素都不能使f()函数返回true），Search()方法会返回n（而不是返回-1）。  </p>
<p>为了查找某个值，而不是某一范围的值时，如果slice以升序排序，则　f func中应该使用＞＝,如果slice以降序排序，则应该使用&lt;=。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    b := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &gt;= <span class="number">30</span> &#125;)</span><br><span class="line">    fmt.Println(b)　　　　　　　<span class="comment">//5，查找不到，返回a slice的长度５，而不是-1</span></span><br><span class="line">    c := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] &lt;= <span class="number">3</span> &#125;)</span><br><span class="line">    fmt.Println(c)                             <span class="comment">//0，利用二分法进行查找，返回符合条件的最左边数值的index，即为０</span></span><br><span class="line">    d := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i] == <span class="number">3</span> &#125;)</span><br><span class="line">    fmt.Println(d)                          <span class="comment">//2　　　</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></span>　　</span><br><span class="line"><span class="comment">//SearchFloat64s 在float64s切片中搜索x并返回索引如Search函数所述. 返回可以插入x值的索引位置，如果x不存在，返回数组a的长度切片必须以升序排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span>  </span><br><span class="line"><span class="comment">//SearchInts 在ints切片中搜索x并返回索引如Search函数所述. 返回可以插入x值的索引位置，如果x不存在，返回数组a的长度切片必须以升序排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchStrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="comment">//SearchFloat64s 在strings切片中搜索x并返回索引如Search函数所述. 返回可以插入x值的索引位置，如果x不存在，返回数组a的长度切片必须以升序排列</span></span><br></pre></td></tr></table></figure>
<p>其中需要注意的是，以上三种search查找方法，其对应的slice必须按照<strong>升序</strong>进行排序，否则会出现奇怪的结果．</p>
<h2 id="Stable-排序"><a href="#Stable-排序" class="headerlink" title="Stable 排序"></a>Stable 排序</h2><p><code>func Stable(data Interface)</code> ：Stable对data进行排序，不过排序过程中，如果data中存在相等的元素，则他们原来的顺序不会改变，即如果有两个相等元素num,他们的初始index分别为i和j，并且i &lt; j，则利用Stable对data进行排序后，i依然小于ｊ．直接利用sort进行排序则不能够保证这一点．</p>
<h2 id="Reverse-逆序排序"><a href="#Reverse-逆序排序" class="headerlink" title="Reverse 逆序排序"></a>Reverse 逆序排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(a)        <span class="comment">// [1 2 5 3 4]</span></span><br><span class="line">    sort.Sort(sort.Reverse(sort.IntSlice(a)))</span><br><span class="line">    fmt.Println(a)        <span class="comment">// [5 4 3 2 1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="strconv-包"><a href="#strconv-包" class="headerlink" title="strconv 包"></a><code>strconv</code> 包</h1><p>与字符串相关的类型转换。<br>包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：<code>strconv.IntSize</code>。<br>任何类型 T 转换为字符串总是成功的。<br>数字 → 字符串：</p>
<ul>
<li><code>strconv.Itoa(i int) string</code> 返回数字 i 所表示的字符串类型的十进制数。  </li>
<li><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code> 将64位浮点型数字转换为字符串，其中 <code>fmt</code> 表示格式（其值可以是 <code>b</code>、<code>e</code>、<code>f</code> 或 <code>g</code>），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示 float32，用 64 表示 float64。  </li>
</ul>
<p>将字符串转换为其他类型 tp 并不总是可能的，可能会在运行时抛出错误 <code>parsing &quot;…&quot;: invalid argument</code>。<br>字符串 → 数字类型：  </p>
<ul>
<li><code>strconv.Atoi(s string) (i int, err error)</code> 将字符串转换为 int 型。  </li>
<li><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code> 将字符串转换为 float64 型。  </li>
</ul>
<p>利用多个返回值的特性（第 1 个是转换后的结果（若成功），第 2 个是可能出现的错误），一般使用如下形式进行从字符串到其它类型的转换：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val, err = strconv.Atoi(s)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="strings-包"><a href="#strings-包" class="headerlink" title="strings 包"></a><code>strings</code> 包</h1><p>Go 中使用 <code>strings</code> 包对字符串进行操作。<a href="http://docscn.studygolang.com/pkg/strings/" target="_blank" rel="noopener">中文文档</a>、 <a href="http://golang.org/pkg/strings/" target="_blank" rel="noopener">官方文档</a> 或 <a href="http://docs.studygolang.com/pkg/strings/" target="_blank" rel="noopener">国内访问文档</a>  </p>
<h2 id="前、后缀"><a href="#前、后缀" class="headerlink" title="前、后缀"></a>前、后缀</h2><p><code>HasPrefix</code> 判断字符串 <code>s</code> 是否以 <code>prefix</code> 开头：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasPrefix(s, prefix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<p><code>HasSuffix</code> 判断字符串 <code>s</code> 是否以 <code>suffix</code> 结尾：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.HasSuffix(s, suffix <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串包含关系"><a href="#字符串包含关系" class="headerlink" title="字符串包含关系"></a>字符串包含关系</h2><p><code>Contains</code> 判断字符串 <code>s</code> 是否包含 <code>substr</code> :  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Contains(s, substr <span class="keyword">string</span>) <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>

<p><code>func ContainsAny(s, chars string) bool</code> : 判断字符串s是否包含chars中任意一个字符，若chars为空，返回false  </p>
<p><code>func ContainsRune(s string, r rune) bool</code> : 是否包含r rune  </p>
<h2 id="索引字符串位置"><a href="#索引字符串位置" class="headerlink" title="索引字符串位置"></a>索引字符串位置</h2><p><code>Index</code> 返回字符串 <code>str</code> 在字符串 <code>s</code> 中的第一次出现的索引（<code>str</code> 的第一个字符的索引），<br>返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Index(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p><code>LastIndex</code> 返回 <code>str</code> 在 <code>s</code> 中最后出现的所有（第一个字符），<br>返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.LastIndex(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>建议用 <code>IndexRune</code> 查询非 ASCII 编码的字符在字符串中的位置（返回 <code>-1</code> 表示 <code>s</code> 不包含 <code>str</code>：  ）：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strings.IndexRune(s <span class="keyword">string</span>, r <span class="keyword">rune</span>) <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eg.</span></span><br><span class="line">strings.IndexRune(<span class="string">"chicken"</span>, <span class="number">99</span>)</span><br><span class="line">strings.IndexRune(<span class="string">"chicken"</span>, <span class="keyword">rune</span>(<span class="string">'k'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><p><code>Replace</code> 用于将字符串 <code>str</code> 中的前 <code>n</code> 个字符串 <code>old</code> 替换为字符串 <code>new</code>，并范围一个新的字符串，如果 <code>n = -1</code> 啧替换所有有 <code>old</code> 为 <code>new</code>：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Replace(str, old, <span class="built_in">new</span>, n) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>返回的是str的副本  </p>
<h2 id="统计字符串出现的次数"><a href="#统计字符串出现的次数" class="headerlink" title="统计字符串出现的次数"></a>统计字符串出现的次数</h2><p><code>Count</code> 用于统计字符串 <code>str</code> 中字符串 <code>s</code> 出现的非重叠次数：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Count(s, str <span class="keyword">string</span>) <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<h2 id="重复字符串"><a href="#重复字符串" class="headerlink" title="重复字符串"></a>重复字符串</h2><p><code>Repeat</code> 用于重复 <code>count</code> 次字符串 <code>s</code> 并返回一个新的字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Repeat(s, count <span class="keyword">int</span>) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h2 id="修改字符串大小写"><a href="#修改字符串大小写" class="headerlink" title="修改字符串大小写"></a>修改字符串大小写</h2><p><code>ToLower</code> 将字符串中的 Unicode 字符全部转换为相应的小写字符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Tolower(s) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p><code>ToUpper</code> 将字符串中的 Unicode 字符全部转换为相应的大写字符：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.ToUpper(s) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p><code>ToTitle</code> s 中的所有字符修改为其 Title 格式：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<h2 id="修剪字符串"><a href="#修剪字符串" class="headerlink" title="修剪字符串"></a>修剪字符串</h2><p><code>strings.TrimSpace(s)</code> 用于剔除字符串开头和结尾的空白符号；<br><code>strings.Trim(s, &quot;cut&quot;)</code> 用于剔除字符串开头和结尾的 <code>cut</code>；<br><code>TrimLeft</code> 或者 <code>TrimRight</code> 用于只剔除开头或结尾的字符串。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimRight</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>注：TrimSuffix只是去掉s字符串结尾的suffix字符串，只是去掉１次，而TrimRight是一直去掉s字符串右边的字符串，只要有响应的字符串就去掉，是一个多次的过程，这也是二者的本质区别．</p>
<h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><p><code>strings.Fields(s)</code> 会利用 1 个或多个空白符号(\t, \n, \v, \f, \r, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP))来作为动态长度的分隔符将字符串分割成若干小块，并返回一个 slice，如果字符串只包含空白符号，则返回一个长度为 0 的空 slice。  </p>
<p><code>strings.Split(s, sep)</code> 用于自定义分割符号来对指定字符串进行分割，同样范围 slice。<br>因为这 2 个函数都会返回 slice，所以习惯使用 for - range 循环来对其进行处理。  </p>
<h2 id="拼接-slice-到字符串"><a href="#拼接-slice-到字符串" class="headerlink" title="拼接 slice 到字符串"></a>拼接 slice 到字符串</h2><p><code>Join</code> 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Join(sl [<span class="keyword">string</span>], sep <span class="keyword">string</span>) <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<h2 id="从字符串中读取内容"><a href="#从字符串中读取内容" class="headerlink" title="从字符串中读取内容"></a>从字符串中读取内容</h2><p><code>strings.NewReader(str)</code> 用于生成一个 ‘Reader’ 并读取字符串中的内容，然后返回指向该 <code>Reader</code> 的指针，从其他类型读取内容的函数还有：<br><code>Read</code> 从 []byte 中读取内容；<br><code>ReadByte()</code> 和 <code>ReadRune()</code> 从字符串中读取下一个 byte 或者 rune。  </p>
<h2 id="比较两字符串字典顺序"><a href="#比较两字符串字典顺序" class="headerlink" title="比较两字符串字典顺序"></a>比较两字符串字典顺序</h2><p><code>func Compare(a, b string) int</code><br>return 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b.<br>但不常用，通常用 go 自身的 ==, &gt;, &lt; 来比较，更快更易懂。  </p>
<h2 id="忽略大小写判断s和t是否相等"><a href="#忽略大小写判断s和t是否相等" class="headerlink" title="忽略大小写判断s和t是否相等"></a>忽略大小写判断s和t是否相等</h2><p><code>func EqualFold(s, t string) bool</code></p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>func Map(mapping func(rune) rune, s string) string</code> ：s 中满足 mapping(rune) 的字符替换为 mapping(rune) 的返回值。如果 mapping(rune) 返回负数，则相应的字符将被删除。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Slash</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r == <span class="string">'\\'</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    s := <span class="string">"C:\\Windows\\System32\\FileName"</span></span><br><span class="line">    ms := strings.Map(Slash, s)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, ms) <span class="comment">// "C:/Windows/System32/FileName"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reader-go"><a href="#reader-go" class="headerlink" title="reader.go"></a>reader.go</h2><h3 id="Reader结构"><a href="#Reader结构" class="headerlink" title="Reader结构"></a>Reader结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader 结构通过读取字符串，实现了 io.Reader，io.ReaderAt，</span></span><br><span class="line"><span class="comment">// io.Seeker，io.WriterTo，io.ByteScanner，io.RuneScanner 接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span> <span class="comment">// 要读取的字符串</span></span><br><span class="line">    i <span class="keyword">int</span> <span class="comment">// 当前读取的索引位置，从 i 处开始读取数据</span></span><br><span class="line">    prevRune <span class="keyword">int</span> <span class="comment">// 读取的前一个字符的索引位置，小于 0 表示之前未读取字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字符串 s 创建 strings.Reader 对象</span></span><br><span class="line"><span class="comment">// 这个函数类似于 bytes.NewBufferString</span></span><br><span class="line"><span class="comment">// 但比 bytes.NewBufferString 更有效率，而且只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(s <span class="keyword">string</span>)</span> *<span class="title">Reader</span></span> &#123; <span class="keyword">return</span> &amp;Reader&#123;s, <span class="number">0</span>, <span class="number">-1</span>&#125; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Len-返回-r-i-之后的所有数据的字节长度"><a href="#Len-返回-r-i-之后的所有数据的字节长度" class="headerlink" title="Len 返回 r.i 之后的所有数据的字节长度"></a>Len 返回 r.i 之后的所有数据的字节长度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Read-将-r-i-之后的所有数据写入到-b-中（如果-b-的容量足够大）"><a href="#Read-将-r-i-之后的所有数据写入到-b-中（如果-b-的容量足够大）" class="headerlink" title="Read 将 r.i 之后的所有数据写入到 b 中（如果 b 的容量足够大）"></a>Read 将 r.i 之后的所有数据写入到 b 中（如果 b 的容量足够大）</h3><p>返回读取的字节数和读取过程中遇到的错误<br>如果无可读数据，则返回 io.EOF  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 创建长度为 5 个字节的缓冲区</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 循环读取 r 中的字符串</span></span><br><span class="line">    <span class="keyword">for</span> n, _ := r.Read(b); n &gt; <span class="number">0</span>; n, _ = r.Read(b) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%q, "</span>, b[:n]) <span class="comment">// "Hello", " Worl", "d!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReadAt-将-off-之后的所有数据写入到-b-中（如果-b-的容量足够大）"><a href="#ReadAt-将-off-之后的所有数据写入到-b-中（如果-b-的容量足够大）" class="headerlink" title="ReadAt 将 off 之后的所有数据写入到 b 中（如果 b 的容量足够大）"></a>ReadAt 将 off 之后的所有数据写入到 b 中（如果 b 的容量足够大）</h3><p>返回读取的字节数和读取过程中遇到的错误<br>如果无可读数据，则返回 io.EOF<br>如果数据被一次性读取完毕，则返回 io.EOF  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 创建长度为 5 个字节的缓冲区</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 读取 r 中指定位置的字符串</span></span><br><span class="line">    n, _ := r.ReadAt(b, <span class="number">0</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, b[:n]) <span class="comment">// "Hello"</span></span><br><span class="line">    <span class="comment">// 读取 r 中指定位置的字符串</span></span><br><span class="line">    n, _ = r.ReadAt(b, <span class="number">6</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, b[:n]) <span class="comment">// "World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadByte-将-r-i-之后的一个字节写入到返回值-b-中"><a href="#ReadByte-将-r-i-之后的一个字节写入到返回值-b-中" class="headerlink" title="ReadByte 将 r.i 之后的一个字节写入到返回值 b 中"></a>ReadByte 将 r.i 之后的一个字节写入到返回值 b 中</h3><p>返回读取的字节和读取过程中遇到的错误<br>如果无可读数据，则返回 io.EOF  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadByte</span><span class="params">()</span> <span class="params">(b <span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 读取 r 中的一个字节</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        b, _ := r.ReadByte()</span><br><span class="line">        fmt.Printf(<span class="string">"%q, "</span>, b) <span class="comment">// 'H', 'e', 'l',</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UnreadByte-撤消前一次的-ReadByte-操作，即-r-i–"><a href="#UnreadByte-撤消前一次的-ReadByte-操作，即-r-i–" class="headerlink" title="UnreadByte 撤消前一次的 ReadByte 操作，即 r.i–"></a>UnreadByte 撤消前一次的 ReadByte 操作，即 r.i–</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">UnreadByte</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 读取 r 中的一个字节</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        b, _ := r.ReadByte()</span><br><span class="line">        fmt.Printf(<span class="string">"%q, "</span>, b) <span class="comment">// 'H', 'H', 'H',</span></span><br><span class="line">        r.UnreadByte()        <span class="comment">// 撤消前一次的字节读取操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadRune-将-r-i-之后的一个字符写入到返回值-ch-中"><a href="#ReadRune-将-r-i-之后的一个字符写入到返回值-ch-中" class="headerlink" title="ReadRune 将 r.i 之后的一个字符写入到返回值 ch 中"></a>ReadRune 将 r.i 之后的一个字符写入到返回值 ch 中</h3><p>ch： 读取的字符<br>size：ch 的编码长度<br>err： 读取过程中遇到的错误<br>如果无可读数据，则返回 io.EOF<br>如果 r.i 之后不是一个合法的 UTF-8 字符编码，则返回 utf8.RuneError 字符  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">ReadRune</span><span class="params">()</span> <span class="params">(ch <span class="keyword">rune</span>, size <span class="keyword">int</span>, err error)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"你好 世界！"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 读取 r 中的一个字符</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        b, n, _ := r.ReadRune()</span><br><span class="line">        fmt.Printf(<span class="string">`"%c:%v", `</span>, b, n)</span><br><span class="line">        <span class="comment">// "你:3", "好:3", " :1", "世:3", "界:3",</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="撤消前一次的-ReadRune-操作"><a href="#撤消前一次的-ReadRune-操作" class="headerlink" title="撤消前一次的 ReadRune 操作"></a>撤消前一次的 ReadRune 操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"你好 世界！"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 读取 r 中的一个字符</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        b, _, _ := r.ReadRune()</span><br><span class="line">        fmt.Printf(<span class="string">"%q, "</span>, b)</span><br><span class="line">        <span class="comment">// '你', '你', '你', '你', '你',</span></span><br><span class="line">        r.UnreadRune() <span class="comment">// 撤消前一次的字符读取操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Seek-用来移动-r-中的索引位置"><a href="#Seek-用来移动-r-中的索引位置" class="headerlink" title="Seek 用来移动 r 中的索引位置"></a>Seek 用来移动 r 中的索引位置</h3><p>offset：要移动的偏移量，负数表示反向移动<br>whence：从那里开始移动，0：起始位置，1：当前位置，2：结尾位置<br>如果 whence 不是 0、1、2，则返回错误信息<br>如果目标索引位置超出字符串范围，则返回错误信息<br>目标索引位置不能超出 1 &lt;&lt; 31，否则返回错误信息  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Seek</span><span class="params">(offset <span class="keyword">int64</span>, whence <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 创建读取缓冲区</span></span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 读取 r 中指定位置的内容</span></span><br><span class="line">    r.Seek(<span class="number">6</span>, <span class="number">0</span>) <span class="comment">// 移动索引位置到第 7 个字节</span></span><br><span class="line">    r.Read(b)    <span class="comment">// 开始读取</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line">    r.Seek(<span class="number">-5</span>, <span class="number">1</span>) <span class="comment">// 将索引位置移回去</span></span><br><span class="line">    r.Read(b)     <span class="comment">// 继续读取</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WriteTo-将-r-i-之后的数据写入接口-w-中"><a href="#WriteTo-将-r-i-之后的数据写入接口-w-中" class="headerlink" title="WriteTo 将 r.i 之后的数据写入接口 w 中"></a>WriteTo 将 r.i 之后的数据写入接口 w 中</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="comment">// 创建 Reader</span></span><br><span class="line">    r := strings.NewReader(s)</span><br><span class="line">    <span class="comment">// 创建 bytes.Buffer 对象，它实现了 io.Writer 接口</span></span><br><span class="line">    buf := bytes.NewBuffer(<span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 将 r 中的数据写入 buf 中</span></span><br><span class="line">    r.WriteTo(buf)</span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, buf) <span class="comment">// "Hello World!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="replace-go"><a href="#replace-go" class="headerlink" title="replace.go"></a>replace.go</h2><h3 id="Replacer-根据一个替换列表执行替换操作"><a href="#Replacer-根据一个替换列表执行替换操作" class="headerlink" title="Replacer 根据一个替换列表执行替换操作"></a>Replacer 根据一个替换列表执行替换操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Replacer <span class="keyword">struct</span> &#123;</span><br><span class="line">    Replace(s <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">    WriteString(w io.Writer, s <span class="keyword">string</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NewReplacer-通过“替换列表”创建一个-Replacer-对象"><a href="#NewReplacer-通过“替换列表”创建一个-Replacer-对象" class="headerlink" title="NewReplacer 通过“替换列表”创建一个 Replacer 对象"></a>NewReplacer 通过“替换列表”创建一个 Replacer 对象</h3><p>按照“替换列表”中的顺序进行替换，只替换非重叠部分。<br>如果参数的个数不是偶数，则抛出异常。<br>如果在“替换列表”中有相同的“查找项”，则后面重复的“查找项”会被忽略  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReplacer</span><span class="params">(oldnew ...<span class="keyword">string</span>)</span> *<span class="title">Replacer</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Replace-返回对-s-进行“查找和替换”后的结果"><a href="#Replace-返回对-s-进行“查找和替换”后的结果" class="headerlink" title="Replace 返回对 s 进行“查找和替换”后的结果"></a>Replace 返回对 s 进行“查找和替换”后的结果</h3><p>Replace 使用的是 Boyer-Moore 算法，速度很快</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span> <span class="title">Replace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    srp := strings.NewReplacer(<span class="string">"Hello"</span>, <span class="string">"你好"</span>, <span class="string">"World"</span>, <span class="string">"世界"</span>, <span class="string">"!"</span>, <span class="string">"！"</span>)</span><br><span class="line">    s := <span class="string">"Hello World!Hello World!hello world!"</span></span><br><span class="line">    rst := srp.Replace(s)</span><br><span class="line">    fmt.Print(rst) <span class="comment">// 你好 世界！你好 世界！hello world！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注：这两种写法均可．</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    wl := []<span class="keyword">string</span>&#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Hello"</span>, <span class="string">"你好"</span>&#125;</span><br><span class="line">    srp := strings.NewReplacer(wl...)</span><br><span class="line">    s := <span class="string">"Hello World! Hello World! hello world!"</span></span><br><span class="line">    rst := srp.Replace(s)</span><br><span class="line">    fmt.Print(rst) <span class="comment">// Hi World! Hi World! hello world!</span></span><br></pre></td></tr></table></figure>
<h3 id="WriteString-对-s-进行“查找和替换”，然后将结果写入-w-中"><a href="#WriteString-对-s-进行“查找和替换”，然后将结果写入-w-中" class="headerlink" title="WriteString 对 s 进行“查找和替换”，然后将结果写入 w 中"></a>WriteString 对 s 进行“查找和替换”，然后将结果写入 w 中</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replacer)</span> <span class="title">WriteString</span><span class="params">(w io.Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wl := []<span class="keyword">string</span>&#123;<span class="string">"Hello"</span>, <span class="string">"你好"</span>, <span class="string">"World"</span>, <span class="string">"世界"</span>, <span class="string">"!"</span>, <span class="string">"！"</span>&#125;</span><br><span class="line">    srp := strings.NewReplacer(wl...)</span><br><span class="line">    s := <span class="string">"Hello World!Hello World!hello world!"</span></span><br><span class="line">    srp.WriteString(os.Stdout, s)</span><br><span class="line">    <span class="comment">// 你好 世界！你好 世界！hello world！</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="sync-包"><a href="#sync-包" class="headerlink" title="sync 包"></a><code>sync</code> 包</h1><h2 id="临时对象池"><a href="#临时对象池" class="headerlink" title="临时对象池"></a>临时对象池</h2><p>Pool 用于存储临时对象，它将使用完毕的对象存入对象池中，在需要的时候取出来重复使用，目的是为了避免重复创建相同的对象造成 GC 负担过重。其中存放的临时对象随时可能被 GC 回收掉（如果该对象不再被其它变量引用）。  </p>
<p>从 Pool 中取出对象时，如果 Pool 中没有对象，将返回 nil，但是如果给 Pool.New 字段指定了一个函数的话，Pool 将使用该函数创建一个新对象返回。  </p>
<p>Pool 可以安全的在多个例程中并行使用，但 Pool 并不适用于所有空闲对象，Pool 应该用来管理并发的例程共享的临时对象，而不应该管理短寿命对象中的临时对象，因为这种情况下内存不能很好的分配，这些短寿命对象应该自己实现空闲列表。  </p>
<p>Pool 在开始使用之后，不能再被复制。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 创建临时对象的函数</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向临时对象池中存入对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从临时对象池中取出对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p>Once 的作用是多次调用但只执行一次，Once 只有一个方法，Once.Do()，向 Do 传入一个函数，这个函数在第一次执行 Once.Do() 的时候会被调用，以后再执行 Once.Do() 将没有任何动作，即使传入了其它的函数，也不会被执行，如果要执行其它函数，需要重新创建一个 Once 对象。  </p>
<p>Once 可以安全的在多个例程中并行使用。  </p>
<p>多次调用仅执行一次指定的函数 f：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure>

<p>eg：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Only once"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            once.Do(onceBody) <span class="comment">// 多次调用只执行一次</span></span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// Only once</span></span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁用来保证在任一时刻，只能有一个例程访问某对象。Mutex 的初始值为解锁状态。Mutex 通常作为其它结构体的匿名字段使用，使该结构体具有 Lock 和 Unlock 方法。  </p>
<p>Mutex 可以安全的在多个例程中并行使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Locker 接口包装了基本的 Lock 和 UnLock 方法，用于加锁和解锁。</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock 用于锁住 m，如果 m 已经被加锁，则 Lock 将被阻塞，直到 m 被解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock 用于解锁 m，如果 m 未加锁，则该操作会引发 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>eg：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeInt <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    count := SafeInt&#123;&#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            count.Lock() <span class="comment">// 加锁，防止其它例程修改 count</span></span><br><span class="line">            count.Num += i</span><br><span class="line">            fmt.Print(count.Num, <span class="string">" "</span>)</span><br><span class="line">            count.Unlock() <span class="comment">// 修改完毕，解锁</span></span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果（不固定）：</span></span><br><span class="line"><span class="comment">// 2 11 14 18 23 29 36 44 45 45</span></span><br></pre></td></tr></table></figure>

<h2 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h2><p>RWMutex 比 Mutex 多了一个“读锁定”和“读解锁”，可以让多个例程同时读取某对象。RWMutex 的初始值为解锁状态。RWMutex 通常作为其它结构体的匿名字段使用。  </p>
<p>Mutex 可以安全的在多个例程中并行使用。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock 将 rw 设置为写锁定状态，禁止其他例程读取或写入。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock 解除 rw 的写锁定状态，如果 rw 未被写锁定，则该操作会引发 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RLock 将 rw 设置为读锁定状态，禁止其他例程写入，但可以读取。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Runlock 解除 rw 的读锁定状态，如果 rw 未被读锁顶，则该操作会引发 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RLocker 返回一个互斥锁，将 rw.RLock 和 rw.RUnlock 封装成了一个 Locker 接口。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLocker</span><span class="params">()</span> <span class="title">Locker</span></span></span><br></pre></td></tr></table></figure>

<h2 id="组等待"><a href="#组等待" class="headerlink" title="组等待"></a>组等待</h2><p>WaitGroup 用于等待一组例程的结束。主例程在创建每个子例程的时候先调用 Add 增加等待计数，每个子例程在结束时调用 Done 减少例程计数。之后，主例程通过 Wait 方法开始等待，直到计数器归零才继续执行。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器增加 delta，delta 可以是负数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器减少 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待直到计数器归零。如果计数器小于 0，则该操作会引发 panic。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>eg：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Print(i, <span class="string">" "</span>)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果（不固定）：</span></span><br><span class="line"><span class="comment">// 9 3 4 5 6 7 8 0 1 2</span></span><br></pre></td></tr></table></figure>

<h2 id="条件等待"><a href="#条件等待" class="headerlink" title="条件等待"></a>条件等待</h2><p>条件等待通过 Wait 让例程等待，通过 Signal 让一个等待的例程继续，通过 Broadcast 让所有等待的例程继续。  </p>
<p>在 Wait 之前应当手动为 c.L 上锁，Wait 结束后手动解锁。为避免虚假唤醒，需要将 Wait 放到一个条件判断循环中。官方要求的写法如下：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() &#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行条件满足之后的动作...</span></span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure>

<p>Cond 在开始使用之后，不能再被复制。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    L Locker <span class="comment">// 在“检查条件”或“更改条件”时 L 应该锁定。</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Broadcast 唤醒所有等待的 Wait，建议在“更改条件”时锁定 c.L，更改完毕再解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Signal 唤醒一个等待的 Wait，建议在“更改条件”时锁定 c.L，更改完毕再解锁。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 会解锁 c.L 并进入等待状态，在被唤醒时，会重新锁定 c.L</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>eg：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    condition := <span class="literal">false</span> <span class="comment">// 条件不满足</span></span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    cond := sync.NewCond(&amp;mu)</span><br><span class="line">    <span class="comment">// 让例程去创造条件</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        condition = <span class="literal">true</span> <span class="comment">// 更改条件</span></span><br><span class="line">        cond.Signal()    <span class="comment">// 发送通知：条件已经满足</span></span><br><span class="line">        mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">// 检查条件是否满足，避免虚假通知，同时避免 Signal 提前于 Wait 执行。</span></span><br><span class="line">    <span class="keyword">for</span> !condition &#123;</span><br><span class="line">        <span class="comment">// 等待条件满足的通知，如果收到虚假通知，则循环继续等待。</span></span><br><span class="line">        cond.Wait() <span class="comment">// 等待时 mu 处于解锁状态，唤醒时重新锁定。</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"条件满足，开始后续动作..."</span>)</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 条件满足，开始后续动作...</span></span><br></pre></td></tr></table></figure>


<hr>
<h1 id="time-包：时间和日期"><a href="#time-包：时间和日期" class="headerlink" title="time 包：时间和日期"></a><code>time</code> 包：时间和日期</h1><p>包中包括了两类时间：时间点（某一时刻）和时长（某一个时间段）<br><code>time</code> 包提供了一个数据类型 <code>time.Time</code>（作为值使用）以及显示和测量时间和日期的功能函数。  </p>
<p>戳→<a href="http://docscn.studygolang.com/pkg/time/" target="_blank" rel="noopener">中文文档</a>、 <a href="http://golang.org/pkg/time/" target="_blank" rel="noopener">官方文档</a> 、 <a href="http://docs.studygolang.com/pkg/time/" target="_blank" rel="noopener">国内访问页面</a>   </p>
<p>获取当前时间：<code>time.Now()</code>；  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t time.Time = time.Now()</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">t := time.Now()</span><br></pre></td></tr></table></figure>
<p>获取时间的一部分： <code>t.Day</code>、<code>t.Minute()</code>…<br>自定义时间格式化字符串：eg.<code>fmt.Printf(&quot;%02d.%02d.%4d\n&quot;, t.Day(), t.Month(), t.Year())</code> 将会输出 <code>08.03.2019</code><br>Duration 类型表示两个连续时刻所相差的<strong>纳秒数</strong>，类型为 int64。Location 类型映射某个时区的时间，UTC 表示通用协调世界时间。<br>包中的一个预定义函数 <code>func (t Time) Format(layout string) string</code> 可以根据一个格式化字符串来将一个t转换为相应格式的字符串，你可以使用一些预定义的格式，如：<code>time.ANSIC</code> 或 <code>time.RFC822</code>。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println((t.Format(<span class="string">"02 Jan 2006 15:04"</span>)))</span><br></pre></td></tr></table></figure>
<p>如果需要在应用程序在经过一定时间或周期执行某项任务（事件处理的特例），则可以使用 <code>time.After</code> 或者 <code>time.Ticker</code>。<br>另外，<code>time.Sleep(Duration d)</code> 可以实现对某个进程（实质上是 goroutine）时长为 d 的暂停。  </p>
<h2 id="时间敞亮（时间格式化）"><a href="#时间敞亮（时间格式化）" class="headerlink" title="时间敞亮（时间格式化）"></a>时间敞亮（时间格式化）</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    ANSIC       = <span class="string">"Mon Jan _2 15:04:05 2006"</span></span><br><span class="line">    UnixDate    = <span class="string">"Mon Jan _2 15:04:05 MST 2006"</span></span><br><span class="line">    RubyDate    = <span class="string">"Mon Jan 02 15:04:05 -0700 2006"</span></span><br><span class="line">    RFC822      = <span class="string">"02 Jan 06 15:04 MST"</span></span><br><span class="line">    RFC822Z     = <span class="string">"02 Jan 06 15:04 -0700"</span> <span class="comment">// RFC822 with numeric zone</span></span><br><span class="line">    RFC850      = <span class="string">"Monday, 02-Jan-06 15:04:05 MST"</span></span><br><span class="line">    RFC1123     = <span class="string">"Mon, 02 Jan 2006 15:04:05 MST"</span></span><br><span class="line">    RFC1123Z    = <span class="string">"Mon, 02 Jan 2006 15:04:05 -0700"</span> <span class="comment">// RFC1123 with numeric zone</span></span><br><span class="line">    RFC3339     = <span class="string">"2006-01-02T15:04:05Z07:00"</span></span><br><span class="line">    RFC3339Nano = <span class="string">"2006-01-02T15:04:05.999999999Z07:00"</span></span><br><span class="line">    Kitchen     = <span class="string">"3:04PM"</span></span><br><span class="line">    <span class="comment">// Handy time stamps.</span></span><br><span class="line">    Stamp      = <span class="string">"Jan _2 15:04:05"</span></span><br><span class="line">    StampMilli = <span class="string">"Jan _2 15:04:05.000"</span></span><br><span class="line">    StampMicro = <span class="string">"Jan _2 15:04:05.000000"</span></span><br><span class="line">    StampNano  = <span class="string">"Jan _2 15:04:05.000000000"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这些常量是在time包中进行time 格式化 和time解析而预定义的一些常量，其实他们使用的都是一个特定的时间：<code>Mon Jan 2 15:04:05 MST 2006</code>  </p>
<h2 id="函数-5"><a href="#函数-5" class="headerlink" title="函数"></a>函数</h2><h3 id="time-组成"><a href="#time-组成" class="headerlink" title="time 组成"></a>time 组成</h3><p><code>time.Duration</code> 时间长度，消耗时间<br><code>time.Time</code> 时间点<br><code>time.C</code> 放时间的通道(tine.C := make(chan time.Time))</p>
<h3 id="After-函数"><a href="#After-函数" class="headerlink" title="After 函数"></a>After 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure>
<p>表示多少时间之后，但是在去除channel内容之前不阻塞，后续程序可以继续执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sleep</span><span class="params">(d Duration)</span></span></span><br></pre></td></tr></table></figure>
<p>表示休眠多少时间，休眠时处于阻塞状态，后续程序无法执行。  </p>
<p>鉴于After特性，其通常用来处理程序超时问题，如下所示：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m := &lt;-c:</span><br><span class="line">    handle(m)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Minute):</span><br><span class="line">    fmt.Println(<span class="string">"timed out"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Tick</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure>
<p>time.Tick(time.Duration)用法和time.After差不多，但是它是表示每隔多少时间之后，是一个重复的过程，其他与After一致。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span> </span><br><span class="line"><span class="comment">//时间长度，其对应的时间单位有Nanosecond，Microsecond,Millisecond,Second,Minute,Hour</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseDuration</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(Duration, error)</span></span></span><br><span class="line"><span class="comment">//传入字符串，返回响应的时间，其中传入的字符串中的有效时间单位如下：h,m,s,ms,us,ns，其他单位均无效，如果传入无效时间单位，则会返回０ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Since</span><span class="params">(t Time)</span> <span class="title">Duration</span></span> </span><br><span class="line"><span class="comment">//表示自从t时刻以后过了多长时间，是一个时间段，相当于time.Now().Sub(t)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">Hours</span><span class="params">()</span> <span class="title">float64</span></span> </span><br><span class="line"><span class="comment">//将制定时间段换算为float64类型的Hour为单位进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">Minutes</span><span class="params">()</span> <span class="title">float64</span></span> </span><br><span class="line"><span class="comment">//将制定时间段换算为float64类型的Minutes为单位进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">Nanoseconds</span><span class="params">()</span> <span class="title">int64</span></span> </span><br><span class="line"><span class="comment">//将制定时间段换算为int64类型的Nanoseconds为单位进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">Seconds</span><span class="params">()</span> <span class="title">float64</span></span> </span><br><span class="line"><span class="comment">//将制定时间段换算为float64类型的Seconds为单位进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(d Duration)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>  </span><br><span class="line"><span class="comment">//与ParseDuration函数相反，该函数是将时间段转化为字符串输出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Location</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FixedZone</span><span class="params">(name <span class="keyword">string</span>, offset <span class="keyword">int</span>)</span> *<span class="title">Location</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadLocation</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Location, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Location)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Month <span class="comment">// 定义了1年的12个月</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Month)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>  //将时间月份以字符串形式打印出来．如<span class="title">fmt</span>.<span class="title">Println</span><span class="params">(time.June.String()</span>)则打印出<span class="title">June</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParseError</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ParseError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ticker  </span><br><span class="line"><span class="comment">//主要用来按照指定的时间周期来调用函数或者计算表达式，</span></span><br><span class="line"><span class="comment">//通常的使用方式是利用go新开一个协程使用，它是一个断续器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTicker</span><span class="params">(d Duration)</span> *<span class="title">Ticker</span></span></span><br><span class="line"><span class="comment">//新生成一个ticker,此Ticker包含一个channel，</span></span><br><span class="line"><span class="comment">//此channel以给定的duration发送时间。duration d必须大于0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Ticker)</span> <span class="title">Stop</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">//用于关闭相应的Ticker，但并不关闭channel</span></span><br></pre></td></tr></table></figure>
<p>例子：<br>使用时间控制停止ticker：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">1500</span>)   </span><br><span class="line"><span class="comment">//阻塞，则执行次数为sleep的休眠时间/ticker的时间</span></span><br><span class="line">ticker.Stop()     </span><br><span class="line">fmt.Println(<span class="string">"Ticker stopped"</span>)</span><br></pre></td></tr></table></figure>
<p>使用channel控制停止ticker：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>，num) <span class="comment">//num为指定的执行次数</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">              c&lt;<span class="number">-1</span></span><br><span class="line">               fmt.Println(<span class="string">"Tick at"</span>, t)</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">        </span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure>
<p>这种情况下，在执行num次以Ticker时间为单位的函数之后，c　channel中已满，以后便不会再执行对应的函数  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Time  <span class="comment">//包括日期和时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Date</span><span class="params">(year <span class="keyword">int</span>, month Month, day, hour, min, sec, nsec <span class="keyword">int</span>, loc *Location)</span> <span class="title">Time</span></span>　</span><br><span class="line"><span class="comment">//按照指定格式输入数据后，便会按照如下格式输出对应的时间，输出格式为</span></span><br><span class="line"><span class="comment">//yyyy-mm-dd hh:mm:ss + nsec nanoseconds，　其中loc必须指定，否则便会panic</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//eg，</span></span><br><span class="line">t := time.Date(<span class="number">2009</span>, time.November, <span class="number">10</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">fmt.Printf(<span class="string">"Go launched at %s\n"</span>, t.Local())</span><br><span class="line"><span class="comment">//输出为：</span></span><br><span class="line">Go launched at <span class="number">2009</span><span class="number">-11</span><span class="number">-10</span> <span class="number">15</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">-0800</span> PST</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span> //返回当前时间，包括日期，时间和时区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(layout, value <span class="keyword">string</span>)</span> <span class="params">(Time, error)</span>　//输入格式化<span class="title">layout</span>和时间字符串，输出时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInLocation</span><span class="params">(layout, value <span class="keyword">string</span>, loc *Location)</span> <span class="params">(Time, error)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec <span class="keyword">int64</span>, nsec <span class="keyword">int64</span>)</span> <span class="title">Time</span>　//返回本地时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span>　　//增加时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">AddDate</span><span class="params">(years <span class="keyword">int</span>, months <span class="keyword">int</span>, days <span class="keyword">int</span>)</span> <span class="title">Time</span>//增加日期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span>　　//判断时间<span class="title">t</span>是否在时间ｕ的后面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span>　//判断时间<span class="title">t</span>是否在时间ｕ的前面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Clock</span><span class="params">()</span> <span class="params">(hour, min, sec <span class="keyword">int</span>)</span>　//获取时间ｔ的<span class="title">hour</span>,<span class="title">min</span>和<span class="title">second</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Date</span><span class="params">()</span> <span class="params">(year <span class="keyword">int</span>, month Month, day <span class="keyword">int</span>)</span>　//获取时间ｔ的<span class="title">year</span>,<span class="title">month</span>和<span class="title">day</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Day</span><span class="params">()</span> <span class="title">int</span>   //获取时间ｔ的<span class="title">day</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span>  //判断时间<span class="title">t</span>和时间<span class="title">u</span>是否相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Format</span><span class="params">(layout <span class="keyword">string</span>)</span> <span class="title">string</span>  //时间字符串格式化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">GobDecode</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span> //编码为<span class="title">god</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">GobEncode</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span>//解码<span class="title">god</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Hour</span><span class="params">()</span> <span class="title">int</span>　//获取时间ｔ的小时</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">ISOWeek</span><span class="params">()</span> <span class="params">(year, week <span class="keyword">int</span>)</span>//获取时间ｔ的年份和星期</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">In</span><span class="params">(loc *Location)</span> <span class="title">Time</span>//获取<span class="title">loc</span>时区的时间ｔ的对应时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">IsZero</span><span class="params">()</span> <span class="title">bool</span>　//判断是否为０时间实例<span class="title">January</span> 1, <span class="title">year</span> 1, 00:00:00 <span class="title">UTC</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Local</span><span class="params">()</span> <span class="title">Time</span>　//获取当地时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Location</span><span class="params">()</span> *<span class="title">Location</span>   //获取当地时区</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">MarshalBinary</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span>　//<span class="title">marshal</span> <span class="title">binary</span>序列化，将时间<span class="title">t</span>序列化后存入[]<span class="title">byte</span>数组中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span>     //<span class="title">marshal</span> <span class="title">json</span>序列化，将时间<span class="title">t</span>序列化后存入[]<span class="title">byte</span>数组中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">MarshalText</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span>    //<span class="title">marshal</span> <span class="title">text</span>序列化，将时间<span class="title">t</span>序列化后存入[]<span class="title">byte</span>数组中</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">t := time.Date(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">918273645</span>, time.UTC)</span><br><span class="line">round := []time.Duration&#123;</span><br><span class="line">    time.Nanosecond,</span><br><span class="line">    time.Microsecond,</span><br><span class="line">    time.Millisecond,</span><br><span class="line">    time.Second,</span><br><span class="line">    <span class="number">2</span> * time.Second,</span><br><span class="line">    time.Minute,</span><br><span class="line">    <span class="number">10</span> * time.Minute,</span><br><span class="line">    time.Hour,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> round &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"t.Round(%6s) = %s\n"</span>, d, t.Round(d).Format(<span class="string">"15:04:05.999999999"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Second</span><span class="params">()</span> <span class="title">int</span>　//获取时间ｔ的秒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>　//获取时间ｔ的字符串表示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Sub</span><span class="params">(u Time)</span> <span class="title">Duration</span>　//与<span class="title">Add</span>相反，<span class="title">Sub</span>表示从时间ｔ中减去时间ｕ</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Truncate</span><span class="params">(d Duration)</span> <span class="title">Time</span>　//去尾法求近似值</span></span><br></pre></td></tr></table></figure>
<p>例子：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">t, _ := time.Parse(<span class="string">"2006 Jan 02 15:04:05"</span>, <span class="string">"2012 Dec 07 12:15:30.918273645"</span>)</span><br><span class="line">trunc := []time.Duration&#123;</span><br><span class="line">    time.Nanosecond,</span><br><span class="line">    time.Microsecond,</span><br><span class="line">    time.Millisecond,</span><br><span class="line">    time.Second,</span><br><span class="line">    <span class="number">2</span> * time.Second,</span><br><span class="line">    time.Minute,</span><br><span class="line">    <span class="number">10</span> * time.Minute,</span><br><span class="line">    time.Hour,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, d := <span class="keyword">range</span> trunc &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"t.Truncate(%6s) = %s\n"</span>, d, t.Truncate(d).Format(<span class="string">"15:04:05.999999999"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">t.Truncate(   <span class="number">1</span>ns) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30.918273645</span></span><br><span class="line">t.Truncate(   <span class="number">1</span>µs) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30.918273</span></span><br><span class="line">t.Truncate(   <span class="number">1</span>ms) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30.918</span></span><br><span class="line">t.Truncate(    <span class="number">1</span>s) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30</span></span><br><span class="line">t.Truncate(    <span class="number">2</span>s) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">30</span></span><br><span class="line">t.Truncate(  <span class="number">1</span>m0s) = <span class="number">12</span>:<span class="number">15</span>:<span class="number">00</span></span><br><span class="line">t.Truncate( <span class="number">10</span>m0s) = <span class="number">12</span>:<span class="number">10</span>:<span class="number">00</span></span><br><span class="line">t.Truncate(<span class="number">1</span>h0m0s) = <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">UTC</span><span class="params">()</span> <span class="title">Time</span>　//将本地时间变换为<span class="title">UTC</span>时区的时间并返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Unix</span><span class="params">()</span> <span class="title">int64</span>　//返回<span class="title">Unix</span>时间，该时间是从<span class="title">January</span> 1, 1970 <span class="title">UTC</span>这个时间开始算起的．</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">UnixNano</span><span class="params">()</span> <span class="title">int64</span>　//以纳秒为单位返回<span class="title">Unix</span>时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">UnmarshalBinary</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">error</span>　//将<span class="title">data</span>数据反序列化到时间ｔ中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">UnmarshalJSON</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span>　//将<span class="title">data</span>数据反序列化到时间ｔ中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Time)</span> <span class="title">UnmarshalText</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="params">(err error)</span>　//将<span class="title">data</span>数据反序列化到时间ｔ中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Weekday</span><span class="params">()</span> <span class="title">Weekday</span>　//获取时间ｔ的<span class="title">Weekday</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Year</span><span class="params">()</span> <span class="title">int</span>　　　//获取时间ｔ的<span class="title">Year</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">YearDay</span><span class="params">()</span> <span class="title">int</span>     //获取时间ｔ的<span class="title">YearDay</span>，即１年中的第几天</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Zone</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>, offset <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer　<span class="comment">//用于在指定的Duration类型时间后调用函数或计算表达式，它是一个计时器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span>) *<span class="title">Timer</span>　//和<span class="title">After</span>差不多，意思是多少时间之后执行函数<span class="title">f</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span>　//使用<span class="title">NewTimer</span><span class="params">()</span>,可以返回的<span class="title">Timer</span>类型在计时器到期之前,取消该计时器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Reset</span><span class="params">(d Duration)</span> <span class="title">bool</span>　//重新设定<span class="title">timer</span> <span class="title">t</span>的<span class="title">Duration</span> <span class="title">d</span>.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Timer)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">bool</span>　//阻止<span class="title">timer</span>事件发生，当该函数执行后，<span class="title">timer</span>计时器停止，相应的事件不再执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Weekday</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Weekday)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span>　//获取一周的字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="一些例子："><a href="#一些例子：" class="headerlink" title="一些例子："></a>一些例子：</h3><p>获取年月日方法  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">y := t.Year() <span class="comment">// 年</span></span><br><span class="line">m := <span class="keyword">int</span>(t.Month()) <span class="comment">//月</span></span><br><span class="line">d := t.Day()<span class="comment">// 日</span></span><br><span class="line">h := t.Hour() <span class="comment">//小时</span></span><br><span class="line">min := t.Minute()<span class="comment">//分钟</span></span><br><span class="line">s := t.Second()<span class="comment">//秒</span></span><br><span class="line">fmt.Printf(<span class="string">"%d-%d-%d"</span>,y,m,d)<span class="comment">// 2017-12-26</span></span><br><span class="line">fmt.Printf(<span class="string">"%d%02d%02d"</span>,y,m,d) <span class="comment">// 20180101</span></span><br></pre></td></tr></table></figure>

<p>获取格式为:2017-12-29 16:58:39  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">fmt.Println(t.String()[:<span class="number">19</span>])</span><br><span class="line">layout := <span class="string">"2006-01-02 15:04:05"</span></span><br><span class="line">fmt.Println(t.Format(layout))</span><br></pre></td></tr></table></figure>

<p>获取三个小时之前的时间  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du, _ := time.ParseDuration(<span class="string">"-3h"</span>)</span><br><span class="line">t := time.Now().Add(du)</span><br></pre></td></tr></table></figure>

<p>获取三天之前的时间</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">t.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">-3</span>) </span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<p>t.AddDate(year,month,day) 正数向前，负数向后  </p>
<p>时间戳转time.Time 类型  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timestamp := <span class="number">1513580645</span></span><br><span class="line">t := time.Unix(timestamp,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>获取时间戳：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line">timestamp := t.Unix()</span><br></pre></td></tr></table></figure>

<p>两个时间的间隔  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 := time.Now()</span><br><span class="line"><span class="comment">//do some function</span></span><br><span class="line">t2 := time.Now()</span><br><span class="line">sub := t2.Since(t1)</span><br></pre></td></tr></table></figure>

<p>字符串转时间  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout := <span class="string">"2006-01-02 15:04:05"</span> </span><br><span class="line"><span class="comment">// 这个格式，不能改，据说是Go诞生的时间，可能有特殊含义吧</span></span><br><span class="line">t , err := time.Parse(layout,<span class="string">"2017-12-26 17:20:21"</span>)</span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<p>标准时间字符串转化为时间<br>使用byte读取数据库当中的timestamp字段时，会出现标准的时间格式  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">layout := <span class="string">"2006-01-02T15:04:05Z07:00"</span></span><br><span class="line">timeStr := <span class="string">"2018-01-02T11:30:21Z"</span></span><br><span class="line">t , _ := time.Parse(layout,timeStr)</span><br><span class="line"><span class="comment">// t , _ := time.Parse(time.RFC3339,timeStr)</span></span><br><span class="line">fmt.Println(t)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="unicode-包"><a href="#unicode-包" class="headerlink" title="unicode 包"></a><code>unicode</code> 包</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MaxRune         = <span class="string">'\U0010FFFF'</span> <span class="comment">// Unicode 码点的最大值</span></span><br><span class="line">    ReplacementChar = <span class="string">'\uFFFD'</span>     <span class="comment">// 表示无效的码点</span></span><br><span class="line">    MaxASCII        = <span class="string">'\u007F'</span>     <span class="comment">// 最大 ASCII 值</span></span><br><span class="line">    MaxLatin1       = <span class="string">'\u00FF'</span>     <span class="comment">// 最大 Latin-1 值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="RangeTable"><a href="#RangeTable" class="headerlink" title="RangeTable"></a>RangeTable</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符 r 是否在 rangtab 范围内。</span></span><br><span class="line"><span class="comment">// 可用的 RangeTable 参见 go/src/unicode/tables.go。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(rangeTab *RangeTable, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeTable 定义一个 Unicode 码点集合，包含 16 位和 32 位两个范围列表。</span></span><br><span class="line"><span class="comment">// 这两个列表必须经过排序而且不能重叠。R32 中只能包含大于 16 位的值。</span></span><br><span class="line"><span class="keyword">type</span> RangeTable <span class="keyword">struct</span> &#123;</span><br><span class="line">    R16         []Range16</span><br><span class="line">    R32         []Range32</span><br><span class="line">    LatinOffset <span class="keyword">int</span> <span class="comment">// R16 中 Hi &lt;= MaxLatin1 的条目数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range16 表示一个 16 位的 Unicode 码点范围。范围从 Lo 到 Hi，具有指定的步长。</span></span><br><span class="line"><span class="keyword">type</span> Range16 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lo     <span class="keyword">uint16</span></span><br><span class="line">    Hi     <span class="keyword">uint16</span></span><br><span class="line">    Stride <span class="keyword">uint16</span> <span class="comment">// 步长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Range32 表示一个 32 位的 Unicode 码点范围。范围从 Lo 到 Hi，具有指定的步长。</span></span><br><span class="line"><span class="comment">// Lo 和 Hi 必须都大于 16 位。</span></span><br><span class="line"><span class="keyword">type</span> Range32 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lo     <span class="keyword">uint32</span></span><br><span class="line">    Hi     <span class="keyword">uint32</span></span><br><span class="line">    Stride <span class="keyword">uint32</span> <span class="comment">// 步长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断及转换字符大小写、Title"><a href="#判断及转换字符大小写、Title" class="headerlink" title="判断及转换字符大小写、Title"></a>判断及转换字符大小写、Title</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符 r 是否为大写格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符 r 是否为小写格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符 r 是否为 Unicode 规定的 Title 字符</span></span><br><span class="line"><span class="comment">// 大部分字符的 Title 格式就是其大写格式</span></span><br><span class="line"><span class="comment">// 只有少数字符的 Title 格式是特殊字符</span></span><br><span class="line"><span class="comment">// 这里判断的就是特殊字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToUpper 将字符 r 转换为大写格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToLower 将字符 r 转换为小写格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToTitle 将字符 r 转换为 Title 格式</span></span><br><span class="line"><span class="comment">// 大部分字符的 Title 格式就是其大写格式</span></span><br><span class="line"><span class="comment">// 只有少数字符的 Title 格式是特殊字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To 将字符 r 转换为指定的格式</span></span><br><span class="line"><span class="comment">// _case 取值：UpperCase、LowerCase、TitleCase</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">To</span><span class="params">(_case <span class="keyword">int</span>, r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br></pre></td></tr></table></figure>

<p>示例1：判断汉字：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 世界！"</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为汉字</span></span><br><span class="line">        <span class="keyword">if</span> unicode.Is(unicode.Scripts[<span class="string">"Han"</span>], r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r) <span class="comment">// 世界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更多 unicode.Scripts 取值请参考：http://www.cnblogs.com/golove/p/3269099.html</span></span><br></pre></td></tr></table></figure>

<p>示例2：判断大小写：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello ＡＢＣ！"</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为大写</span></span><br><span class="line">        <span class="keyword">if</span> unicode.IsUpper(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r) <span class="comment">// HＡＢＣ</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello ａｂｃ！"</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为小写</span></span><br><span class="line">        <span class="keyword">if</span> unicode.IsLower(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r) <span class="comment">// elloａｂｃ</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello ᾏᾟᾯ！"</span> &#123;</span><br><span class="line">        <span class="comment">// 判断字符是否为标题</span></span><br><span class="line">        <span class="keyword">if</span> unicode.IsTitle(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r) <span class="comment">// ᾏᾟᾯ</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例3：输出 Unicode 规定的标题字符  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, cr := <span class="keyword">range</span> unicode.Lt.R16 &#123;</span><br><span class="line">        <span class="keyword">for</span> i := cr.Lo; i &lt;= cr.Hi; i += cr.Stride &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// ǅǈǋǲᾈᾉᾊᾋᾌᾍᾎᾏᾘᾙᾚᾛᾜᾝᾞᾟᾨᾩᾪᾫᾬᾭᾮᾯᾼῌῼ</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例4：转换大小写  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello 世界！"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.ToUpper(r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.ToLower(r))</span><br><span class="line">    &#125; <span class="comment">// hello 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.ToTitle(r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.To(unicode.UpperCase, r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.To(unicode.LowerCase, r))</span><br><span class="line">    &#125; <span class="comment">// hello 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.To(unicode.TitleCase, r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rune操作"><a href="#rune操作" class="headerlink" title="rune操作"></a>rune操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ToUpper 将 r 转换为大写格式</span></span><br><span class="line"><span class="comment">// 优先使用指定的映射表 special</span></span><br><span class="line"><span class="comment">// 可用的 SpecialCase 参见 go/src/unicode/casetables.go。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(special SpecialCase)</span> <span class="title">ToUpper</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToLower 将 r 转换为小写格式</span></span><br><span class="line"><span class="comment">// 优先使用指定的映射表 special</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(special SpecialCase)</span> <span class="title">ToLower</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ToTitle 将 r 转换为 Title 格式</span></span><br><span class="line"><span class="comment">// 优先使用指定的映射表 special</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(special SpecialCase)</span> <span class="title">ToTitle</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SpecialCase 表示特定语言的大小写映射，比如土耳其语。</span></span><br><span class="line"><span class="comment">// SpecialCase 的方法可以自定义标准映射（通过重写）。</span></span><br><span class="line"><span class="keyword">type</span> SpecialCase []CaseRange</span><br><span class="line"></span><br><span class="line"><span class="comment">// CaseRange 表示一个简单的 Unicode 码点范围，用于大小写转换。</span></span><br><span class="line"><span class="comment">// 在 Lo 和 Hi 范围内的码点，如果要转换成大写，只需要加上 d[0] 即可</span></span><br><span class="line"><span class="comment">// 如果要转换为小写，只需要加上 d[1] 即可，如果要转换为 Title 格式，</span></span><br><span class="line"><span class="comment">// 只需要加上 d[2] 即可。</span></span><br><span class="line"><span class="keyword">type</span> CaseRange <span class="keyword">struct</span> &#123;</span><br><span class="line">    Lo    <span class="keyword">uint32</span></span><br><span class="line">    Hi    <span class="keyword">uint32</span></span><br><span class="line">    Delta d <span class="comment">// [3]rune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CaseRanges 中 Delta 数组的索引。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UpperCase = <span class="literal">iota</span></span><br><span class="line">    LowerCase</span><br><span class="line">    TitleCase</span><br><span class="line">    MaxCase</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一个 CaseRange 中的 Delta 元素是 UpperLower，则表示这个 CaseRange 是</span></span><br><span class="line"><span class="comment">// 一个有着连续的大写小写大写小写的范围。也就是说，Lo 是大写，Lo+1 是小写，</span></span><br><span class="line"><span class="comment">// Lo+2 是大写，Lo+3 是小写 ... 一直到 Hi 为止。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    UpperLower = MaxRune + <span class="number">1</span> <span class="comment">// 不是一个有效的 Delta 元素</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"Hello 世界！"</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.SpecialCase(unicode.CaseRanges).ToUpper(r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.SpecialCase(unicode.CaseRanges).ToLower(r))</span><br><span class="line">    &#125; <span class="comment">// hello 世界！</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, unicode.SpecialCase(unicode.CaseRanges).ToTitle(r))</span><br><span class="line">    &#125; <span class="comment">// HELLO 世界！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SimpleFold-环绕查找"><a href="#SimpleFold-环绕查找" class="headerlink" title="SimpleFold 环绕查找"></a>SimpleFold 环绕查找</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleFold 在 Unicode 字符表中从字符 r 开始环绕查找（到尾部后再从头开始）</span></span><br><span class="line"><span class="comment">// 下一个与 r 大小写相匹配的字符（一个字符的大写、小写、标题三者视为大小写相</span></span><br><span class="line"><span class="comment">// 匹配），这个函数遵循 Unicode 定义的大小写环绕匹配表。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="comment">// SimpleFold('A') = 'a'</span></span><br><span class="line"><span class="comment">// SimpleFold('a') = 'A'</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SimpleFold('K') = 'k'</span></span><br><span class="line"><span class="comment">// SimpleFold('k') = 'K' (开尔文符号)</span></span><br><span class="line"><span class="comment">// SimpleFold('K') = 'K'</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SimpleFold('1') = '1'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SimpleFold</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">"ΦφϕkKK"</span></span><br><span class="line">    <span class="comment">// 看看 s 里面是什么</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%x  "</span>, c)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="comment">// 大写，小写，标题 | 当前字符 -&gt; 下一个匹配字符</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%c, %c, %c | %c -&gt; %c\n"</span>,</span><br><span class="line">            unicode.ToUpper(v),</span><br><span class="line">            unicode.ToLower(v),</span><br><span class="line">            unicode.ToTitle(v),</span><br><span class="line">            v,</span><br><span class="line">            unicode.SimpleFold(v),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 3a6  3c6  3d5  6b  4b  212a</span></span><br><span class="line"><span class="comment">// Φ, φ, Φ | Φ -&gt; φ</span></span><br><span class="line"><span class="comment">// Φ, φ, Φ | φ -&gt; ϕ</span></span><br><span class="line"><span class="comment">// Φ, ϕ, Φ | ϕ -&gt; Φ</span></span><br><span class="line"><span class="comment">// K, k, K | k -&gt; K</span></span><br><span class="line"><span class="comment">// K, k, K | K -&gt; k</span></span><br><span class="line"><span class="comment">// K, k, K | K -&gt; K</span></span><br></pre></td></tr></table></figure>

<h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsDigit 判断 r 是否为一个十进制的数字字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsDigit</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsNumber 判断 r 是否为一个数字字符 (类别 N)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNumber</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsLetter 判断 r 是否为一个字母字符 (类别 L)</span></span><br><span class="line"><span class="comment">// 汉字也是一个字母字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsLetter</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsSpace 判断 r 是否为一个空白字符</span></span><br><span class="line"><span class="comment">// 在 Latin-1 字符集中，空白字符为：\t, \n, \v, \f, \r,</span></span><br><span class="line"><span class="comment">// 空格, U+0085 (NEL), U+00A0 (NBSP)</span></span><br><span class="line"><span class="comment">// 其它空白字符的定义有“类别 Z”和“Pattern_White_Space 属性”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSpace</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsControl 判断 r 是否为一个控制字符</span></span><br><span class="line"><span class="comment">// Unicode 类别 C 包含更多字符，比如代理字符</span></span><br><span class="line"><span class="comment">// 使用 Is(C, r) 来测试它们</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsControl</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsGraphic 判断字符 r 是否为一个“图形字符”</span></span><br><span class="line"><span class="comment">// “图形字符”包括字母、标记、数字、标点、符号、空格</span></span><br><span class="line"><span class="comment">// 他们分别对应于 L、M、N、P、S、Zs 类别</span></span><br><span class="line"><span class="comment">// 这些类别是 RangeTable 类型，存储了相应类别的字符范围</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsGraphic</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsPrint 判断字符 r 是否为 Go 所定义的“可打印字符”</span></span><br><span class="line"><span class="comment">// “可打印字符”包括字母、标记、数字、标点、符号和 ASCII 空格</span></span><br><span class="line"><span class="comment">// 他们分别对应于 L, M, N, P, S 类别和 ASCII 空格</span></span><br><span class="line"><span class="comment">// “可打印字符”和“图形字符”基本是相同的，不同之处在于</span></span><br><span class="line"><span class="comment">// “可打印字符”只包含 Zs 类别中的 ASCII 空格（U+0020）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsPunct 判断 r 是否为一个标点字符 (类别 P)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPunct</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsSymbol 判断 r 是否为一个符号字符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSymbol</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsMark 判断 r 是否为一个 mark 字符 (类别 M)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsMark</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IsOneOf 判断 r 是否在 set 范围内</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsOneOf</span><span class="params">(set []*RangeTable, r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println() <span class="comment">// 数字</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 123１２３一二三！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsDigit(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 123１２３</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 数字</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 123１２３一二三！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsNumber(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 123１２３</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 字母</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello\n\t世界！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsLetter(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Hello世界</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 空白</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello \t世　界！\n"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsSpace(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%q"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// ' ''\t''\u3000''\n'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 控制字符</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello\n\t世界！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsControl(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%#q"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// '\n''\t'</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 可打印</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello　世界！\t"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsPrint(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Hello世界！</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 图形</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello　世界！\t"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsGraphic(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// Hello　世界！</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 掩码</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello ៉៊់៌៍！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsMark(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// ៉៊់៌៍</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 标点</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 世界！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsPunct(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// ！</span></span><br><span class="line"></span><br><span class="line">    fmt.Println() <span class="comment">// 符号</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello (&lt;世=界&gt;)"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsSymbol(r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// &lt;=&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg.判断汉字和标点：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将 set 设置为“汉字、标点符号”</span></span><br><span class="line">    set := []*unicode.RangeTable&#123;unicode.Han, unicode.P&#125;</span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello 世界！"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> unicode.IsOneOf(set, r) &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 世界！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eg.输出所有 mark 字符：  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, cr := <span class="keyword">range</span> unicode.M.R16 &#123;</span><br><span class="line">        Lo, Hi, Stride := <span class="keyword">rune</span>(cr.Lo), <span class="keyword">rune</span>(cr.Hi), <span class="keyword">rune</span>(cr.Stride)</span><br><span class="line">        <span class="keyword">for</span> i := Lo; i &gt;= Lo &amp;&amp; i &lt;= Hi; i += Stride &#123;</span><br><span class="line">            <span class="keyword">if</span> unicode.IsMark(i) &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%c"</span>, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="unicode-utf16-包"><a href="#unicode-utf16-包" class="headerlink" title="unicode/utf16 包"></a><code>unicode/utf16</code> 包</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IsSurrogate 判断 r 是否为代理区字符</span></span><br><span class="line"><span class="comment">// 两个代理区字符可以用来组合成一个 utf16 编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSurrogate</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EncodeRune 将字符 r 编码成 UTF-16 代理对</span></span><br><span class="line"><span class="comment">// r：要编码的字符</span></span><br><span class="line"><span class="comment">// 如果 r &lt; 0x10000 ，则无需编码，其 UTF-16 序列就是其自身</span></span><br><span class="line"><span class="comment">// r1：编码后的 UTF-16 代理对的高位码元</span></span><br><span class="line"><span class="comment">// r2：编码后的 UTF-16 代理对的低位码元</span></span><br><span class="line"><span class="comment">// 如果 r 不是有效的 Unicode 字符，或者是代理区字符，或者无需编码</span></span><br><span class="line"><span class="comment">// 则返回 U+FFFD, U+FFFD</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(r1, r2 <span class="keyword">rune</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DecodeRune 将 UTF-16 代理对解码成一个 Unicode 字符</span></span><br><span class="line"><span class="comment">// r1：是 UTF-16 代理对的高位码元</span></span><br><span class="line"><span class="comment">// r2：是 UTF-16 代理对的低位码元</span></span><br><span class="line"><span class="comment">// 返回值为解码后的 Unicode 字符</span></span><br><span class="line"><span class="comment">// 如果 r1 或 r2 不是有效的 UTF-16 代理区字符，则返回 U+FFFD</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeRune</span><span class="params">(r1, r2 <span class="keyword">rune</span>)</span> <span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Decode 将 UTF-16 序列 s 解码成 Unicode 字符序列并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">(s []<span class="keyword">uint16</span>)</span> []<span class="title">rune</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Encode 将 s 编码成 UTF-16 序列并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(s []<span class="keyword">rune</span>)</span> []<span class="title">uint16</span></span></span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf16.IsSurrogate(<span class="number">0xD400</span>)) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf16.IsSurrogate(<span class="number">0xDC00</span>)) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf16.IsSurrogate(<span class="number">0xDFFF</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    r1, r2 := utf16.EncodeRune(<span class="string">'𠀾'</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%x, %x\n"</span>, r1, r2) <span class="comment">// d840, dc3e</span></span><br><span class="line"></span><br><span class="line">    r := utf16.DecodeRune(<span class="number">0xD840</span>, <span class="number">0xDC3E</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, r) <span class="comment">// d840, dc3e</span></span><br><span class="line"></span><br><span class="line">    u := []<span class="keyword">uint16</span>&#123;<span class="string">'不'</span>, <span class="string">'会'</span>, <span class="number">0xD840</span>, <span class="number">0xDC3E</span>&#125;</span><br><span class="line">    s := utf16.Decode(u)</span><br><span class="line">    fmt.Printf(<span class="string">"%c"</span>, s) <span class="comment">// [不 会 𠀾]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="unicode-utf8-包"><a href="#unicode-utf8-包" class="headerlink" title="unicode/utf8 包"></a><code>unicode/utf8</code> 包</h1><h2 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码所需的基本数字</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    RuneError = <span class="string">'\uFFFD'</span>     <span class="comment">// 错误的 Rune 或 Unicode 代理字符</span></span><br><span class="line">    RuneSelf  = <span class="number">0x80</span>         <span class="comment">// ASCII 字符范围</span></span><br><span class="line">    MaxRune   = <span class="string">'\U0010FFFF'</span> <span class="comment">// Unicode 码点的最大值</span></span><br><span class="line">    UTFMax    = <span class="number">4</span>            <span class="comment">// 一个字符编码的最大长度</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="函数-6"><a href="#函数-6" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 r 转换为 UTF-8 编码写入 p 中（p 必须足够长，通常为 4 个字节）</span></span><br><span class="line"><span class="comment">// 如果 r 是无效的 Unicode 字符，则写入 RuneError</span></span><br><span class="line"><span class="comment">// 返回写入的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRune</span><span class="params">(p []<span class="keyword">byte</span>, r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码 p 中的第一个字符，返回解码后的字符和 p 中被解码的字节数</span></span><br><span class="line"><span class="comment">// 如果 p 为空，则返回（RuneError, 0）</span></span><br><span class="line"><span class="comment">// 如果 p 中的编码无效，则返回（RuneError, 1）</span></span><br><span class="line"><span class="comment">// 无效编码：UTF-8 编码不正确（比如长度不够）、结果超出 Unicode 范围、编码不是最短的。</span></span><br><span class="line"><span class="comment">// 关于最短编码：可以用四个字节编码一个单字节字符，但它不是最短的，比如：</span></span><br><span class="line"><span class="comment">// [111100000 10000000 10000000 10111000] 不是最短的，应该使用 [00111000]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeRuneInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码 p 中的最后一个字符，返回解码后的字符，和 p 中被解码的字节数</span></span><br><span class="line"><span class="comment">// 如果 p 为空，则返回（RuneError, 0）</span></span><br><span class="line"><span class="comment">// 如果 p 中的编码无效，则返回（RuneError, 1）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeLastRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeLastRuneInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FullRune 检测 p 中第一个字符的 UTF-8 编码是否完整（完整并不表示有效）。</span></span><br><span class="line"><span class="comment">// 一个无效的编码也被认为是完整字符，因为它将被转换为一个 RuneError 字符。</span></span><br><span class="line"><span class="comment">// 只有“编码有效但长度不够”的字符才被认为是不完整字符。</span></span><br><span class="line"><span class="comment">// 也就是说，只有截去一个有效字符的一个或多个尾部字节，该字符才算是不完整字符。</span></span><br><span class="line"><span class="comment">// 举例：</span></span><br><span class="line"><span class="comment">// "好"     是完整字符</span></span><br><span class="line"><span class="comment">// "好"[1:] 是完整字符（首字节无效，可转换为 RuneError 字符）</span></span><br><span class="line"><span class="comment">// "好"[2:] 是完整字符（首字节无效，可转换为 RuneError 字符）</span></span><br><span class="line"><span class="comment">// "好"[:2] 是不完整字符（编码有效但长度不够）</span></span><br><span class="line"><span class="comment">// "好"[:1] 是不完整字符（编码有效但长度不够）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FullRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FullRuneInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 p 中的字符个数</span></span><br><span class="line"><span class="comment">// 错误的 UTF8 编码和长度不足的 UTF8 编码将被当作单字节的 RuneError 处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneCount</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneCountInString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RuneLen 返回需要多少字节来编码字符 r，如果 r 是无效的字符，则返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneLen</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 b 是否为 UTF8 字符的首字节编码，最高位(bit)是不是 10 的字节就是首字节。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RuneStart</span><span class="params">(b <span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Valid 判断 p 是否为完整有效的 UTF8 编码序列。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Valid</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能同上，参数为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ValidRune 判断 r 能否被正确的转换为 UTF8 编码</span></span><br><span class="line"><span class="comment">// 超出 Unicode 范围的码点或 UTF-16 代理区中的码点是不能转换的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>eg.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, utf8.UTFMax)</span><br><span class="line"></span><br><span class="line">    n := utf8.EncodeRune(b, <span class="string">'好'</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%v：%v\n"</span>, b, n) <span class="comment">// [229 165 189 0]：3</span></span><br><span class="line"></span><br><span class="line">    r, n := utf8.DecodeRune(b)</span><br><span class="line">    fmt.Printf(<span class="string">"%c：%v\n"</span>, r, n) <span class="comment">// 好：3</span></span><br><span class="line"></span><br><span class="line">    s := <span class="string">"大家好"</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">        r, n = utf8.DecodeRuneInString(s[i:])</span><br><span class="line">        fmt.Printf(<span class="string">"%c：%v   "</span>, r, n) <span class="comment">// 大：3   家：3   好：3</span></span><br><span class="line">        i += n</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s); i &gt; <span class="number">0</span>; &#123;</span><br><span class="line">        r, n = utf8.DecodeLastRuneInString(s[:i])</span><br><span class="line">        fmt.Printf(<span class="string">"%c：%v   "</span>, r, n) <span class="comment">// 好：3   家：3   大：3</span></span><br><span class="line">        i -= n</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    b = []<span class="keyword">byte</span>(<span class="string">"好"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.FullRune(b))     <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.FullRune(b[<span class="number">1</span>:])) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.FullRune(b[<span class="number">2</span>:])) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.FullRune(b[:<span class="number">2</span>])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf8.FullRune(b[:<span class="number">1</span>])) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    b = []<span class="keyword">byte</span>(<span class="string">"大家好"</span>)</span><br><span class="line">    fmt.Println(utf8.RuneCount(b)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%d, "</span>, utf8.RuneLen(<span class="string">'A'</span>))          <span class="comment">// 1</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d, "</span>, utf8.RuneLen(<span class="string">'\u03A6'</span>))     <span class="comment">// 2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d, "</span>, utf8.RuneLen(<span class="string">'好'</span>))          <span class="comment">// 3</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d, "</span>, utf8.RuneLen(<span class="string">'\U0010FFFF'</span>)) <span class="comment">// 4</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, utf8.RuneLen(<span class="number">0x1FFFFFFF</span>))   <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.RuneStart(<span class="string">"好"</span>[<span class="number">0</span>])) <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.RuneStart(<span class="string">"好"</span>[<span class="number">1</span>])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf8.RuneStart(<span class="string">"好"</span>[<span class="number">2</span>])) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    b = []<span class="keyword">byte</span>(<span class="string">"你好"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b))     <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b[<span class="number">1</span>:])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b[<span class="number">2</span>:])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b[:<span class="number">2</span>])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.Valid(b[:<span class="number">1</span>])) <span class="comment">// false</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf8.Valid(b[<span class="number">3</span>:])) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.ValidRune(<span class="string">'好'</span>))        <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.ValidRune(<span class="number">0</span>))          <span class="comment">// true</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t, "</span>, utf8.ValidRune(<span class="number">0xD800</span>))     <span class="comment">// false  代理区字符</span></span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, utf8.ValidRune(<span class="number">0x10FFFFFF</span>)) <span class="comment">// false  超出范围</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p><em><code>to be continued...</code></em>  </p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"><i class="fa fa-tag"></i> Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/19/Go-Action-Notes/" rel="prev" title="Golang in Action Notes">
      <i class="fa fa-chevron-left"></i> Golang in Action Notes
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/27/Hexo-NexT-Config/" rel="next" title="Hexo + NexT(v7.0.1) 博客配置备忘">
      Hexo + NexT(v7.0.1) 博客配置备忘 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#bufio-包"><span class="nav-number">1.</span> <span class="nav-text">bufio 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Read-相关函数"><span class="nav-number">1.1.</span> <span class="nav-text">Read 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NewReaderSize、NewReader"><span class="nav-number">1.1.1.</span> <span class="nav-text">NewReaderSize、NewReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Peek"><span class="nav-number">1.1.2.</span> <span class="nav-text">Peek</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read"><span class="nav-number">1.1.3.</span> <span class="nav-text">Read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffered"><span class="nav-number">1.1.4.</span> <span class="nav-text">Buffered</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Discard"><span class="nav-number">1.1.5.</span> <span class="nav-text">Discard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadSlice"><span class="nav-number">1.1.6.</span> <span class="nav-text">ReadSlice</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadLine"><span class="nav-number">1.1.7.</span> <span class="nav-text">ReadLine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadBytes、ReadString"><span class="nav-number">1.1.8.</span> <span class="nav-text">ReadBytes、ReadString</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reset"><span class="nav-number">1.1.9.</span> <span class="nav-text">Reset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例1：Peek、Read、Discard、Buffered"><span class="nav-number">1.1.10.</span> <span class="nav-text">示例1：Peek、Read、Discard、Buffered</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例2：ReadLine"><span class="nav-number">1.1.11.</span> <span class="nav-text">示例2：ReadLine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例3：ReadSlice"><span class="nav-number">1.1.12.</span> <span class="nav-text">示例3：ReadSlice</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Write-相关函数"><span class="nav-number">1.2.</span> <span class="nav-text">Write 相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NewWriterSize、NewWriter"><span class="nav-number">1.2.1.</span> <span class="nav-text">NewWriterSize、NewWriter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WriteString"><span class="nav-number">1.2.2.</span> <span class="nav-text">WriteString</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WriteRune"><span class="nav-number">1.2.3.</span> <span class="nav-text">WriteRune</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flush"><span class="nav-number">1.2.4.</span> <span class="nav-text">Flush</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Available"><span class="nav-number">1.2.5.</span> <span class="nav-text">Available</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffered-1"><span class="nav-number">1.2.6.</span> <span class="nav-text">Buffered</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reset-1"><span class="nav-number">1.2.7.</span> <span class="nav-text">Reset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例1：Available、Buffered、WriteString、Flush"><span class="nav-number">1.2.8.</span> <span class="nav-text">示例1：Available、Buffered、WriteString、Flush</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-ReadWriter"><span class="nav-number">1.3.</span> <span class="nav-text">type ReadWriter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-Scanner"><span class="nav-number">1.4.</span> <span class="nav-text">type Scanner</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-SplitFunc"><span class="nav-number">1.5.</span> <span class="nav-text">type SplitFunc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#示例1：扫描"><span class="nav-number">1.5.1.</span> <span class="nav-text">示例1：扫描</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例2：待检查扫描"><span class="nav-number">1.5.2.</span> <span class="nav-text">示例2：待检查扫描</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bytes-包"><span class="nav-number">2.</span> <span class="nav-text">bytes 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#转换"><span class="nav-number">2.1.</span> <span class="nav-text">转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#将s中所有字符修改为大写（小写、标题）格式返回"><span class="nav-number">2.1.1.</span> <span class="nav-text">将s中所有字符修改为大写（小写、标题）格式返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用指定的映射表将-s-中的所有字符修改为大写（小写、标题）格式返回"><span class="nav-number">2.1.2.</span> <span class="nav-text">使用指定的映射表将 s 中的所有字符修改为大写（小写、标题）格式返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将-s-中的所有单词的首字符修改为-Title-格式返回"><span class="nav-number">2.1.3.</span> <span class="nav-text">将 s 中的所有单词的首字符修改为 Title 格式返回</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较"><span class="nav-number">2.2.</span> <span class="nav-text">比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#比较两个-byte的字典顺序"><span class="nav-number">2.2.1.</span> <span class="nav-text">比较两个[]byte的字典顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断a、b是否相等"><span class="nav-number">2.2.2.</span> <span class="nav-text">判断a、b是否相等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断s，t是否相似"><span class="nav-number">2.2.3.</span> <span class="nav-text">判断s，t是否相似</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#清理"><span class="nav-number">2.3.</span> <span class="nav-text">清理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#去掉-s-左右两边包含在cutset中的字符（返回s的切片）"><span class="nav-number">2.3.1.</span> <span class="nav-text">去掉 s 左右两边包含在cutset中的字符（返回s的切片）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#去掉s两边符合f要求的字符（返回s的切片）"><span class="nav-number">2.3.2.</span> <span class="nav-text">去掉s两边符合f要求的字符（返回s的切片）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#去掉s两边的空白-unicode-IsSpace-（返回s的切片）"><span class="nav-number">2.3.3.</span> <span class="nav-text">去掉s两边的空白(unicode.IsSpace)（返回s的切片）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#去掉-s-的前缀-prefix（后缀-suffix）（返回-s-的切片）"><span class="nav-number">2.3.4.</span> <span class="nav-text">去掉 s 的前缀 prefix（后缀 suffix）（返回 s 的切片）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拆合"><span class="nav-number">2.4.</span> <span class="nav-text">拆合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Split按seq分割"><span class="nav-number">2.4.1.</span> <span class="nav-text">Split按seq分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SplitAfter"><span class="nav-number">2.4.2.</span> <span class="nav-text">SplitAfter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fields-空白符分割"><span class="nav-number">2.4.3.</span> <span class="nav-text">Fields 空白符分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以符合-f-的字符为分隔符将-s-切分成多个子串，结果不包含分隔符"><span class="nav-number">2.4.4.</span> <span class="nav-text">以符合 f 的字符为分隔符将 s 切分成多个子串，结果不包含分隔符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Join，sep为连接符"><span class="nav-number">2.4.5.</span> <span class="nav-text">Join，sep为连接符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#把子串b重复count次吼返回"><span class="nav-number">2.4.6.</span> <span class="nav-text">把子串b重复count次吼返回</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子串"><span class="nav-number">2.5.</span> <span class="nav-text">子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判断前缀、后缀"><span class="nav-number">2.5.1.</span> <span class="nav-text">判断前缀、后缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否包含子串subslice-或字符r"><span class="nav-number">2.5.2.</span> <span class="nav-text">是否包含子串subslice 或字符r</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否包含chars中任一字符"><span class="nav-number">2.5.3.</span> <span class="nav-text">是否包含chars中任一字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找子串seq（字节c、字符r）在s中第一次出现的位置"><span class="nav-number">2.5.4.</span> <span class="nav-text">查找子串seq（字节c、字符r）在s中第一次出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找chars中任一字符在s中第一次出现的位置"><span class="nav-number">2.5.5.</span> <span class="nav-text">查找chars中任一字符在s中第一次出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找符合f的字符在s中第一次出现的位置"><span class="nav-number">2.5.6.</span> <span class="nav-text">查找符合f的字符在s中第一次出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#功能同上，只不过查找最后一次出现的位置"><span class="nav-number">2.5.7.</span> <span class="nav-text">功能同上，只不过查找最后一次出现的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取seq在s中出现的次数（不重叠）"><span class="nav-number">2.5.8.</span> <span class="nav-text">获取seq在s中出现的次数（不重叠）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#替换"><span class="nav-number">2.6.</span> <span class="nav-text">替换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#s中前n个old替换为new，n-lt-0则替换全部"><span class="nav-number">2.6.1.</span> <span class="nav-text">s中前n个old替换为new，n&lt;0则替换全部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将-s-中的字符替换为-mapping-r-的返回值"><span class="nav-number">2.6.2.</span> <span class="nav-text">将 s 中的字符替换为 mapping(r) 的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将s转换为-rune类型返回"><span class="nav-number">2.6.3.</span> <span class="nav-text">将s转换为[]rune类型返回</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type"><span class="nav-number">2.7.</span> <span class="nav-text">type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Reader"><span class="nav-number">2.7.1.</span> <span class="nav-text">type Reader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Buffer"><span class="nav-number">2.7.2.</span> <span class="nav-text">type Buffer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#errors-包"><span class="nav-number">3.</span> <span class="nav-text">errors 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#error-New-函数"><span class="nav-number">3.1.</span> <span class="nav-text">error.New()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义error类型"><span class="nav-number">3.2.</span> <span class="nav-text">自定义error类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#fmt-包"><span class="nav-number">4.</span> <span class="nav-text">fmt 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#占位符"><span class="nav-number">4.1.</span> <span class="nav-text">占位符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scanning"><span class="nav-number">4.2.</span> <span class="nav-text">Scanning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">4.3.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Errorf"><span class="nav-number">4.3.1.</span> <span class="nav-text">Errorf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fprint、Fprintf、Fprintln"><span class="nav-number">4.3.2.</span> <span class="nav-text">Fprint、Fprintf、Fprintln</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fscan、Fscanf、Fscanln"><span class="nav-number">4.3.3.</span> <span class="nav-text">Fscan、Fscanf、Fscanln</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Print、Printf、Println"><span class="nav-number">4.3.4.</span> <span class="nav-text">Print、Printf、Println</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scan、Scanf、Scanln"><span class="nav-number">4.3.5.</span> <span class="nav-text">Scan、Scanf、Scanln</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sprint、Sprintf、Sprintln"><span class="nav-number">4.3.6.</span> <span class="nav-text">Sprint、Sprintf、Sprintln</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sscan、Sscanf、Sscanln"><span class="nav-number">4.3.7.</span> <span class="nav-text">Sscan、Sscanf、Sscanln</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-1"><span class="nav-number">4.4.</span> <span class="nav-text">type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Formatter"><span class="nav-number">4.4.1.</span> <span class="nav-text">type Formatter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-GoStringer"><span class="nav-number">4.4.2.</span> <span class="nav-text">type GoStringer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-ScanState"><span class="nav-number">4.4.3.</span> <span class="nav-text">type ScanState</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Scanner-1"><span class="nav-number">4.4.4.</span> <span class="nav-text">type Scanner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-State"><span class="nav-number">4.4.5.</span> <span class="nav-text">type State</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Stringer"><span class="nav-number">4.4.6.</span> <span class="nav-text">type Stringer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#net-http-包"><span class="nav-number">5.</span> <span class="nav-text">net&#x2F;http 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">5.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数-1"><span class="nav-number">5.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Client"><span class="nav-number">5.2.1.</span> <span class="nav-text">type Client</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-CloseNotifier-接口"><span class="nav-number">5.2.2.</span> <span class="nav-text">type CloseNotifier 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-ConnState-int"><span class="nav-number">5.2.3.</span> <span class="nav-text">type ConnState int</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Cookie-struct"><span class="nav-number">5.2.4.</span> <span class="nav-text">type Cookie struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Dir-string"><span class="nav-number">5.2.5.</span> <span class="nav-text">type Dir string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-File-接口"><span class="nav-number">5.2.6.</span> <span class="nav-text">type File 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Flusher-接口"><span class="nav-number">5.2.7.</span> <span class="nav-text">type Flusher 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Handler-接口"><span class="nav-number">5.2.8.</span> <span class="nav-text">type Handler 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-HandlerFunc"><span class="nav-number">5.2.9.</span> <span class="nav-text">type HandlerFunc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Hijacker-接口"><span class="nav-number">5.2.10.</span> <span class="nav-text">type Hijacker 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-ProtocolError"><span class="nav-number">5.2.11.</span> <span class="nav-text">type ProtocolError</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Reques-struct"><span class="nav-number">5.2.12.</span> <span class="nav-text">type Reques struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Response-struct"><span class="nav-number">5.2.13.</span> <span class="nav-text">type Response struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-RoundTripper-接口"><span class="nav-number">5.2.14.</span> <span class="nav-text">type RoundTripper 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-ServeMux"><span class="nav-number">5.2.15.</span> <span class="nav-text">*type ServeMux *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Server-struct"><span class="nav-number">5.2.16.</span> <span class="nav-text">type Server struct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-Transport-struct"><span class="nav-number">5.2.17.</span> <span class="nav-text">type Transport struct</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#io-ioutil-包"><span class="nav-number">6.</span> <span class="nav-text">io&#x2F;ioutil 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数-2"><span class="nav-number">6.1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Discard-1"><span class="nav-number">6.1.1.</span> <span class="nav-text">Discard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadAll"><span class="nav-number">6.1.2.</span> <span class="nav-text">ReadAll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadFile"><span class="nav-number">6.1.3.</span> <span class="nav-text">ReadFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WriteFile"><span class="nav-number">6.1.4.</span> <span class="nav-text">WriteFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadDir"><span class="nav-number">6.1.5.</span> <span class="nav-text">ReadDir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NopCloser"><span class="nav-number">6.1.6.</span> <span class="nav-text">NopCloser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TempFile"><span class="nav-number">6.1.7.</span> <span class="nav-text">TempFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TempDir"><span class="nav-number">6.1.8.</span> <span class="nav-text">TempDir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">6.1.9.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#os-包"><span class="nav-number">7.</span> <span class="nav-text">os 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数-3"><span class="nav-number">7.1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前目录、改变目录"><span class="nav-number">7.1.1.</span> <span class="nav-text">获取当前目录、改变目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改文件权限"><span class="nav-number">7.1.2.</span> <span class="nav-text">修改文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取用户识别码uid-和-群组识别码gid"><span class="nav-number">7.1.3.</span> <span class="nav-text">获取用户识别码uid 和 群组识别码gid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看用户所属组的列表"><span class="nav-number">7.1.4.</span> <span class="nav-text">查看用户所属组的列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回底层系统的内存页面大小"><span class="nav-number">7.1.5.</span> <span class="nav-text">返回底层系统的内存页面大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取主机名称"><span class="nav-number">7.1.6.</span> <span class="nav-text">获取主机名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前进程id、父进程id"><span class="nav-number">7.1.7.</span> <span class="nav-text">获取当前进程id、父进程id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取文件的状态"><span class="nav-number">7.1.8.</span> <span class="nav-text">获取文件的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误检测"><span class="nav-number">7.1.9.</span> <span class="nav-text">错误检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建文件夹、删除文件或文件夹"><span class="nav-number">7.1.10.</span> <span class="nav-text">创建文件夹、删除文件或文件夹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改文件夹或文件的名称"><span class="nav-number">7.1.11.</span> <span class="nav-text">修改文件夹或文件的名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#移动文件夹或文件"><span class="nav-number">7.1.12.</span> <span class="nav-text">移动文件夹或文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新建文件"><span class="nav-number">7.1.13.</span> <span class="nav-text">新建文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打开文件"><span class="nav-number">7.1.14.</span> <span class="nav-text">打开文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入文件"><span class="nav-number">7.1.15.</span> <span class="nav-text">写入文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取文件"><span class="nav-number">7.1.16.</span> <span class="nav-text">读取文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭文件"><span class="nav-number">7.1.17.</span> <span class="nav-text">关闭文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检测文件是否是同一个"><span class="nav-number">7.1.18.</span> <span class="nav-text">检测文件是否是同一个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取文件模式相关信息"><span class="nav-number">7.1.19.</span> <span class="nav-text">获取文件模式相关信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#把文件所在的目录切换为当前目录"><span class="nav-number">7.1.20.</span> <span class="nav-text">把文件所在的目录切换为当前目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看文件名称"><span class="nav-number">7.1.21.</span> <span class="nav-text">查看文件名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何查看所有文件夹下的所有文件和文件数量"><span class="nav-number">7.1.22.</span> <span class="nav-text">如何查看所有文件夹下的所有文件和文件数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取文件夹的下面文件的名称"><span class="nav-number">7.1.23.</span> <span class="nav-text">读取文件夹的下面文件的名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取临时陌路的文件夹路径"><span class="nav-number">7.1.24.</span> <span class="nav-text">获取临时陌路的文件夹路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断字符是否是支持的路径分隔符"><span class="nav-number">7.1.25.</span> <span class="nav-text">判断字符是否是支持的路径分隔符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看环境变量"><span class="nav-number">7.1.26.</span> <span class="nav-text">查看环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找指定环境变量"><span class="nav-number">7.1.27.</span> <span class="nav-text">查找指定环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取文件对应的unix文件描述符"><span class="nav-number">7.1.28.</span> <span class="nav-text">获取文件对应的unix文件描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chown修改文件的用户ID和组ID"><span class="nav-number">7.1.29.</span> <span class="nav-text">Chown修改文件的用户ID和组ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改文件权限-1"><span class="nav-number">7.1.30.</span> <span class="nav-text">修改文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强制改变文件大小"><span class="nav-number">7.1.31.</span> <span class="nav-text">强制改变文件大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接-硬链接"><span class="nav-number">7.1.32.</span> <span class="nav-text">链接 硬链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步保存当前文件的内容"><span class="nav-number">7.1.33.</span> <span class="nav-text">同步保存当前文件的内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NewFile使用给出的Unix文件描述符和名称创建一个文件"><span class="nav-number">7.1.34.</span> <span class="nav-text">NewFile使用给出的Unix文件描述符和名称创建一个文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lstat返回一个描述name指定的文件对象的FileInfo"><span class="nav-number">7.1.35.</span> <span class="nav-text">Lstat返回一个描述name指定的文件对象的FileInfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看所有环境变量、清除环境变量"><span class="nav-number">7.1.36.</span> <span class="nav-text">查看所有环境变量、清除环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前程序可执行的文件地址"><span class="nav-number">7.1.37.</span> <span class="nav-text">获取当前程序可执行的文件地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让程序已给定的状态码退出"><span class="nav-number">7.1.38.</span> <span class="nav-text">让程序已给定的状态码退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置环和取消环境变量"><span class="nav-number">7.1.39.</span> <span class="nav-text">设置环和取消环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建软链接"><span class="nav-number">7.1.40.</span> <span class="nav-text">创建软链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取软链接文件对应的实际文件路径地址"><span class="nav-number">7.1.41.</span> <span class="nav-text">获取软链接文件对应的实际文件路径地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更改指定文件的访问和修改时间"><span class="nav-number">7.1.42.</span> <span class="nav-text">更改指定文件的访问和修改时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建文件夹-并设置权限"><span class="nav-number">7.1.43.</span> <span class="nav-text">创建文件夹,并设置权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置文章的读写位置"><span class="nav-number">7.1.44.</span> <span class="nav-text">设置文章的读写位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改文件权限-2"><span class="nav-number">7.1.45.</span> <span class="nav-text">修改文件权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道的用法"><span class="nav-number">7.1.46.</span> <span class="nav-text">管道的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建系统错误"><span class="nav-number">7.1.47.</span> <span class="nav-text">创建系统错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过pid查找进行进程"><span class="nav-number">7.1.48.</span> <span class="nav-text">通过pid查找进行进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#杀死进程"><span class="nav-number">7.1.49.</span> <span class="nav-text">杀死进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#释放与进程p关联的任何资源"><span class="nav-number">7.1.50.</span> <span class="nav-text">释放与进程p关联的任何资源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#runtime-包"><span class="nav-number">8.</span> <span class="nav-text">runtime 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数-4"><span class="nav-number">8.1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取GO的信息"><span class="nav-number">8.1.1.</span> <span class="nav-text">获取GO的信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置cpu-profile记录的速率"><span class="nav-number">8.1.2.</span> <span class="nav-text">设置cpu profile记录的速率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即执行一次垃圾回收"><span class="nav-number">8.1.3.</span> <span class="nav-text">立即执行一次垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给变量绑定方法，当垃圾回收的时候进行监听"><span class="nav-number">8.1.4.</span> <span class="nav-text">给变量绑定方法，当垃圾回收的时候进行监听</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看内存申请和分配统计信息"><span class="nav-number">8.1.5.</span> <span class="nav-text">查看内存申请和分配统计信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看程序"><span class="nav-number">8.1.6.</span> <span class="nav-text">查看程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行一个断点"><span class="nav-number">8.1.7.</span> <span class="nav-text">执行一个断点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取程序调用go协程的栈踪迹历史"><span class="nav-number">8.1.8.</span> <span class="nav-text">获取程序调用go协程的栈踪迹历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号"><span class="nav-number">8.1.9.</span> <span class="nav-text">获取当前函数或者上层函数的标识号、文件名、调用方法在当前文件中的行号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取与当前堆栈记录相关链的调用栈踪迹"><span class="nav-number">8.1.10.</span> <span class="nav-text">获取与当前堆栈记录相关链的调用栈踪迹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取一个标识调用栈标识符pc对应的调用栈"><span class="nav-number">8.1.11.</span> <span class="nav-text">获取一个标识调用栈标识符pc对应的调用栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前进程执行的cgo调用次数"><span class="nav-number">8.1.12.</span> <span class="nav-text">获取当前进程执行的cgo调用次数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取当前存在的go协程数"><span class="nav-number">8.1.13.</span> <span class="nav-text">获取当前存在的go协程数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终止掉当前的go协程"><span class="nav-number">8.1.14.</span> <span class="nav-text">终止掉当前的go协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让其他go协程优先执行-等其他协程执行完后-在执行当前的协程"><span class="nav-number">8.1.15.</span> <span class="nav-text">让其他go协程优先执行,等其他协程执行完后,在执行当前的协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取活跃的go协程的堆栈profile以及记录个数"><span class="nav-number">8.1.16.</span> <span class="nav-text">获取活跃的go协程的堆栈profile以及记录个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程"><span class="nav-number">8.1.17.</span> <span class="nav-text">将调用的go协程绑定到当前所在的操作系统线程，其它go协程不能进入该线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取线程创建profile中的记录个数"><span class="nav-number">8.1.18.</span> <span class="nav-text">获取线程创建profile中的记录个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制阻塞profile记录go协程阻塞事件的采样率"><span class="nav-number">8.1.19.</span> <span class="nav-text">控制阻塞profile记录go协程阻塞事件的采样率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回当前阻塞profile中的记录个数"><span class="nav-number">8.1.20.</span> <span class="nav-text">返回当前阻塞profile中的记录个数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sort-包"><span class="nav-number">9.</span> <span class="nav-text">sort 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#type-Interface"><span class="nav-number">9.1.</span> <span class="nav-text">type Interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Search-二分法查找"><span class="nav-number">9.2.</span> <span class="nav-text">Search 二分法查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stable-排序"><span class="nav-number">9.3.</span> <span class="nav-text">Stable 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reverse-逆序排序"><span class="nav-number">9.4.</span> <span class="nav-text">Reverse 逆序排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strconv-包"><span class="nav-number">10.</span> <span class="nav-text">strconv 包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strings-包"><span class="nav-number">11.</span> <span class="nav-text">strings 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前、后缀"><span class="nav-number">11.1.</span> <span class="nav-text">前、后缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串包含关系"><span class="nav-number">11.2.</span> <span class="nav-text">字符串包含关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引字符串位置"><span class="nav-number">11.3.</span> <span class="nav-text">索引字符串位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串替换"><span class="nav-number">11.4.</span> <span class="nav-text">字符串替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计字符串出现的次数"><span class="nav-number">11.5.</span> <span class="nav-text">统计字符串出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重复字符串"><span class="nav-number">11.6.</span> <span class="nav-text">重复字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修改字符串大小写"><span class="nav-number">11.7.</span> <span class="nav-text">修改字符串大小写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修剪字符串"><span class="nav-number">11.8.</span> <span class="nav-text">修剪字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分割字符串"><span class="nav-number">11.9.</span> <span class="nav-text">分割字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拼接-slice-到字符串"><span class="nav-number">11.10.</span> <span class="nav-text">拼接 slice 到字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从字符串中读取内容"><span class="nav-number">11.11.</span> <span class="nav-text">从字符串中读取内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#比较两字符串字典顺序"><span class="nav-number">11.12.</span> <span class="nav-text">比较两字符串字典顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#忽略大小写判断s和t是否相等"><span class="nav-number">11.13.</span> <span class="nav-text">忽略大小写判断s和t是否相等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">11.14.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reader-go"><span class="nav-number">11.15.</span> <span class="nav-text">reader.go</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reader结构"><span class="nav-number">11.15.1.</span> <span class="nav-text">Reader结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Len-返回-r-i-之后的所有数据的字节长度"><span class="nav-number">11.15.2.</span> <span class="nav-text">Len 返回 r.i 之后的所有数据的字节长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-将-r-i-之后的所有数据写入到-b-中（如果-b-的容量足够大）"><span class="nav-number">11.15.3.</span> <span class="nav-text">Read 将 r.i 之后的所有数据写入到 b 中（如果 b 的容量足够大）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadAt-将-off-之后的所有数据写入到-b-中（如果-b-的容量足够大）"><span class="nav-number">11.15.4.</span> <span class="nav-text">ReadAt 将 off 之后的所有数据写入到 b 中（如果 b 的容量足够大）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadByte-将-r-i-之后的一个字节写入到返回值-b-中"><span class="nav-number">11.15.5.</span> <span class="nav-text">ReadByte 将 r.i 之后的一个字节写入到返回值 b 中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UnreadByte-撤消前一次的-ReadByte-操作，即-r-i–"><span class="nav-number">11.15.6.</span> <span class="nav-text">UnreadByte 撤消前一次的 ReadByte 操作，即 r.i–</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadRune-将-r-i-之后的一个字符写入到返回值-ch-中"><span class="nav-number">11.15.7.</span> <span class="nav-text">ReadRune 将 r.i 之后的一个字符写入到返回值 ch 中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#撤消前一次的-ReadRune-操作"><span class="nav-number">11.15.8.</span> <span class="nav-text">撤消前一次的 ReadRune 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Seek-用来移动-r-中的索引位置"><span class="nav-number">11.15.9.</span> <span class="nav-text">Seek 用来移动 r 中的索引位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WriteTo-将-r-i-之后的数据写入接口-w-中"><span class="nav-number">11.15.10.</span> <span class="nav-text">WriteTo 将 r.i 之后的数据写入接口 w 中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#replace-go"><span class="nav-number">11.16.</span> <span class="nav-text">replace.go</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Replacer-根据一个替换列表执行替换操作"><span class="nav-number">11.16.1.</span> <span class="nav-text">Replacer 根据一个替换列表执行替换操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NewReplacer-通过“替换列表”创建一个-Replacer-对象"><span class="nav-number">11.16.2.</span> <span class="nav-text">NewReplacer 通过“替换列表”创建一个 Replacer 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Replace-返回对-s-进行“查找和替换”后的结果"><span class="nav-number">11.16.3.</span> <span class="nav-text">Replace 返回对 s 进行“查找和替换”后的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WriteString-对-s-进行“查找和替换”，然后将结果写入-w-中"><span class="nav-number">11.16.4.</span> <span class="nav-text">WriteString 对 s 进行“查找和替换”，然后将结果写入 w 中</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sync-包"><span class="nav-number">12.</span> <span class="nav-text">sync 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#临时对象池"><span class="nav-number">12.1.</span> <span class="nav-text">临时对象池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Once"><span class="nav-number">12.2.</span> <span class="nav-text">Once</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥锁"><span class="nav-number">12.3.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写互斥锁"><span class="nav-number">12.4.</span> <span class="nav-text">读写互斥锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组等待"><span class="nav-number">12.5.</span> <span class="nav-text">组等待</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件等待"><span class="nav-number">12.6.</span> <span class="nav-text">条件等待</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#time-包：时间和日期"><span class="nav-number">13.</span> <span class="nav-text">time 包：时间和日期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#时间敞亮（时间格式化）"><span class="nav-number">13.1.</span> <span class="nav-text">时间敞亮（时间格式化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数-5"><span class="nav-number">13.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#time-组成"><span class="nav-number">13.2.1.</span> <span class="nav-text">time 组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#After-函数"><span class="nav-number">13.2.2.</span> <span class="nav-text">After 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些例子："><span class="nav-number">13.2.3.</span> <span class="nav-text">一些例子：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unicode-包"><span class="nav-number">14.</span> <span class="nav-text">unicode 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量"><span class="nav-number">14.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RangeTable"><span class="nav-number">14.2.</span> <span class="nav-text">RangeTable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断及转换字符大小写、Title"><span class="nav-number">14.3.</span> <span class="nav-text">判断及转换字符大小写、Title</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rune操作"><span class="nav-number">14.4.</span> <span class="nav-text">rune操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SimpleFold-环绕查找"><span class="nav-number">14.5.</span> <span class="nav-text">SimpleFold 环绕查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断"><span class="nav-number">14.6.</span> <span class="nav-text">判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unicode-utf16-包"><span class="nav-number">15.</span> <span class="nav-text">unicode&#x2F;utf16 包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unicode-utf8-包"><span class="nav-number">16.</span> <span class="nav-text">unicode&#x2F;utf8 包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量-1"><span class="nav-number">16.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数-6"><span class="nav-number">16.2.</span> <span class="nav-text">函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="rtk"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">rtk</p>
  <div class="site-description" itemprop="description">冷萃少冰不加糖</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/reitake" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;reitake" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/rrrrrtk" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;rrrrrtk" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rtk</span>
</div><span class="post-meta-item-icon">
    <i class="fa fa-clock-o"></i>
</span>
<span id="sitetime"></span>
<script language="javascript">
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
    year - 作为date对象的年份，为4位年份值
    month - 0-11之间的整数，做为date对象的月份
    day - 1-31之间的整数，做为date对象的天数
    hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
    minutes - 0-59之间的整数，做为date对象的分钟数
    seconds - 0-59之间的整数，做为date对象的秒数
    microseconds - 0-999之间的整数，做为date对象的毫秒数 */
    var t1 = Date.UTC(2019,03,07,10,00,00); //建站时间
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒 ~喵~";
  }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
  siteTime();
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'FY0k4GNyVIFSqBrIxPq7yN7t-gzGzoHsz',
      appKey     : 'FqCFfTcVczkkBx9SyMlf7myz',
      placeholder: "喵w ヾﾉ≧w≦)o",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
